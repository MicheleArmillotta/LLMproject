[
  {
    "function_name": "qemuMigrationSrcFetchMirrorStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5557-5605",
    "snippet": "int\nqemuMigrationSrcFetchMirrorStats(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 qemuDomainJobInfoPtr jobInfo)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool nbd = false;\n    virHashTablePtr blockinfo = NULL;\n    qemuDomainMirrorStatsPtr stats = &jobInfo->mirrorStats;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        if (QEMU_DOMAIN_DISK_PRIVATE(disk)->migrating) {\n            nbd = true;\n            break;\n        }\n    }\n\n    if (!nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    blockinfo = qemuMonitorGetAllBlockJobInfo(priv->mon, false);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockinfo)\n        return -1;\n\n    memset(stats, 0, sizeof(*stats));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuMonitorBlockJobInfoPtr data;\n\n        if (!diskPriv->migrating ||\n            !(data = virHashLookup(blockinfo, disk->info.alias)))\n            continue;\n\n        stats->transferred += data->cur;\n        stats->total += data->end;\n    }\n\n    virHashFree(blockinfo);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashFree",
          "args": [
            "blockinfo"
          ],
          "line": 5603
        },
        "resolved": true,
        "details": {
          "function_name": "virHashFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "313-337",
          "snippet": "void\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirHashFree(virHashTablePtr table)\n{\n    size_t i;\n\n    if (table == NULL)\n        return;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr iter = table->table[i];\n        while (iter) {\n            virHashEntryPtr next = iter->next;\n\n            if (table->dataFree)\n                table->dataFree(iter->payload);\n            if (table->keyFree)\n                table->keyFree(iter->name);\n            VIR_FREE(iter);\n            iter = next;\n        }\n    }\n\n    VIR_FREE(table->table);\n    VIR_FREE(table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "blockinfo",
            "disk->info.alias"
          ],
          "line": 5596
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 5592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(*stats)"
          ],
          "line": 5588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5585
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetAllBlockJobInfo",
          "args": [
            "priv->mon",
            "false"
          ],
          "line": 5583
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetAllBlockJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3256-3262",
          "snippet": "virHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvirHashTablePtr\nqemuMonitorGetAllBlockJobInfo(qemuMonitorPtr mon,\n                              bool rawjobname)\n{\n    QEMU_CHECK_MONITOR_NULL(mon);\n    return qemuMonitorJSONGetAllBlockJobInfo(mon, rawjobname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 5580
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 5571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcFetchMirrorStats(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 qemuDomainJobInfoPtr jobInfo)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool nbd = false;\n    virHashTablePtr blockinfo = NULL;\n    qemuDomainMirrorStatsPtr stats = &jobInfo->mirrorStats;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        if (QEMU_DOMAIN_DISK_PRIVATE(disk)->migrating) {\n            nbd = true;\n            break;\n        }\n    }\n\n    if (!nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    blockinfo = qemuMonitorGetAllBlockJobInfo(priv->mon, false);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockinfo)\n        return -1;\n\n    memset(stats, 0, sizeof(*stats));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuMonitorBlockJobInfoPtr data;\n\n        if (!diskPriv->migrating ||\n            !(data = virHashLookup(blockinfo, disk->info.alias)))\n            continue;\n\n        stats->transferred += data->cur;\n        stats->total += data->end;\n    }\n\n    virHashFree(blockinfo);\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationDstErrorReport",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5542-5554",
    "snippet": "void\nqemuMigrationDstErrorReport(virQEMUDriverPtr driver,\n                            const char *name)\n{\n    virErrorPtr err;\n\n    if (!(err = virHashAtomicSteal(driver->migrationErrors, name)))\n        return;\n\n    VIR_DEBUG(\"Restoring saved incoming migration error for domain %s: %s\",\n              name, err->message);\n    virErrorRestore(&err);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 5553
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Restoring saved incoming migration error for domain %s: %s\"",
            "name",
            "err->message"
          ],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashAtomicSteal",
          "args": [
            "driver->migrationErrors",
            "name"
          ],
          "line": 5548
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAtomicSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "524-535",
          "snippet": "void *\nvirHashAtomicSteal(virHashAtomicPtr table,\n                   const void *name)\n{\n    void *data;\n\n    virObjectLock(table);\n    data = virHashSteal(table->hash, name);\n    virObjectUnlock(table);\n\n    return data;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashAtomicSteal(virHashAtomicPtr table,\n                   const void *name)\n{\n    void *data;\n\n    virObjectLock(table);\n    data = virHashSteal(table->hash, name);\n    virObjectUnlock(table);\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationDstErrorReport(virQEMUDriverPtr driver,\n                            const char *name)\n{\n    virErrorPtr err;\n\n    if (!(err = virHashAtomicSteal(driver->migrationErrors, name)))\n        return;\n\n    VIR_DEBUG(\"Restoring saved incoming migration error for domain %s: %s\",\n              name, err->message);\n    virErrorRestore(&err);\n}"
  },
  {
    "function_name": "qemuMigrationDstErrorSave",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5526-5540",
    "snippet": "void\nqemuMigrationDstErrorSave(virQEMUDriverPtr driver,\n                          const char *name,\n                          virErrorPtr err)\n{\n    if (!err)\n        return;\n\n    VIR_DEBUG(\"Saving incoming migration error for domain %s: %s\",\n              name, err->message);\n    if (virHashAtomicUpdate(driver->migrationErrors, name, err) < 0) {\n        VIR_WARN(\"Failed to save migration error for domain '%s'\", name);\n        virFreeError(err);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "err"
          ],
          "line": 5538
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to save migration error for domain '%s'\"",
            "name"
          ],
          "line": 5537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashAtomicUpdate",
          "args": [
            "driver->migrationErrors",
            "name",
            "err"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAtomicUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "429-441",
          "snippet": "int\nvirHashAtomicUpdate(virHashAtomicPtr table,\n                    const void *name,\n                    void *userdata)\n{\n    int ret;\n\n    virObjectLock(table);\n    ret = virHashAddOrUpdateEntry(table->hash, name, userdata, true);\n    virObjectUnlock(table);\n\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAtomicUpdate(virHashAtomicPtr table,\n                    const void *name,\n                    void *userdata)\n{\n    int ret;\n\n    virObjectLock(table);\n    ret = virHashAddOrUpdateEntry(table->hash, name, userdata, true);\n    virObjectUnlock(table);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Saving incoming migration error for domain %s: %s\"",
            "name",
            "err->message"
          ],
          "line": 5534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationDstErrorSave(virQEMUDriverPtr driver,\n                          const char *name,\n                          virErrorPtr err)\n{\n    if (!err)\n        return;\n\n    VIR_DEBUG(\"Saving incoming migration error for domain %s: %s\",\n              name, err->message);\n    if (virHashAtomicUpdate(driver->migrationErrors, name, err) < 0) {\n        VIR_WARN(\"Failed to save migration error for domain '%s'\", name);\n        virFreeError(err);\n    }\n}"
  },
  {
    "function_name": "qemuMigrationDstErrorInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5512-5520",
    "snippet": "int\nqemuMigrationDstErrorInit(virQEMUDriverPtr driver)\n{\n    driver->migrationErrors = virHashAtomicNew(64, qemuMigrationDstErrorFree);\n    if (driver->migrationErrors)\n        return 0;\n    else\n        return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHashAtomicNew",
          "args": [
            "64",
            "qemuMigrationDstErrorFree"
          ],
          "line": 5515
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAtomicNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "214-231",
          "snippet": "virHashAtomicPtr\nvirHashAtomicNew(ssize_t size,\n                 virHashDataFree dataFree)\n{\n    virHashAtomicPtr hash;\n\n    if (virHashAtomicInitialize() < 0)\n        return NULL;\n\n    if (!(hash = virObjectLockableNew(virHashAtomicClass)))\n        return NULL;\n\n    if (!(hash->hash = virHashCreate(size, dataFree))) {\n        virObjectUnref(hash);\n        return NULL;\n    }\n    return hash;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virHashAtomicClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virClassPtr virHashAtomicClass;\n\nvirHashAtomicPtr\nvirHashAtomicNew(ssize_t size,\n                 virHashDataFree dataFree)\n{\n    virHashAtomicPtr hash;\n\n    if (virHashAtomicInitialize() < 0)\n        return NULL;\n\n    if (!(hash = virObjectLockableNew(virHashAtomicClass)))\n        return NULL;\n\n    if (!(hash->hash = virHashCreate(size, dataFree))) {\n        virObjectUnref(hash);\n        return NULL;\n    }\n    return hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstErrorInit(virQEMUDriverPtr driver)\n{\n    driver->migrationErrors = virHashAtomicNew(64, qemuMigrationDstErrorFree);\n    if (driver->migrationErrors)\n        return 0;\n    else\n        return -1;\n}"
  },
  {
    "function_name": "qemuMigrationDstErrorFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5505-5510",
    "snippet": "static void\nqemuMigrationDstErrorFree(void *data)\n{\n    virErrorPtr err = data;\n    virFreeError(err);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "err"
          ],
          "line": 5509
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationDstErrorFree(void *data)\n{\n    virErrorPtr err = data;\n    virFreeError(err);\n}"
  },
  {
    "function_name": "qemuMigrationJobFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5498-5502",
    "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjEndAsyncJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5501
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEndAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10072-10086",
          "snippet": "void\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\nobj, obj->def->name);\n\nvoid\nqemuDomainObjEndAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping async job: %s (vm=%p name=%s)\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n    virCondBroadcast(&priv->job.asyncCond);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
  },
  {
    "function_name": "qemuMigrationJobIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5478-5496",
    "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "msg",
            "vm->def->name"
          ],
          "line": 5492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domain '%s' is not being migrated\""
          ],
          "line": 5490
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "qemuMigrationJobContinue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5472-5476",
    "snippet": "static void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjReleaseAsyncJob",
          "args": [
            "vm"
          ],
          "line": 5475
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjReleaseAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9647-9661",
          "snippet": "void\nqemuDomainObjReleaseAsyncJob(virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    VIR_DEBUG(\"Releasing ownership of '%s' async job\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    if (priv->job.asyncOwner != virThreadSelfID()) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n    priv->job.asyncOwner = 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nvoid\nqemuDomainObjReleaseAsyncJob(virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    VIR_DEBUG(\"Releasing ownership of '%s' async job\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    if (priv->job.asyncOwner != virThreadSelfID()) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n    priv->job.asyncOwner = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}"
  },
  {
    "function_name": "qemuMigrationJobStartPhase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5464-5470",
    "snippet": "static void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "phase"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}"
  },
  {
    "function_name": "qemuMigrationJobSetPhase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5447-5462",
    "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjSetJobPhase",
          "args": [
            "driver",
            "vm",
            "phase"
          ],
          "line": 5461
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjSetJobPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9598-9622",
          "snippet": "void\nqemuDomainObjSetJobPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr obj,\n                         int phase)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long me = virThreadSelfID();\n\n    if (!priv->job.asyncJob)\n        return;\n\n    VIR_DEBUG(\"Setting '%s' phase to '%s'\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              qemuDomainAsyncJobPhaseToString(priv->job.asyncJob, phase));\n\n    if (priv->job.asyncOwner && me != priv->job.asyncOwner) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n\n    priv->job.phase = phase;\n    priv->job.asyncOwner = me;\n    qemuDomainObjSaveStatus(driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nvoid\nqemuDomainObjSetJobPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr obj,\n                         int phase)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    unsigned long long me = virThreadSelfID();\n\n    if (!priv->job.asyncJob)\n        return;\n\n    VIR_DEBUG(\"Setting '%s' phase to '%s'\",\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              qemuDomainAsyncJobPhaseToString(priv->job.asyncJob, phase));\n\n    if (priv->job.asyncOwner && me != priv->job.asyncOwner) {\n        VIR_WARN(\"'%s' async job is owned by thread %llu\",\n                 qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                 priv->job.asyncOwner);\n    }\n\n    priv->job.phase = phase;\n    priv->job.asyncOwner = me;\n    qemuDomainObjSaveStatus(driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"migration protocol going backwards %s => %s\")",
            "qemuMigrationJobPhaseTypeToString(priv->job.phase)",
            "qemuMigrationJobPhaseTypeToString(phase)"
          ],
          "line": 5455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobPhaseTypeToString",
          "args": [
            "phase"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobPhaseTypeToString",
          "args": [
            "priv->job.phase"
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"migration protocol going backwards %s => %s\""
          ],
          "line": 5455
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
  },
  {
    "function_name": "qemuMigrationJobStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5418-5445",
    "snippet": "static int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjSetAsyncJobMask",
          "args": [
            "vm",
            "mask"
          ],
          "line": 5443
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjSetAsyncJobMask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9624-9634",
          "snippet": "void\nqemuDomainObjSetAsyncJobMask(virDomainObjPtr obj,\n                             unsigned long long allowedJobs)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (!priv->job.asyncJob)\n        return;\n\n    priv->job.mask = allowedJobs | JOB_MASK(QEMU_JOB_DESTROY);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nvoid\nqemuDomainObjSetAsyncJobMask(virDomainObjPtr obj,\n                             unsigned long long allowedJobs)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (!priv->job.asyncJob)\n        return;\n\n    priv->job.mask = allowedJobs | JOB_MASK(QEMU_JOB_DESTROY);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjBeginAsyncJob",
          "args": [
            "driver",
            "vm",
            "job",
            "op",
            "apiFlags"
          ],
          "line": 5438
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjBeginAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9958-9975",
          "snippet": "int qemuDomainObjBeginAsyncJob(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainJobOperation operation,\n                               unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    if (qemuDomainObjBeginJobInternal(driver, obj, QEMU_JOB_ASYNC,\n                                      QEMU_AGENT_JOB_NONE,\n                                      asyncJob, false) < 0)\n        return -1;\n\n    priv = obj->privateData;\n    priv->job.current->operation = operation;\n    priv->job.apiFlags = apiFlags;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint qemuDomainObjBeginAsyncJob(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob,\n                               virDomainJobOperation operation,\n                               unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv;\n\n    if (qemuDomainObjBeginJobInternal(driver, obj, QEMU_JOB_ASYNC,\n                                      QEMU_AGENT_JOB_NONE,\n                                      asyncJob, false) < 0)\n        return -1;\n\n    priv = obj->privateData;\n    priv->job.current->operation = operation;\n    priv->job.apiFlags = apiFlags;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "JOB_MASK",
          "args": [
            "QEMU_JOB_MIGRATION_OP"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "JOB_MASK",
          "args": [
            "QEMU_JOB_SUSPEND"
          ],
          "line": 5434
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcCancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5376-5415",
    "snippet": "int\nqemuMigrationSrcCancel(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool storage = false;\n    size_t i;\n\n    VIR_DEBUG(\"Canceling unfinished outgoing migration of domain %s\",\n              vm->def->name);\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ignore_value(qemuMonitorMigrateCancel(priv->mon));\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (diskPriv->migrating) {\n            qemuBlockJobSyncBegin(job);\n            storage = true;\n        }\n\n        virObjectUnref(job);\n    }\n\n    if (storage &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_NONE, NULL) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDCopyCancel",
          "args": [
            "driver",
            "vm",
            "false",
            "QEMU_ASYNC_JOB_NONE",
            "NULL"
          ],
          "line": 5410
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDCopyCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "694-777",
          "snippet": "static int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job"
          ],
          "line": 5406
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobSyncBegin",
          "args": [
            "job"
          ],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobSyncBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1697-1707",
          "snippet": "void\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobIsRunning",
          "args": [
            "job"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobIsRunning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "473-480",
          "snippet": "bool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nbool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "disk"
          ],
          "line": 5397
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 5394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuMonitorMigrateCancel(priv->mon)"
          ],
          "line": 5388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateCancel",
          "args": [
            "priv->mon"
          ],
          "line": 5388
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2526-2532",
          "snippet": "int\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5387
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10172-10177",
          "snippet": "void qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Canceling unfinished outgoing migration of domain %s\"",
            "vm->def->name"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcCancel(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool storage = false;\n    size_t i;\n\n    VIR_DEBUG(\"Canceling unfinished outgoing migration of domain %s\",\n              vm->def->name);\n\n    qemuDomainObjEnterMonitor(driver, vm);\n    ignore_value(qemuMonitorMigrateCancel(priv->mon));\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (diskPriv->migrating) {\n            qemuBlockJobSyncBegin(job);\n            storage = true;\n        }\n\n        virObjectUnref(job);\n    }\n\n    if (storage &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_NONE, NULL) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcToFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "5254-5373",
    "snippet": "int\nqemuMigrationSrcToFile(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                       int fd,\n                       virCommandPtr compressor,\n                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n    int ret = -1;\n    int pipeFD[2] = { -1, -1 };\n    unsigned long saveMigBandwidth = priv->migMaxBandwidth;\n    char *errbuf = NULL;\n    virErrorPtr orig_err = NULL;\n\n    /* Increase migration bandwidth to unlimited since target is a file.\n     * Failure to change migration speed is not fatal. */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        qemuMonitorSetMigrationSpeed(priv->mon,\n                                     QEMU_DOMAIN_MIG_BANDWIDTH_MAX);\n        priv->migMaxBandwidth = QEMU_DOMAIN_MIG_BANDWIDTH_MAX;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        /* nothing to tear down */\n        return -1;\n    }\n\n    if (compressor && virPipe(pipeFD) < 0)\n        return -1;\n\n    /* All right! We can use fd migration, which means that qemu\n     * doesn't have to open() the file, so while we still have to\n     * grant SELinux access, we can do it on fd and avoid cleanup\n     * later, as well as skip futzing with cgroup.  */\n    if (qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    compressor ? pipeFD[1] : fd) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (!compressor) {\n        rc = qemuMonitorMigrateToFd(priv->mon,\n                                    QEMU_MONITOR_MIGRATE_BACKGROUND,\n                                    fd);\n    } else {\n        virCommandSetInputFD(compressor, pipeFD[0]);\n        virCommandSetOutputFD(compressor, &fd);\n        virCommandSetErrorBuffer(compressor, &errbuf);\n        virCommandDoAsyncIO(compressor);\n        if (virSetCloseExec(pipeFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to set cloexec flag\"));\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            goto cleanup;\n        }\n        if (virCommandRunAsync(compressor, NULL) < 0) {\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            goto cleanup;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon,\n                                    QEMU_MONITOR_MIGRATE_BACKGROUND,\n                                    pipeFD[1]);\n        if (VIR_CLOSE(pipeFD[0]) < 0 ||\n            VIR_CLOSE(pipeFD[1]) < 0)\n            VIR_WARN(\"failed to close intermediate pipe\");\n    }\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (rc < 0)\n        goto cleanup;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm, asyncJob, NULL, 0);\n\n    if (rc < 0) {\n        if (rc == -2) {\n            virErrorPreserveLast(&orig_err);\n            virCommandAbort(compressor);\n            if (virDomainObjIsActive(vm) &&\n                qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n                qemuMonitorMigrateCancel(priv->mon);\n                ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            }\n        }\n        goto cleanup;\n    }\n\n    if (compressor && virCommandWait(compressor, NULL) < 0)\n        goto cleanup;\n\n    qemuDomainEventEmitJobCompleted(driver, vm);\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && !orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /* Restore max migration bandwidth */\n    if (virDomainObjIsActive(vm) &&\n        qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        qemuMonitorSetMigrationSpeed(priv->mon, saveMigBandwidth);\n        priv->migMaxBandwidth = saveMigBandwidth;\n        ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    }\n\n    VIR_FORCE_CLOSE(pipeFD[0]);\n    VIR_FORCE_CLOSE(pipeFD[1]);\n    if (errbuf) {\n        VIR_DEBUG(\"Compression binary stderr: %s\", NULLSTR(errbuf));\n        VIR_FREE(errbuf);\n    }\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 5370
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "errbuf"
          ],
          "line": 5367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Compression binary stderr: %s\"",
            "NULLSTR(errbuf)"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "errbuf"
          ],
          "line": 5366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeFD[1]"
          ],
          "line": 5364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "pipeFD[0]"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 5360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5360
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSetMigrationSpeed",
          "args": [
            "priv->mon",
            "saveMigBandwidth"
          ],
          "line": 5358
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSetMigrationSpeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2364-2380",
          "snippet": "int\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 5357
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 5356
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 5353
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainEventEmitJobCompleted",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5348
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainEventEmitJobCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "307-328",
          "snippet": "void\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nvoid\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandWait",
          "args": [
            "compressor",
            "NULL"
          ],
          "line": 5345
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2940-2946",
          "snippet": "int\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandWait(virCommandPtr cmd G_GNUC_UNUSED, int *exitstatus G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateCancel",
          "args": [
            "priv->mon"
          ],
          "line": 5338
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2526-2532",
          "snippet": "int\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAbort",
          "args": [
            "compressor"
          ],
          "line": 5335
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2949-2955",
          "snippet": "void\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAbort(virCommandPtr cmd G_GNUC_UNUSED)\n{\n    /* Mingw lacks WNOHANG and kill().  But since we haven't ported\n     * virExec to mingw yet, there's no process to be killed,\n     * making this implementation trivially correct for now :)  */\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcWaitForCompletion",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "NULL",
            "0"
          ],
          "line": 5330
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcWaitForCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1690-1741",
          "snippet": "static int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to close intermediate pipe\""
          ],
          "line": 5323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "pipeFD[1]"
          ],
          "line": 5322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "pipeFD[0]"
          ],
          "line": 5321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateToFd",
          "args": [
            "priv->mon",
            "QEMU_MONITOR_MIGRATE_BACKGROUND",
            "pipeFD[1]"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateToFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2478-2499",
          "snippet": "int\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRunAsync",
          "args": [
            "compressor",
            "NULL"
          ],
          "line": 5314
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 5311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to set cloexec flag\")"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set cloexec flag\""
          ],
          "line": 5310
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetCloseExec",
          "args": [
            "pipeFD[1]"
          ],
          "line": 5308
        },
        "resolved": true,
        "details": {
          "function_name": "virSetCloseExec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "131-134",
          "snippet": "int virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetCloseExec(int fd)\n{\n    return virSetInherit(fd, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandDoAsyncIO",
          "args": [
            "compressor"
          ],
          "line": 5307
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandDoAsyncIO",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "3084-3091",
          "snippet": "void\nvirCommandDoAsyncIO(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_ASYNC_IO | VIR_EXEC_NONBLOCK;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandDoAsyncIO(virCommandPtr cmd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    cmd->flags |= VIR_EXEC_ASYNC_IO | VIR_EXEC_NONBLOCK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetErrorBuffer",
          "args": [
            "compressor",
            "&errbuf"
          ],
          "line": 5306
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetErrorBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1903-1918",
          "snippet": "void\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetErrorBuffer(virCommandPtr cmd, char **errbuf)\n{\n    *errbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->errfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify stderr twice\");\n        return;\n    }\n\n    cmd->errbuf = errbuf;\n    cmd->errfdptr = &cmd->errfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputFD",
          "args": [
            "compressor",
            "&fd"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1958-1971",
          "snippet": "void\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputFD(virCommandPtr cmd, int *outfd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outfdptr = outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetInputFD",
          "args": [
            "compressor",
            "pipeFD[0]"
          ],
          "line": 5304
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetInputFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1928-1946",
          "snippet": "void\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetInputFD(virCommandPtr cmd, int infd)\n{\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->infd != -1 || cmd->inbuf) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify input twice\");\n        return;\n    }\n    if (infd < 0) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify invalid input fd\");\n        return;\n    }\n\n    cmd->infd = infd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetImageFDLabel",
          "args": [
            "driver->securityManager",
            "vm->def",
            "compressor ? pipeFD[1] : fd"
          ],
          "line": 5292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "pipeFD"
          ],
          "line": 5285
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"guest unexpectedly quit\")"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcToFile(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                       int fd,\n                       virCommandPtr compressor,\n                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rc;\n    int ret = -1;\n    int pipeFD[2] = { -1, -1 };\n    unsigned long saveMigBandwidth = priv->migMaxBandwidth;\n    char *errbuf = NULL;\n    virErrorPtr orig_err = NULL;\n\n    /* Increase migration bandwidth to unlimited since target is a file.\n     * Failure to change migration speed is not fatal. */\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        qemuMonitorSetMigrationSpeed(priv->mon,\n                                     QEMU_DOMAIN_MIG_BANDWIDTH_MAX);\n        priv->migMaxBandwidth = QEMU_DOMAIN_MIG_BANDWIDTH_MAX;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        /* nothing to tear down */\n        return -1;\n    }\n\n    if (compressor && virPipe(pipeFD) < 0)\n        return -1;\n\n    /* All right! We can use fd migration, which means that qemu\n     * doesn't have to open() the file, so while we still have to\n     * grant SELinux access, we can do it on fd and avoid cleanup\n     * later, as well as skip futzing with cgroup.  */\n    if (qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    compressor ? pipeFD[1] : fd) < 0)\n        goto cleanup;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (!compressor) {\n        rc = qemuMonitorMigrateToFd(priv->mon,\n                                    QEMU_MONITOR_MIGRATE_BACKGROUND,\n                                    fd);\n    } else {\n        virCommandSetInputFD(compressor, pipeFD[0]);\n        virCommandSetOutputFD(compressor, &fd);\n        virCommandSetErrorBuffer(compressor, &errbuf);\n        virCommandDoAsyncIO(compressor);\n        if (virSetCloseExec(pipeFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"Unable to set cloexec flag\"));\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            goto cleanup;\n        }\n        if (virCommandRunAsync(compressor, NULL) < 0) {\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            goto cleanup;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon,\n                                    QEMU_MONITOR_MIGRATE_BACKGROUND,\n                                    pipeFD[1]);\n        if (VIR_CLOSE(pipeFD[0]) < 0 ||\n            VIR_CLOSE(pipeFD[1]) < 0)\n            VIR_WARN(\"failed to close intermediate pipe\");\n    }\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n    if (rc < 0)\n        goto cleanup;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm, asyncJob, NULL, 0);\n\n    if (rc < 0) {\n        if (rc == -2) {\n            virErrorPreserveLast(&orig_err);\n            virCommandAbort(compressor);\n            if (virDomainObjIsActive(vm) &&\n                qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n                qemuMonitorMigrateCancel(priv->mon);\n                ignore_value(qemuDomainObjExitMonitor(driver, vm));\n            }\n        }\n        goto cleanup;\n    }\n\n    if (compressor && virCommandWait(compressor, NULL) < 0)\n        goto cleanup;\n\n    qemuDomainEventEmitJobCompleted(driver, vm);\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && !orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /* Restore max migration bandwidth */\n    if (virDomainObjIsActive(vm) &&\n        qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        qemuMonitorSetMigrationSpeed(priv->mon, saveMigBandwidth);\n        priv->migMaxBandwidth = saveMigBandwidth;\n        ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    }\n\n    VIR_FORCE_CLOSE(pipeFD[0]);\n    VIR_FORCE_CLOSE(pipeFD[1]);\n    if (errbuf) {\n        VIR_DEBUG(\"Compression binary stderr: %s\", NULLSTR(errbuf));\n        VIR_FREE(errbuf);\n    }\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationDstFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4957-5250",
    "snippet": "virDomainPtr\nqemuMigrationDstFinish(virQEMUDriverPtr driver,\n                       virConnectPtr dconn,\n                       virDomainObjPtr vm,\n                       const char *cookiein,\n                       int cookieinlen,\n                       char **cookieout,\n                       int *cookieoutlen,\n                       unsigned long flags,\n                       int retcode,\n                       bool v3proto)\n{\n    virDomainPtr dom = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virErrorPtr orig_err = NULL;\n    int cookie_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    unsigned short port;\n    unsigned long long timeReceived = 0;\n    virObjectEventPtr event;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    bool inPostCopy = false;\n    bool doKill = true;\n\n    VIR_DEBUG(\"driver=%p, dconn=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, retcode=%d\",\n              driver, dconn, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, retcode);\n\n    port = priv->migrationPort;\n    priv->migrationPort = 0;\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_IN)) {\n        qemuMigrationDstErrorReport(driver, vm->def->name);\n        goto cleanup;\n    }\n\n    ignore_value(virTimeMillisNow(&timeReceived));\n\n    qemuMigrationJobStartPhase(driver, vm,\n                               v3proto ? QEMU_MIGRATION_PHASE_FINISH3\n                                       : QEMU_MIGRATION_PHASE_FINISH2);\n\n    qemuDomainCleanupRemove(vm, qemuMigrationDstPrepareCleanup);\n    VIR_FREE(priv->job.completed);\n\n    cookie_flags = QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS |\n                   QEMU_MIGRATION_COOKIE_NBD;\n    /* Some older versions of libvirt always send persistent XML in the cookie\n     * even though VIR_MIGRATE_PERSIST_DEST was not used. */\n    cookie_flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen, cookie_flags)))\n        goto endjob;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (retcode == 0 &&\n            qemuMigrationDstPersist(driver, vm, mig, false) == 0)\n            dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, -1);\n        goto endjob;\n    }\n\n    if (retcode != 0) {\n        /* Check for a possible error on the monitor in case Finish was called\n         * earlier than monitor EOF handler got a chance to process the error\n         */\n        qemuDomainCheckMonitor(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN);\n        goto endjob;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        qemuMigrationDstErrorReport(driver, vm->def->name);\n        goto endjob;\n    }\n\n    if (qemuMigrationDstVPAssociatePortProfiles(vm->def) < 0)\n        goto endjob;\n\n    if (mig->network && qemuMigrationDstOPDRelocate(driver, vm, mig) < 0)\n        VIR_WARN(\"unable to provide network data for relocation\");\n\n    if (qemuMigrationDstStopNBDServer(driver, vm, mig) < 0)\n        goto endjob;\n\n    if (qemuRefreshVirtioChannelState(driver, vm,\n                                      QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto endjob;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto endjob;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (qemuMigrationDstPersist(driver, vm, mig, !v3proto) < 0) {\n            /* Hmpf.  Migration was successful, but making it persistent\n             * was not.  If we report successful, then when this domain\n             * shuts down, management tools are in for a surprise.  On the\n             * other hand, if we report failure, then the management tools\n             * might try to restart the domain on the source side, even\n             * though the domain is actually running on the destination.\n             * Pretend success and hope that this is a rare situation and\n             * management tools are smart.\n             *\n             * However, in v3 protocol, the source VM is still available\n             * to restart during confirm() step, so we kill it off now.\n             */\n            if (v3proto)\n                goto endjob;\n        }\n    }\n\n    /* We need to wait for QEMU to process all data sent by the source\n     * before starting guest CPUs.\n     */\n    if (qemuMigrationDstWaitForCompletion(driver, vm,\n                                          QEMU_ASYNC_JOB_MIGRATION_IN,\n                                          !!(flags & VIR_MIGRATE_POSTCOPY)) < 0) {\n        /* There's not much we can do for v2 protocol since the\n         * original domain on the source host is already gone.\n         */\n        if (v3proto)\n            goto endjob;\n    }\n\n    /* Now that the state data was transferred we can refresh the actual state\n     * of the devices */\n    if (qemuProcessRefreshState(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN) < 0) {\n        /* Similarly to the case above v2 protocol will not be able to recover\n         * from this. Let's ignore this and perhaps stuff will not break. */\n        if (v3proto)\n            goto endjob;\n    }\n\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY)\n        inPostCopy = true;\n\n    if (!(flags & VIR_MIGRATE_PAUSED)) {\n        /* run 'cont' on the destination, which allows migration on qemu\n         * >= 0.10.6 to work properly.  This isn't strictly necessary on\n         * older qemu's, but it also doesn't hurt anything there\n         */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 inPostCopy ? VIR_DOMAIN_RUNNING_POSTCOPY\n                                            : VIR_DOMAIN_RUNNING_MIGRATED,\n                                 QEMU_ASYNC_JOB_MIGRATION_IN) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"resume operation failed\"));\n            /* Need to save the current error, in case shutting\n             * down the process overwrites it\n             */\n            virErrorPreserveLast(&orig_err);\n\n            /*\n             * In v3 protocol, the source VM is still available to\n             * restart during confirm() step, so we kill it off\n             * now.\n             * In v2 protocol, the source is dead, so we leave\n             * target in paused state, in case admin can fix\n             * things up.\n             */\n            if (v3proto)\n                goto endjob;\n        }\n\n        if (inPostCopy)\n            doKill = false;\n    }\n\n    if (mig->jobInfo) {\n        jobInfo = mig->jobInfo;\n        mig->jobInfo = NULL;\n\n        if (jobInfo->sent && timeReceived) {\n            jobInfo->timeDelta = timeReceived - jobInfo->sent;\n            jobInfo->received = timeReceived;\n            jobInfo->timeDeltaSet = true;\n        }\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        qemuDomainJobInfoUpdateDowntime(jobInfo);\n    }\n\n    if (inPostCopy) {\n        if (qemuMigrationDstWaitForCompletion(driver, vm,\n                                              QEMU_ASYNC_JOB_MIGRATION_IN,\n                                              false) < 0) {\n            goto endjob;\n        }\n        if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n            virDomainObjSetState(vm,\n                                 VIR_DOMAIN_RUNNING,\n                                 VIR_DOMAIN_RUNNING_MIGRATED);\n        }\n    }\n\n    dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, vm->def->id);\n\n    if (inPostCopy) {\n        /* The only RESUME event during post-copy migration is triggered by\n         * QEMU when the running domain moves from the source to the\n         * destination host, but then the migration keeps running until all\n         * modified memory is transferred from the source host. This will\n         * result in VIR_DOMAIN_EVENT_RESUMED with RESUMED_POSTCOPY detail.\n         * However, our API documentation says we need to fire another RESUMED\n         * event at the very end of migration with RESUMED_MIGRATED detail.\n         */\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_RESUMED,\n                                                  VIR_DOMAIN_EVENT_RESUMED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_PAUSED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    if (virDomainObjIsActive(vm) &&\n        virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n\n    /* Guest is successfully running, so cancel previous auto destroy */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n endjob:\n    if (!dom &&\n        !(flags & VIR_MIGRATE_OFFLINE) &&\n        virDomainObjIsActive(vm)) {\n        if (doKill) {\n            qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                            QEMU_ASYNC_JOB_MIGRATION_IN,\n                            VIR_QEMU_PROCESS_STOP_MIGRATED);\n            virDomainAuditStop(vm, \"failed\");\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                VIR_DOMAIN_EVENT_STOPPED,\n                                VIR_DOMAIN_EVENT_STOPPED_FAILED);\n            virObjectEventStateQueue(driver->domainEventState, event);\n        } else {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        }\n    }\n\n    if (dom) {\n        if (jobInfo) {\n            priv->job.completed = g_steal_pointer(&jobInfo);\n            priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n            priv->job.completed->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n        }\n\n        if (qemuMigrationBakeCookie(mig, driver, vm,\n                                    QEMU_MIGRATION_DESTINATION,\n                                    cookieout, cookieoutlen,\n                                    QEMU_MIGRATION_COOKIE_STATS) < 0)\n            VIR_WARN(\"Unable to encode migration cookie\");\n\n        /* Remove completed stats for post-copy, everything but timing fields\n         * is obsolete anyway.\n         */\n        if (inPostCopy)\n            VIR_FREE(priv->job.completed);\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n cleanup:\n    VIR_FREE(jobInfo);\n    virPortAllocatorRelease(port);\n    if (priv->mon)\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    VIR_FREE(priv->origname);\n    virDomainObjEndAPI(&vm);\n    qemuMigrationCookieFree(mig);\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n\n    /* Set a special error if Finish is expected to return NULL as a result of\n     * successful call with retcode != 0\n     */\n    if (retcode != 0 && !dom && virGetLastErrorCode() == VIR_ERR_OK)\n        virReportError(VIR_ERR_MIGRATE_FINISH_OK, NULL);\n    return dom;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_MIGRATE_FINISH_OK",
            "NULL"
          ],
          "line": 5248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorCode",
          "args": [],
          "line": 5247
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorCode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "280-287",
          "snippet": "int\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirGetLastErrorCode(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (!err)\n        return VIR_ERR_OK;\n    return err->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 5241
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 5240
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 5239
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->origname"
          ],
          "line": 5238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorSetDomainLog",
          "args": [
            "priv->mon",
            "NULL",
            "NULL",
            "NULL"
          ],
          "line": 5237
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSetDomainLog",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3985-3994",
          "snippet": "void\nqemuMonitorSetDomainLog(qemuMonitorPtr mon,\n                        qemuMonitorReportDomainLogError func,\n                        void *opaque,\n                        virFreeCallback destroy)\n{\n    virObjectLock(mon);\n    qemuMonitorSetDomainLogLocked(mon, func, opaque, destroy);\n    virObjectUnlock(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorSetDomainLog(qemuMonitorPtr mon,\n                        qemuMonitorReportDomainLogError func,\n                        void *opaque,\n                        virFreeCallback destroy)\n{\n    virObjectLock(mon);\n    qemuMonitorSetDomainLogLocked(mon, func, opaque, destroy);\n    virObjectUnlock(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "port"
          ],
          "line": 5235
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "jobInfo"
          ],
          "line": 5234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainRemoveInactiveJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5231
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainRemoveInactiveJobLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11335-11347",
          "snippet": "void\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 5230
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5229
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 5226
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->job.completed"
          ],
          "line": 5223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to encode migration cookie\""
          ],
          "line": 5217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationBakeCookie",
          "args": [
            "mig",
            "driver",
            "vm",
            "QEMU_MIGRATION_DESTINATION",
            "cookieout",
            "cookieoutlen",
            "QEMU_MIGRATION_COOKIE_STATS"
          ],
          "line": 5213
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationBakeCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1397-1459",
          "snippet": "int\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&jobInfo"
          ],
          "line": 5208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyPostcopyFailed",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5202
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyPostcopyFailed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1386-1415",
          "snippet": "void\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 5200
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_FAILED"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "vm",
            "\"failed\""
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_FAILED",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "VIR_QEMU_PROCESS_STOP_MIGRATED"
          ],
          "line": 5193
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7306-7649",
          "snippet": "void qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessAutoDestroyRemove",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5186
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessAutoDestroyRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7702-7708",
          "snippet": "int qemuProcessAutoDestroyRemove(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    return virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                                  qemuProcessAutoDestroy);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint qemuProcessAutoDestroyRemove(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm)\n{\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    return virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                                  qemuProcessAutoDestroy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to save status on vm %s\"",
            "vm->def->name"
          ],
          "line": 5183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_PAUSED",
            "VIR_DOMAIN_PAUSED_USER"
          ],
          "line": 5174
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 5173
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "dconn",
            "vm->def->name",
            "vm->def->uuid",
            "vm->def->id"
          ],
          "line": 5156
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstWaitForCompletion",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "false"
          ],
          "line": 5144
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstWaitForCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1744-1769",
          "snippet": "static int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateDowntime",
          "args": [
            "jobInfo"
          ],
          "line": 5140
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateDowntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "451-471",
          "snippet": "int\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "jobInfo"
          ],
          "line": 5139
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 5112
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"resume operation failed\")"
          ],
          "line": 5107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"resume operation failed\""
          ],
          "line": 5108
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStartCPUs",
          "args": [
            "driver",
            "vm",
            "inPostCopy ? VIR_DOMAIN_RUNNING_POSTCOPY\n                                            : VIR_DOMAIN_RUNNING_MIGRATED",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 5102
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStartCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "3210-3259",
          "snippet": "int\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessRefreshState",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 5087
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessRefreshState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7023-7050",
          "snippet": "int\nqemuProcessRefreshState(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"Fetching list of active devices\");\n    if (qemuDomainUpdateDeviceList(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating info of memory devices\");\n    if (qemuDomainUpdateMemoryDeviceInfo(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Detecting actual memory size for video device\");\n    if (qemuProcessUpdateVideoRamSize(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating disk data\");\n    if (qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        return -1;\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessRefreshState(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"Fetching list of active devices\");\n    if (qemuDomainUpdateDeviceList(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating info of memory devices\");\n    if (qemuDomainUpdateMemoryDeviceInfo(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Detecting actual memory size for video device\");\n    if (qemuProcessUpdateVideoRamSize(driver, vm, asyncJob) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Updating disk data\");\n    if (qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        return -1;\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n        qemuBlockNodeNamesDetect(driver, vm, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstPersist",
          "args": [
            "driver",
            "vm",
            "mig",
            "!v3proto"
          ],
          "line": 5054
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPersist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4908-4954",
          "snippet": "static int\nqemuMigrationDstPersist(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationCookiePtr mig,\n                        bool ignoreSaveError)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr vmdef;\n    virDomainDefPtr oldDef = NULL;\n    unsigned int oldPersist = vm->persistent;\n    virObjectEventPtr event;\n    int ret = -1;\n\n    vm->persistent = 1;\n    oldDef = vm->newDef;\n    vm->newDef = qemuMigrationCookieGetPersistent(mig);\n\n    if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm,\n                                               priv->qemuCaps)))\n        goto error;\n\n    if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0 &&\n        !ignoreSaveError)\n        goto error;\n\n    event = virDomainEventLifecycleNewFromObj(vm,\n                                              VIR_DOMAIN_EVENT_DEFINED,\n                                              oldPersist ?\n                                              VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                              VIR_DOMAIN_EVENT_DEFINED_ADDED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n\n cleanup:\n    virDomainDefFree(oldDef);\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virDomainDefFree(vm->newDef);\n    vm->persistent = oldPersist;\n    vm->newDef = oldDef;\n    oldDef = NULL;\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPersist(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationCookiePtr mig,\n                        bool ignoreSaveError)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr vmdef;\n    virDomainDefPtr oldDef = NULL;\n    unsigned int oldPersist = vm->persistent;\n    virObjectEventPtr event;\n    int ret = -1;\n\n    vm->persistent = 1;\n    oldDef = vm->newDef;\n    vm->newDef = qemuMigrationCookieGetPersistent(mig);\n\n    if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm,\n                                               priv->qemuCaps)))\n        goto error;\n\n    if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0 &&\n        !ignoreSaveError)\n        goto error;\n\n    event = virDomainEventLifecycleNewFromObj(vm,\n                                              VIR_DOMAIN_EVENT_DEFINED,\n                                              oldPersist ?\n                                              VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                              VIR_DOMAIN_EVENT_DEFINED_ADDED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n\n cleanup:\n    virDomainDefFree(oldDef);\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virDomainDefFree(vm->newDef);\n    vm->persistent = oldPersist;\n    vm->newDef = oldDef;\n    oldDef = NULL;\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuConnectAgent",
          "args": [
            "driver",
            "vm"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "qemuConnectAgent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "206-274",
          "snippet": "int\nqemuConnectAgent(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuAgentPtr agent = NULL;\n    virDomainChrDefPtr config = qemuFindAgentConfig(vm->def);\n\n    if (!config)\n        return 0;\n\n    if (priv->agent)\n        return 0;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE) &&\n        config->state != VIR_DOMAIN_CHR_DEVICE_STATE_CONNECTED) {\n        VIR_DEBUG(\"Deferring connecting to guest agent\");\n        return 0;\n    }\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for agent for %s\"),\n                  vm->def->name);\n        goto cleanup;\n    }\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the agent is active */\n    virObjectRef(vm);\n\n    virObjectUnlock(vm);\n\n    agent = qemuAgentOpen(vm,\n                          config->source,\n                          virEventThreadGetContext(priv->eventThread),\n                          &agentCallbacks,\n                          virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE));\n\n    virObjectLock(vm);\n\n    if (agent == NULL)\n        virObjectUnref(vm);\n\n    if (!virDomainObjIsActive(vm)) {\n        qemuAgentClose(agent);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest crashed while connecting to the guest agent\"));\n        return -1;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for agent for %s\"),\n                  vm->def->name);\n        qemuAgentClose(agent);\n        goto cleanup;\n    }\n\n    priv->agent = agent;\n    if (!priv->agent)\n        VIR_INFO(\"Failed to connect agent for %s\", vm->def->name);\n\n cleanup:\n    if (!priv->agent) {\n        VIR_WARN(\"Cannot connect to QEMU guest agent for %s\", vm->def->name);\n        priv->agentError = true;\n        virResetLastError();\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static qemuAgentCallbacks agentCallbacks = {\n    .destroy = qemuProcessHandleAgentDestroy,\n    .eofNotify = qemuProcessHandleAgentEOF,\n    .errorNotify = qemuProcessHandleAgentError,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic qemuAgentCallbacks agentCallbacks = {\n    .destroy = qemuProcessHandleAgentDestroy,\n    .eofNotify = qemuProcessHandleAgentEOF,\n    .errorNotify = qemuProcessHandleAgentError,\n};\n\nint\nqemuConnectAgent(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuAgentPtr agent = NULL;\n    virDomainChrDefPtr config = qemuFindAgentConfig(vm->def);\n\n    if (!config)\n        return 0;\n\n    if (priv->agent)\n        return 0;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE) &&\n        config->state != VIR_DOMAIN_CHR_DEVICE_STATE_CONNECTED) {\n        VIR_DEBUG(\"Deferring connecting to guest agent\");\n        return 0;\n    }\n\n    if (qemuSecuritySetDaemonSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to set security context for agent for %s\"),\n                  vm->def->name);\n        goto cleanup;\n    }\n\n    /* Hold an extra reference because we can't allow 'vm' to be\n     * deleted while the agent is active */\n    virObjectRef(vm);\n\n    virObjectUnlock(vm);\n\n    agent = qemuAgentOpen(vm,\n                          config->source,\n                          virEventThreadGetContext(priv->eventThread),\n                          &agentCallbacks,\n                          virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_VSERPORT_CHANGE));\n\n    virObjectLock(vm);\n\n    if (agent == NULL)\n        virObjectUnref(vm);\n\n    if (!virDomainObjIsActive(vm)) {\n        qemuAgentClose(agent);\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest crashed while connecting to the guest agent\"));\n        return -1;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0) {\n        VIR_ERROR(_(\"Failed to clear security context for agent for %s\"),\n                  vm->def->name);\n        qemuAgentClose(agent);\n        goto cleanup;\n    }\n\n    priv->agent = agent;\n    if (!priv->agent)\n        VIR_INFO(\"Failed to connect agent for %s\", vm->def->name);\n\n cleanup:\n    if (!priv->agent) {\n        VIR_WARN(\"Cannot connect to QEMU guest agent for %s\", vm->def->name);\n        priv->agentError = true;\n        virResetLastError();\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuRefreshVirtioChannelState",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 5046
        },
        "resolved": true,
        "details": {
          "function_name": "qemuRefreshVirtioChannelState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "2236-2261",
          "snippet": "int\nqemuRefreshVirtioChannelState(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virHashTablePtr info = NULL;\n    int ret = -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    qemuProcessRefreshChannelVirtioState(driver, vm, info, false);\n    ret = 0;\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuRefreshVirtioChannelState(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virHashTablePtr info = NULL;\n    int ret = -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorGetChardevInfo(priv->mon, &info);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    qemuProcessRefreshChannelVirtioState(driver, vm, info, false);\n    ret = 0;\n\n cleanup:\n    virHashFree(info);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstStopNBDServer",
          "args": [
            "driver",
            "vm",
            "mig"
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstStopNBDServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "456-478",
          "snippet": "static int\nqemuMigrationDstStopNBDServer(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuMigrationCookiePtr mig)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!mig->nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        return -1;\n\n    if (qemuMonitorNBDServerStop(priv->mon) < 0)\n        VIR_WARN(\"Unable to stop NBD server\");\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstStopNBDServer(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuMigrationCookiePtr mig)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!mig->nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        return -1;\n\n    if (qemuMonitorNBDServerStop(priv->mon) < 0)\n        VIR_WARN(\"Unable to stop NBD server\");\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unable to provide network data for relocation\""
          ],
          "line": 5041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstOPDRelocate",
          "args": [
            "driver",
            "vm",
            "mig"
          ],
          "line": 5040
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstOPDRelocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1871-1902",
          "snippet": "static int\nqemuMigrationDstOPDRelocate(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMigrationCookiePtr cookie)\n{\n    virDomainNetDefPtr netptr;\n    size_t i;\n\n    for (i = 0; i < cookie->network->nnets; i++) {\n        netptr = vm->def->nets[i];\n\n        switch (cookie->network->net[i].vporttype) {\n        case VIR_NETDEV_VPORT_PROFILE_NONE:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n           break;\n        case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n            if (virNetDevOpenvswitchSetMigrateData(cookie->network->net[i].portdata,\n                                                   netptr->ifname) != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\"), netptr->ifname);\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstOPDRelocate(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMigrationCookiePtr cookie)\n{\n    virDomainNetDefPtr netptr;\n    size_t i;\n\n    for (i = 0; i < cookie->network->nnets; i++) {\n        netptr = vm->def->nets[i];\n\n        switch (cookie->network->net[i].vporttype) {\n        case VIR_NETDEV_VPORT_PROFILE_NONE:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n           break;\n        case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n            if (virNetDevOpenvswitchSetMigrateData(cookie->network->net[i].portdata,\n                                                   netptr->ifname) != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\"), netptr->ifname);\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstVPAssociatePortProfiles",
          "args": [
            "vm->def"
          ],
          "line": 5037
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstVPAssociatePortProfiles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4856-4905",
          "snippet": "static int\nqemuMigrationDstVPAssociatePortProfiles(virDomainDefPtr def)\n{\n    size_t i;\n    int last_good_net = -1;\n    virDomainNetDefPtr net;\n\n    for (i = 0; i < def->nnets; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            if (virNetDevVPortProfileAssociate(net->ifname,\n                                               virDomainNetGetActualVirtPortProfile(net),\n                                               &net->mac,\n                                               virDomainNetGetActualDirectDev(net),\n                                               -1,\n                                               def->uuid,\n                                               VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH,\n                                               false) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Port profile Associate failed for %s\"),\n                               net->ifname);\n                goto err_exit;\n            }\n            last_good_net = i;\n            VIR_DEBUG(\"Port profile Associate succeeded for %s\", net->ifname);\n\n            if (virNetDevMacVLanVPortProfileRegisterCallback(net->ifname, &net->mac,\n                                                             virDomainNetGetActualDirectDev(net), def->uuid,\n                                                             virDomainNetGetActualVirtPortProfile(net),\n                                                             VIR_NETDEV_VPORT_PROFILE_OP_CREATE))\n                goto err_exit;\n        }\n    }\n\n    return 0;\n\n err_exit:\n    for (i = 0; last_good_net != -1 && i <= last_good_net; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            ignore_value(virNetDevVPortProfileDisassociate(net->ifname,\n                                                           virDomainNetGetActualVirtPortProfile(net),\n                                                           &net->mac,\n                                                           virDomainNetGetActualDirectDev(net),\n                                                           -1,\n                                                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH));\n        }\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstVPAssociatePortProfiles(virDomainDefPtr def)\n{\n    size_t i;\n    int last_good_net = -1;\n    virDomainNetDefPtr net;\n\n    for (i = 0; i < def->nnets; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            if (virNetDevVPortProfileAssociate(net->ifname,\n                                               virDomainNetGetActualVirtPortProfile(net),\n                                               &net->mac,\n                                               virDomainNetGetActualDirectDev(net),\n                                               -1,\n                                               def->uuid,\n                                               VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH,\n                                               false) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Port profile Associate failed for %s\"),\n                               net->ifname);\n                goto err_exit;\n            }\n            last_good_net = i;\n            VIR_DEBUG(\"Port profile Associate succeeded for %s\", net->ifname);\n\n            if (virNetDevMacVLanVPortProfileRegisterCallback(net->ifname, &net->mac,\n                                                             virDomainNetGetActualDirectDev(net), def->uuid,\n                                                             virDomainNetGetActualVirtPortProfile(net),\n                                                             VIR_NETDEV_VPORT_PROFILE_OP_CREATE))\n                goto err_exit;\n        }\n    }\n\n    return 0;\n\n err_exit:\n    for (i = 0; last_good_net != -1 && i <= last_good_net; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            ignore_value(virNetDevVPortProfileDisassociate(net->ifname,\n                                                           virDomainNetGetActualVirtPortProfile(net),\n                                                           &net->mac,\n                                                           virDomainNetGetActualDirectDev(net),\n                                                           -1,\n                                                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH));\n        }\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstErrorReport",
          "args": [
            "driver",
            "vm->def->name"
          ],
          "line": 5033
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstErrorReport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5542-5554",
          "snippet": "void\nqemuMigrationDstErrorReport(virQEMUDriverPtr driver,\n                            const char *name)\n{\n    virErrorPtr err;\n\n    if (!(err = virHashAtomicSteal(driver->migrationErrors, name)))\n        return;\n\n    VIR_DEBUG(\"Restoring saved incoming migration error for domain %s: %s\",\n              name, err->message);\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationDstErrorReport(virQEMUDriverPtr driver,\n                            const char *name)\n{\n    virErrorPtr err;\n\n    if (!(err = virHashAtomicSteal(driver->migrationErrors, name)))\n        return;\n\n    VIR_DEBUG(\"Restoring saved incoming migration error for domain %s: %s\",\n              name, err->message);\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"guest unexpectedly quit\")"
          ],
          "line": 5031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainCheckMonitor",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 5026
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainCheckMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "14195-14212",
          "snippet": "int\nqemuDomainCheckMonitor(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorCheck(priv->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainCheckMonitor(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorCheck(priv->mon);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationEatCookie",
          "args": [
            "driver",
            "vm->def",
            "priv->origname",
            "priv",
            "cookiein",
            "cookieinlen",
            "cookie_flags"
          ],
          "line": 5011
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1462-1527",
          "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->job.completed"
          ],
          "line": 5002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainCleanupRemove",
          "args": [
            "vm",
            "qemuMigrationDstPrepareCleanup"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainCleanupRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11487-11505",
          "snippet": "void\nqemuDomainCleanupRemove(virDomainObjPtr vm,\n                        qemuDomainCleanupCallback cb)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    VIR_DEBUG(\"vm=%s, cb=%p\", vm->def->name, cb);\n\n    for (i = 0; i < priv->ncleanupCallbacks; i++) {\n        if (priv->cleanupCallbacks[i] == cb)\n            VIR_DELETE_ELEMENT_INPLACE(priv->cleanupCallbacks,\n                                       i, priv->ncleanupCallbacks);\n    }\n\n    VIR_SHRINK_N(priv->cleanupCallbacks,\n                 priv->ncleanupCallbacks_max,\n                 priv->ncleanupCallbacks_max - priv->ncleanupCallbacks);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nvoid\nqemuDomainCleanupRemove(virDomainObjPtr vm,\n                        qemuDomainCleanupCallback cb)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    VIR_DEBUG(\"vm=%s, cb=%p\", vm->def->name, cb);\n\n    for (i = 0; i < priv->ncleanupCallbacks; i++) {\n        if (priv->cleanupCallbacks[i] == cb)\n            VIR_DELETE_ELEMENT_INPLACE(priv->cleanupCallbacks,\n                                       i, priv->ncleanupCallbacks);\n    }\n\n    VIR_SHRINK_N(priv->cleanupCallbacks,\n                 priv->ncleanupCallbacks_max,\n                 priv->ncleanupCallbacks_max - priv->ncleanupCallbacks);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStartPhase",
          "args": [
            "driver",
            "vm",
            "v3proto ? QEMU_MIGRATION_PHASE_FINISH3\n                                       : QEMU_MIGRATION_PHASE_FINISH2"
          ],
          "line": 4997
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStartPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5464-5470",
          "snippet": "static void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virTimeMillisNow(&timeReceived)"
          ],
          "line": 4995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTimeMillisNow",
          "args": [
            "&timeReceived"
          ],
          "line": 4995
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeMillisNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "214-222",
          "snippet": "int virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobIsActive",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 4990
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5478-5496",
          "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, dconn=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, retcode=%d\"",
            "driver",
            "dconn",
            "vm",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "retcode"
          ],
          "line": 4982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 4984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 4974
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvirDomainPtr\nqemuMigrationDstFinish(virQEMUDriverPtr driver,\n                       virConnectPtr dconn,\n                       virDomainObjPtr vm,\n                       const char *cookiein,\n                       int cookieinlen,\n                       char **cookieout,\n                       int *cookieoutlen,\n                       unsigned long flags,\n                       int retcode,\n                       bool v3proto)\n{\n    virDomainPtr dom = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virErrorPtr orig_err = NULL;\n    int cookie_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    unsigned short port;\n    unsigned long long timeReceived = 0;\n    virObjectEventPtr event;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n    bool inPostCopy = false;\n    bool doKill = true;\n\n    VIR_DEBUG(\"driver=%p, dconn=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, retcode=%d\",\n              driver, dconn, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, retcode);\n\n    port = priv->migrationPort;\n    priv->migrationPort = 0;\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_IN)) {\n        qemuMigrationDstErrorReport(driver, vm->def->name);\n        goto cleanup;\n    }\n\n    ignore_value(virTimeMillisNow(&timeReceived));\n\n    qemuMigrationJobStartPhase(driver, vm,\n                               v3proto ? QEMU_MIGRATION_PHASE_FINISH3\n                                       : QEMU_MIGRATION_PHASE_FINISH2);\n\n    qemuDomainCleanupRemove(vm, qemuMigrationDstPrepareCleanup);\n    VIR_FREE(priv->job.completed);\n\n    cookie_flags = QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS |\n                   QEMU_MIGRATION_COOKIE_NBD;\n    /* Some older versions of libvirt always send persistent XML in the cookie\n     * even though VIR_MIGRATE_PERSIST_DEST was not used. */\n    cookie_flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen, cookie_flags)))\n        goto endjob;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (retcode == 0 &&\n            qemuMigrationDstPersist(driver, vm, mig, false) == 0)\n            dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, -1);\n        goto endjob;\n    }\n\n    if (retcode != 0) {\n        /* Check for a possible error on the monitor in case Finish was called\n         * earlier than monitor EOF handler got a chance to process the error\n         */\n        qemuDomainCheckMonitor(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN);\n        goto endjob;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"guest unexpectedly quit\"));\n        qemuMigrationDstErrorReport(driver, vm->def->name);\n        goto endjob;\n    }\n\n    if (qemuMigrationDstVPAssociatePortProfiles(vm->def) < 0)\n        goto endjob;\n\n    if (mig->network && qemuMigrationDstOPDRelocate(driver, vm, mig) < 0)\n        VIR_WARN(\"unable to provide network data for relocation\");\n\n    if (qemuMigrationDstStopNBDServer(driver, vm, mig) < 0)\n        goto endjob;\n\n    if (qemuRefreshVirtioChannelState(driver, vm,\n                                      QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto endjob;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto endjob;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (qemuMigrationDstPersist(driver, vm, mig, !v3proto) < 0) {\n            /* Hmpf.  Migration was successful, but making it persistent\n             * was not.  If we report successful, then when this domain\n             * shuts down, management tools are in for a surprise.  On the\n             * other hand, if we report failure, then the management tools\n             * might try to restart the domain on the source side, even\n             * though the domain is actually running on the destination.\n             * Pretend success and hope that this is a rare situation and\n             * management tools are smart.\n             *\n             * However, in v3 protocol, the source VM is still available\n             * to restart during confirm() step, so we kill it off now.\n             */\n            if (v3proto)\n                goto endjob;\n        }\n    }\n\n    /* We need to wait for QEMU to process all data sent by the source\n     * before starting guest CPUs.\n     */\n    if (qemuMigrationDstWaitForCompletion(driver, vm,\n                                          QEMU_ASYNC_JOB_MIGRATION_IN,\n                                          !!(flags & VIR_MIGRATE_POSTCOPY)) < 0) {\n        /* There's not much we can do for v2 protocol since the\n         * original domain on the source host is already gone.\n         */\n        if (v3proto)\n            goto endjob;\n    }\n\n    /* Now that the state data was transferred we can refresh the actual state\n     * of the devices */\n    if (qemuProcessRefreshState(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN) < 0) {\n        /* Similarly to the case above v2 protocol will not be able to recover\n         * from this. Let's ignore this and perhaps stuff will not break. */\n        if (v3proto)\n            goto endjob;\n    }\n\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY)\n        inPostCopy = true;\n\n    if (!(flags & VIR_MIGRATE_PAUSED)) {\n        /* run 'cont' on the destination, which allows migration on qemu\n         * >= 0.10.6 to work properly.  This isn't strictly necessary on\n         * older qemu's, but it also doesn't hurt anything there\n         */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 inPostCopy ? VIR_DOMAIN_RUNNING_POSTCOPY\n                                            : VIR_DOMAIN_RUNNING_MIGRATED,\n                                 QEMU_ASYNC_JOB_MIGRATION_IN) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               \"%s\", _(\"resume operation failed\"));\n            /* Need to save the current error, in case shutting\n             * down the process overwrites it\n             */\n            virErrorPreserveLast(&orig_err);\n\n            /*\n             * In v3 protocol, the source VM is still available to\n             * restart during confirm() step, so we kill it off\n             * now.\n             * In v2 protocol, the source is dead, so we leave\n             * target in paused state, in case admin can fix\n             * things up.\n             */\n            if (v3proto)\n                goto endjob;\n        }\n\n        if (inPostCopy)\n            doKill = false;\n    }\n\n    if (mig->jobInfo) {\n        jobInfo = mig->jobInfo;\n        mig->jobInfo = NULL;\n\n        if (jobInfo->sent && timeReceived) {\n            jobInfo->timeDelta = timeReceived - jobInfo->sent;\n            jobInfo->received = timeReceived;\n            jobInfo->timeDeltaSet = true;\n        }\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        qemuDomainJobInfoUpdateDowntime(jobInfo);\n    }\n\n    if (inPostCopy) {\n        if (qemuMigrationDstWaitForCompletion(driver, vm,\n                                              QEMU_ASYNC_JOB_MIGRATION_IN,\n                                              false) < 0) {\n            goto endjob;\n        }\n        if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n            virDomainObjSetState(vm,\n                                 VIR_DOMAIN_RUNNING,\n                                 VIR_DOMAIN_RUNNING_MIGRATED);\n        }\n    }\n\n    dom = virGetDomain(dconn, vm->def->name, vm->def->uuid, vm->def->id);\n\n    if (inPostCopy) {\n        /* The only RESUME event during post-copy migration is triggered by\n         * QEMU when the running domain moves from the source to the\n         * destination host, but then the migration keeps running until all\n         * modified memory is transferred from the source host. This will\n         * result in VIR_DOMAIN_EVENT_RESUMED with RESUMED_POSTCOPY detail.\n         * However, our API documentation says we need to fire another RESUMED\n         * event at the very end of migration with RESUMED_MIGRATED detail.\n         */\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_RESUMED,\n                                                  VIR_DOMAIN_EVENT_RESUMED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED) {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_USER);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED,\n                                                  VIR_DOMAIN_EVENT_SUSPENDED_PAUSED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    if (virDomainObjIsActive(vm) &&\n        virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n\n    /* Guest is successfully running, so cancel previous auto destroy */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n endjob:\n    if (!dom &&\n        !(flags & VIR_MIGRATE_OFFLINE) &&\n        virDomainObjIsActive(vm)) {\n        if (doKill) {\n            qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                            QEMU_ASYNC_JOB_MIGRATION_IN,\n                            VIR_QEMU_PROCESS_STOP_MIGRATED);\n            virDomainAuditStop(vm, \"failed\");\n            event = virDomainEventLifecycleNewFromObj(vm,\n                                VIR_DOMAIN_EVENT_STOPPED,\n                                VIR_DOMAIN_EVENT_STOPPED_FAILED);\n            virObjectEventStateQueue(driver->domainEventState, event);\n        } else {\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        }\n    }\n\n    if (dom) {\n        if (jobInfo) {\n            priv->job.completed = g_steal_pointer(&jobInfo);\n            priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n            priv->job.completed->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n        }\n\n        if (qemuMigrationBakeCookie(mig, driver, vm,\n                                    QEMU_MIGRATION_DESTINATION,\n                                    cookieout, cookieoutlen,\n                                    QEMU_MIGRATION_COOKIE_STATS) < 0)\n            VIR_WARN(\"Unable to encode migration cookie\");\n\n        /* Remove completed stats for post-copy, everything but timing fields\n         * is obsolete anyway.\n         */\n        if (inPostCopy)\n            VIR_FREE(priv->job.completed);\n    }\n\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n cleanup:\n    VIR_FREE(jobInfo);\n    virPortAllocatorRelease(port);\n    if (priv->mon)\n        qemuMonitorSetDomainLog(priv->mon, NULL, NULL, NULL);\n    VIR_FREE(priv->origname);\n    virDomainObjEndAPI(&vm);\n    qemuMigrationCookieFree(mig);\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n\n    /* Set a special error if Finish is expected to return NULL as a result of\n     * successful call with retcode != 0\n     */\n    if (retcode != 0 && !dom && virGetLastErrorCode() == VIR_ERR_OK)\n        virReportError(VIR_ERR_MIGRATE_FINISH_OK, NULL);\n    return dom;\n}"
  },
  {
    "function_name": "qemuMigrationDstPersist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4908-4954",
    "snippet": "static int\nqemuMigrationDstPersist(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationCookiePtr mig,\n                        bool ignoreSaveError)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr vmdef;\n    virDomainDefPtr oldDef = NULL;\n    unsigned int oldPersist = vm->persistent;\n    virObjectEventPtr event;\n    int ret = -1;\n\n    vm->persistent = 1;\n    oldDef = vm->newDef;\n    vm->newDef = qemuMigrationCookieGetPersistent(mig);\n\n    if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm,\n                                               priv->qemuCaps)))\n        goto error;\n\n    if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0 &&\n        !ignoreSaveError)\n        goto error;\n\n    event = virDomainEventLifecycleNewFromObj(vm,\n                                              VIR_DOMAIN_EVENT_DEFINED,\n                                              oldPersist ?\n                                              VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                              VIR_DOMAIN_EVENT_DEFINED_ADDED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n\n cleanup:\n    virDomainDefFree(oldDef);\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virDomainDefFree(vm->newDef);\n    vm->persistent = oldPersist;\n    vm->newDef = oldDef;\n    oldDef = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "vm->newDef"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 4945
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_DEFINED",
            "oldPersist ?\n                                              VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                              VIR_DOMAIN_EVENT_DEFINED_ADDED"
          ],
          "line": 4934
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefSave",
          "args": [
            "vmdef",
            "driver->xmlopt",
            "cfg->configDir"
          ],
          "line": 4930
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29693-29704",
          "snippet": "int\nvirDomainDefSave(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *configDir)\n{\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainDefFormat(def, xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE)))\n        return -1;\n\n    return virDomainDefSaveXML(def, configDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDefSave(virDomainDefPtr def,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *configDir)\n{\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainDefFormat(def, xmlopt, VIR_DOMAIN_DEF_FORMAT_SECURE)))\n        return -1;\n\n    return virDomainDefSaveXML(def, configDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetPersistentDef",
          "args": [
            "driver->xmlopt",
            "vm",
            "priv->qemuCaps"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetPersistentDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3757-3770",
          "snippet": "virDomainDefPtr\nvirDomainObjGetPersistentDef(virDomainXMLOptionPtr xmlopt,\n                             virDomainObjPtr domain,\n                             void *parseOpaque)\n{\n    if (virDomainObjIsActive(domain) &&\n        virDomainObjSetDefTransient(xmlopt, domain, parseOpaque) < 0)\n        return NULL;\n\n    if (domain->newDef)\n        return domain->newDef;\n    else\n        return domain->def;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainObjGetPersistentDef(virDomainXMLOptionPtr xmlopt,\n                             virDomainObjPtr domain,\n                             void *parseOpaque)\n{\n    if (virDomainObjIsActive(domain) &&\n        virDomainObjSetDefTransient(xmlopt, domain, parseOpaque) < 0)\n        return NULL;\n\n    if (domain->newDef)\n        return domain->newDef;\n    else\n        return domain->def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieGetPersistent",
          "args": [
            "mig"
          ],
          "line": 4924
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieGetPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "416-426",
          "snippet": "virDomainDefPtr\nqemuMigrationCookieGetPersistent(qemuMigrationCookiePtr mig)\n{\n    virDomainDefPtr def = mig->persistent;\n\n    mig->persistent = NULL;\n    mig->flags &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    return def;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvirDomainDefPtr\nqemuMigrationCookieGetPersistent(qemuMigrationCookiePtr mig)\n{\n    virDomainDefPtr def = mig->persistent;\n\n    mig->persistent = NULL;\n    mig->flags &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory &= ~QEMU_MIGRATION_COOKIE_PERSISTENT;\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 4914
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPersist(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationCookiePtr mig,\n                        bool ignoreSaveError)\n{\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr vmdef;\n    virDomainDefPtr oldDef = NULL;\n    unsigned int oldPersist = vm->persistent;\n    virObjectEventPtr event;\n    int ret = -1;\n\n    vm->persistent = 1;\n    oldDef = vm->newDef;\n    vm->newDef = qemuMigrationCookieGetPersistent(mig);\n\n    if (!(vmdef = virDomainObjGetPersistentDef(driver->xmlopt, vm,\n                                               priv->qemuCaps)))\n        goto error;\n\n    if (virDomainDefSave(vmdef, driver->xmlopt, cfg->configDir) < 0 &&\n        !ignoreSaveError)\n        goto error;\n\n    event = virDomainEventLifecycleNewFromObj(vm,\n                                              VIR_DOMAIN_EVENT_DEFINED,\n                                              oldPersist ?\n                                              VIR_DOMAIN_EVENT_DEFINED_UPDATED :\n                                              VIR_DOMAIN_EVENT_DEFINED_ADDED);\n    virObjectEventStateQueue(driver->domainEventState, event);\n\n    ret = 0;\n\n cleanup:\n    virDomainDefFree(oldDef);\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virDomainDefFree(vm->newDef);\n    vm->persistent = oldPersist;\n    vm->newDef = oldDef;\n    oldDef = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuMigrationDstVPAssociatePortProfiles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4856-4905",
    "snippet": "static int\nqemuMigrationDstVPAssociatePortProfiles(virDomainDefPtr def)\n{\n    size_t i;\n    int last_good_net = -1;\n    virDomainNetDefPtr net;\n\n    for (i = 0; i < def->nnets; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            if (virNetDevVPortProfileAssociate(net->ifname,\n                                               virDomainNetGetActualVirtPortProfile(net),\n                                               &net->mac,\n                                               virDomainNetGetActualDirectDev(net),\n                                               -1,\n                                               def->uuid,\n                                               VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH,\n                                               false) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Port profile Associate failed for %s\"),\n                               net->ifname);\n                goto err_exit;\n            }\n            last_good_net = i;\n            VIR_DEBUG(\"Port profile Associate succeeded for %s\", net->ifname);\n\n            if (virNetDevMacVLanVPortProfileRegisterCallback(net->ifname, &net->mac,\n                                                             virDomainNetGetActualDirectDev(net), def->uuid,\n                                                             virDomainNetGetActualVirtPortProfile(net),\n                                                             VIR_NETDEV_VPORT_PROFILE_OP_CREATE))\n                goto err_exit;\n        }\n    }\n\n    return 0;\n\n err_exit:\n    for (i = 0; last_good_net != -1 && i <= last_good_net; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            ignore_value(virNetDevVPortProfileDisassociate(net->ifname,\n                                                           virDomainNetGetActualVirtPortProfile(net),\n                                                           &net->mac,\n                                                           virDomainNetGetActualDirectDev(net),\n                                                           -1,\n                                                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH));\n        }\n    }\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevVPortProfileDisassociate(net->ifname,\n                                                           virDomainNetGetActualVirtPortProfile(net),\n                                                           &net->mac,\n                                                           virDomainNetGetActualDirectDev(net),\n                                                           -1,\n                                                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH)"
          ],
          "line": 4896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileDisassociate",
          "args": [
            "net->ifname",
            "virDomainNetGetActualVirtPortProfile(net)",
            "&net->mac",
            "virDomainNetGetActualDirectDev(net)",
            "-1",
            "VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileDisassociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1365-1375",
          "snippet": "int virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualDirectDev",
          "args": [
            "net"
          ],
          "line": 4899
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualDirectDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30188-30198",
          "snippet": "const char *\nvirDomainNetGetActualDirectDev(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.linkdev;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.linkdev;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainNetGetActualDirectDev(const virDomainNetDef *iface)\n{\n    if (iface->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.direct.linkdev;\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual &&\n        iface->data.network.actual->type == VIR_DOMAIN_NET_TYPE_DIRECT)\n        return iface->data.network.actual->data.direct.linkdev;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "net"
          ],
          "line": 4897
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualType",
          "args": [
            "net"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30154-30162",
          "snippet": "virDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainNetType\nvirDomainNetGetActualType(const virDomainNetDef *iface)\n{\n    if (iface->type != VIR_DOMAIN_NET_TYPE_NETWORK)\n        return iface->type;\n    if (!iface->data.network.actual)\n        return iface->type;\n    return iface->data.network.actual->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevMacVLanVPortProfileRegisterCallback",
          "args": [
            "net->ifname",
            "&net->mac",
            "virDomainNetGetActualDirectDev(net)",
            "def->uuid",
            "virDomainNetGetActualVirtPortProfile(net)",
            "VIR_NETDEV_VPORT_PROFILE_OP_CREATE"
          ],
          "line": 4882
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevMacVLanVPortProfileRegisterCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevmacvlan.c",
          "lines": "1262-1272",
          "snippet": "int virNetDevMacVLanVPortProfileRegisterCallback(const char *ifname G_GNUC_UNUSED,\n                                                 const virMacAddr *macaddress G_GNUC_UNUSED,\n                                                 const char *linkdev G_GNUC_UNUSED,\n                                                 const unsigned char *vmuuid G_GNUC_UNUSED,\n                                                 const virNetDevVPortProfile *virtPortProfile G_GNUC_UNUSED,\n                                                 virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virbitmap.h\"",
            "# include \"virpidfile.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virnetlink.h\"",
            "# include \"virfile.h\"",
            "# include \"viruuid.h\"",
            "# include \"virlog.h\"",
            "# include \"viralloc.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virbitmap.h\"\n# include \"virpidfile.h\"\n# include \"virnetdev.h\"\n# include \"virnetlink.h\"\n# include \"virfile.h\"\n# include \"viruuid.h\"\n# include \"virlog.h\"\n# include \"viralloc.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virnetdevmacvlan.h\"\n#include <config.h>\n\nint virNetDevMacVLanVPortProfileRegisterCallback(const char *ifname G_GNUC_UNUSED,\n                                                 const virMacAddr *macaddress G_GNUC_UNUSED,\n                                                 const char *linkdev G_GNUC_UNUSED,\n                                                 const unsigned char *vmuuid G_GNUC_UNUSED,\n                                                 const virNetDevVPortProfile *virtPortProfile G_GNUC_UNUSED,\n                                                 virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Cannot create macvlan devices on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Port profile Associate succeeded for %s\"",
            "net->ifname"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Port profile Associate failed for %s\")",
            "net->ifname"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Port profile Associate failed for %s\""
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileAssociate",
          "args": [
            "net->ifname",
            "virDomainNetGetActualVirtPortProfile(net)",
            "&net->mac",
            "virDomainNetGetActualDirectDev(net)",
            "-1",
            "def->uuid",
            "VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH",
            "false"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileAssociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1351-1363",
          "snippet": "int virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstVPAssociatePortProfiles(virDomainDefPtr def)\n{\n    size_t i;\n    int last_good_net = -1;\n    virDomainNetDefPtr net;\n\n    for (i = 0; i < def->nnets; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            if (virNetDevVPortProfileAssociate(net->ifname,\n                                               virDomainNetGetActualVirtPortProfile(net),\n                                               &net->mac,\n                                               virDomainNetGetActualDirectDev(net),\n                                               -1,\n                                               def->uuid,\n                                               VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH,\n                                               false) < 0) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Port profile Associate failed for %s\"),\n                               net->ifname);\n                goto err_exit;\n            }\n            last_good_net = i;\n            VIR_DEBUG(\"Port profile Associate succeeded for %s\", net->ifname);\n\n            if (virNetDevMacVLanVPortProfileRegisterCallback(net->ifname, &net->mac,\n                                                             virDomainNetGetActualDirectDev(net), def->uuid,\n                                                             virDomainNetGetActualVirtPortProfile(net),\n                                                             VIR_NETDEV_VPORT_PROFILE_OP_CREATE))\n                goto err_exit;\n        }\n    }\n\n    return 0;\n\n err_exit:\n    for (i = 0; last_good_net != -1 && i <= last_good_net; i++) {\n        net = def->nets[i];\n        if (virDomainNetGetActualType(net) == VIR_DOMAIN_NET_TYPE_DIRECT) {\n            ignore_value(virNetDevVPortProfileDisassociate(net->ifname,\n                                                           virDomainNetGetActualVirtPortProfile(net),\n                                                           &net->mac,\n                                                           virDomainNetGetActualDirectDev(net),\n                                                           -1,\n                                                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH));\n        }\n    }\n    return -1;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4781-4854",
    "snippet": "int\nqemuMigrationSrcPerform(virQEMUDriverPtr driver,\n                        virConnectPtr conn,\n                        virDomainObjPtr vm,\n                        const char *xmlin,\n                        const char *persist_xml,\n                        const char *dconnuri,\n                        const char *uri,\n                        const char *graphicsuri,\n                        const char *listenAddress,\n                        size_t nmigrate_disks,\n                        const char **migrate_disks,\n                        int nbdPort,\n                        qemuMigrationParamsPtr migParams,\n                        const char *cookiein,\n                        int cookieinlen,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long resource,\n                        bool v3proto)\n{\n    VIR_DEBUG(\"driver=%p, conn=%p, vm=%p, xmlin=%s, dconnuri=%s, \"\n              \"uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"cookiein=%s, cookieinlen=%d, cookieout=%p, cookieoutlen=%p, \"\n              \"flags=0x%lx, dname=%s, resource=%lu, v3proto=%d\",\n              driver, conn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort,\n              NULLSTR(cookiein), cookieinlen, cookieout, cookieoutlen,\n              flags, NULLSTR(dname), resource, v3proto);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        if (cookieinlen) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           \"%s\", _(\"received unexpected cookie with P2P migration\"));\n            return -1;\n        }\n\n        return qemuMigrationSrcPerformJob(driver, conn, vm, xmlin, persist_xml, dconnuri, uri,\n                                          graphicsuri, listenAddress,\n                                          nmigrate_disks, migrate_disks, nbdPort,\n                                          migParams,\n                                          cookiein, cookieinlen,\n                                          cookieout, cookieoutlen,\n                                          flags, dname, resource, v3proto);\n    } else {\n        if (dconnuri) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Unexpected dconnuri parameter with non-peer2peer migration\"));\n            return -1;\n        }\n\n        if (v3proto) {\n            return qemuMigrationSrcPerformPhase(driver, conn, vm, persist_xml, uri,\n                                                graphicsuri,\n                                                nmigrate_disks, migrate_disks,\n                                                migParams,\n                                                cookiein, cookieinlen,\n                                                cookieout, cookieoutlen,\n                                                flags, resource);\n        } else {\n            return qemuMigrationSrcPerformJob(driver, conn, vm, xmlin, persist_xml, NULL,\n                                              uri, graphicsuri, listenAddress,\n                                              nmigrate_disks, migrate_disks, nbdPort,\n                                              migParams,\n                                              cookiein, cookieinlen,\n                                              cookieout, cookieoutlen, flags,\n                                              dname, resource, v3proto);\n        }\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformJob",
          "args": [
            "driver",
            "conn",
            "vm",
            "xmlin",
            "persist_xml",
            "NULL",
            "uri",
            "graphicsuri",
            "listenAddress",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "migParams",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "dname",
            "resource",
            "v3proto"
          ],
          "line": 4845
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4608-4712",
          "snippet": "static int\nqemuMigrationSrcPerformJob(virQEMUDriverPtr driver,\n                           virConnectPtr conn,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *persist_xml,\n                           const char *dconnuri,\n                           const char *uri,\n                           const char *graphicsuri,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           unsigned long flags,\n                           const char *dname,\n                           unsigned long resource,\n                           bool v3proto)\n{\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                              flags) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto endjob;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto endjob;\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        ret = qemuMigrationSrcPerformPeer2Peer(driver, conn, vm, xmlin, persist_xml,\n                                               dconnuri, uri, graphicsuri, listenAddress,\n                                               nmigrate_disks, migrate_disks, nbdPort,\n                                               migParams, flags, dname, resource,\n                                               &v3proto);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                            cookieout, cookieoutlen,\n                                            flags, resource, NULL, NULL, 0, NULL,\n                                            migParams);\n    }\n    if (ret < 0)\n        goto endjob;\n\n    /*\n     * In v3 protocol, the source VM is not killed off until the\n     * confirm step.\n     */\n    if (!v3proto) {\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n    }\n\n endjob:\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* v2 proto has no confirm phase so we need to reset migration parameters\n     * here\n     */\n    if (!v3proto && ret < 0)\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationSrcRestoreDomainState(driver, vm);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm) && ret == 0) {\n        if (flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n    virErrorRestore(&orig_err);\n\n cleanup:\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformJob(virQEMUDriverPtr driver,\n                           virConnectPtr conn,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *persist_xml,\n                           const char *dconnuri,\n                           const char *uri,\n                           const char *graphicsuri,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           unsigned long flags,\n                           const char *dname,\n                           unsigned long resource,\n                           bool v3proto)\n{\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                              flags) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto endjob;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto endjob;\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        ret = qemuMigrationSrcPerformPeer2Peer(driver, conn, vm, xmlin, persist_xml,\n                                               dconnuri, uri, graphicsuri, listenAddress,\n                                               nmigrate_disks, migrate_disks, nbdPort,\n                                               migParams, flags, dname, resource,\n                                               &v3proto);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                            cookieout, cookieoutlen,\n                                            flags, resource, NULL, NULL, 0, NULL,\n                                            migParams);\n    }\n    if (ret < 0)\n        goto endjob;\n\n    /*\n     * In v3 protocol, the source VM is not killed off until the\n     * confirm step.\n     */\n    if (!v3proto) {\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n    }\n\n endjob:\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* v2 proto has no confirm phase so we need to reset migration parameters\n     * here\n     */\n    if (!v3proto && ret < 0)\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationSrcRestoreDomainState(driver, vm);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm) && ret == 0) {\n        if (flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n    virErrorRestore(&orig_err);\n\n cleanup:\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformPhase",
          "args": [
            "driver",
            "conn",
            "vm",
            "persist_xml",
            "uri",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource"
          ],
          "line": 4837
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4717-4779",
          "snippet": "static int\nqemuMigrationSrcPerformPhase(virQEMUDriverPtr driver,\n                             virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *persist_xml,\n                             const char *uri,\n                             const char *graphicsuri,\n                             size_t nmigrate_disks,\n                             const char **migrate_disks,\n                             qemuMigrationParamsPtr migParams,\n                             const char *cookiein,\n                             int cookieinlen,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned long flags,\n                             unsigned long resource)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* If we didn't start the job in the begin phase, start it now. */\n    if (!(flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            return ret;\n    } else if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) {\n        return ret;\n    }\n\n    qemuMigrationJobStartPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                        cookieout, cookieoutlen,\n                                        flags, resource, NULL, graphicsuri,\n                                        nmigrate_disks, migrate_disks, migParams);\n\n    if (ret < 0) {\n        qemuMigrationSrcRestoreDomainState(driver, vm);\n        goto endjob;\n    }\n\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n\n    if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                             qemuMigrationSrcCleanup) < 0)\n        goto endjob;\n\n endjob:\n    if (ret < 0) {\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        qemuMigrationJobFinish(driver, vm);\n    } else {\n        qemuMigrationJobContinue(vm);\n    }\n\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPhase(virQEMUDriverPtr driver,\n                             virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *persist_xml,\n                             const char *uri,\n                             const char *graphicsuri,\n                             size_t nmigrate_disks,\n                             const char **migrate_disks,\n                             qemuMigrationParamsPtr migParams,\n                             const char *cookiein,\n                             int cookieinlen,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned long flags,\n                             unsigned long resource)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* If we didn't start the job in the begin phase, start it now. */\n    if (!(flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            return ret;\n    } else if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) {\n        return ret;\n    }\n\n    qemuMigrationJobStartPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                        cookieout, cookieoutlen,\n                                        flags, resource, NULL, graphicsuri,\n                                        nmigrate_disks, migrate_disks, migParams);\n\n    if (ret < 0) {\n        qemuMigrationSrcRestoreDomainState(driver, vm);\n        goto endjob;\n    }\n\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n\n    if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                             qemuMigrationSrcCleanup) < 0)\n        goto endjob;\n\n endjob:\n    if (ret < 0) {\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        qemuMigrationJobFinish(driver, vm);\n    } else {\n        qemuMigrationJobContinue(vm);\n    }\n\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unexpected dconnuri parameter with non-peer2peer migration\")"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected dconnuri parameter with non-peer2peer migration\""
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"received unexpected cookie with P2P migration\")"
          ],
          "line": 4817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, conn=%p, vm=%p, xmlin=%s, dconnuri=%s, \"\n              \"uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"cookiein=%s, cookieinlen=%d, cookieout=%p, cookieoutlen=%p, \"\n              \"flags=0x%lx, dname=%s, resource=%lu, v3proto=%d\"",
            "driver",
            "conn",
            "vm",
            "NULLSTR(xmlin)",
            "NULLSTR(dconnuri)",
            "NULLSTR(uri)",
            "NULLSTR(graphicsuri)",
            "NULLSTR(listenAddress)",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "NULLSTR(dname)",
            "resource",
            "v3proto"
          ],
          "line": 4804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dname"
          ],
          "line": 4813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 4812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "listenAddress"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dconnuri"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xmlin"
          ],
          "line": 4809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcPerform(virQEMUDriverPtr driver,\n                        virConnectPtr conn,\n                        virDomainObjPtr vm,\n                        const char *xmlin,\n                        const char *persist_xml,\n                        const char *dconnuri,\n                        const char *uri,\n                        const char *graphicsuri,\n                        const char *listenAddress,\n                        size_t nmigrate_disks,\n                        const char **migrate_disks,\n                        int nbdPort,\n                        qemuMigrationParamsPtr migParams,\n                        const char *cookiein,\n                        int cookieinlen,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long resource,\n                        bool v3proto)\n{\n    VIR_DEBUG(\"driver=%p, conn=%p, vm=%p, xmlin=%s, dconnuri=%s, \"\n              \"uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"cookiein=%s, cookieinlen=%d, cookieout=%p, cookieoutlen=%p, \"\n              \"flags=0x%lx, dname=%s, resource=%lu, v3proto=%d\",\n              driver, conn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort,\n              NULLSTR(cookiein), cookieinlen, cookieout, cookieoutlen,\n              flags, NULLSTR(dname), resource, v3proto);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        if (cookieinlen) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           \"%s\", _(\"received unexpected cookie with P2P migration\"));\n            return -1;\n        }\n\n        return qemuMigrationSrcPerformJob(driver, conn, vm, xmlin, persist_xml, dconnuri, uri,\n                                          graphicsuri, listenAddress,\n                                          nmigrate_disks, migrate_disks, nbdPort,\n                                          migParams,\n                                          cookiein, cookieinlen,\n                                          cookieout, cookieoutlen,\n                                          flags, dname, resource, v3proto);\n    } else {\n        if (dconnuri) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           \"%s\", _(\"Unexpected dconnuri parameter with non-peer2peer migration\"));\n            return -1;\n        }\n\n        if (v3proto) {\n            return qemuMigrationSrcPerformPhase(driver, conn, vm, persist_xml, uri,\n                                                graphicsuri,\n                                                nmigrate_disks, migrate_disks,\n                                                migParams,\n                                                cookiein, cookieinlen,\n                                                cookieout, cookieoutlen,\n                                                flags, resource);\n        } else {\n            return qemuMigrationSrcPerformJob(driver, conn, vm, xmlin, persist_xml, NULL,\n                                              uri, graphicsuri, listenAddress,\n                                              nmigrate_disks, migrate_disks, nbdPort,\n                                              migParams,\n                                              cookiein, cookieinlen,\n                                              cookieout, cookieoutlen, flags,\n                                              dname, resource, v3proto);\n        }\n    }\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformPhase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4717-4779",
    "snippet": "static int\nqemuMigrationSrcPerformPhase(virQEMUDriverPtr driver,\n                             virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *persist_xml,\n                             const char *uri,\n                             const char *graphicsuri,\n                             size_t nmigrate_disks,\n                             const char **migrate_disks,\n                             qemuMigrationParamsPtr migParams,\n                             const char *cookiein,\n                             int cookieinlen,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned long flags,\n                             unsigned long resource)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* If we didn't start the job in the begin phase, start it now. */\n    if (!(flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            return ret;\n    } else if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) {\n        return ret;\n    }\n\n    qemuMigrationJobStartPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                        cookieout, cookieoutlen,\n                                        flags, resource, NULL, graphicsuri,\n                                        nmigrate_disks, migrate_disks, migParams);\n\n    if (ret < 0) {\n        qemuMigrationSrcRestoreDomainState(driver, vm);\n        goto endjob;\n    }\n\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n\n    if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                             qemuMigrationSrcCleanup) < 0)\n        goto endjob;\n\n endjob:\n    if (ret < 0) {\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        qemuMigrationJobFinish(driver, vm);\n    } else {\n        qemuMigrationJobContinue(vm);\n    }\n\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainRemoveInactiveJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4776
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainRemoveInactiveJobLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11335-11347",
          "snippet": "void\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 4775
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobContinue",
          "args": [
            "vm"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5472-5476",
          "snippet": "static void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4770
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 4768
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksSet",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "conn",
            "qemuMigrationSrcCleanup"
          ],
          "line": 4762
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "89-140",
          "snippet": "int\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PERFORM3_DONE"
          ],
          "line": 4760
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcRestoreDomainState",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4756
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcRestoreDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "128-168",
          "snippet": "static bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformNative",
          "args": [
            "driver",
            "vm",
            "persist_xml",
            "uri",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "NULL",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams"
          ],
          "line": 4750
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3800-3878",
          "snippet": "static int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksUnset",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "qemuMigrationSrcCleanup"
          ],
          "line": 4747
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksUnset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "142-178",
          "snippet": "int\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStartPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PERFORM3"
          ],
          "line": 4746
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStartPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5464-5470",
          "snippet": "static void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobIsActive",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 4742
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5478-5496",
          "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStart",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "flags"
          ],
          "line": 4739
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5418-5445",
          "snippet": "static int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPhase(virQEMUDriverPtr driver,\n                             virConnectPtr conn,\n                             virDomainObjPtr vm,\n                             const char *persist_xml,\n                             const char *uri,\n                             const char *graphicsuri,\n                             size_t nmigrate_disks,\n                             const char **migrate_disks,\n                             qemuMigrationParamsPtr migParams,\n                             const char *cookiein,\n                             int cookieinlen,\n                             char **cookieout,\n                             int *cookieoutlen,\n                             unsigned long flags,\n                             unsigned long resource)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n\n    /* If we didn't start the job in the begin phase, start it now. */\n    if (!(flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            return ret;\n    } else if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) {\n        return ret;\n    }\n\n    qemuMigrationJobStartPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                        cookieout, cookieoutlen,\n                                        flags, resource, NULL, graphicsuri,\n                                        nmigrate_disks, migrate_disks, migParams);\n\n    if (ret < 0) {\n        qemuMigrationSrcRestoreDomainState(driver, vm);\n        goto endjob;\n    }\n\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n\n    if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                             qemuMigrationSrcCleanup) < 0)\n        goto endjob;\n\n endjob:\n    if (ret < 0) {\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        qemuMigrationJobFinish(driver, vm);\n    } else {\n        qemuMigrationJobContinue(vm);\n    }\n\n    if (!virDomainObjIsActive(vm))\n        qemuDomainRemoveInactiveJob(driver, vm);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4608-4712",
    "snippet": "static int\nqemuMigrationSrcPerformJob(virQEMUDriverPtr driver,\n                           virConnectPtr conn,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *persist_xml,\n                           const char *dconnuri,\n                           const char *uri,\n                           const char *graphicsuri,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           unsigned long flags,\n                           const char *dname,\n                           unsigned long resource,\n                           bool v3proto)\n{\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                              flags) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto endjob;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto endjob;\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        ret = qemuMigrationSrcPerformPeer2Peer(driver, conn, vm, xmlin, persist_xml,\n                                               dconnuri, uri, graphicsuri, listenAddress,\n                                               nmigrate_disks, migrate_disks, nbdPort,\n                                               migParams, flags, dname, resource,\n                                               &v3proto);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                            cookieout, cookieoutlen,\n                                            flags, resource, NULL, NULL, 0, NULL,\n                                            migParams);\n    }\n    if (ret < 0)\n        goto endjob;\n\n    /*\n     * In v3 protocol, the source VM is not killed off until the\n     * confirm step.\n     */\n    if (!v3proto) {\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n    }\n\n endjob:\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* v2 proto has no confirm phase so we need to reset migration parameters\n     * here\n     */\n    if (!v3proto && ret < 0)\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationSrcRestoreDomainState(driver, vm);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm) && ret == 0) {\n        if (flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n    virErrorRestore(&orig_err);\n\n cleanup:\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 4710
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 4709
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 4706
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainRemoveInactiveJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4703
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainRemoveInactiveJobLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11335-11347",
          "snippet": "void\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeleteConfig",
          "args": [
            "cfg->configDir",
            "cfg->autostartDir",
            "vm"
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeleteConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29726-29753",
          "snippet": "int\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 4698
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4697
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcRestoreDomainState",
          "args": [
            "driver",
            "vm"
          ],
          "line": 4695
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcRestoreDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "128-168",
          "snippet": "static bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 4692
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 4686
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_MIGRATED"
          ],
          "line": 4679
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "vm",
            "\"migrated\""
          ],
          "line": 4678
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_MIGRATED",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "VIR_QEMU_PROCESS_STOP_MIGRATED"
          ],
          "line": 4675
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7306-7649",
          "snippet": "void qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformNative",
          "args": [
            "driver",
            "vm",
            "persist_xml",
            "uri",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "migParams"
          ],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3800-3878",
          "snippet": "static int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PERFORM2"
          ],
          "line": 4661
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformPeer2Peer",
          "args": [
            "driver",
            "conn",
            "vm",
            "xmlin",
            "persist_xml",
            "dconnuri",
            "uri",
            "graphicsuri",
            "listenAddress",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "migParams",
            "flags",
            "dname",
            "resource",
            "&v3proto"
          ],
          "line": 4655
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformPeer2Peer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4449-4600",
          "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer(virQEMUDriverPtr driver,\n                                 virConnectPtr sconn,\n                                 virDomainObjPtr vm,\n                                 const char *xmlin,\n                                 const char *persist_xml,\n                                 const char *dconnuri,\n                                 const char *uri,\n                                 const char *graphicsuri,\n                                 const char *listenAddress,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 int nbdPort,\n                                 qemuMigrationParamsPtr migParams,\n                                 unsigned long flags,\n                                 const char *dname,\n                                 unsigned long resource,\n                                 bool *v3proto)\n{\n    int ret = -1;\n    virConnectPtr dconn = NULL;\n    bool p2p;\n    virErrorPtr orig_err = NULL;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n    bool dstOffline = false;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    bool useParams;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, vm=%p, xmlin=%s, dconnuri=%s, uri=%s, \"\n              \"graphicsuri=%s, listenAddress=%s, nmigrate_disks=%zu, \"\n              \"migrate_disks=%p, nbdPort=%d, flags=0x%lx, dname=%s, \"\n              \"resource=%lu\",\n              driver, sconn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags, NULLSTR(dname),\n              resource);\n\n    if (flags & VIR_MIGRATE_TUNNELLED && uri) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"migration URI is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && listenAddress) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"listen address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && nbdPort) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"disk port address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    /* the order of operations is important here; we make sure the\n     * destination side is completely setup before we touch the source\n     */\n\n    qemuDomainObjEnterRemote(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        virObjectUnref(cfg);\n        return -1;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    if (virConnectRegisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed,\n                                        vm, NULL) < 0) {\n        goto cleanup;\n    }\n\n    qemuDomainObjEnterRemote(vm);\n    p2p = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                   VIR_DRV_FEATURE_MIGRATION_P2P);\n        /* v3proto reflects whether the caller used Perform3, but with\n         * p2p migrate, regardless of whether Perform2 or Perform3\n         * were used, we decide protocol based on what target supports\n         */\n    *v3proto = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    if (offline)\n        dstOffline = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                              VIR_DRV_FEATURE_MIGRATION_OFFLINE);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (!p2p) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support peer-to-peer migration protocol\"));\n        goto cleanup;\n    }\n\n    /* Only xmlin, dname, uri, and bandwidth parameters can be used with\n     * old-style APIs. */\n    if (!useParams && (graphicsuri || listenAddress || nmigrate_disks)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto cleanup;\n    }\n\n    if (offline && !dstOffline) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the destination host\"));\n        goto cleanup;\n    }\n\n    /* Change protection is only required on the source side (us), and\n     * only for v3 migration when begin and perform are separate jobs.\n     * But peer-2-peer is already a single job, and we still want to\n     * talk to older destinations that would reject the flag.\n     * Therefore it is safe to clear the bit here.  */\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    if (*v3proto) {\n        ret = qemuMigrationSrcPerformPeer2Peer3(driver, sconn, dconn, dconnuri, vm, xmlin,\n                                                persist_xml, dname, uri, graphicsuri,\n                                                listenAddress, nmigrate_disks, migrate_disks,\n                                                nbdPort, migParams, resource,\n                                                useParams, flags);\n    } else {\n        ret = qemuMigrationSrcPerformPeer2Peer2(driver, sconn, dconn, vm,\n                                                dconnuri, flags, dname, resource,\n                                                migParams);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    qemuDomainObjEnterRemote(vm);\n    virConnectUnregisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed);\n    virObjectUnref(dconn);\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer(virQEMUDriverPtr driver,\n                                 virConnectPtr sconn,\n                                 virDomainObjPtr vm,\n                                 const char *xmlin,\n                                 const char *persist_xml,\n                                 const char *dconnuri,\n                                 const char *uri,\n                                 const char *graphicsuri,\n                                 const char *listenAddress,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 int nbdPort,\n                                 qemuMigrationParamsPtr migParams,\n                                 unsigned long flags,\n                                 const char *dname,\n                                 unsigned long resource,\n                                 bool *v3proto)\n{\n    int ret = -1;\n    virConnectPtr dconn = NULL;\n    bool p2p;\n    virErrorPtr orig_err = NULL;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n    bool dstOffline = false;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    bool useParams;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, vm=%p, xmlin=%s, dconnuri=%s, uri=%s, \"\n              \"graphicsuri=%s, listenAddress=%s, nmigrate_disks=%zu, \"\n              \"migrate_disks=%p, nbdPort=%d, flags=0x%lx, dname=%s, \"\n              \"resource=%lu\",\n              driver, sconn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags, NULLSTR(dname),\n              resource);\n\n    if (flags & VIR_MIGRATE_TUNNELLED && uri) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"migration URI is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && listenAddress) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"listen address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && nbdPort) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"disk port address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    /* the order of operations is important here; we make sure the\n     * destination side is completely setup before we touch the source\n     */\n\n    qemuDomainObjEnterRemote(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        virObjectUnref(cfg);\n        return -1;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    if (virConnectRegisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed,\n                                        vm, NULL) < 0) {\n        goto cleanup;\n    }\n\n    qemuDomainObjEnterRemote(vm);\n    p2p = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                   VIR_DRV_FEATURE_MIGRATION_P2P);\n        /* v3proto reflects whether the caller used Perform3, but with\n         * p2p migrate, regardless of whether Perform2 or Perform3\n         * were used, we decide protocol based on what target supports\n         */\n    *v3proto = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    if (offline)\n        dstOffline = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                              VIR_DRV_FEATURE_MIGRATION_OFFLINE);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (!p2p) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support peer-to-peer migration protocol\"));\n        goto cleanup;\n    }\n\n    /* Only xmlin, dname, uri, and bandwidth parameters can be used with\n     * old-style APIs. */\n    if (!useParams && (graphicsuri || listenAddress || nmigrate_disks)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto cleanup;\n    }\n\n    if (offline && !dstOffline) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the destination host\"));\n        goto cleanup;\n    }\n\n    /* Change protection is only required on the source side (us), and\n     * only for v3 migration when begin and perform are separate jobs.\n     * But peer-2-peer is already a single job, and we still want to\n     * talk to older destinations that would reject the flag.\n     * Therefore it is safe to clear the bit here.  */\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    if (*v3proto) {\n        ret = qemuMigrationSrcPerformPeer2Peer3(driver, sconn, dconn, dconnuri, vm, xmlin,\n                                                persist_xml, dname, uri, graphicsuri,\n                                                listenAddress, nmigrate_disks, migrate_disks,\n                                                nbdPort, migParams, resource,\n                                                useParams, flags);\n    } else {\n        ret = qemuMigrationSrcPerformPeer2Peer2(driver, sconn, dconn, vm,\n                                                dconnuri, flags, dname, resource,\n                                                migParams);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    qemuDomainObjEnterRemote(vm);\n    virConnectUnregisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed);\n    virObjectUnref(dconn);\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcStoreDomainState",
          "args": [
            "vm"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcStoreDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "117-125",
          "snippet": "static void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsSafe",
          "args": [
            "vm->def",
            "priv->qemuCaps",
            "nmigrate_disks",
            "migrate_disks",
            "flags"
          ],
          "line": 4648
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsSafe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1299-1383",
          "snippet": "static bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsAllowed",
          "args": [
            "driver",
            "vm",
            "true",
            "flags"
          ],
          "line": 4644
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsAllowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1166-1297",
          "snippet": "bool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nbool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjCheckActive",
          "args": [
            "vm"
          ],
          "line": 4641
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjCheckActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "7294-7303",
          "snippet": "int\nvirDomainObjCheckActive(virDomainObjPtr dom)\n{\n    if (!virDomainObjIsActive(dom)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"domain is not running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjCheckActive(virDomainObjPtr dom)\n{\n    if (!virDomainObjIsActive(dom)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"domain is not running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStart",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "flags"
          ],
          "line": 4637
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5418-5445",
          "snippet": "static int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 4634
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformJob(virQEMUDriverPtr driver,\n                           virConnectPtr conn,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *persist_xml,\n                           const char *dconnuri,\n                           const char *uri,\n                           const char *graphicsuri,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           unsigned long flags,\n                           const char *dname,\n                           unsigned long resource,\n                           bool v3proto)\n{\n    virObjectEventPtr event = NULL;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                              flags) < 0)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto endjob;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto endjob;\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if ((flags & (VIR_MIGRATE_TUNNELLED | VIR_MIGRATE_PEER2PEER))) {\n        ret = qemuMigrationSrcPerformPeer2Peer(driver, conn, vm, xmlin, persist_xml,\n                                               dconnuri, uri, graphicsuri, listenAddress,\n                                               nmigrate_disks, migrate_disks, nbdPort,\n                                               migParams, flags, dname, resource,\n                                               &v3proto);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri, cookiein, cookieinlen,\n                                            cookieout, cookieoutlen,\n                                            flags, resource, NULL, NULL, 0, NULL,\n                                            migParams);\n    }\n    if (ret < 0)\n        goto endjob;\n\n    /*\n     * In v3 protocol, the source VM is not killed off until the\n     * confirm step.\n     */\n    if (!v3proto) {\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n    }\n\n endjob:\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* v2 proto has no confirm phase so we need to reset migration parameters\n     * here\n     */\n    if (!v3proto && ret < 0)\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n    qemuMigrationSrcRestoreDomainState(driver, vm);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm) && ret == 0) {\n        if (flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n    virErrorRestore(&orig_err);\n\n cleanup:\n    virObjectEventStateQueue(driver->domainEventState, event);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformPeer2Peer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4449-4600",
    "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer(virQEMUDriverPtr driver,\n                                 virConnectPtr sconn,\n                                 virDomainObjPtr vm,\n                                 const char *xmlin,\n                                 const char *persist_xml,\n                                 const char *dconnuri,\n                                 const char *uri,\n                                 const char *graphicsuri,\n                                 const char *listenAddress,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 int nbdPort,\n                                 qemuMigrationParamsPtr migParams,\n                                 unsigned long flags,\n                                 const char *dname,\n                                 unsigned long resource,\n                                 bool *v3proto)\n{\n    int ret = -1;\n    virConnectPtr dconn = NULL;\n    bool p2p;\n    virErrorPtr orig_err = NULL;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n    bool dstOffline = false;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    bool useParams;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, vm=%p, xmlin=%s, dconnuri=%s, uri=%s, \"\n              \"graphicsuri=%s, listenAddress=%s, nmigrate_disks=%zu, \"\n              \"migrate_disks=%p, nbdPort=%d, flags=0x%lx, dname=%s, \"\n              \"resource=%lu\",\n              driver, sconn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags, NULLSTR(dname),\n              resource);\n\n    if (flags & VIR_MIGRATE_TUNNELLED && uri) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"migration URI is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && listenAddress) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"listen address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && nbdPort) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"disk port address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    /* the order of operations is important here; we make sure the\n     * destination side is completely setup before we touch the source\n     */\n\n    qemuDomainObjEnterRemote(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        virObjectUnref(cfg);\n        return -1;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    if (virConnectRegisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed,\n                                        vm, NULL) < 0) {\n        goto cleanup;\n    }\n\n    qemuDomainObjEnterRemote(vm);\n    p2p = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                   VIR_DRV_FEATURE_MIGRATION_P2P);\n        /* v3proto reflects whether the caller used Perform3, but with\n         * p2p migrate, regardless of whether Perform2 or Perform3\n         * were used, we decide protocol based on what target supports\n         */\n    *v3proto = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    if (offline)\n        dstOffline = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                              VIR_DRV_FEATURE_MIGRATION_OFFLINE);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (!p2p) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support peer-to-peer migration protocol\"));\n        goto cleanup;\n    }\n\n    /* Only xmlin, dname, uri, and bandwidth parameters can be used with\n     * old-style APIs. */\n    if (!useParams && (graphicsuri || listenAddress || nmigrate_disks)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto cleanup;\n    }\n\n    if (offline && !dstOffline) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the destination host\"));\n        goto cleanup;\n    }\n\n    /* Change protection is only required on the source side (us), and\n     * only for v3 migration when begin and perform are separate jobs.\n     * But peer-2-peer is already a single job, and we still want to\n     * talk to older destinations that would reject the flag.\n     * Therefore it is safe to clear the bit here.  */\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    if (*v3proto) {\n        ret = qemuMigrationSrcPerformPeer2Peer3(driver, sconn, dconn, dconnuri, vm, xmlin,\n                                                persist_xml, dname, uri, graphicsuri,\n                                                listenAddress, nmigrate_disks, migrate_disks,\n                                                nbdPort, migParams, resource,\n                                                useParams, flags);\n    } else {\n        ret = qemuMigrationSrcPerformPeer2Peer2(driver, sconn, dconn, vm,\n                                                dconnuri, flags, dname, resource,\n                                                migParams);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    qemuDomainObjEnterRemote(vm);\n    virConnectUnregisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed);\n    virObjectUnref(dconn);\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 4597
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitRemote(vm, false)"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitRemote",
          "args": [
            "vm",
            "false"
          ],
          "line": 4596
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10274-10290",
          "snippet": "int\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nint\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectUnregisterCloseCallback",
          "args": [
            "dconn",
            "qemuMigrationSrcConnectionClosed"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectUnregisterCloseCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1472-1491",
          "snippet": "int\nvirConnectUnregisterCloseCallback(virConnectPtr conn,\n                                  virConnectCloseFunc cb)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver->connectUnregisterCloseCallback &&\n        conn->driver->connectUnregisterCloseCallback(conn, cb) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectUnregisterCloseCallback(virConnectPtr conn,\n                                  virConnectCloseFunc cb)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver->connectUnregisterCloseCallback &&\n        conn->driver->connectUnregisterCloseCallback(conn, cb) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterRemote",
          "args": [
            "vm"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10266-10271",
          "snippet": "void qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nvoid qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 4592
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformPeer2Peer2",
          "args": [
            "driver",
            "sconn",
            "dconn",
            "vm",
            "dconnuri",
            "flags",
            "dname",
            "resource",
            "migParams"
          ],
          "line": 4586
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformPeer2Peer2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3950-4084",
          "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer2(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  virDomainObjPtr vm,\n                                  const char *dconnuri,\n                                  unsigned long flags,\n                                  const char *dname,\n                                  unsigned long resource,\n                                  qemuMigrationParamsPtr migParams)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virErrorPtr orig_err = NULL;\n    bool cancelled;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, vm=%p, dconnuri=%s, \"\n              \"flags=0x%lx, dname=%s, resource=%lu\",\n              driver, sconn, dconn, vm, NULLSTR(dconnuri),\n              flags, NULLSTR(dname), resource);\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!(dom_xml = qemuDomainFormatXML(driver, vm,\n                                        QEMU_DOMAIN_FORMAT_LIVE_FLAGS |\n                                        VIR_DOMAIN_XML_MIGRATABLE)))\n        return -1;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p\", dconn);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        /*\n         * Tunnelled Migrate Version 2 does not support cookies\n         * due to missing parameters in the prepareTunnel() API.\n         */\n\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepareTunnel\n            (dconn, st, destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepare2\n            (dconn, &cookie, &cookielen, NULL, &uri_out,\n             destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED) &&\n        (uri_out == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = true;\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", sconn);\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, NULL,\n                                            NULL, 0, NULL, NULL,\n                                            flags, resource, dconn,\n                                            NULL, 0, NULL, migParams);\n    else\n        ret = qemuMigrationSrcPerformNative(driver, vm, NULL, uri_out,\n                                            cookie, cookielen,\n                                            NULL, NULL, /* No out cookie with v2 migration */\n                                            flags, resource, dconn, NULL, 0, NULL,\n                                            migParams);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : vm->def->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    qemuDomainObjEnterRemote(vm);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen,\n         uri_out ? uri_out : dconnuri, destflags, cancelled);\n    /* The domain is already gone at this point */\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer2(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  virDomainObjPtr vm,\n                                  const char *dconnuri,\n                                  unsigned long flags,\n                                  const char *dname,\n                                  unsigned long resource,\n                                  qemuMigrationParamsPtr migParams)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virErrorPtr orig_err = NULL;\n    bool cancelled;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, vm=%p, dconnuri=%s, \"\n              \"flags=0x%lx, dname=%s, resource=%lu\",\n              driver, sconn, dconn, vm, NULLSTR(dconnuri),\n              flags, NULLSTR(dname), resource);\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!(dom_xml = qemuDomainFormatXML(driver, vm,\n                                        QEMU_DOMAIN_FORMAT_LIVE_FLAGS |\n                                        VIR_DOMAIN_XML_MIGRATABLE)))\n        return -1;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p\", dconn);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        /*\n         * Tunnelled Migrate Version 2 does not support cookies\n         * due to missing parameters in the prepareTunnel() API.\n         */\n\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepareTunnel\n            (dconn, st, destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepare2\n            (dconn, &cookie, &cookielen, NULL, &uri_out,\n             destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED) &&\n        (uri_out == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = true;\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", sconn);\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, NULL,\n                                            NULL, 0, NULL, NULL,\n                                            flags, resource, dconn,\n                                            NULL, 0, NULL, migParams);\n    else\n        ret = qemuMigrationSrcPerformNative(driver, vm, NULL, uri_out,\n                                            cookie, cookielen,\n                                            NULL, NULL, /* No out cookie with v2 migration */\n                                            flags, resource, dconn, NULL, 0, NULL,\n                                            migParams);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : vm->def->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    qemuDomainObjEnterRemote(vm);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen,\n         uri_out ? uri_out : dconnuri, destflags, cancelled);\n    /* The domain is already gone at this point */\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformPeer2Peer3",
          "args": [
            "driver",
            "sconn",
            "dconn",
            "dconnuri",
            "vm",
            "xmlin",
            "persist_xml",
            "dname",
            "uri",
            "graphicsuri",
            "listenAddress",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "migParams",
            "resource",
            "useParams",
            "flags"
          ],
          "line": 4580
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformPeer2Peer3",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4091-4422",
          "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer3(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  const char *dconnuri,\n                                  virDomainObjPtr vm,\n                                  const char *xmlin,\n                                  const char *persist_xml,\n                                  const char *dname,\n                                  const char *uri,\n                                  const char *graphicsuri,\n                                  const char *listenAddress,\n                                  size_t nmigrate_disks,\n                                  const char **migrate_disks,\n                                  int nbdPort,\n                                  qemuMigrationParamsPtr migParams,\n                                  unsigned long long bandwidth,\n                                  bool useParams,\n                                  unsigned long flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    bool cancelled = true;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    size_t i;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, dconnuri=%s, vm=%p, xmlin=%s, \"\n              \"dname=%s, uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"bandwidth=%llu, useParams=%d, flags=0x%lx\",\n              driver, sconn, dconn, NULLSTR(dconnuri), vm, NULLSTR(xmlin),\n              NULLSTR(dname), NULLSTR(uri), NULLSTR(graphicsuri),\n              NULLSTR(listenAddress), nmigrate_disks, migrate_disks, nbdPort,\n              bandwidth, useParams, flags);\n\n    /* Unlike the virDomainMigrateVersion3 counterpart, we don't need\n     * to worry about auto-setting the VIR_MIGRATE_CHANGE_PROTECTION\n     * bit here, because we are already running inside the context of\n     * a single job.  */\n\n    dom_xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                         &cookieout, &cookieoutlen,\n                                         nmigrate_disks, migrate_disks, flags);\n    if (!dom_xml)\n        goto cleanup;\n\n    if (useParams) {\n        if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n            goto cleanup;\n\n        if (dname &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n            goto cleanup;\n\n        if (uri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_URI, uri) < 0)\n            goto cleanup;\n\n        if (bandwidth &&\n            virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_BANDWIDTH,\n                                    bandwidth) < 0)\n            goto cleanup;\n\n        if (graphicsuri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_GRAPHICS_URI,\n                                    graphicsuri) < 0)\n            goto cleanup;\n        if (listenAddress &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_LISTEN_ADDRESS,\n                                    listenAddress) < 0)\n            goto cleanup;\n        for (i = 0; i < nmigrate_disks; i++)\n            if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                        VIR_MIGRATE_PARAM_MIGRATE_DISKS,\n                                        migrate_disks[i]) < 0)\n                goto cleanup;\n        if (nbdPort &&\n            virTypedParamsAddInt(&params, &nparams, &maxparams,\n                                 VIR_MIGRATE_PARAM_DISKS_PORT,\n                                 nbdPort) < 0)\n            goto cleanup;\n\n        if (qemuMigrationParamsDump(migParams, &params, &nparams,\n                                    &maxparams, &flags) < 0)\n            goto cleanup;\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p\", dconn);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepareTunnel3Params\n                (dconn, st, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepareTunnel3\n                (dconn, st, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepare3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, &uri_out, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepare3\n                (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (offline) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = false;\n        goto finish;\n    }\n\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n            virErrorPreserveLast(&orig_err);\n            goto finish;\n        }\n    } else if (!uri && !(flags & VIR_MIGRATE_TUNNELLED)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", sconn, NULLSTR(uri));\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, persist_xml,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    } else {\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        virErrorPreserveLast(&orig_err);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm,\n                                 QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup in the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        vm->def->name) < 0) {\n            ddomain = NULL;\n        } else {\n            qemuDomainObjEnterRemote(vm);\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n            if (qemuDomainObjExitRemote(vm, !offline) < 0)\n                goto cleanup;\n        }\n    } else {\n        dname = dname ? dname : vm->def->name;\n        qemuDomainObjEnterRemote(vm);\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             dconnuri, uri, destflags, cancelled);\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /*\n     * If cancelled, then src VM will be restarted, else\n     * it will be killed\n     */\n    VIR_DEBUG(\"Confirm3 %p cancelled=%d vm=%p\", sconn, cancelled, vm);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n    /* If Confirm3 returns -1, there's nothing more we can\n     * do, but fortunately worst case is that there is a\n     * domain left in 'paused' state on source.\n     */\n    if (ret < 0)\n        VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                 vm->def->name);\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer3(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  const char *dconnuri,\n                                  virDomainObjPtr vm,\n                                  const char *xmlin,\n                                  const char *persist_xml,\n                                  const char *dname,\n                                  const char *uri,\n                                  const char *graphicsuri,\n                                  const char *listenAddress,\n                                  size_t nmigrate_disks,\n                                  const char **migrate_disks,\n                                  int nbdPort,\n                                  qemuMigrationParamsPtr migParams,\n                                  unsigned long long bandwidth,\n                                  bool useParams,\n                                  unsigned long flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    bool cancelled = true;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    size_t i;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, dconnuri=%s, vm=%p, xmlin=%s, \"\n              \"dname=%s, uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"bandwidth=%llu, useParams=%d, flags=0x%lx\",\n              driver, sconn, dconn, NULLSTR(dconnuri), vm, NULLSTR(xmlin),\n              NULLSTR(dname), NULLSTR(uri), NULLSTR(graphicsuri),\n              NULLSTR(listenAddress), nmigrate_disks, migrate_disks, nbdPort,\n              bandwidth, useParams, flags);\n\n    /* Unlike the virDomainMigrateVersion3 counterpart, we don't need\n     * to worry about auto-setting the VIR_MIGRATE_CHANGE_PROTECTION\n     * bit here, because we are already running inside the context of\n     * a single job.  */\n\n    dom_xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                         &cookieout, &cookieoutlen,\n                                         nmigrate_disks, migrate_disks, flags);\n    if (!dom_xml)\n        goto cleanup;\n\n    if (useParams) {\n        if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n            goto cleanup;\n\n        if (dname &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n            goto cleanup;\n\n        if (uri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_URI, uri) < 0)\n            goto cleanup;\n\n        if (bandwidth &&\n            virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_BANDWIDTH,\n                                    bandwidth) < 0)\n            goto cleanup;\n\n        if (graphicsuri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_GRAPHICS_URI,\n                                    graphicsuri) < 0)\n            goto cleanup;\n        if (listenAddress &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_LISTEN_ADDRESS,\n                                    listenAddress) < 0)\n            goto cleanup;\n        for (i = 0; i < nmigrate_disks; i++)\n            if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                        VIR_MIGRATE_PARAM_MIGRATE_DISKS,\n                                        migrate_disks[i]) < 0)\n                goto cleanup;\n        if (nbdPort &&\n            virTypedParamsAddInt(&params, &nparams, &maxparams,\n                                 VIR_MIGRATE_PARAM_DISKS_PORT,\n                                 nbdPort) < 0)\n            goto cleanup;\n\n        if (qemuMigrationParamsDump(migParams, &params, &nparams,\n                                    &maxparams, &flags) < 0)\n            goto cleanup;\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p\", dconn);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepareTunnel3Params\n                (dconn, st, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepareTunnel3\n                (dconn, st, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepare3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, &uri_out, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepare3\n                (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (offline) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = false;\n        goto finish;\n    }\n\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n            virErrorPreserveLast(&orig_err);\n            goto finish;\n        }\n    } else if (!uri && !(flags & VIR_MIGRATE_TUNNELLED)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", sconn, NULLSTR(uri));\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, persist_xml,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    } else {\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        virErrorPreserveLast(&orig_err);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm,\n                                 QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup in the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        vm->def->name) < 0) {\n            ddomain = NULL;\n        } else {\n            qemuDomainObjEnterRemote(vm);\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n            if (qemuDomainObjExitRemote(vm, !offline) < 0)\n                goto cleanup;\n        }\n    } else {\n        dname = dname ? dname : vm->def->name;\n        qemuDomainObjEnterRemote(vm);\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             dconnuri, uri, destflags, cancelled);\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /*\n     * If cancelled, then src VM will be restarted, else\n     * it will be killed\n     */\n    VIR_DEBUG(\"Confirm3 %p cancelled=%d vm=%p\", sconn, cancelled, vm);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n    /* If Confirm3 returns -1, there's nothing more we can\n     * do, but fortunately worst case is that there is a\n     * domain left in 'paused' state on source.\n     */\n    if (ret < 0)\n        VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                 vm->def->name);\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"offline migration is not supported by \"\n                         \"the destination host\")"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"offline migration is not supported by \"\n                         \"the destination host\""
          ],
          "line": 4567
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\")"
          ],
          "line": 4559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Destination libvirt does not support peer-to-peer migration protocol\")"
          ],
          "line": 4551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "dconn->driver",
            "dconn",
            "VIR_DRV_FEATURE_MIGRATION_OFFLINE"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "dconn->driver",
            "dconn",
            "VIR_DRV_FEATURE_MIGRATION_PARAMS"
          ],
          "line": 4542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "dconn->driver",
            "dconn",
            "VIR_DRV_FEATURE_MIGRATION_V3"
          ],
          "line": 4540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DRV_SUPPORTS_FEATURE",
          "args": [
            "dconn->driver",
            "dconn",
            "VIR_DRV_FEATURE_MIGRATION_P2P"
          ],
          "line": 4534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virConnectRegisterCloseCallback",
          "args": [
            "dconn",
            "qemuMigrationSrcConnectionClosed",
            "vm",
            "NULL"
          ],
          "line": 4528
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectRegisterCloseCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1435-1456",
          "snippet": "int\nvirConnectRegisterCloseCallback(virConnectPtr conn,\n                                virConnectCloseFunc cb,\n                                void *opaque,\n                                virFreeCallback freecb)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver->connectRegisterCloseCallback &&\n        conn->driver->connectRegisterCloseCallback(conn, cb, opaque, freecb) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectRegisterCloseCallback(virConnectPtr conn,\n                                virConnectCloseFunc cb,\n                                void *opaque,\n                                virFreeCallback freecb)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n    virCheckConnectReturn(conn, -1);\n    virCheckNonNullArgGoto(cb, error);\n\n    if (conn->driver->connectRegisterCloseCallback &&\n        conn->driver->connectRegisterCloseCallback(conn, cb, opaque, freecb) < 0)\n        goto error;\n\n    return 0;\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectSetKeepAlive",
          "args": [
            "dconn",
            "cfg->keepAliveInterval",
            "cfg->keepAliveCount"
          ],
          "line": 4524
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectSetKeepAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1350-1375",
          "snippet": "int\nvirConnectSetKeepAlive(virConnectPtr conn,\n                       int interval,\n                       unsigned int count)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, interval=%d, count=%u\", conn, interval, count);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectSetKeepAlive) {\n        ret = conn->driver->connectSetKeepAlive(conn, interval, count);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectSetKeepAlive(virConnectPtr conn,\n                       int interval,\n                       unsigned int count)\n{\n    int ret = -1;\n\n    VIR_DEBUG(\"conn=%p, interval=%d, count=%u\", conn, interval, count);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n\n    if (conn->driver->connectSetKeepAlive) {\n        ret = conn->driver->connectSetKeepAlive(conn, interval, count);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to connect to remote libvirt URI %s: %s\")",
            "dconnuri",
            "virGetLastErrorMessage()"
          ],
          "line": 4517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 4519
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectOpenAuth",
          "args": [
            "dconnuri",
            "&virConnectAuthConfig",
            "0"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectOpenAuth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "1219-1239",
          "snippet": "virConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirConnectPtr\nvirConnectOpenAuth(const char *name,\n                   virConnectAuthPtr auth,\n                   unsigned int flags)\n{\n    virConnectPtr ret = NULL;\n\n    if (virInitialize() < 0)\n        goto error;\n\n    VIR_DEBUG(\"name=%s, auth=%p, flags=0x%x\", NULLSTR(name), auth, flags);\n    virResetLastError();\n    ret = virConnectOpenInternal(name, auth, flags);\n    if (!ret)\n        goto error;\n    return ret;\n\n error:\n    virDispatchError(NULL);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"disk port address is not supported by tunnelled \"\n                         \"migration\")"
          ],
          "line": 4501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"listen address is not supported by tunnelled \"\n                         \"migration\")"
          ],
          "line": 4494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"migration URI is not supported by tunnelled \"\n                         \"migration\")"
          ],
          "line": 4487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, sconn=%p, vm=%p, xmlin=%s, dconnuri=%s, uri=%s, \"\n              \"graphicsuri=%s, listenAddress=%s, nmigrate_disks=%zu, \"\n              \"migrate_disks=%p, nbdPort=%d, flags=0x%lx, dname=%s, \"\n              \"resource=%lu\"",
            "driver",
            "sconn",
            "vm",
            "NULLSTR(xmlin)",
            "NULLSTR(dconnuri)",
            "NULLSTR(uri)",
            "NULLSTR(graphicsuri)",
            "NULLSTR(listenAddress)",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "flags",
            "NULLSTR(dname)",
            "resource"
          ],
          "line": 4477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dname"
          ],
          "line": 4483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "listenAddress"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri"
          ],
          "line": 4482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dconnuri"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xmlin"
          ],
          "line": 4481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virConnectAuth virConnectAuthConfig = {\n    .credtype = virConnectCredType,\n    .ncredtype = G_N_ELEMENTS(virConnectCredType),\n};\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer(virQEMUDriverPtr driver,\n                                 virConnectPtr sconn,\n                                 virDomainObjPtr vm,\n                                 const char *xmlin,\n                                 const char *persist_xml,\n                                 const char *dconnuri,\n                                 const char *uri,\n                                 const char *graphicsuri,\n                                 const char *listenAddress,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 int nbdPort,\n                                 qemuMigrationParamsPtr migParams,\n                                 unsigned long flags,\n                                 const char *dname,\n                                 unsigned long resource,\n                                 bool *v3proto)\n{\n    int ret = -1;\n    virConnectPtr dconn = NULL;\n    bool p2p;\n    virErrorPtr orig_err = NULL;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n    bool dstOffline = false;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    bool useParams;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, vm=%p, xmlin=%s, dconnuri=%s, uri=%s, \"\n              \"graphicsuri=%s, listenAddress=%s, nmigrate_disks=%zu, \"\n              \"migrate_disks=%p, nbdPort=%d, flags=0x%lx, dname=%s, \"\n              \"resource=%lu\",\n              driver, sconn, vm, NULLSTR(xmlin), NULLSTR(dconnuri),\n              NULLSTR(uri), NULLSTR(graphicsuri), NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags, NULLSTR(dname),\n              resource);\n\n    if (flags & VIR_MIGRATE_TUNNELLED && uri) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"migration URI is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && listenAddress) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"listen address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_TUNNELLED && nbdPort) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"disk port address is not supported by tunnelled \"\n                         \"migration\"));\n        goto cleanup;\n    }\n\n    /* the order of operations is important here; we make sure the\n     * destination side is completely setup before we touch the source\n     */\n\n    qemuDomainObjEnterRemote(vm);\n    dconn = virConnectOpenAuth(dconnuri, &virConnectAuthConfig, 0);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (dconn == NULL) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Failed to connect to remote libvirt URI %s: %s\"),\n                       dconnuri, virGetLastErrorMessage());\n        virObjectUnref(cfg);\n        return -1;\n    }\n\n    if (virConnectSetKeepAlive(dconn, cfg->keepAliveInterval,\n                               cfg->keepAliveCount) < 0)\n        goto cleanup;\n\n    if (virConnectRegisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed,\n                                        vm, NULL) < 0) {\n        goto cleanup;\n    }\n\n    qemuDomainObjEnterRemote(vm);\n    p2p = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                   VIR_DRV_FEATURE_MIGRATION_P2P);\n        /* v3proto reflects whether the caller used Perform3, but with\n         * p2p migrate, regardless of whether Perform2 or Perform3\n         * were used, we decide protocol based on what target supports\n         */\n    *v3proto = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                        VIR_DRV_FEATURE_MIGRATION_V3);\n    useParams = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                         VIR_DRV_FEATURE_MIGRATION_PARAMS);\n    if (offline)\n        dstOffline = VIR_DRV_SUPPORTS_FEATURE(dconn->driver, dconn,\n                                              VIR_DRV_FEATURE_MIGRATION_OFFLINE);\n    if (qemuDomainObjExitRemote(vm, !offline) < 0)\n        goto cleanup;\n\n    if (!p2p) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Destination libvirt does not support peer-to-peer migration protocol\"));\n        goto cleanup;\n    }\n\n    /* Only xmlin, dname, uri, and bandwidth parameters can be used with\n     * old-style APIs. */\n    if (!useParams && (graphicsuri || listenAddress || nmigrate_disks)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"Migration APIs with extensible parameters are not \"\n                         \"supported but extended parameters were passed\"));\n        goto cleanup;\n    }\n\n    if (offline && !dstOffline) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"offline migration is not supported by \"\n                         \"the destination host\"));\n        goto cleanup;\n    }\n\n    /* Change protection is only required on the source side (us), and\n     * only for v3 migration when begin and perform are separate jobs.\n     * But peer-2-peer is already a single job, and we still want to\n     * talk to older destinations that would reject the flag.\n     * Therefore it is safe to clear the bit here.  */\n    flags &= ~VIR_MIGRATE_CHANGE_PROTECTION;\n\n    if (*v3proto) {\n        ret = qemuMigrationSrcPerformPeer2Peer3(driver, sconn, dconn, dconnuri, vm, xmlin,\n                                                persist_xml, dname, uri, graphicsuri,\n                                                listenAddress, nmigrate_disks, migrate_disks,\n                                                nbdPort, migParams, resource,\n                                                useParams, flags);\n    } else {\n        ret = qemuMigrationSrcPerformPeer2Peer2(driver, sconn, dconn, vm,\n                                                dconnuri, flags, dname, resource,\n                                                migParams);\n    }\n\n cleanup:\n    virErrorPreserveLast(&orig_err);\n    qemuDomainObjEnterRemote(vm);\n    virConnectUnregisterCloseCallback(dconn, qemuMigrationSrcConnectionClosed);\n    virObjectUnref(dconn);\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    virErrorRestore(&orig_err);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcConnectionClosed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4425-4434",
    "snippet": "static void\nqemuMigrationSrcConnectionClosed(virConnectPtr conn,\n                                 int reason,\n                                 void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n\n    VIR_DEBUG(\"conn=%p, reason=%d, vm=%s\", conn, reason, vm->def->name);\n    virDomainObjBroadcast(vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjBroadcast",
          "args": [
            "vm"
          ],
          "line": 4433
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjBroadcast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3652-3656",
          "snippet": "void\nvirDomainObjBroadcast(virDomainObjPtr vm)\n{\n    virCondBroadcast(&vm->cond);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjBroadcast(virDomainObjPtr vm)\n{\n    virCondBroadcast(&vm->cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"conn=%p, reason=%d, vm=%s\"",
            "conn",
            "reason",
            "vm->def->name"
          ],
          "line": 4432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcConnectionClosed(virConnectPtr conn,\n                                 int reason,\n                                 void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n\n    VIR_DEBUG(\"conn=%p, reason=%d, vm=%s\", conn, reason, vm->def->name);\n    virDomainObjBroadcast(vm);\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformPeer2Peer3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "4091-4422",
    "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer3(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  const char *dconnuri,\n                                  virDomainObjPtr vm,\n                                  const char *xmlin,\n                                  const char *persist_xml,\n                                  const char *dname,\n                                  const char *uri,\n                                  const char *graphicsuri,\n                                  const char *listenAddress,\n                                  size_t nmigrate_disks,\n                                  const char **migrate_disks,\n                                  int nbdPort,\n                                  qemuMigrationParamsPtr migParams,\n                                  unsigned long long bandwidth,\n                                  bool useParams,\n                                  unsigned long flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    bool cancelled = true;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    size_t i;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, dconnuri=%s, vm=%p, xmlin=%s, \"\n              \"dname=%s, uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"bandwidth=%llu, useParams=%d, flags=0x%lx\",\n              driver, sconn, dconn, NULLSTR(dconnuri), vm, NULLSTR(xmlin),\n              NULLSTR(dname), NULLSTR(uri), NULLSTR(graphicsuri),\n              NULLSTR(listenAddress), nmigrate_disks, migrate_disks, nbdPort,\n              bandwidth, useParams, flags);\n\n    /* Unlike the virDomainMigrateVersion3 counterpart, we don't need\n     * to worry about auto-setting the VIR_MIGRATE_CHANGE_PROTECTION\n     * bit here, because we are already running inside the context of\n     * a single job.  */\n\n    dom_xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                         &cookieout, &cookieoutlen,\n                                         nmigrate_disks, migrate_disks, flags);\n    if (!dom_xml)\n        goto cleanup;\n\n    if (useParams) {\n        if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n            goto cleanup;\n\n        if (dname &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n            goto cleanup;\n\n        if (uri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_URI, uri) < 0)\n            goto cleanup;\n\n        if (bandwidth &&\n            virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_BANDWIDTH,\n                                    bandwidth) < 0)\n            goto cleanup;\n\n        if (graphicsuri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_GRAPHICS_URI,\n                                    graphicsuri) < 0)\n            goto cleanup;\n        if (listenAddress &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_LISTEN_ADDRESS,\n                                    listenAddress) < 0)\n            goto cleanup;\n        for (i = 0; i < nmigrate_disks; i++)\n            if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                        VIR_MIGRATE_PARAM_MIGRATE_DISKS,\n                                        migrate_disks[i]) < 0)\n                goto cleanup;\n        if (nbdPort &&\n            virTypedParamsAddInt(&params, &nparams, &maxparams,\n                                 VIR_MIGRATE_PARAM_DISKS_PORT,\n                                 nbdPort) < 0)\n            goto cleanup;\n\n        if (qemuMigrationParamsDump(migParams, &params, &nparams,\n                                    &maxparams, &flags) < 0)\n            goto cleanup;\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p\", dconn);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepareTunnel3Params\n                (dconn, st, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepareTunnel3\n                (dconn, st, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepare3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, &uri_out, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepare3\n                (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (offline) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = false;\n        goto finish;\n    }\n\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n            virErrorPreserveLast(&orig_err);\n            goto finish;\n        }\n    } else if (!uri && !(flags & VIR_MIGRATE_TUNNELLED)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", sconn, NULLSTR(uri));\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, persist_xml,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    } else {\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        virErrorPreserveLast(&orig_err);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm,\n                                 QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup in the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        vm->def->name) < 0) {\n            ddomain = NULL;\n        } else {\n            qemuDomainObjEnterRemote(vm);\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n            if (qemuDomainObjExitRemote(vm, !offline) < 0)\n                goto cleanup;\n        }\n    } else {\n        dname = dname ? dname : vm->def->name;\n        qemuDomainObjEnterRemote(vm);\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             dconnuri, uri, destflags, cancelled);\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /*\n     * If cancelled, then src VM will be restarted, else\n     * it will be killed\n     */\n    VIR_DEBUG(\"Confirm3 %p cancelled=%d vm=%p\", sconn, cancelled, vm);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n    /* If Confirm3 returns -1, there's nothing more we can\n     * do, but fortunately worst case is that there is a\n     * domain left in 'paused' state on source.\n     */\n    if (ret < 0)\n        VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                 vm->def->name);\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virTypedParamsFree",
          "args": [
            "params",
            "nparams"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "878-884",
          "snippet": "void\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nvoid\nvirTypedParamsFree(virTypedParameterPtr params,\n                   int nparams)\n{\n    virTypedParamsClear(params, nparams);\n    VIR_FREE(params);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookieout"
          ],
          "line": 4419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookiein"
          ],
          "line": 4418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri_out"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Guest %s probably left in 'paused' state on source\"",
            "vm->def->name"
          ],
          "line": 4403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcConfirmPhase",
          "args": [
            "driver",
            "vm",
            "cookiein",
            "cookieinlen",
            "flags",
            "cancelled"
          ],
          "line": 4395
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcConfirmPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2982-3093",
          "snippet": "static int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cookieout"
          ],
          "line": 4392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookiein"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Confirm3 %p cancelled=%d vm=%p\"",
            "sconn",
            "cancelled",
            "vm"
          ],
          "line": 4390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 4384
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "orig_err"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 4359
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"finish step ignored that migration was cancelled\")"
          ],
          "line": 4343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"finish step ignored that migration was cancelled\""
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitRemote",
          "args": [
            "vm",
            "!offline"
          ],
          "line": 4337
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10274-10290",
          "snippet": "int\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nint\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigrateFinish3",
          "args": [
            "dconn",
            "dname",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "dconnuri",
            "uri",
            "destflags",
            "cancelled"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterRemote",
          "args": [
            "vm"
          ],
          "line": 4333
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10266-10271",
          "snippet": "void qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nvoid qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigrateFinish3Params",
          "args": [
            "dconn",
            "params",
            "nparams",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "destflags",
            "cancelled"
          ],
          "line": 4325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParamsReplaceString",
          "args": [
            "&params",
            "&nparams",
            "VIR_MIGRATE_PARAM_DEST_NAME",
            "vm->def->name"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsReplaceString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "312-350",
          "snippet": "int\nvirTypedParamsReplaceString(virTypedParameterPtr *params,\n                            int *nparams,\n                            const char *name,\n                            const char *value)\n{\n    char *str = NULL;\n    char *old = NULL;\n    size_t n = *nparams;\n    virTypedParameterPtr param;\n\n    param = virTypedParamsGet(*params, n, name);\n    if (param) {\n        if (param->type != VIR_TYPED_PARAM_STRING) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Parameter '%s' is not a string\"),\n                           param->field);\n            return -1;\n        }\n        old = param->value.s;\n    } else {\n        if (VIR_EXPAND_N(*params, n, 1) < 0)\n            return -1;\n        param = *params + n - 1;\n    }\n\n    str = g_strdup(value);\n\n    if (virTypedParameterAssign(param, name,\n                                VIR_TYPED_PARAM_STRING, str) < 0) {\n        param->value.s = old;\n        VIR_FREE(str);\n        return -1;\n    }\n    VIR_FREE(old);\n\n    *nparams = n;\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsReplaceString(virTypedParameterPtr *params,\n                            int *nparams,\n                            const char *name,\n                            const char *value)\n{\n    char *str = NULL;\n    char *old = NULL;\n    size_t n = *nparams;\n    virTypedParameterPtr param;\n\n    param = virTypedParamsGet(*params, n, name);\n    if (param) {\n        if (param->type != VIR_TYPED_PARAM_STRING) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Parameter '%s' is not a string\"),\n                           param->field);\n            return -1;\n        }\n        old = param->value.s;\n    } else {\n        if (VIR_EXPAND_N(*params, n, 1) < 0)\n            return -1;\n        param = *params + n - 1;\n    }\n\n    str = g_strdup(value);\n\n    if (virTypedParameterAssign(param, name,\n                                VIR_TYPED_PARAM_STRING, str) < 0) {\n        param->value.s = old;\n        VIR_FREE(str);\n        return -1;\n    }\n    VIR_FREE(old);\n\n    *nparams = n;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsGetString",
          "args": [
            "params",
            "nparams",
            "VIR_MIGRATE_PARAM_DEST_NAME",
            "NULL"
          ],
          "line": 4317
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsGetStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "432-467",
          "snippet": "int\nvirTypedParamsGetStringList(virTypedParameterPtr params,\n                            int nparams,\n                            const char *name,\n                            const char ***values)\n{\n    size_t i, n;\n    int nfiltered;\n    virTypedParameterPtr *filtered = NULL;\n\n    virCheckNonNullArgGoto(values, error);\n    *values = NULL;\n\n    nfiltered = virTypedParamsFilter(params, nparams, name, &filtered);\n\n    if (nfiltered < 0)\n        goto error;\n\n    if (nfiltered &&\n        VIR_ALLOC_N(*values, nfiltered) < 0)\n        goto error;\n\n    for (n = 0, i = 0; i < nfiltered; i++) {\n        if (filtered[i]->type == VIR_TYPED_PARAM_STRING)\n            (*values)[n++] = filtered[i]->value.s;\n    }\n\n    VIR_FREE(filtered);\n    return n;\n\n error:\n    if (values)\n        VIR_FREE(*values);\n    VIR_FREE(filtered);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsGetStringList(virTypedParameterPtr params,\n                            int nparams,\n                            const char *name,\n                            const char ***values)\n{\n    size_t i, n;\n    int nfiltered;\n    virTypedParameterPtr *filtered = NULL;\n\n    virCheckNonNullArgGoto(values, error);\n    *values = NULL;\n\n    nfiltered = virTypedParamsFilter(params, nparams, name, &filtered);\n\n    if (nfiltered < 0)\n        goto error;\n\n    if (nfiltered &&\n        VIR_ALLOC_N(*values, nfiltered) < 0)\n        goto error;\n\n    for (n = 0, i = 0; i < nfiltered; i++) {\n        if (filtered[i]->type == VIR_TYPED_PARAM_STRING)\n            (*values)[n++] = filtered[i]->value.s;\n    }\n\n    VIR_FREE(filtered);\n    return n;\n\n error:\n    if (values)\n        VIR_FREE(*values);\n    VIR_FREE(filtered);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cookieout"
          ],
          "line": 4312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookiein"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finish3 %p ret=%d\"",
            "dconn",
            "ret"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PERFORM3_DONE"
          ],
          "line": 4294
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformNative",
          "args": [
            "driver",
            "vm",
            "persist_xml",
            "uri",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "flags",
            "bandwidth",
            "dconn",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams"
          ],
          "line": 4282
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3800-3878",
          "snippet": "static int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformTunnel",
          "args": [
            "driver",
            "vm",
            "st",
            "persist_xml",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "flags",
            "bandwidth",
            "dconn",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams"
          ],
          "line": 4275
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3881-3943",
          "snippet": "static int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cookieout"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookiein"
          ],
          "line": 4270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Perform3 %p uri=%s\"",
            "sconn",
            "NULLSTR(uri)"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri"
          ],
          "line": 4268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domainMigratePrepare3 did not set uri\")"
          ],
          "line": 4257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookieout"
          ],
          "line": 4242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Offline migration, skipping Perform phase\""
          ],
          "line": 4241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom_xml"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepare3",
          "args": [
            "dconn",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "uri",
            "&uri_out",
            "destflags",
            "dname",
            "bandwidth",
            "dom_xml"
          ],
          "line": 4229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepare3Params",
          "args": [
            "dconn",
            "params",
            "nparams",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "&uri_out",
            "destflags"
          ],
          "line": 4225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepareTunnel3",
          "args": [
            "dconn",
            "st",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "destflags",
            "dname",
            "bandwidth",
            "dom_xml"
          ],
          "line": 4216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepareTunnel3Params",
          "args": [
            "dconn",
            "st",
            "params",
            "nparams",
            "cookiein",
            "cookieinlen",
            "&cookieout",
            "&cookieoutlen",
            "destflags"
          ],
          "line": 4212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamNew",
          "args": [
            "dconn",
            "0"
          ],
          "line": 4207
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "52-71",
          "snippet": "virStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&cookieout"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Prepare3 %p\"",
            "dconn"
          ],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 4196
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsDump",
          "args": [
            "migParams",
            "&params",
            "&nparams",
            "&maxparams",
            "&flags"
          ],
          "line": 4191
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsDump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "621-678",
          "snippet": "int\nqemuMigrationParamsDump(qemuMigrationParamsPtr migParams,\n                        virTypedParameterPtr *params,\n                        int *nparams,\n                        int *maxparams,\n                        unsigned long *flags)\n{\n    size_t i;\n\n    if (migParams->compMethods == 1ULL << QEMU_MIGRATION_COMPRESS_XBZRLE &&\n        !migParams->params[QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE].set) {\n        *flags |= VIR_MIGRATE_COMPRESSED;\n        return 0;\n    }\n\n    for (i = 0; i < QEMU_MIGRATION_COMPRESS_LAST; ++i) {\n        if ((migParams->compMethods & (1ULL << i)) &&\n            virTypedParamsAddString(params, nparams, maxparams,\n                                    VIR_MIGRATE_PARAM_COMPRESSION,\n                                    qemuMigrationCompressMethodTypeToString(i)) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsTPMap); i++) {\n        const qemuMigrationParamsTPMapItem *item = &qemuMigrationParamsTPMap[i];\n\n        if (!(item->party & QEMU_MIGRATION_DESTINATION))\n            continue;\n\n        switch (qemuMigrationParamTypes[item->param]) {\n        case QEMU_MIGRATION_PARAM_TYPE_INT:\n            if (qemuMigrationParamsSetTPInt(migParams, item->param,\n                                            params, nparams, maxparams,\n                                            item->typedParam, item->unit) < 0)\n                return -1;\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_ULL:\n            if (qemuMigrationParamsSetTPULL(migParams, item->param,\n                                            params, nparams, maxparams,\n                                            item->typedParam, item->unit) < 0)\n                return -1;\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_BOOL:\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_STRING:\n            if (qemuMigrationParamsSetTPString(migParams, item->param,\n                                               params, nparams, maxparams,\n                                               item->typedParam) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const qemuMigrationParamsTPMapItem qemuMigrationParamsTPMap[] = {\n    {.typedParam = VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL,\n     .param = QEMU_MIGRATION_PARAM_THROTTLE_INITIAL,\n     .party = QEMU_MIGRATION_SOURCE},\n\n    {.typedParam = VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT,\n     .param = QEMU_MIGRATION_PARAM_THROTTLE_INCREMENT,\n     .party = QEMU_MIGRATION_SOURCE},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,\n     .param = QEMU_MIGRATION_PARAM_COMPRESS_LEVEL,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,\n     .param = QEMU_MIGRATION_PARAM_COMPRESS_THREADS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,\n     .param = QEMU_MIGRATION_PARAM_DECOMPRESS_THREADS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,\n     .param = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY,\n     .unit = 1024 * 1024, /* MiB/s */\n     .param = QEMU_MIGRATION_PARAM_MAX_POSTCOPY_BANDWIDTH,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS,\n     .param = QEMU_MIGRATION_PARAM_MULTIFD_CHANNELS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_TLS_DESTINATION,\n     .param = QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n     .party = QEMU_MIGRATION_SOURCE},\n};",
            "static const qemuMigrationParamType qemuMigrationParamTypes[] = {\n    [QEMU_MIGRATION_PARAM_COMPRESS_LEVEL] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_COMPRESS_THREADS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_DECOMPRESS_THREADS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_THROTTLE_INITIAL] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_THROTTLE_INCREMENT] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_TLS_CREDS] = QEMU_MIGRATION_PARAM_TYPE_STRING,\n    [QEMU_MIGRATION_PARAM_TLS_HOSTNAME] = QEMU_MIGRATION_PARAM_TYPE_STRING,\n    [QEMU_MIGRATION_PARAM_MAX_BANDWIDTH] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_DOWNTIME_LIMIT] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_BLOCK_INCREMENTAL] = QEMU_MIGRATION_PARAM_TYPE_BOOL,\n    [QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_MAX_POSTCOPY_BANDWIDTH] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_MULTIFD_CHANNELS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const qemuMigrationParamsTPMapItem qemuMigrationParamsTPMap[] = {\n    {.typedParam = VIR_MIGRATE_PARAM_AUTO_CONVERGE_INITIAL,\n     .param = QEMU_MIGRATION_PARAM_THROTTLE_INITIAL,\n     .party = QEMU_MIGRATION_SOURCE},\n\n    {.typedParam = VIR_MIGRATE_PARAM_AUTO_CONVERGE_INCREMENT,\n     .param = QEMU_MIGRATION_PARAM_THROTTLE_INCREMENT,\n     .party = QEMU_MIGRATION_SOURCE},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_LEVEL,\n     .param = QEMU_MIGRATION_PARAM_COMPRESS_LEVEL,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_THREADS,\n     .param = QEMU_MIGRATION_PARAM_COMPRESS_THREADS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_MT_DTHREADS,\n     .param = QEMU_MIGRATION_PARAM_DECOMPRESS_THREADS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_COMPRESSION_XBZRLE_CACHE,\n     .param = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_BANDWIDTH_POSTCOPY,\n     .unit = 1024 * 1024, /* MiB/s */\n     .param = QEMU_MIGRATION_PARAM_MAX_POSTCOPY_BANDWIDTH,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_PARALLEL_CONNECTIONS,\n     .param = QEMU_MIGRATION_PARAM_MULTIFD_CHANNELS,\n     .party = QEMU_MIGRATION_SOURCE | QEMU_MIGRATION_DESTINATION},\n\n    {.typedParam = VIR_MIGRATE_PARAM_TLS_DESTINATION,\n     .param = QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n     .party = QEMU_MIGRATION_SOURCE},\n};\nstatic const qemuMigrationParamType qemuMigrationParamTypes[] = {\n    [QEMU_MIGRATION_PARAM_COMPRESS_LEVEL] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_COMPRESS_THREADS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_DECOMPRESS_THREADS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_THROTTLE_INITIAL] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_THROTTLE_INCREMENT] = QEMU_MIGRATION_PARAM_TYPE_INT,\n    [QEMU_MIGRATION_PARAM_TLS_CREDS] = QEMU_MIGRATION_PARAM_TYPE_STRING,\n    [QEMU_MIGRATION_PARAM_TLS_HOSTNAME] = QEMU_MIGRATION_PARAM_TYPE_STRING,\n    [QEMU_MIGRATION_PARAM_MAX_BANDWIDTH] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_DOWNTIME_LIMIT] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_BLOCK_INCREMENTAL] = QEMU_MIGRATION_PARAM_TYPE_BOOL,\n    [QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_MAX_POSTCOPY_BANDWIDTH] = QEMU_MIGRATION_PARAM_TYPE_ULL,\n    [QEMU_MIGRATION_PARAM_MULTIFD_CHANNELS] = QEMU_MIGRATION_PARAM_TYPE_INT,\n};\n\nint\nqemuMigrationParamsDump(qemuMigrationParamsPtr migParams,\n                        virTypedParameterPtr *params,\n                        int *nparams,\n                        int *maxparams,\n                        unsigned long *flags)\n{\n    size_t i;\n\n    if (migParams->compMethods == 1ULL << QEMU_MIGRATION_COMPRESS_XBZRLE &&\n        !migParams->params[QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE].set) {\n        *flags |= VIR_MIGRATE_COMPRESSED;\n        return 0;\n    }\n\n    for (i = 0; i < QEMU_MIGRATION_COMPRESS_LAST; ++i) {\n        if ((migParams->compMethods & (1ULL << i)) &&\n            virTypedParamsAddString(params, nparams, maxparams,\n                                    VIR_MIGRATE_PARAM_COMPRESSION,\n                                    qemuMigrationCompressMethodTypeToString(i)) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsTPMap); i++) {\n        const qemuMigrationParamsTPMapItem *item = &qemuMigrationParamsTPMap[i];\n\n        if (!(item->party & QEMU_MIGRATION_DESTINATION))\n            continue;\n\n        switch (qemuMigrationParamTypes[item->param]) {\n        case QEMU_MIGRATION_PARAM_TYPE_INT:\n            if (qemuMigrationParamsSetTPInt(migParams, item->param,\n                                            params, nparams, maxparams,\n                                            item->typedParam, item->unit) < 0)\n                return -1;\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_ULL:\n            if (qemuMigrationParamsSetTPULL(migParams, item->param,\n                                            params, nparams, maxparams,\n                                            item->typedParam, item->unit) < 0)\n                return -1;\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_BOOL:\n            break;\n\n        case QEMU_MIGRATION_PARAM_TYPE_STRING:\n            if (qemuMigrationParamsSetTPString(migParams, item->param,\n                                               params, nparams, maxparams,\n                                               item->typedParam) < 0)\n                return -1;\n            break;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsAddInt",
          "args": [
            "&params",
            "&nparams",
            "&maxparams",
            "VIR_MIGRATE_PARAM_DISKS_PORT",
            "nbdPort"
          ],
          "line": 4186
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsAddInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "437-463",
          "snippet": "int\nvirTypedParamsAddInt(virTypedParameterPtr *params,\n                     int *nparams,\n                     int *maxparams,\n                     const char *name,\n                     int value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_INT, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsAddInt(virTypedParameterPtr *params,\n                     int *nparams,\n                     int *maxparams,\n                     const char *name,\n                     int value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_INT, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsAddString",
          "args": [
            "&params",
            "&nparams",
            "&maxparams",
            "VIR_MIGRATE_PARAM_MIGRATE_DISKS",
            "migrate_disks[i]"
          ],
          "line": 4181
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsAddStringList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "768-788",
          "snippet": "int\nvirTypedParamsAddStringList(virTypedParameterPtr *params,\n                            int *nparams,\n                            int *maxparams,\n                            const char *name,\n                            const char **values)\n{\n    size_t i;\n    int rv = -1;\n\n    if (!values)\n        return 0;\n\n    for (i = 0; values[i]; i++) {\n        if ((rv = virTypedParamsAddString(params, nparams, maxparams,\n                                          name, values[i])) < 0)\n            break;\n    }\n\n    return rv;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsAddStringList(virTypedParameterPtr *params,\n                            int *nparams,\n                            int *maxparams,\n                            const char *name,\n                            const char **values)\n{\n    size_t i;\n    int rv = -1;\n\n    if (!values)\n        return 0;\n\n    for (i = 0; values[i]; i++) {\n        if ((rv = virTypedParamsAddString(params, nparams, maxparams,\n                                          name, values[i])) < 0)\n            break;\n    }\n\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsAddULLong",
          "args": [
            "&params",
            "&nparams",
            "&maxparams",
            "VIR_MIGRATE_PARAM_BANDWIDTH",
            "bandwidth"
          ],
          "line": 4165
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsAddULLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam-public.c",
          "lines": "578-604",
          "snippet": "int\nvirTypedParamsAddULLong(virTypedParameterPtr *params,\n                        int *nparams,\n                        int *maxparams,\n                        const char *name,\n                        unsigned long long value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_ULLONG, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsAddULLong(virTypedParameterPtr *params,\n                        int *nparams,\n                        int *maxparams,\n                        const char *name,\n                        unsigned long long value)\n{\n    size_t max = *maxparams;\n    size_t n = *nparams;\n\n    virResetLastError();\n\n    if (VIR_RESIZE_N(*params, max, n, 1) < 0)\n        goto error;\n    *maxparams = max;\n\n    if (virTypedParameterAssign(*params + n, name,\n                                VIR_TYPED_PARAM_ULLONG, value) < 0)\n        goto error;\n\n    *nparams += 1;\n    return 0;\n\n error:\n    virDispatchError(NULL);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcBeginPhase",
          "args": [
            "driver",
            "vm",
            "xmlin",
            "dname",
            "&cookieout",
            "&cookieoutlen",
            "nmigrate_disks",
            "migrate_disks",
            "flags"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcBeginPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2039-2197",
          "snippet": "static char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, sconn=%p, dconn=%p, dconnuri=%s, vm=%p, xmlin=%s, \"\n              \"dname=%s, uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"bandwidth=%llu, useParams=%d, flags=0x%lx\"",
            "driver",
            "sconn",
            "dconn",
            "NULLSTR(dconnuri)",
            "vm",
            "NULLSTR(xmlin)",
            "NULLSTR(dname)",
            "NULLSTR(uri)",
            "NULLSTR(graphicsuri)",
            "NULLSTR(listenAddress)",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "bandwidth",
            "useParams",
            "flags"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "listenAddress"
          ],
          "line": 4135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dname"
          ],
          "line": 4134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xmlin"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dconnuri"
          ],
          "line": 4133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer3(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  const char *dconnuri,\n                                  virDomainObjPtr vm,\n                                  const char *xmlin,\n                                  const char *persist_xml,\n                                  const char *dname,\n                                  const char *uri,\n                                  const char *graphicsuri,\n                                  const char *listenAddress,\n                                  size_t nmigrate_disks,\n                                  const char **migrate_disks,\n                                  int nbdPort,\n                                  qemuMigrationParamsPtr migParams,\n                                  unsigned long long bandwidth,\n                                  bool useParams,\n                                  unsigned long flags)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookiein = NULL;\n    char *cookieout = NULL;\n    char *dom_xml = NULL;\n    int cookieinlen = 0;\n    int cookieoutlen = 0;\n    int ret = -1;\n    virErrorPtr orig_err = NULL;\n    bool cancelled = true;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int maxparams = 0;\n    size_t i;\n    bool offline = !!(flags & VIR_MIGRATE_OFFLINE);\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, dconnuri=%s, vm=%p, xmlin=%s, \"\n              \"dname=%s, uri=%s, graphicsuri=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, \"\n              \"bandwidth=%llu, useParams=%d, flags=0x%lx\",\n              driver, sconn, dconn, NULLSTR(dconnuri), vm, NULLSTR(xmlin),\n              NULLSTR(dname), NULLSTR(uri), NULLSTR(graphicsuri),\n              NULLSTR(listenAddress), nmigrate_disks, migrate_disks, nbdPort,\n              bandwidth, useParams, flags);\n\n    /* Unlike the virDomainMigrateVersion3 counterpart, we don't need\n     * to worry about auto-setting the VIR_MIGRATE_CHANGE_PROTECTION\n     * bit here, because we are already running inside the context of\n     * a single job.  */\n\n    dom_xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                         &cookieout, &cookieoutlen,\n                                         nmigrate_disks, migrate_disks, flags);\n    if (!dom_xml)\n        goto cleanup;\n\n    if (useParams) {\n        if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_XML, dom_xml) < 0)\n            goto cleanup;\n\n        if (dname &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, dname) < 0)\n            goto cleanup;\n\n        if (uri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_URI, uri) < 0)\n            goto cleanup;\n\n        if (bandwidth &&\n            virTypedParamsAddULLong(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_BANDWIDTH,\n                                    bandwidth) < 0)\n            goto cleanup;\n\n        if (graphicsuri &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_GRAPHICS_URI,\n                                    graphicsuri) < 0)\n            goto cleanup;\n        if (listenAddress &&\n            virTypedParamsAddString(&params, &nparams, &maxparams,\n                                    VIR_MIGRATE_PARAM_LISTEN_ADDRESS,\n                                    listenAddress) < 0)\n            goto cleanup;\n        for (i = 0; i < nmigrate_disks; i++)\n            if (virTypedParamsAddString(&params, &nparams, &maxparams,\n                                        VIR_MIGRATE_PARAM_MIGRATE_DISKS,\n                                        migrate_disks[i]) < 0)\n                goto cleanup;\n        if (nbdPort &&\n            virTypedParamsAddInt(&params, &nparams, &maxparams,\n                                 VIR_MIGRATE_PARAM_DISKS_PORT,\n                                 nbdPort) < 0)\n            goto cleanup;\n\n        if (qemuMigrationParamsDump(migParams, &params, &nparams,\n                                    &maxparams, &flags) < 0)\n            goto cleanup;\n    }\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare3 %p\", dconn);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepareTunnel3Params\n                (dconn, st, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepareTunnel3\n                (dconn, st, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        if (useParams) {\n            ret = dconn->driver->domainMigratePrepare3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, &uri_out, destflags);\n        } else {\n            ret = dconn->driver->domainMigratePrepare3\n                (dconn, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n                 uri, &uri_out, destflags, dname, bandwidth, dom_xml);\n        }\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (offline) {\n        VIR_DEBUG(\"Offline migration, skipping Perform phase\");\n        VIR_FREE(cookieout);\n        cookieoutlen = 0;\n        cancelled = false;\n        goto finish;\n    }\n\n    if (uri_out) {\n        uri = uri_out;\n        if (useParams &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_URI, uri_out) < 0) {\n            virErrorPreserveLast(&orig_err);\n            goto finish;\n        }\n    } else if (!uri && !(flags & VIR_MIGRATE_TUNNELLED)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare3 did not set uri\"));\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete. The src VM should remain\n     * running, but in paused state until the destination can\n     * confirm migration completion.\n     */\n    VIR_DEBUG(\"Perform3 %p uri=%s\", sconn, NULLSTR(uri));\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM3);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, persist_xml,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    } else {\n        ret = qemuMigrationSrcPerformNative(driver, vm, persist_xml, uri,\n                                            cookiein, cookieinlen,\n                                            &cookieout, &cookieoutlen,\n                                            flags, bandwidth, dconn, graphicsuri,\n                                            nmigrate_disks, migrate_disks,\n                                            migParams);\n    }\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0) {\n        virErrorPreserveLast(&orig_err);\n    } else {\n        qemuMigrationJobSetPhase(driver, vm,\n                                 QEMU_MIGRATION_PHASE_PERFORM3_DONE);\n    }\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /*\n     * The status code from the source is passed to the destination.\n     * The dest can cleanup in the source indicated it failed to\n     * send all migration data. Returns NULL for ddomain if\n     * the dest was unable to complete migration.\n     */\n    VIR_DEBUG(\"Finish3 %p ret=%d\", dconn, ret);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n\n    if (useParams) {\n        if (virTypedParamsGetString(params, nparams,\n                                    VIR_MIGRATE_PARAM_DEST_NAME, NULL) <= 0 &&\n            virTypedParamsReplaceString(&params, &nparams,\n                                        VIR_MIGRATE_PARAM_DEST_NAME,\n                                        vm->def->name) < 0) {\n            ddomain = NULL;\n        } else {\n            qemuDomainObjEnterRemote(vm);\n            ddomain = dconn->driver->domainMigrateFinish3Params\n                (dconn, params, nparams, cookiein, cookieinlen,\n                 &cookieout, &cookieoutlen, destflags, cancelled);\n            if (qemuDomainObjExitRemote(vm, !offline) < 0)\n                goto cleanup;\n        }\n    } else {\n        dname = dname ? dname : vm->def->name;\n        qemuDomainObjEnterRemote(vm);\n        ddomain = dconn->driver->domainMigrateFinish3\n            (dconn, dname, cookiein, cookieinlen, &cookieout, &cookieoutlen,\n             dconnuri, uri, destflags, cancelled);\n        if (qemuDomainObjExitRemote(vm, !offline) < 0)\n            goto cleanup;\n    }\n\n    if (cancelled) {\n        if (ddomain) {\n            VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n        } else {\n            /* If Finish reported a useful error, use it instead of the\n             * original \"migration unexpectedly failed\" error.\n             *\n             * This is ugly but we can't do better with the APIs we have. We\n             * only replace the error if Finish was called with cancelled == 1\n             * and reported a real error (old libvirt would report an error\n             * from RPC instead of MIGRATE_FINISH_OK), which only happens when\n             * the domain died on destination. To further reduce a possibility\n             * of false positives we also check that Perform returned\n             * VIR_ERR_OPERATION_FAILED.\n             */\n            if (orig_err &&\n                orig_err->domain == VIR_FROM_QEMU &&\n                orig_err->code == VIR_ERR_OPERATION_FAILED) {\n                virErrorPtr err = virGetLastError();\n                if (err &&\n                    err->domain == VIR_FROM_QEMU &&\n                    err->code != VIR_ERR_MIGRATE_FINISH_OK) {\n                    virFreeError(orig_err);\n                    orig_err = NULL;\n                }\n            }\n        }\n    }\n\n    /* If ddomain is NULL, then we were unable to start\n     * the guest on the target, and must restart on the\n     * source. There is a small chance that the ddomain\n     * is NULL due to an RPC failure, in which case\n     * ddomain could in fact be running on the dest.\n     * The lock manager plugins should take care of\n     * safety in this scenario.\n     */\n    cancelled = ddomain == NULL;\n\n    /* If finish3 set an error, and we don't have an earlier\n     * one we need to preserve it in case confirm3 overwrites\n     */\n    if (!orig_err)\n        virErrorPreserveLast(&orig_err);\n\n    /*\n     * If cancelled, then src VM will be restarted, else\n     * it will be killed\n     */\n    VIR_DEBUG(\"Confirm3 %p cancelled=%d vm=%p\", sconn, cancelled, vm);\n    VIR_FREE(cookiein);\n    cookiein = g_steal_pointer(&cookieout);\n    cookieinlen = cookieoutlen;\n    cookieoutlen = 0;\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n    /* If Confirm3 returns -1, there's nothing more we can\n     * do, but fortunately worst case is that there is a\n     * domain left in 'paused' state on source.\n     */\n    if (ret < 0)\n        VIR_WARN(\"Guest %s probably left in 'paused' state on source\",\n                 vm->def->name);\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookiein);\n    VIR_FREE(cookieout);\n    virTypedParamsFree(params, nparams);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformPeer2Peer2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3950-4084",
    "snippet": "static int\nqemuMigrationSrcPerformPeer2Peer2(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  virDomainObjPtr vm,\n                                  const char *dconnuri,\n                                  unsigned long flags,\n                                  const char *dname,\n                                  unsigned long resource,\n                                  qemuMigrationParamsPtr migParams)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virErrorPtr orig_err = NULL;\n    bool cancelled;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, vm=%p, dconnuri=%s, \"\n              \"flags=0x%lx, dname=%s, resource=%lu\",\n              driver, sconn, dconn, vm, NULLSTR(dconnuri),\n              flags, NULLSTR(dname), resource);\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!(dom_xml = qemuDomainFormatXML(driver, vm,\n                                        QEMU_DOMAIN_FORMAT_LIVE_FLAGS |\n                                        VIR_DOMAIN_XML_MIGRATABLE)))\n        return -1;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p\", dconn);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        /*\n         * Tunnelled Migrate Version 2 does not support cookies\n         * due to missing parameters in the prepareTunnel() API.\n         */\n\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepareTunnel\n            (dconn, st, destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepare2\n            (dconn, &cookie, &cookielen, NULL, &uri_out,\n             destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED) &&\n        (uri_out == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = true;\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", sconn);\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, NULL,\n                                            NULL, 0, NULL, NULL,\n                                            flags, resource, dconn,\n                                            NULL, 0, NULL, migParams);\n    else\n        ret = qemuMigrationSrcPerformNative(driver, vm, NULL, uri_out,\n                                            cookie, cookielen,\n                                            NULL, NULL, /* No out cookie with v2 migration */\n                                            flags, resource, dconn, NULL, 0, NULL,\n                                            migParams);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : vm->def->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    qemuDomainObjEnterRemote(vm);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen,\n         uri_out ? uri_out : dconnuri, destflags, cancelled);\n    /* The domain is already gone at this point */\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cookie"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "uri_out"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 4079
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st"
          ],
          "line": 4077
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"finish step ignored that migration was cancelled\")"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"finish step ignored that migration was cancelled\""
          ],
          "line": 4067
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitRemote(vm, false)"
          ],
          "line": 4065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitRemote",
          "args": [
            "vm",
            "false"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10274-10290",
          "snippet": "int\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nint\nqemuDomainObjExitRemote(virDomainObjPtr obj,\n                        bool checkActive)\n{\n    virObjectLock(obj);\n    VIR_DEBUG(\"Exited remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n\n    if (checkActive && !virDomainObjIsActive(obj)) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"domain '%s' is not running\"),\n                       obj->def->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigrateFinish2",
          "args": [
            "dconn",
            "dname",
            "cookie",
            "cookielen",
            "uri_out ? uri_out : dconnuri",
            "destflags",
            "cancelled"
          ],
          "line": 4061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterRemote",
          "args": [
            "vm"
          ],
          "line": 4060
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterRemote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10266-10271",
          "snippet": "void qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nvoid qemuDomainObjEnterRemote(virDomainObjPtr obj)\n{\n    VIR_DEBUG(\"Entering remote (vm=%p name=%s)\",\n              obj, obj->def->name);\n    virObjectUnlock(obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Finish2 %p ret=%d\"",
            "dconn",
            "ret"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 4046
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformNative",
          "args": [
            "driver",
            "vm",
            "NULL",
            "uri_out",
            "cookie",
            "cookielen",
            "NULL",
            "NULL",
            "/* No out cookie with v2 migration */flags",
            "resource",
            "dconn",
            "NULL",
            "0",
            "NULL",
            "migParams"
          ],
          "line": 4038
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformNative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3800-3878",
          "snippet": "static int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcPerformTunnel",
          "args": [
            "driver",
            "vm",
            "st",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "NULL",
            "flags",
            "resource",
            "dconn",
            "NULL",
            "0",
            "NULL",
            "migParams"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcPerformTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3881-3943",
          "snippet": "static int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PERFORM2"
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Perform %p\"",
            "sconn"
          ],
          "line": 4030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"domainMigratePrepare2 did not set uri\")"
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dom_xml"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepare2",
          "args": [
            "dconn",
            "&cookie",
            "&cookielen",
            "NULL",
            "&uri_out",
            "destflags",
            "dname",
            "resource",
            "dom_xml"
          ],
          "line": 4008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dconn->driver->domainMigratePrepareTunnel",
          "args": [
            "dconn",
            "st",
            "destflags",
            "dname",
            "resource",
            "dom_xml"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamNew",
          "args": [
            "dconn",
            "0"
          ],
          "line": 3998
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "52-71",
          "snippet": "virStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStreamPtr\nvirStreamNew(virConnectPtr conn,\n             unsigned int flags)\n{\n    virStreamPtr st;\n\n    VIR_DEBUG(\"conn=%p, flags=0x%x\", conn, flags);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n\n    st = virGetStream(conn);\n    if (st)\n        st->flags = flags;\n    else\n        virDispatchError(conn);\n\n    return st;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Prepare2 %p\"",
            "dconn"
          ],
          "line": 3991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 3985
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainFormatXML",
          "args": [
            "driver",
            "vm",
            "QEMU_DOMAIN_FORMAT_LIVE_FLAGS |\n                                        VIR_DOMAIN_XML_MIGRATABLE"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainFormatXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10575-10591",
          "snippet": "char *qemuDomainFormatXML(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          unsigned int flags)\n{\n    virDomainDefPtr def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virCPUDefPtr origCPU = NULL;\n\n    if ((flags & VIR_DOMAIN_XML_INACTIVE) && vm->newDef) {\n        def = vm->newDef;\n    } else {\n        def = vm->def;\n        origCPU = priv->origCPU;\n    }\n\n    return qemuDomainDefFormatXMLInternal(driver, priv->qemuCaps, def, origCPU, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nchar *qemuDomainFormatXML(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          unsigned int flags)\n{\n    virDomainDefPtr def;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virCPUDefPtr origCPU = NULL;\n\n    if ((flags & VIR_DOMAIN_XML_INACTIVE) && vm->newDef) {\n        def = vm->newDef;\n    } else {\n        def = vm->def;\n        origCPU = priv->origCPU;\n    }\n\n    return qemuDomainDefFormatXMLInternal(driver, priv->qemuCaps, def, origCPU, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, sconn=%p, dconn=%p, vm=%p, dconnuri=%s, \"\n              \"flags=0x%lx, dname=%s, resource=%lu\"",
            "driver",
            "sconn",
            "dconn",
            "vm",
            "NULLSTR(dconnuri)",
            "flags",
            "NULLSTR(dname)",
            "resource"
          ],
          "line": 3971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dname"
          ],
          "line": 3974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dconnuri"
          ],
          "line": 3973
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformPeer2Peer2(virQEMUDriverPtr driver,\n                                  virConnectPtr sconn,\n                                  virConnectPtr dconn,\n                                  virDomainObjPtr vm,\n                                  const char *dconnuri,\n                                  unsigned long flags,\n                                  const char *dname,\n                                  unsigned long resource,\n                                  qemuMigrationParamsPtr migParams)\n{\n    virDomainPtr ddomain = NULL;\n    char *uri_out = NULL;\n    char *cookie = NULL;\n    char *dom_xml = NULL;\n    int cookielen = 0, ret;\n    virErrorPtr orig_err = NULL;\n    bool cancelled;\n    virStreamPtr st = NULL;\n    unsigned long destflags;\n\n    VIR_DEBUG(\"driver=%p, sconn=%p, dconn=%p, vm=%p, dconnuri=%s, \"\n              \"flags=0x%lx, dname=%s, resource=%lu\",\n              driver, sconn, dconn, vm, NULLSTR(dconnuri),\n              flags, NULLSTR(dname), resource);\n\n    /* In version 2 of the protocol, the prepare step is slightly\n     * different.  We fetch the domain XML of the source domain\n     * and pass it to Prepare2.\n     */\n    if (!(dom_xml = qemuDomainFormatXML(driver, vm,\n                                        QEMU_DOMAIN_FORMAT_LIVE_FLAGS |\n                                        VIR_DOMAIN_XML_MIGRATABLE)))\n        return -1;\n\n    if (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_PAUSED)\n        flags |= VIR_MIGRATE_PAUSED;\n\n    destflags = flags & ~(VIR_MIGRATE_ABORT_ON_ERROR |\n                          VIR_MIGRATE_AUTO_CONVERGE);\n\n    VIR_DEBUG(\"Prepare2 %p\", dconn);\n    if (flags & VIR_MIGRATE_TUNNELLED) {\n        /*\n         * Tunnelled Migrate Version 2 does not support cookies\n         * due to missing parameters in the prepareTunnel() API.\n         */\n\n        if (!(st = virStreamNew(dconn, 0)))\n            goto cleanup;\n\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepareTunnel\n            (dconn, st, destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    } else {\n        qemuDomainObjEnterRemote(vm);\n        ret = dconn->driver->domainMigratePrepare2\n            (dconn, &cookie, &cookielen, NULL, &uri_out,\n             destflags, dname, resource, dom_xml);\n        if (qemuDomainObjExitRemote(vm, true) < 0)\n            goto cleanup;\n    }\n    VIR_FREE(dom_xml);\n    if (ret == -1)\n        goto cleanup;\n\n    if (!(flags & VIR_MIGRATE_TUNNELLED) &&\n        (uri_out == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"domainMigratePrepare2 did not set uri\"));\n        cancelled = true;\n        virErrorPreserveLast(&orig_err);\n        goto finish;\n    }\n\n    /* Perform the migration.  The driver isn't supposed to return\n     * until the migration is complete.\n     */\n    VIR_DEBUG(\"Perform %p\", sconn);\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PERFORM2);\n    if (flags & VIR_MIGRATE_TUNNELLED)\n        ret = qemuMigrationSrcPerformTunnel(driver, vm, st, NULL,\n                                            NULL, 0, NULL, NULL,\n                                            flags, resource, dconn,\n                                            NULL, 0, NULL, migParams);\n    else\n        ret = qemuMigrationSrcPerformNative(driver, vm, NULL, uri_out,\n                                            cookie, cookielen,\n                                            NULL, NULL, /* No out cookie with v2 migration */\n                                            flags, resource, dconn, NULL, 0, NULL,\n                                            migParams);\n\n    /* Perform failed. Make sure Finish doesn't overwrite the error */\n    if (ret < 0)\n        virErrorPreserveLast(&orig_err);\n\n    /* If Perform returns < 0, then we need to cancel the VM\n     * startup on the destination\n     */\n    cancelled = ret < 0;\n\n finish:\n    /* In version 2 of the migration protocol, we pass the\n     * status code from the sender to the destination host,\n     * so it can do any cleanup if the migration failed.\n     */\n    dname = dname ? dname : vm->def->name;\n    VIR_DEBUG(\"Finish2 %p ret=%d\", dconn, ret);\n    qemuDomainObjEnterRemote(vm);\n    ddomain = dconn->driver->domainMigrateFinish2\n        (dconn, dname, cookie, cookielen,\n         uri_out ? uri_out : dconnuri, destflags, cancelled);\n    /* The domain is already gone at this point */\n    ignore_value(qemuDomainObjExitRemote(vm, false));\n    if (cancelled && ddomain)\n        VIR_ERROR(_(\"finish step ignored that migration was cancelled\"));\n\n cleanup:\n    if (ddomain) {\n        virObjectUnref(ddomain);\n        ret = 0;\n    } else {\n        ret = -1;\n    }\n\n    virObjectUnref(st);\n\n    virErrorRestore(&orig_err);\n    VIR_FREE(uri_out);\n    VIR_FREE(cookie);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3881-3943",
    "snippet": "static int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 3941
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "spec.dest.fd.local"
          ],
          "line": 3939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "spec.dest.fd.qemu"
          ],
          "line": 3938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcRun",
          "args": [
            "driver",
            "vm",
            "persist_xml",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "&spec",
            "dconn",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams"
          ],
          "line": 3932
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3431-3795",
          "snippet": "static int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot create pipe for tunnelled migration\")"
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot create pipe for tunnelled migration\""
          ],
          "line": 3928
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetImageFDLabel",
          "args": [
            "driver->securityManager",
            "vm->def",
            "spec.dest.fd.qemu"
          ],
          "line": 3925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "fds"
          ],
          "line": 3918
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\"",
            "driver",
            "vm",
            "st",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "NULLSTR(graphicsuri)",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 3903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 3908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 3906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformTunnel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStreamPtr st,\n                              const char *persist_xml,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    qemuMigrationSpec spec;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    int fds[2] = { -1, -1 };\n\n    VIR_DEBUG(\"driver=%p, vm=%p, st=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, st, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    spec.fwdType = MIGRATION_FWD_STREAM;\n    spec.fwd.stream = st;\n\n\n    spec.destType = MIGRATION_DEST_FD;\n    spec.dest.fd.qemu = -1;\n    spec.dest.fd.local = -1;\n\n    if (virPipe(fds) < 0)\n        goto cleanup;\n\n    spec.dest.fd.qemu = fds[1];\n    spec.dest.fd.local = fds[0];\n\n    if (spec.dest.fd.qemu == -1 ||\n        qemuSecuritySetImageFDLabel(driver->securityManager, vm->def,\n                                    spec.dest.fd.qemu) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"cannot create pipe for tunnelled migration\"));\n        goto cleanup;\n    }\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen,\n                              cookieout, cookieoutlen, flags, resource, &spec,\n                              dconn, graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n cleanup:\n    VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n    VIR_FORCE_CLOSE(spec.dest.fd.local);\n\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcPerformNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3800-3878",
    "snippet": "static int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uribits"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "spec.dest.fd.qemu"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcRun",
          "args": [
            "driver",
            "vm",
            "persist_xml",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "&spec",
            "dconn",
            "graphicsuri",
            "nmigrate_disks",
            "migrate_disks",
            "migParams"
          ],
          "line": 3866
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3431-3795",
          "snippet": "static int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "uribits->scheme",
            "\"rdma\""
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\")"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\""
          ],
          "line": 3848
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMemoryLimitIsSet",
          "args": [
            "vm->def->mem.hard_limit"
          ],
          "line": 3846
        },
        "resolved": true,
        "details": {
          "function_name": "virMemoryLimitIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1628-1632",
          "snippet": "bool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\")"
          ],
          "line": 3841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_MIGRATE_RDMA"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "uribits->scheme",
            "\"rdma\""
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing scheme in migration URI: %s\")",
            "uri"
          ],
          "line": 3833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyParseURI",
          "args": [
            "uri",
            "NULL"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyParseURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2774-2793",
          "snippet": "static virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\"",
            "driver",
            "vm",
            "uri",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "NULLSTR(graphicsuri)",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 3825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcPerformNative(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              const char *persist_xml,\n                              const char *uri,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              unsigned long flags,\n                              unsigned long resource,\n                              virConnectPtr dconn,\n                              const char *graphicsuri,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virURIPtr uribits = NULL;\n    int ret = -1;\n    qemuMigrationSpec spec;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, uri=%s, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"graphicsuri=%s, nmigrate_disks=%zu migrate_disks=%p\",\n              driver, vm, uri, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (!(uribits = qemuMigrationAnyParseURI(uri, NULL)))\n        return -1;\n\n    if (uribits->scheme == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"missing scheme in migration URI: %s\"),\n                       uri);\n        goto cleanup;\n    }\n\n    if (STREQ(uribits->scheme, \"rdma\")) {\n        if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"outgoing RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            goto cleanup;\n        }\n        if (!virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"cannot start RDMA migration with no memory hard \"\n                             \"limit set\"));\n            goto cleanup;\n        }\n    }\n\n    /* RDMA and multi-fd migration requires QEMU to connect to the destination\n     * itself.\n     */\n    if (STREQ(uribits->scheme, \"rdma\") || (flags & VIR_MIGRATE_PARALLEL))\n        spec.destType = MIGRATION_DEST_HOST;\n    else\n        spec.destType = MIGRATION_DEST_CONNECT_HOST;\n    spec.dest.host.protocol = uribits->scheme;\n    spec.dest.host.name = uribits->server;\n    spec.dest.host.port = uribits->port;\n    spec.fwdType = MIGRATION_FWD_DIRECT;\n\n    ret = qemuMigrationSrcRun(driver, vm, persist_xml, cookiein, cookieinlen, cookieout,\n                              cookieoutlen, flags, resource, &spec, dconn,\n                              graphicsuri, nmigrate_disks, migrate_disks,\n                              migParams);\n\n    if (spec.destType == MIGRATION_DEST_FD)\n        VIR_FORCE_CLOSE(spec.dest.fd.qemu);\n\n cleanup:\n    virURIFree(uribits);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3431-3795",
    "snippet": "static int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3793
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcStopTunnel",
          "args": [
            "iothread",
            "true"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcStopTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3331-3363",
          "snippet": "static int\nqemuMigrationSrcStopTunnel(qemuMigrationIOThreadPtr io, bool error)\n{\n    int rv = -1;\n    char stop = error ? 1 : 0;\n\n    /* make sure the thread finishes its job and is joinable */\n    if (safewrite(io->wakeupSendFD, &stop, 1) != 1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wakeup migration tunnel\"));\n        goto cleanup;\n    }\n\n    virThreadJoin(&io->thread);\n\n    /* Forward error from the IO thread, to this thread */\n    if (io->err.code != VIR_ERR_OK) {\n        if (error)\n            rv = 0;\n        else\n            virSetError(&io->err);\n        virResetError(&io->err);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(io->wakeupSendFD);\n    VIR_FORCE_CLOSE(io->wakeupRecvFD);\n    VIR_FREE(io);\n    return rv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcStopTunnel(qemuMigrationIOThreadPtr io, bool error)\n{\n    int rv = -1;\n    char stop = error ? 1 : 0;\n\n    /* make sure the thread finishes its job and is joinable */\n    if (safewrite(io->wakeupSendFD, &stop, 1) != 1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wakeup migration tunnel\"));\n        goto cleanup;\n    }\n\n    virThreadJoin(&io->thread);\n\n    /* Forward error from the IO thread, to this thread */\n    if (io->err.code != VIR_ERR_OK) {\n        if (error)\n            rv = 0;\n        else\n            virSetError(&io->err);\n        virResetError(&io->err);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(io->wakeupSendFD);\n    VIR_FORCE_CLOSE(io->wakeupRecvFD);\n    VIR_FREE(io);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDCopyCancel",
          "args": [
            "driver",
            "vm",
            "false",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "dconn"
          ],
          "line": 3779
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDCopyCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "694-777",
          "snippet": "static int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateCancel",
          "args": [
            "priv->mon"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2526-2532",
          "snippet": "int\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateCancel(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateCancel(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 3771
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 3768
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 3766
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 3761
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 3756
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "persistDef"
          ],
          "line": 3755
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tlsAlias"
          ],
          "line": 3753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to encode migration cookie\""
          ],
          "line": 3747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationBakeCookie",
          "args": [
            "mig",
            "driver",
            "vm",
            "QEMU_MIGRATION_SOURCE",
            "cookieout",
            "cookieoutlen",
            "cookieFlags"
          ],
          "line": 3744
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationBakeCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1397-1459",
          "snippet": "int\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieAddPersistent",
          "args": [
            "mig",
            "&persistDef"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieAddPersistent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "395-413",
          "snippet": "int\nqemuMigrationCookieAddPersistent(qemuMigrationCookiePtr mig,\n                                 virDomainDefPtr *def)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration persistent data already present\"));\n        return -1;\n    }\n\n    if (!def || !*def)\n        return 0;\n\n    mig->persistent = *def;\n    *def = NULL;\n    mig->flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationCookieAddPersistent(qemuMigrationCookiePtr mig,\n                                 virDomainDefPtr *def)\n{\n    if (mig->flags & QEMU_MIGRATION_COOKIE_PERSISTENT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration persistent data already present\"));\n        return -1;\n    }\n\n    if (!def || !*def)\n        return 0;\n\n    mig->persistent = *def;\n    *def = NULL;\n    mig->flags |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_PERSISTENT;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virTimeMillisNow(&priv->job.completed->sent)"
          ],
          "line": 3737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTimeMillisNow",
          "args": [
            "&priv->job.completed->sent"
          ],
          "line": 3737
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeMillisNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "214-222",
          "snippet": "int virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nint virTimeMillisNow(unsigned long long *now)\n{\n    if (virTimeMillisNowRaw(now) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to get current time\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateDowntime",
          "args": [
            "priv->job.completed"
          ],
          "line": 3736
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateDowntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "451-471",
          "snippet": "int\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "priv->job.completed"
          ],
          "line": 3735
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&iothread"
          ],
          "line": 3728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcWaitForCompletion",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "dconn",
            "waitFlags"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcWaitForCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1690-1741",
          "snippet": "static int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcContinue",
          "args": [
            "driver",
            "vm",
            "QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 3706
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3410-3428",
          "snippet": "static int\nqemuMigrationSrcContinue(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMonitorMigrationStatus status,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorMigrateContinue(priv->mon, status);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcContinue(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMonitorMigrationStatus status,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorMigrateContinue(priv->mon, status);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 3689
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 3687
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcStartTunnel",
          "args": [
            "spec->fwd.stream",
            "fd"
          ],
          "line": 3657
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcStartTunnel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "3294-3329",
          "snippet": "static qemuMigrationIOThreadPtr\nqemuMigrationSrcStartTunnel(virStreamPtr st,\n                            int sock)\n{\n    qemuMigrationIOThreadPtr io = NULL;\n    int wakeupFD[2] = { -1, -1 };\n\n    if (virPipe(wakeupFD) < 0)\n        goto error;\n\n    if (VIR_ALLOC(io) < 0)\n        goto error;\n\n    io->st = st;\n    io->sock = sock;\n    io->wakeupRecvFD = wakeupFD[0];\n    io->wakeupSendFD = wakeupFD[1];\n\n    if (virThreadCreateFull(&io->thread, true,\n                            qemuMigrationSrcIOFunc,\n                            \"qemu-mig-tunnel\",\n                            false,\n                            io) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create migration thread\"));\n        goto error;\n    }\n\n    return io;\n\n error:\n    VIR_FORCE_CLOSE(wakeupFD[0]);\n    VIR_FORCE_CLOSE(wakeupFD[1]);\n    VIR_FREE(io);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic qemuMigrationIOThreadPtr\nqemuMigrationSrcStartTunnel(virStreamPtr st,\n                            int sock)\n{\n    qemuMigrationIOThreadPtr io = NULL;\n    int wakeupFD[2] = { -1, -1 };\n\n    if (virPipe(wakeupFD) < 0)\n        goto error;\n\n    if (VIR_ALLOC(io) < 0)\n        goto error;\n\n    io->st = st;\n    io->sock = sock;\n    io->wakeupRecvFD = wakeupFD[0];\n    io->wakeupSendFD = wakeupFD[1];\n\n    if (virThreadCreateFull(&io->thread, true,\n                            qemuMigrationSrcIOFunc,\n                            \"qemu-mig-tunnel\",\n                            false,\n                            io) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create migration thread\"));\n        goto error;\n    }\n\n    return io;\n\n error:\n    VIR_FORCE_CLOSE(wakeupFD[0]);\n    VIR_FORCE_CLOSE(wakeupFD[1]);\n    VIR_FREE(io);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "spec->dest.fd.qemu"
          ],
          "line": 3645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateToFd",
          "args": [
            "priv->mon",
            "migrate_flags",
            "spec->dest.fd.qemu"
          ],
          "line": 3643
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateToFd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2478-2499",
          "snippet": "int\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateToFd(qemuMonitorPtr mon,\n                       unsigned int flags,\n                       int fd)\n{\n    int ret;\n    VIR_DEBUG(\"fd=%d flags=0x%x\", fd, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (qemuMonitorSendFileHandle(mon, \"migrate\", fd) < 0)\n        return -1;\n\n    ret = qemuMonitorJSONMigrate(mon, flags, \"fd:migrate\");\n\n    if (ret < 0) {\n        if (qemuMonitorCloseFileHandle(mon, \"migrate\") < 0)\n            VIR_WARN(\"failed to close migration handle\");\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateToHost",
          "args": [
            "priv->mon",
            "migrate_flags",
            "spec->dest.host.protocol",
            "spec->dest.host.name",
            "spec->dest.host.port"
          ],
          "line": 3628
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateToHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2502-2523",
          "snippet": "int\nqemuMonitorMigrateToHost(qemuMonitorPtr mon,\n                         unsigned int flags,\n                         const char *protocol,\n                         const char *hostname,\n                         int port)\n{\n    int ret;\n    char *uri = NULL;\n    VIR_DEBUG(\"hostname=%s port=%d flags=0x%x\", hostname, port, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (strchr(hostname, ':')) {\n        uri = g_strdup_printf(\"%s:[%s]:%d\", protocol, hostname, port);\n    } else uri = g_strdup_printf(\"%s:%s:%d\", protocol, hostname, port);\n\n    ret = qemuMonitorJSONMigrate(mon, flags, uri);\n\n    VIR_FREE(uri);\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateToHost(qemuMonitorPtr mon,\n                         unsigned int flags,\n                         const char *protocol,\n                         const char *hostname,\n                         int port)\n{\n    int ret;\n    char *uri = NULL;\n    VIR_DEBUG(\"hostname=%s port=%d flags=0x%x\", hostname, port, flags);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (strchr(hostname, ':')) {\n        uri = g_strdup_printf(\"%s:[%s]:%d\", protocol, hostname, port);\n    } else uri = g_strdup_printf(\"%s:%s:%d\", protocol, hostname, port);\n\n    ret = qemuMonitorJSONMigrate(mon, flags, uri);\n\n    VIR_FREE(uri);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxMemLock",
          "args": [
            "vm->pid",
            "vm->def->mem.hard_limit << 10"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxMemLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "772-780",
          "snippet": "int\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "spec->dest.host.protocol",
            "\"rdma\""
          ],
          "line": 3624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "timestamp"
          ],
          "line": 3618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainLogAppendMessage",
          "args": [
            "driver",
            "vm",
            "\"%s: initiating migration\\n\"",
            "timestamp"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainLogAppendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10921-10970",
          "snippet": "int\nqemuDomainLogAppendMessage(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *fmt,\n                           ...)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virLogManagerPtr manager = NULL;\n    va_list ap;\n    g_autofree char *path = NULL;\n    int writefd = -1;\n    g_autofree char *message = NULL;\n    int ret = -1;\n\n    va_start(ap, fmt);\n\n    message = g_strdup_vprintf(fmt, ap);\n\n    VIR_DEBUG(\"Append log message (vm='%s' message='%s) stdioLogD=%d\",\n              vm->def->name, message, cfg->stdioLogD);\n\n    path = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (cfg->stdioLogD) {\n        if (!(manager = virLogManagerNew(virQEMUDriverIsPrivileged(driver))))\n            goto cleanup;\n\n        if (virLogManagerDomainAppendMessage(manager, \"qemu\", vm->def->uuid,\n                                             vm->def->name, path, message, 0) < 0)\n            goto cleanup;\n    } else {\n        if ((writefd = open(path, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (safewrite(writefd, message, strlen(message)) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    va_end(ap);\n    VIR_FORCE_CLOSE(writefd);\n    virLogManagerFree(manager);\n\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nint\nqemuDomainLogAppendMessage(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *fmt,\n                           ...)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virLogManagerPtr manager = NULL;\n    va_list ap;\n    g_autofree char *path = NULL;\n    int writefd = -1;\n    g_autofree char *message = NULL;\n    int ret = -1;\n\n    va_start(ap, fmt);\n\n    message = g_strdup_vprintf(fmt, ap);\n\n    VIR_DEBUG(\"Append log message (vm='%s' message='%s) stdioLogD=%d\",\n              vm->def->name, message, cfg->stdioLogD);\n\n    path = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (cfg->stdioLogD) {\n        if (!(manager = virLogManagerNew(virQEMUDriverIsPrivileged(driver))))\n            goto cleanup;\n\n        if (virLogManagerDomainAppendMessage(manager, \"qemu\", vm->def->uuid,\n                                             vm->def->name, path, message, 0) < 0)\n            goto cleanup;\n    } else {\n        if ((writefd = open(path, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (safewrite(writefd, message, strlen(message)) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    va_end(ap);\n    VIR_FORCE_CLOSE(writefd);\n    virLogManagerFree(manager);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeStringNow",
          "args": [],
          "line": 3616
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeStringNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "256-271",
          "snippet": "char *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcConnect",
          "args": [
            "driver",
            "vm",
            "spec"
          ],
          "line": 3611
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcConnectionClosed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "4425-4434",
          "snippet": "static void\nqemuMigrationSrcConnectionClosed(virConnectPtr conn,\n                                 int reason,\n                                 void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n\n    VIR_DEBUG(\"conn=%p, reason=%d, vm=%s\", conn, reason, vm->def->name);\n    virDomainObjBroadcast(vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcConnectionClosed(virConnectPtr conn,\n                                 int reason,\n                                 void *opaque)\n{\n    virDomainObjPtr vm = opaque;\n\n    VIR_DEBUG(\"conn=%p, reason=%d, vm=%s\", conn, reason, vm->def->name);\n    virDomainObjBroadcast(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorSetMigrationSpeed",
          "args": [
            "priv->mon",
            "migrate_speed"
          ],
          "line": 3606
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorSetMigrationSpeed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2364-2380",
          "snippet": "int\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorSetMigrationSpeed(qemuMonitorPtr mon,\n                             unsigned long bandwidth)\n{\n    VIR_DEBUG(\"bandwidth=%lu\", bandwidth);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    if (bandwidth > QEMU_DOMAIN_MIG_BANDWIDTH_MAX) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       QEMU_DOMAIN_MIG_BANDWIDTH_MAX + 1ULL);\n        return -1;\n    }\n\n    return qemuMonitorJSONSetMigrationSpeed(mon, bandwidth);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_ABORTED",
            "_(\"%s: %s\")",
            "qemuDomainAsyncJobTypeToString(priv->job.asyncJob)",
            "_(\"canceled by client\")"
          ],
          "line": 3600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"canceled by client\""
          ],
          "line": 3602
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAsyncJobTypeToString",
          "args": [
            "priv->job.asyncJob"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuProcessStopCPUs",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_PAUSED_MIGRATION",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 3586
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStopCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "3262-3304",
          "snippet": "int qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\""
          ],
          "line": 3578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopy",
          "args": [
            "driver",
            "vm",
            "mig",
            "spec->dest.host.name",
            "migrate_speed",
            "&migrate_flags",
            "nmigrate_disks",
            "migrate_disks",
            "dconn",
            "tlsAlias",
            "flags"
          ],
          "line": 3566
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "994-1077",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuMigrationCookiePtr mig,\n                               const char *host,\n                               unsigned long speed,\n                               unsigned int *migrate_flags,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               virConnectPtr dconn,\n                               const char *tlsAlias,\n                               unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int port;\n    size_t i;\n    unsigned long long mirror_speed = speed;\n    bool mirror_shallow = *migrate_flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n    int rv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    VIR_DEBUG(\"Starting drive mirrors for domain %s\", vm->def->name);\n\n    if (mirror_speed > LLONG_MAX >> 20) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       LLONG_MAX >> 20);\n        return -1;\n    }\n    mirror_speed <<= 20;\n\n    /* steal NBD port and thus prevent its propagation back to destination */\n    port = mig->nbd->port;\n    mig->nbd->port = 0;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (qemuMigrationSrcNBDStorageCopyOne(driver, vm, disk, host, port,\n                                              mirror_speed, mirror_shallow,\n                                              tlsAlias, flags) < 0)\n            return -1;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n            return -1;\n        }\n    }\n\n    while ((rv = qemuMigrationSrcNBDStorageCopyReady(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) != 1) {\n        if (rv < 0)\n            return -1;\n\n        if (priv->job.abortJob) {\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n            virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                           qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                           _(\"canceled by client\"));\n            return -1;\n        }\n\n        if (dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            return -1;\n        }\n\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    qemuMigrationSrcFetchMirrorStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                     priv->job.current);\n\n    /* Okay, all disks are ready. Modify migrate_flags */\n    *migrate_flags &= ~(QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                        QEMU_MONITOR_MIGRATE_NON_SHARED_INC);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuMigrationCookiePtr mig,\n                               const char *host,\n                               unsigned long speed,\n                               unsigned int *migrate_flags,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               virConnectPtr dconn,\n                               const char *tlsAlias,\n                               unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int port;\n    size_t i;\n    unsigned long long mirror_speed = speed;\n    bool mirror_shallow = *migrate_flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n    int rv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    VIR_DEBUG(\"Starting drive mirrors for domain %s\", vm->def->name);\n\n    if (mirror_speed > LLONG_MAX >> 20) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       LLONG_MAX >> 20);\n        return -1;\n    }\n    mirror_speed <<= 20;\n\n    /* steal NBD port and thus prevent its propagation back to destination */\n    port = mig->nbd->port;\n    mig->nbd->port = 0;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (qemuMigrationSrcNBDStorageCopyOne(driver, vm, disk, host, port,\n                                              mirror_speed, mirror_shallow,\n                                              tlsAlias, flags) < 0)\n            return -1;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n            return -1;\n        }\n    }\n\n    while ((rv = qemuMigrationSrcNBDStorageCopyReady(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) != 1) {\n        if (rv < 0)\n            return -1;\n\n        if (priv->job.abortJob) {\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n            virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                           qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                           _(\"canceled by client\"));\n            return -1;\n        }\n\n        if (dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            return -1;\n        }\n\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    qemuMigrationSrcFetchMirrorStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                     priv->job.current);\n\n    /* Okay, all disks are ready. Modify migrate_flags */\n    *migrate_flags &= ~(QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                        QEMU_MONITOR_MIGRATE_NON_SHARED_INC);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"NBD migration with TLS is not supported\")"
          ],
          "line": 3560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV_DEL"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsApply",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "migParams"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "832-905",
          "snippet": "int\nqemuMigrationParamsApply(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool xbzrleCacheSize_old = false;\n    virJSONValuePtr params = NULL;\n    virJSONValuePtr caps = NULL;\n    qemuMigrationParam xbzrle = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE;\n    int ret = -1;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_NONE) {\n        if (!virBitmapIsAllClear(migParams->caps)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Migration capabilities can only be set by \"\n                             \"a migration job\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(caps = qemuMigrationCapsToJSON(priv->migrationCaps, migParams->caps)))\n            goto cleanup;\n\n        if (virJSONValueArraySize(caps) > 0) {\n            rc = qemuMonitorSetMigrationCapabilities(priv->mon, caps);\n            caps = NULL;\n            if (rc < 0)\n                goto cleanup;\n        }\n    }\n\n    /* If QEMU is too old to support xbzrle-cache-size migration parameter,\n     * we need to set it via migrate-set-cache-size and tell\n     * qemuMonitorSetMigrationParams to ignore this parameter.\n     */\n    if (migParams->params[xbzrle].set &&\n        (!priv->job.migParams ||\n         !priv->job.migParams->params[xbzrle].set)) {\n        if (qemuMonitorSetMigrationCacheSize(priv->mon,\n                                             migParams->params[xbzrle].value.ull) < 0)\n            goto cleanup;\n        xbzrleCacheSize_old = true;\n        migParams->params[xbzrle].set = false;\n    }\n\n    if (!(params = qemuMigrationParamsToJSON(migParams)))\n        goto cleanup;\n\n    if (virJSONValueObjectKeysNumber(params) > 0) {\n        rc = qemuMonitorSetMigrationParams(priv->mon, params);\n        params = NULL;\n        if (rc < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (xbzrleCacheSize_old)\n        migParams->params[xbzrle].set = true;\n\n    virJSONValueFree(params);\n    virJSONValueFree(caps);\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nqemuMigrationParamsApply(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool xbzrleCacheSize_old = false;\n    virJSONValuePtr params = NULL;\n    virJSONValuePtr caps = NULL;\n    qemuMigrationParam xbzrle = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE;\n    int ret = -1;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_NONE) {\n        if (!virBitmapIsAllClear(migParams->caps)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Migration capabilities can only be set by \"\n                             \"a migration job\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(caps = qemuMigrationCapsToJSON(priv->migrationCaps, migParams->caps)))\n            goto cleanup;\n\n        if (virJSONValueArraySize(caps) > 0) {\n            rc = qemuMonitorSetMigrationCapabilities(priv->mon, caps);\n            caps = NULL;\n            if (rc < 0)\n                goto cleanup;\n        }\n    }\n\n    /* If QEMU is too old to support xbzrle-cache-size migration parameter,\n     * we need to set it via migrate-set-cache-size and tell\n     * qemuMonitorSetMigrationParams to ignore this parameter.\n     */\n    if (migParams->params[xbzrle].set &&\n        (!priv->job.migParams ||\n         !priv->job.migParams->params[xbzrle].set)) {\n        if (qemuMonitorSetMigrationCacheSize(priv->mon,\n                                             migParams->params[xbzrle].value.ull) < 0)\n            goto cleanup;\n        xbzrleCacheSize_old = true;\n        migParams->params[xbzrle].set = false;\n    }\n\n    if (!(params = qemuMigrationParamsToJSON(migParams)))\n        goto cleanup;\n\n    if (virJSONValueObjectKeysNumber(params) > 0) {\n        rc = qemuMonitorSetMigrationParams(priv->mon, params);\n        params = NULL;\n        if (rc < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (xbzrleCacheSize_old)\n        migParams->params[xbzrle].set = true;\n\n    virJSONValueFree(params);\n    virJSONValueFree(caps);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsDisableTLS",
          "args": [
            "vm",
            "migParams"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsDisableTLS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1038-1054",
          "snippet": "int\nqemuMigrationParamsDisableTLS(virDomainObjPtr vm,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set)\n        return 0;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS, \"\") < 0 ||\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME, \"\") < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nqemuMigrationParamsDisableTLS(virDomainObjPtr vm,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set)\n        return 0;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS, \"\") < 0 ||\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME, \"\") < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsEnableTLS",
          "args": [
            "driver",
            "vm",
            "false",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "&tlsAlias",
            "hostname",
            "migParams"
          ],
          "line": 3537
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsEnableTLS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "948-1025",
          "snippet": "int\nqemuMigrationParamsEnableTLS(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             bool tlsListen,\n                             int asyncJob,\n                             char **tlsAlias,\n                             const char *hostname,\n                             qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virJSONValuePtr tlsProps = NULL;\n    virJSONValuePtr secProps = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *secAlias = NULL;\n    int ret = -1;\n\n    if (!cfg->migrateTLSx509certdir) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"host migration TLS directory not configured\"));\n        goto error;\n    }\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"TLS migration is not supported with this \"\n                         \"QEMU binary\"));\n        goto error;\n    }\n\n    /* If there's a secret, then grab/store it now using the connection */\n    if (cfg->migrateTLSx509secretUUID) {\n        if (!(priv->migSecinfo =\n              qemuDomainSecretInfoTLSNew(priv, QEMU_MIGRATION_TLS_ALIAS_BASE,\n                                         cfg->migrateTLSx509secretUUID)))\n            goto error;\n        secAlias = priv->migSecinfo->s.aes.alias;\n    }\n\n    if (!(*tlsAlias = qemuAliasTLSObjFromSrcAlias(QEMU_MIGRATION_TLS_ALIAS_BASE)))\n        goto error;\n\n    if (qemuDomainGetTLSObjects(priv->qemuCaps, priv->migSecinfo,\n                                cfg->migrateTLSx509certdir, tlsListen,\n                                cfg->migrateTLSx509verify,\n                                *tlsAlias, &tlsProps, &secProps) < 0)\n        goto error;\n\n    /* Ensure the domain doesn't already have the TLS objects defined...\n     * This should prevent any issues just in case some cleanup wasn't\n     * properly completed (both src and dst use the same alias) or\n     * some other error path between now and perform . */\n    qemuDomainDelTLSObjects(driver, vm, asyncJob, secAlias, *tlsAlias);\n\n    if (qemuDomainAddTLSObjects(driver, vm, asyncJob, &secProps, &tlsProps) < 0)\n        goto error;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS,\n                                     *tlsAlias) < 0)\n        goto error;\n\n    if (!migParams->params[QEMU_MIGRATION_PARAM_TLS_HOSTNAME].set &&\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n                                     NULLSTR_EMPTY(hostname)) < 0)\n        goto error;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virJSONValueFree(tlsProps);\n    virJSONValueFree(secProps);\n    goto cleanup;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_MIGRATION_TLS_ALIAS_BASE \"libvirt_migrate\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define QEMU_MIGRATION_TLS_ALIAS_BASE \"libvirt_migrate\"\n\nint\nqemuMigrationParamsEnableTLS(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             bool tlsListen,\n                             int asyncJob,\n                             char **tlsAlias,\n                             const char *hostname,\n                             qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virJSONValuePtr tlsProps = NULL;\n    virJSONValuePtr secProps = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *secAlias = NULL;\n    int ret = -1;\n\n    if (!cfg->migrateTLSx509certdir) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"host migration TLS directory not configured\"));\n        goto error;\n    }\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"TLS migration is not supported with this \"\n                         \"QEMU binary\"));\n        goto error;\n    }\n\n    /* If there's a secret, then grab/store it now using the connection */\n    if (cfg->migrateTLSx509secretUUID) {\n        if (!(priv->migSecinfo =\n              qemuDomainSecretInfoTLSNew(priv, QEMU_MIGRATION_TLS_ALIAS_BASE,\n                                         cfg->migrateTLSx509secretUUID)))\n            goto error;\n        secAlias = priv->migSecinfo->s.aes.alias;\n    }\n\n    if (!(*tlsAlias = qemuAliasTLSObjFromSrcAlias(QEMU_MIGRATION_TLS_ALIAS_BASE)))\n        goto error;\n\n    if (qemuDomainGetTLSObjects(priv->qemuCaps, priv->migSecinfo,\n                                cfg->migrateTLSx509certdir, tlsListen,\n                                cfg->migrateTLSx509verify,\n                                *tlsAlias, &tlsProps, &secProps) < 0)\n        goto error;\n\n    /* Ensure the domain doesn't already have the TLS objects defined...\n     * This should prevent any issues just in case some cleanup wasn't\n     * properly completed (both src and dst use the same alias) or\n     * some other error path between now and perform . */\n    qemuDomainDelTLSObjects(driver, vm, asyncJob, secAlias, *tlsAlias);\n\n    if (qemuDomainAddTLSObjects(driver, vm, asyncJob, &secProps, &tlsProps) < 0)\n        goto error;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS,\n                                     *tlsAlias) < 0)\n        goto error;\n\n    if (!migParams->params[QEMU_MIGRATION_PARAM_TLS_HOSTNAME].set &&\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n                                     NULLSTR_EMPTY(hostname)) < 0)\n        goto error;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virJSONValueFree(tlsProps);\n    virJSONValueFree(secProps);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsCheck",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "migParams",
            "mig->caps->automatic"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1165-1227",
          "snippet": "int\nqemuMigrationParamsCheck(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams,\n                         virBitmapPtr remoteCaps)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCapability cap;\n    qemuMigrationParty party;\n    size_t i;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        party = QEMU_MIGRATION_SOURCE;\n    else\n        party = QEMU_MIGRATION_DESTINATION;\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool state = false;\n\n        ignore_value(virBitmapGetBit(migParams->caps, cap, &state));\n\n        if (state && !qemuMigrationCapsGet(vm, cap)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"Migration option '%s' is not supported by QEMU binary\"),\n                           qemuMigrationCapabilityTypeToString(cap));\n            return -1;\n        }\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        cap = qemuMigrationParamsAlwaysOn[i].cap;\n\n        if (qemuMigrationParamsAlwaysOn[i].party & party &&\n            qemuMigrationCapsGet(vm, cap)) {\n            if (qemuMigrationParamsAlwaysOn[i].party != party) {\n                bool remote = false;\n\n                if (remoteCaps)\n                    ignore_value(virBitmapGetBit(remoteCaps, cap, &remote));\n\n                if (!remote) {\n                    VIR_DEBUG(\"Not enabling migration capability '%s'; it is \"\n                              \"not supported or automatically enabled by the \"\n                              \"other side of migration\",\n                              qemuMigrationCapabilityTypeToString(cap));\n                    continue;\n                }\n            }\n\n            VIR_DEBUG(\"Enabling migration capability '%s'\",\n                      qemuMigrationCapabilityTypeToString(cap));\n            ignore_value(virBitmapSetBit(migParams->caps, cap));\n        }\n    }\n\n    /*\n     * We want to disable all migration capabilities after migration, no need\n     * to ask QEMU for their current settings.\n     */\n\n    return qemuMigrationParamsFetch(driver, vm, asyncJob, &priv->job.migParams);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};\n\nint\nqemuMigrationParamsCheck(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams,\n                         virBitmapPtr remoteCaps)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCapability cap;\n    qemuMigrationParty party;\n    size_t i;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        party = QEMU_MIGRATION_SOURCE;\n    else\n        party = QEMU_MIGRATION_DESTINATION;\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool state = false;\n\n        ignore_value(virBitmapGetBit(migParams->caps, cap, &state));\n\n        if (state && !qemuMigrationCapsGet(vm, cap)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"Migration option '%s' is not supported by QEMU binary\"),\n                           qemuMigrationCapabilityTypeToString(cap));\n            return -1;\n        }\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        cap = qemuMigrationParamsAlwaysOn[i].cap;\n\n        if (qemuMigrationParamsAlwaysOn[i].party & party &&\n            qemuMigrationCapsGet(vm, cap)) {\n            if (qemuMigrationParamsAlwaysOn[i].party != party) {\n                bool remote = false;\n\n                if (remoteCaps)\n                    ignore_value(virBitmapGetBit(remoteCaps, cap, &remote));\n\n                if (!remote) {\n                    VIR_DEBUG(\"Not enabling migration capability '%s'; it is \"\n                              \"not supported or automatically enabled by the \"\n                              \"other side of migration\",\n                              qemuMigrationCapabilityTypeToString(cap));\n                    continue;\n                }\n            }\n\n            VIR_DEBUG(\"Enabling migration capability '%s'\",\n                      qemuMigrationCapabilityTypeToString(cap));\n            ignore_value(virBitmapSetBit(migParams->caps, cap));\n        }\n    }\n\n    /*\n     * We want to disable all migration capabilities after migration, no need\n     * to ask QEMU for their current settings.\n     */\n\n    return qemuMigrationParamsFetch(driver, vm, asyncJob, &priv->job.migParams);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unable to provide data for graphics client relocation\""
          ],
          "line": 3522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcGraphicsRelocate",
          "args": [
            "driver",
            "vm",
            "mig",
            "graphicsuri"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcGraphicsRelocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1772-1868",
          "snippet": "static int\nqemuMigrationSrcGraphicsRelocate(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuMigrationCookiePtr cookie,\n                                 const char *graphicsuri)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    const char *listenAddress = NULL;\n    virSocketAddr addr;\n    virURIPtr uri = NULL;\n    int type = -1;\n    int port = -1;\n    int tlsPort = -1;\n    const char *tlsSubject = NULL;\n\n    if (!cookie || (!cookie->graphics && !graphicsuri))\n        return 0;\n\n    if (graphicsuri && !(uri = virURIParse(graphicsuri)))\n        goto cleanup;\n\n    if (cookie->graphics) {\n        type = cookie->graphics->type;\n\n        listenAddress = cookie->graphics->listen;\n\n        if (!listenAddress ||\n            (virSocketAddrParse(&addr, listenAddress, AF_UNSPEC) > 0 &&\n             virSocketAddrIsWildcard(&addr)))\n            listenAddress = cookie->remoteHostname;\n\n        port = cookie->graphics->port;\n        tlsPort = cookie->graphics->tlsPort;\n        tlsSubject = cookie->graphics->tlsSubject;\n    }\n\n    if (uri) {\n        size_t i;\n\n        if ((type = virDomainGraphicsTypeFromString(uri->scheme)) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unknown graphics type %s\"), uri->scheme);\n            goto cleanup;\n        }\n\n        if (uri->server)\n            listenAddress = uri->server;\n        if (uri->port > 0)\n            port = uri->port;\n\n        for (i = 0; i < uri->paramsCount; i++) {\n            virURIParamPtr param = uri->params + i;\n\n            if (STRCASEEQ(param->name, \"tlsPort\")) {\n                if (virStrToLong_i(param->value, NULL, 10, &tlsPort) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"invalid tlsPort number: %s\"),\n                                   param->value);\n                    goto cleanup;\n                }\n            } else if (STRCASEEQ(param->name, \"tlsSubject\")) {\n                tlsSubject = param->value;\n            }\n        }\n    }\n\n    /* QEMU doesn't support VNC relocation yet, so\n     * skip it to avoid generating an error\n     */\n    if (type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Older libvirt sends port == 0 for listen type='none' graphics. It's\n     * safe to ignore such requests since relocation to unknown port does\n     * not make sense in general.\n     */\n    if (port <= 0 && tlsPort <= 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n        ret = qemuMonitorGraphicsRelocate(priv->mon, type, listenAddress,\n                                          port, tlsPort, tlsSubject);\n        priv->job.spiceMigration = !ret;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            ret = -1;\n    }\n\n cleanup:\n    virURIFree(uri);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcGraphicsRelocate(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuMigrationCookiePtr cookie,\n                                 const char *graphicsuri)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    const char *listenAddress = NULL;\n    virSocketAddr addr;\n    virURIPtr uri = NULL;\n    int type = -1;\n    int port = -1;\n    int tlsPort = -1;\n    const char *tlsSubject = NULL;\n\n    if (!cookie || (!cookie->graphics && !graphicsuri))\n        return 0;\n\n    if (graphicsuri && !(uri = virURIParse(graphicsuri)))\n        goto cleanup;\n\n    if (cookie->graphics) {\n        type = cookie->graphics->type;\n\n        listenAddress = cookie->graphics->listen;\n\n        if (!listenAddress ||\n            (virSocketAddrParse(&addr, listenAddress, AF_UNSPEC) > 0 &&\n             virSocketAddrIsWildcard(&addr)))\n            listenAddress = cookie->remoteHostname;\n\n        port = cookie->graphics->port;\n        tlsPort = cookie->graphics->tlsPort;\n        tlsSubject = cookie->graphics->tlsSubject;\n    }\n\n    if (uri) {\n        size_t i;\n\n        if ((type = virDomainGraphicsTypeFromString(uri->scheme)) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unknown graphics type %s\"), uri->scheme);\n            goto cleanup;\n        }\n\n        if (uri->server)\n            listenAddress = uri->server;\n        if (uri->port > 0)\n            port = uri->port;\n\n        for (i = 0; i < uri->paramsCount; i++) {\n            virURIParamPtr param = uri->params + i;\n\n            if (STRCASEEQ(param->name, \"tlsPort\")) {\n                if (virStrToLong_i(param->value, NULL, 10, &tlsPort) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"invalid tlsPort number: %s\"),\n                                   param->value);\n                    goto cleanup;\n                }\n            } else if (STRCASEEQ(param->name, \"tlsSubject\")) {\n                tlsSubject = param->value;\n            }\n        }\n    }\n\n    /* QEMU doesn't support VNC relocation yet, so\n     * skip it to avoid generating an error\n     */\n    if (type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Older libvirt sends port == 0 for listen type='none' graphics. It's\n     * safe to ignore such requests since relocation to unknown port does\n     * not make sense in general.\n     */\n    if (port <= 0 && tlsPort <= 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n        ret = qemuMonitorGraphicsRelocate(priv->mon, type, listenAddress,\n                                          port, tlsPort, tlsSubject);\n        priv->job.spiceMigration = !ret;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            ret = -1;\n    }\n\n cleanup:\n    virURIFree(uri);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationEatCookie",
          "args": [
            "driver",
            "vm->def",
            "priv->origname",
            "priv",
            "cookiein",
            "cookieinlen",
            "cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS"
          ],
          "line": 3513
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1462-1527",
          "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDefCopy",
          "args": [
            "driver",
            "priv->qemuCaps",
            "def",
            "VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE"
          ],
          "line": 3506
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10308-10323",
          "snippet": "virDomainDefPtr\nqemuDomainDefCopy(virQEMUDriverPtr driver,\n                  virQEMUCapsPtr qemuCaps,\n                  virDomainDefPtr src,\n                  unsigned int flags)\n{\n    virDomainDefPtr ret = NULL;\n    g_autofree char *xml = NULL;\n\n    if (!(xml = qemuDomainDefFormatXML(driver, qemuCaps, src, flags)))\n        return NULL;\n\n    ret = qemuDomainDefFromXML(driver, qemuCaps, xml);\n\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvirDomainDefPtr\nqemuDomainDefCopy(virQEMUDriverPtr driver,\n                  virQEMUCapsPtr qemuCaps,\n                  virDomainDefPtr src,\n                  unsigned int flags)\n{\n    virDomainDefPtr ret = NULL;\n    g_autofree char *xml = NULL;\n\n    if (!(xml = qemuDomainDefFormatXML(driver, qemuCaps, src, flags)))\n        return NULL;\n\n    ret = qemuDomainDefFromXML(driver, qemuCaps, xml);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyPrepareDef",
          "args": [
            "driver",
            "priv->qemuCaps",
            "persist_xml",
            "NULL",
            "NULL"
          ],
          "line": 3499
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyPrepareDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2946-2979",
          "snippet": "virDomainDefPtr\nqemuMigrationAnyPrepareDef(virQEMUDriverPtr driver,\n                           virQEMUCapsPtr qemuCaps,\n                           const char *dom_xml,\n                           const char *dname,\n                           char **origname)\n{\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        qemuCaps,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    if (def && origname)\n        *origname = name;\n    else\n        VIR_FREE(name);\n    return def;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvirDomainDefPtr\nqemuMigrationAnyPrepareDef(virQEMUDriverPtr driver,\n                           virQEMUCapsPtr qemuCaps,\n                           const char *dom_xml,\n                           const char *dname,\n                           char **origname)\n{\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        qemuCaps,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    if (def && origname)\n        *origname = name;\n    else\n        VIR_FREE(name);\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Migration with lock driver %s requires\"\n                         \" cookie support\")",
            "virLockManagerPluginGetName(driver->lockManager)"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virLockManagerPluginGetName",
          "args": [
            "driver->lockManager"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerPluginGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_manager.c",
          "lines": "259-264",
          "snippet": "const char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "# include <dlfcn.h>",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lock_driver_nop.h\"",
            "#include \"lock_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <unistd.h>\n# include <dlfcn.h>\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lock_driver_nop.h\"\n#include \"lock_manager.h\"\n#include <config.h>\n\nconst char *virLockManagerPluginGetName(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLockManagerPluginUsesState",
          "args": [
            "driver->lockManager"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "virLockManagerPluginUsesState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/lock_manager.c",
          "lines": "267-272",
          "snippet": "bool virLockManagerPluginUsesState(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->driver->flags & VIR_LOCK_MANAGER_USES_STATE;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "# include <dlfcn.h>",
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"lock_driver_nop.h\"",
            "#include \"lock_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include <unistd.h>\n# include <dlfcn.h>\n#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"lock_driver_nop.h\"\n#include \"lock_manager.h\"\n#include <config.h>\n\nbool virLockManagerPluginUsesState(virLockManagerPluginPtr plugin)\n{\n    VIR_DEBUG(\"plugin=%p\", plugin);\n\n    return plugin->driver->flags & VIR_LOCK_MANAGER_USES_STATE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\"",
            "driver",
            "vm",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "flags",
            "resource",
            "spec",
            "spec->destType",
            "spec->fwdType",
            "dconn",
            "NULLSTR(graphicsuri)",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "graphicsuri"
          ],
          "line": 3473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 3470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *persist_xml,\n                    const char *cookiein,\n                    int cookieinlen,\n                    char **cookieout,\n                    int *cookieoutlen,\n                    unsigned long flags,\n                    unsigned long resource,\n                    qemuMigrationSpecPtr spec,\n                    virConnectPtr dconn,\n                    const char *graphicsuri,\n                    size_t nmigrate_disks,\n                    const char **migrate_disks,\n                    qemuMigrationParamsPtr migParams)\n{\n    int ret = -1;\n    unsigned int migrate_flags = QEMU_MONITOR_MIGRATE_BACKGROUND;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCookiePtr mig = NULL;\n    char *tlsAlias = NULL;\n    qemuMigrationIOThreadPtr iothread = NULL;\n    int fd = -1;\n    unsigned long migrate_speed = resource ? resource : priv->migMaxBandwidth;\n    virErrorPtr orig_err = NULL;\n    unsigned int cookieFlags = 0;\n    bool abort_on_error = !!(flags & VIR_MIGRATE_ABORT_ON_ERROR);\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    bool cancel = false;\n    unsigned int waitFlags;\n    virDomainDefPtr persistDef = NULL;\n    char *timestamp;\n    int rc;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, flags=0x%lx, resource=%lu, \"\n              \"spec=%p (dest=%d, fwd=%d), dconn=%p, graphicsuri=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, flags, resource,\n              spec, spec->destType, spec->fwdType, dconn,\n              NULLSTR(graphicsuri), nmigrate_disks, migrate_disks);\n\n    if (flags & VIR_MIGRATE_NON_SHARED_DISK) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_DISK;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (flags & VIR_MIGRATE_NON_SHARED_INC) {\n        migrate_flags |= QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (virLockManagerPluginUsesState(driver->lockManager) &&\n        !cookieout) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Migration with lock driver %s requires\"\n                         \" cookie support\"),\n                       virLockManagerPluginGetName(driver->lockManager));\n        return -1;\n    }\n\n    if (events)\n        priv->signalIOError = abort_on_error;\n\n    if (flags & VIR_MIGRATE_PERSIST_DEST) {\n        if (persist_xml) {\n            if (!(persistDef = qemuMigrationAnyPrepareDef(driver,\n                                                          priv->qemuCaps,\n                                                          persist_xml,\n                                                          NULL, NULL)))\n                goto error;\n        } else {\n            virDomainDefPtr def = vm->newDef ? vm->newDef : vm->def;\n            if (!(persistDef = qemuDomainDefCopy(driver, priv->qemuCaps, def,\n                                                 VIR_DOMAIN_XML_SECURE |\n                                                 VIR_DOMAIN_XML_MIGRATABLE)))\n                goto error;\n        }\n    }\n\n    mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                 cookiein, cookieinlen,\n                                 cookieFlags |\n                                 QEMU_MIGRATION_COOKIE_GRAPHICS |\n                                 QEMU_MIGRATION_COOKIE_CAPS);\n    if (!mig)\n        goto error;\n\n    if (qemuMigrationSrcGraphicsRelocate(driver, vm, mig, graphicsuri) < 0)\n        VIR_WARN(\"unable to provide data for graphics client relocation\");\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams, mig->caps->automatic) < 0)\n        goto error;\n\n    if (flags & VIR_MIGRATE_TLS) {\n        const char *hostname = NULL;\n\n        /* We need to add tls-hostname whenever QEMU itself does not\n         * connect directly to the destination. */\n        if (spec->destType == MIGRATION_DEST_CONNECT_HOST ||\n            spec->destType == MIGRATION_DEST_FD)\n            hostname = spec->dest.host.name;\n\n        if (qemuMigrationParamsEnableTLS(driver, vm, false,\n                                         QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                         &tlsAlias, hostname,\n                                         migParams) < 0)\n            goto error;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto error;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 migParams) < 0)\n        goto error;\n\n    if (migrate_flags & (QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                         QEMU_MONITOR_MIGRATE_NON_SHARED_INC)) {\n        if (mig->nbd) {\n            /* Currently libvirt does not support setting up of the NBD\n             * non-shared storage migration with TLS. As we need to honour the\n             * VIR_MIGRATE_TLS flag, we need to reject such migration until\n             * we implement TLS for NBD. */\n            if (flags & VIR_MIGRATE_TLS &&\n                !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_DEL)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"NBD migration with TLS is not supported\"));\n                goto error;\n            }\n\n            /* This will update migrate_flags on success */\n            if (qemuMigrationSrcNBDStorageCopy(driver, vm, mig,\n                                               spec->dest.host.name,\n                                               migrate_speed,\n                                               &migrate_flags,\n                                               nmigrate_disks,\n                                               migrate_disks,\n                                               dconn, tlsAlias, flags) < 0) {\n                goto error;\n            }\n        } else {\n            /* Destination doesn't support NBD server.\n             * Fall back to previous implementation. */\n            VIR_DEBUG(\"Destination doesn't support NBD server \"\n                      \"Falling back to previous implementation.\");\n        }\n    }\n\n    /* Before EnterMonitor, since already qemuProcessStopCPUs does that */\n    if (!(flags & VIR_MIGRATE_LIVE) &&\n        virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm, VIR_DOMAIN_PAUSED_MIGRATION,\n                                QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        goto error;\n\n    if (priv->job.abortJob) {\n        /* explicitly do this *after* we entered the monitor,\n         * as this is a critical section so we are guaranteed\n         * priv->job.abortJob will not change */\n        priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                       _(\"canceled by client\"));\n        goto exit_monitor;\n    }\n\n    if (qemuMonitorSetMigrationSpeed(priv->mon, migrate_speed) < 0)\n        goto exit_monitor;\n\n    /* connect to the destination qemu if needed */\n    if (spec->destType == MIGRATION_DEST_CONNECT_HOST &&\n        qemuMigrationSrcConnect(driver, vm, spec) < 0) {\n        goto exit_monitor;\n    }\n\n    /* log start of migration */\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: initiating migration\\n\", timestamp);\n        VIR_FREE(timestamp);\n    }\n\n    rc = -1;\n    switch (spec->destType) {\n    case MIGRATION_DEST_HOST:\n        if (STREQ(spec->dest.host.protocol, \"rdma\") &&\n            virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n            goto exit_monitor;\n        }\n        rc = qemuMonitorMigrateToHost(priv->mon, migrate_flags,\n                                      spec->dest.host.protocol,\n                                      spec->dest.host.name,\n                                      spec->dest.host.port);\n        break;\n\n    case MIGRATION_DEST_CONNECT_HOST:\n        /* handled above and transformed into MIGRATION_DEST_FD */\n        break;\n\n    case MIGRATION_DEST_FD:\n        if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n            fd = spec->dest.fd.local;\n            spec->dest.fd.local = -1;\n        }\n        rc = qemuMonitorMigrateToFd(priv->mon, migrate_flags,\n                                    spec->dest.fd.qemu);\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n        break;\n    }\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto error;\n\n    /* From this point onwards we *must* call cancel to abort the\n     * migration on source if anything goes wrong */\n    cancel = true;\n\n    if (spec->fwdType != MIGRATION_FWD_DIRECT) {\n        if (!(iothread = qemuMigrationSrcStartTunnel(spec->fwd.stream, fd)))\n            goto error;\n        /* If we've created a tunnel, then the 'fd' will be closed in the\n         * qemuMigrationIOFunc as data->sock.\n         */\n        fd = -1;\n    }\n\n    waitFlags = QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n    if (abort_on_error)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR;\n    if (mig->nbd)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_CHECK_STORAGE;\n    if (flags & VIR_MIGRATE_POSTCOPY)\n        waitFlags |= QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                           dconn, waitFlags);\n    if (rc == -2) {\n        goto error;\n    } else if (rc == -1) {\n        /* QEMU reported failed migration, nothing to cancel anymore */\n        cancel = false;\n        goto error;\n    }\n\n    /* When migration completed, QEMU will have paused the CPUs for us.\n     * Wait for the STOP event to be processed to release the lock state.\n     */\n    while (virDomainObjGetState(vm, NULL) == VIR_DOMAIN_RUNNING) {\n        priv->signalStop = true;\n        rc = virDomainObjWait(vm);\n        priv->signalStop = false;\n        if (rc < 0)\n            goto error;\n    }\n\n    if (mig->nbd &&\n        qemuMigrationSrcNBDCopyCancel(driver, vm, true,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                      dconn) < 0)\n        goto error;\n\n    /* When migration was paused before serializing device state we need to\n     * resume it now once we finished all block jobs and wait for the real\n     * end of the migration.\n     */\n    if (priv->job.current->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        if (qemuMigrationSrcContinue(driver, vm,\n                                     QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER,\n                                     QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n            goto error;\n\n        waitFlags ^= QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER;\n\n        rc = qemuMigrationSrcWaitForCompletion(driver, vm,\n                                               QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                               dconn, waitFlags);\n        if (rc == -2) {\n            goto error;\n        } else if (rc == -1) {\n            /* QEMU reported failed migration, nothing to cancel anymore */\n            cancel = false;\n            goto error;\n        }\n    }\n\n    if (iothread) {\n        qemuMigrationIOThreadPtr io;\n\n        io = g_steal_pointer(&iothread);\n        if (qemuMigrationSrcStopTunnel(io, false) < 0)\n            goto error;\n    }\n\n    if (priv->job.completed) {\n        priv->job.completed->stopped = priv->job.current->stopped;\n        qemuDomainJobInfoUpdateTime(priv->job.completed);\n        qemuDomainJobInfoUpdateDowntime(priv->job.completed);\n        ignore_value(virTimeMillisNow(&priv->job.completed->sent));\n    }\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_NETWORK |\n                   QEMU_MIGRATION_COOKIE_STATS;\n\n    if (qemuMigrationCookieAddPersistent(mig, &persistDef) < 0 ||\n        qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(tlsAlias);\n    VIR_FORCE_CLOSE(fd);\n    virDomainDefFree(persistDef);\n    qemuMigrationCookieFree(mig);\n\n    if (events)\n        priv->signalIOError = false;\n\n    virErrorRestore(&orig_err);\n\n    return ret;\n\n error:\n    virErrorPreserveLast(&orig_err);\n\n    if (virDomainObjIsActive(vm)) {\n        if (cancel &&\n            priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED &&\n            qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n            qemuMonitorMigrateCancel(priv->mon);\n            ignore_value(qemuDomainObjExitMonitor(driver, vm));\n        }\n\n        /* cancel any outstanding NBD jobs */\n        if (mig && mig->nbd)\n            qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                          QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                          dconn);\n\n        if (priv->job.current->status != QEMU_DOMAIN_JOB_STATUS_CANCELED)\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n    }\n\n    if (iothread)\n        qemuMigrationSrcStopTunnel(iothread, true);\n\n    goto cleanup;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto error;\n}"
  },
  {
    "function_name": "qemuMigrationSrcContinue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3410-3428",
    "snippet": "static int\nqemuMigrationSrcContinue(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMonitorMigrationStatus status,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorMigrateContinue(priv->mon, status);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3424
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateContinue",
          "args": [
            "priv->mon",
            "status"
          ],
          "line": 3422
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4180-4189",
          "snippet": "int\nqemuMonitorMigrateContinue(qemuMonitorPtr mon,\n                           qemuMonitorMigrationStatus status)\n{\n    VIR_DEBUG(\"status=%s\", qemuMonitorMigrationStatusTypeToString(status));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateContinue(mon, status);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateContinue(qemuMonitorPtr mon,\n                           qemuMonitorMigrationStatus status)\n{\n    VIR_DEBUG(\"status=%s\", qemuMonitorMigrationStatusTypeToString(status));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateContinue(mon, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcContinue(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMonitorMigrationStatus status,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorMigrateContinue(priv->mon, status);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3365-3407",
    "snippet": "static int\nqemuMigrationSrcConnect(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationSpecPtr spec)\n{\n    virNetSocketPtr sock;\n    const char *host;\n    char *port = NULL;\n    int ret = -1;\n\n    host = spec->dest.host.name;\n    port = g_strdup_printf(\"%d\", spec->dest.host.port);\n\n    spec->destType = MIGRATION_DEST_FD;\n    spec->dest.fd.qemu = -1;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    if (virNetSocketNewConnectTCP(host, port,\n                                  AF_UNSPEC,\n                                  &sock) == 0) {\n        spec->dest.fd.qemu = virNetSocketDupFD(sock, true);\n        virObjectUnref(sock);\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0 ||\n        spec->dest.fd.qemu == -1)\n        goto cleanup;\n\n    /* Migration expects a blocking FD */\n    if (virSetBlocking(spec->dest.fd.qemu, true) < 0) {\n        virReportSystemError(errno, _(\"Unable to set FD %d blocking\"),\n                             spec->dest.fd.qemu);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(port);\n    if (ret < 0)\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "spec->dest.fd.qemu"
          ],
          "line": 3405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "port"
          ],
          "line": 3403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Unable to set FD %d blocking\")",
            "spec->dest.fd.qemu"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to set FD %d blocking\""
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetBlocking",
          "args": [
            "spec->dest.fd.qemu",
            "true"
          ],
          "line": 3394
        },
        "resolved": true,
        "details": {
          "function_name": "virSetBlocking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "113-121",
          "snippet": "int virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint virSetBlocking(int fd, bool blocking)\n{\n    unsigned long arg = blocking ? 0 : 1;\n\n    if (ioctlsocket(fd, FIONBIO, &arg) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecurityClearSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 3389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "sock"
          ],
          "line": 3387
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketDupFD",
          "args": [
            "sock",
            "true"
          ],
          "line": 3386
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketDupFD",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "1386-1412",
          "snippet": "int virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketDupFD(virNetSocketPtr sock, bool cloexec)\n{\n    int fd;\n\n#ifdef F_DUPFD_CLOEXEC\n    if (cloexec)\n        fd = fcntl(sock->fd, F_DUPFD_CLOEXEC, 0);\n    else\n#endif /* F_DUPFD_CLOEXEC */\n        fd = dup(sock->fd);\n    if (fd < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to copy socket file handle\"));\n        return -1;\n    }\n#ifndef F_DUPFD_CLOEXEC\n    if (cloexec &&\n        virSetCloseExec(fd < 0)) {\n        int saveerr = errno;\n        closesocket(fd);\n        errno = saveerr;\n        return -1;\n    }\n#endif /* F_DUPFD_CLOEXEC */\n\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetSocketNewConnectTCP",
          "args": [
            "host",
            "port",
            "AF_UNSPEC",
            "&sock"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "virNetSocketNewConnectTCP",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetsocket.c",
          "lines": "558-640",
          "snippet": "int virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}",
          "includes": [
            "# include \"virnetlibsshsession.h\"",
            "# include \"virnetsshsession.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virprobe.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virutil.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virsocket.h\"",
            "# include <selinux/selinux.h>",
            "# include <sys/ucred.h>",
            "# include <ifaddrs.h>",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virnetlibsshsession.h\"\n# include \"virnetsshsession.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virprobe.h\"\n#include \"virpidfile.h\"\n#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virutil.h\"\n#include \"virnetsocket.h\"\n#include \"virsocket.h\"\n# include <selinux/selinux.h>\n# include <sys/ucred.h>\n# include <ifaddrs.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint virNetSocketNewConnectTCP(const char *nodename,\n                              const char *service,\n                              int family,\n                              virNetSocketPtr *retsock)\n{\n    struct addrinfo *ai = NULL;\n    struct addrinfo hints;\n    int fd = -1;\n    virSocketAddr localAddr;\n    virSocketAddr remoteAddr;\n    struct addrinfo *runp;\n    int savedErrno = ENOENT;\n\n    *retsock = NULL;\n\n    memset(&localAddr, 0, sizeof(localAddr));\n    memset(&remoteAddr, 0, sizeof(remoteAddr));\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_V4MAPPED;\n    hints.ai_socktype = SOCK_STREAM;\n\n    int e = getaddrinfo(nodename, service, &hints, &ai);\n    if (e != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Unable to resolve address '%s' service '%s': %s\"),\n                       nodename, service, gai_strerror(e));\n        return -1;\n    }\n\n    runp = ai;\n    while (runp) {\n        if ((fd = socket(runp->ai_family, runp->ai_socktype,\n                         runp->ai_protocol)) < 0) {\n            virReportSystemError(errno, \"%s\", _(\"Unable to create socket\"));\n            goto error;\n        }\n\n        if (virSetSockReuseAddr(fd, false) < 0)\n            VIR_WARN(\"Unable to enable port reuse\");\n\n        if (connect(fd, runp->ai_addr, runp->ai_addrlen) >= 0)\n            break;\n\n        savedErrno = errno;\n        closesocket(fd);\n        fd = -1;\n        runp = runp->ai_next;\n    }\n\n    if (fd == -1) {\n        virReportSystemError(savedErrno,\n                             _(\"unable to connect to server at '%s:%s'\"),\n                             nodename, service);\n        goto error;\n    }\n\n    localAddr.len = sizeof(localAddr.data);\n    if (getsockname(fd, &localAddr.data.sa, &localAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get local socket name\"));\n        goto error;\n    }\n\n    remoteAddr.len = sizeof(remoteAddr.data);\n    if (getpeername(fd, &remoteAddr.data.sa, &remoteAddr.len) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"Unable to get remote socket name\"));\n        goto error;\n    }\n\n    if (!(*retsock = virNetSocketNew(&localAddr, &remoteAddr, true, fd, -1, 0, false)))\n        goto error;\n\n    freeaddrinfo(ai);\n\n    return 0;\n\n error:\n    freeaddrinfo(ai);\n    if (fd != -1)\n        closesocket(fd);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSecuritySetSocketLabel",
          "args": [
            "driver->securityManager",
            "vm->def"
          ],
          "line": 3381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%d\"",
            "spec->dest.host.port"
          ],
          "line": 3376
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcConnect(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuMigrationSpecPtr spec)\n{\n    virNetSocketPtr sock;\n    const char *host;\n    char *port = NULL;\n    int ret = -1;\n\n    host = spec->dest.host.name;\n    port = g_strdup_printf(\"%d\", spec->dest.host.port);\n\n    spec->destType = MIGRATION_DEST_FD;\n    spec->dest.fd.qemu = -1;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto cleanup;\n    if (virNetSocketNewConnectTCP(host, port,\n                                  AF_UNSPEC,\n                                  &sock) == 0) {\n        spec->dest.fd.qemu = virNetSocketDupFD(sock, true);\n        virObjectUnref(sock);\n    }\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0 ||\n        spec->dest.fd.qemu == -1)\n        goto cleanup;\n\n    /* Migration expects a blocking FD */\n    if (virSetBlocking(spec->dest.fd.qemu, true) < 0) {\n        virReportSystemError(errno, _(\"Unable to set FD %d blocking\"),\n                             spec->dest.fd.qemu);\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(port);\n    if (ret < 0)\n        VIR_FORCE_CLOSE(spec->dest.fd.qemu);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcStopTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3331-3363",
    "snippet": "static int\nqemuMigrationSrcStopTunnel(qemuMigrationIOThreadPtr io, bool error)\n{\n    int rv = -1;\n    char stop = error ? 1 : 0;\n\n    /* make sure the thread finishes its job and is joinable */\n    if (safewrite(io->wakeupSendFD, &stop, 1) != 1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wakeup migration tunnel\"));\n        goto cleanup;\n    }\n\n    virThreadJoin(&io->thread);\n\n    /* Forward error from the IO thread, to this thread */\n    if (io->err.code != VIR_ERR_OK) {\n        if (error)\n            rv = 0;\n        else\n            virSetError(&io->err);\n        virResetError(&io->err);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(io->wakeupSendFD);\n    VIR_FORCE_CLOSE(io->wakeupRecvFD);\n    VIR_FREE(io);\n    return rv;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "io"
          ],
          "line": 3361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "io->wakeupRecvFD"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "io->wakeupSendFD"
          ],
          "line": 3359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetError",
          "args": [
            "&io->err"
          ],
          "line": 3352
        },
        "resolved": true,
        "details": {
          "function_name": "virResetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "466-476",
          "snippet": "void\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSetError",
          "args": [
            "&io->err"
          ],
          "line": 3351
        },
        "resolved": true,
        "details": {
          "function_name": "virSetErrorLogPriorityFunc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1391-1394",
          "snippet": "void virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvirErrorLogPriorityFunc virErrorLogPriorityFilter = NULL;\n\nvoid virSetErrorLogPriorityFunc(virErrorLogPriorityFunc func)\n{\n    virErrorLogPriorityFilter = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadJoin",
          "args": [
            "&io->thread"
          ],
          "line": 3344
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadJoin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "326-329",
          "snippet": "void virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nvoid virThreadJoin(virThreadPtr thread)\n{\n    pthread_join(thread->thread, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to wakeup migration tunnel\")"
          ],
          "line": 3339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"failed to wakeup migration tunnel\""
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "io->wakeupSendFD",
            "&stop",
            "1"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcStopTunnel(qemuMigrationIOThreadPtr io, bool error)\n{\n    int rv = -1;\n    char stop = error ? 1 : 0;\n\n    /* make sure the thread finishes its job and is joinable */\n    if (safewrite(io->wakeupSendFD, &stop, 1) != 1) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wakeup migration tunnel\"));\n        goto cleanup;\n    }\n\n    virThreadJoin(&io->thread);\n\n    /* Forward error from the IO thread, to this thread */\n    if (io->err.code != VIR_ERR_OK) {\n        if (error)\n            rv = 0;\n        else\n            virSetError(&io->err);\n        virResetError(&io->err);\n        goto cleanup;\n    }\n\n    rv = 0;\n\n cleanup:\n    VIR_FORCE_CLOSE(io->wakeupSendFD);\n    VIR_FORCE_CLOSE(io->wakeupRecvFD);\n    VIR_FREE(io);\n    return rv;\n}"
  },
  {
    "function_name": "qemuMigrationSrcStartTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3294-3329",
    "snippet": "static qemuMigrationIOThreadPtr\nqemuMigrationSrcStartTunnel(virStreamPtr st,\n                            int sock)\n{\n    qemuMigrationIOThreadPtr io = NULL;\n    int wakeupFD[2] = { -1, -1 };\n\n    if (virPipe(wakeupFD) < 0)\n        goto error;\n\n    if (VIR_ALLOC(io) < 0)\n        goto error;\n\n    io->st = st;\n    io->sock = sock;\n    io->wakeupRecvFD = wakeupFD[0];\n    io->wakeupSendFD = wakeupFD[1];\n\n    if (virThreadCreateFull(&io->thread, true,\n                            qemuMigrationSrcIOFunc,\n                            \"qemu-mig-tunnel\",\n                            false,\n                            io) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create migration thread\"));\n        goto error;\n    }\n\n    return io;\n\n error:\n    VIR_FORCE_CLOSE(wakeupFD[0]);\n    VIR_FORCE_CLOSE(wakeupFD[1]);\n    VIR_FREE(io);\n    return NULL;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "io"
          ],
          "line": 3327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "wakeupFD[1]"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "wakeupFD[0]"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"Unable to create migration thread\")"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to create migration thread\""
          ],
          "line": 3318
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virThreadCreateFull",
          "args": [
            "&io->thread",
            "true",
            "qemuMigrationSrcIOFunc",
            "\"qemu-mig-tunnel\"",
            "false",
            "io"
          ],
          "line": 3312
        },
        "resolved": true,
        "details": {
          "function_name": "virThreadCreateFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "242-283",
          "snippet": "int virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virThreadCreateFull(virThreadPtr thread,\n                        bool joinable,\n                        virThreadFunc func,\n                        const char *name,\n                        bool worker,\n                        void *opaque)\n{\n    struct virThreadArgs *args;\n    pthread_attr_t attr;\n    int ret = -1;\n    int err;\n\n    if ((err = pthread_attr_init(&attr)) != 0)\n        goto cleanup;\n    if (VIR_ALLOC_QUIET(args) < 0) {\n        err = ENOMEM;\n        goto cleanup;\n    }\n\n    args->func = func;\n    args->name = g_strdup(name);\n    args->worker = worker;\n    args->opaque = opaque;\n\n    if (!joinable)\n        pthread_attr_setdetachstate(&attr, 1);\n\n    err = pthread_create(&thread->thread, &attr, virThreadHelper, args);\n    if (err != 0) {\n        g_free(args->name);\n        g_free(args);\n        goto cleanup;\n    }\n    /* New thread owns 'args' in success case, so don't free */\n\n    ret = 0;\n cleanup:\n    pthread_attr_destroy(&attr);\n    if (ret < 0)\n        errno = err;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "io"
          ],
          "line": 3304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "wakeupFD"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic qemuMigrationIOThreadPtr\nqemuMigrationSrcStartTunnel(virStreamPtr st,\n                            int sock)\n{\n    qemuMigrationIOThreadPtr io = NULL;\n    int wakeupFD[2] = { -1, -1 };\n\n    if (virPipe(wakeupFD) < 0)\n        goto error;\n\n    if (VIR_ALLOC(io) < 0)\n        goto error;\n\n    io->st = st;\n    io->sock = sock;\n    io->wakeupRecvFD = wakeupFD[0];\n    io->wakeupSendFD = wakeupFD[1];\n\n    if (virThreadCreateFull(&io->thread, true,\n                            qemuMigrationSrcIOFunc,\n                            \"qemu-mig-tunnel\",\n                            false,\n                            io) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to create migration thread\"));\n        goto error;\n    }\n\n    return io;\n\n error:\n    VIR_FORCE_CLOSE(wakeupFD[0]);\n    VIR_FORCE_CLOSE(wakeupFD[1]);\n    VIR_FREE(io);\n    return NULL;\n}"
  },
  {
    "function_name": "qemuMigrationSrcIOFunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3188-3291",
    "snippet": "static void qemuMigrationSrcIOFunc(void *arg)\n{\n    qemuMigrationIOThreadPtr data = arg;\n    char *buffer = NULL;\n    struct pollfd fds[2];\n    int timeout = -1;\n    virErrorPtr err = NULL;\n\n    VIR_DEBUG(\"Running migration tunnel; stream=%p, sock=%d\",\n              data->st, data->sock);\n\n    if (VIR_ALLOC_N(buffer, TUNNEL_SEND_BUF_SIZE) < 0)\n        goto abrt;\n\n    fds[0].fd = data->sock;\n    fds[1].fd = data->wakeupRecvFD;\n\n    for (;;) {\n        int ret;\n\n        fds[0].events = fds[1].events = POLLIN;\n        fds[0].revents = fds[1].revents = 0;\n\n        ret = poll(fds, G_N_ELEMENTS(fds), timeout);\n\n        if (ret < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"poll failed in migration tunnel\"));\n            goto abrt;\n        }\n\n        if (ret == 0) {\n            /* We were asked to gracefully stop but reading would block. This\n             * can only happen if qemu told us migration finished but didn't\n             * close the migration fd. We handle this in the same way as EOF.\n             */\n            VIR_DEBUG(\"QEMU forgot to close migration fd\");\n            break;\n        }\n\n        if (fds[1].revents & (POLLIN | POLLERR | POLLHUP)) {\n            char stop = 0;\n\n            if (saferead(data->wakeupRecvFD, &stop, 1) != 1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to read from wakeup fd\"));\n                goto abrt;\n            }\n\n            VIR_DEBUG(\"Migration tunnel was asked to %s\",\n                      stop ? \"abort\" : \"finish\");\n            if (stop) {\n                goto abrt;\n            } else {\n                timeout = 0;\n            }\n        }\n\n        if (fds[0].revents & (POLLIN | POLLERR | POLLHUP)) {\n            int nbytes;\n\n            nbytes = saferead(data->sock, buffer, TUNNEL_SEND_BUF_SIZE);\n            if (nbytes > 0) {\n                if (virStreamSend(data->st, buffer, nbytes) < 0)\n                    goto error;\n            } else if (nbytes < 0) {\n                virReportSystemError(errno, \"%s\",\n                        _(\"tunnelled migration failed to read from qemu\"));\n                goto abrt;\n            } else {\n                /* EOF; get out of here */\n                break;\n            }\n        }\n    }\n\n    if (virStreamFinish(data->st) < 0)\n        goto error;\n\n    VIR_FORCE_CLOSE(data->sock);\n    VIR_FREE(buffer);\n\n    return;\n\n abrt:\n    virErrorPreserveLast(&err);\n    if (err && err->code == VIR_ERR_OK) {\n        virFreeError(err);\n        err = NULL;\n    }\n    virStreamAbort(data->st);\n    virErrorRestore(&err);\n\n error:\n    /* Let the source qemu know that the transfer cant continue anymore.\n     * Don't copy the error for EPIPE as destination has the actual error. */\n    VIR_FORCE_CLOSE(data->sock);\n    if (!virLastErrorIsSystemErrno(EPIPE))\n        virCopyLastError(&data->err);\n    virResetLastError();\n    VIR_FREE(buffer);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define TUNNEL_SEND_BUF_SIZE 65536"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 3290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCopyLastError",
          "args": [
            "&data->err"
          ],
          "line": 3288
        },
        "resolved": true,
        "details": {
          "function_name": "virCopyLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "370-389",
          "snippet": "int\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirCopyLastError(virErrorPtr to)\n{\n    virErrorPtr err = virLastErrorObject();\n\n    if (!to)\n        return -1;\n\n    /* We can't guarantee caller has initialized it to zero */\n    memset(to, 0, sizeof(*to));\n    if (err) {\n        virCopyError(err, to);\n    } else {\n        virResetError(to);\n        to->code = VIR_ERR_NO_MEMORY;\n        to->domain = VIR_FROM_NONE;\n        to->level = VIR_ERR_ERROR;\n    }\n    return to->code;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLastErrorIsSystemErrno",
          "args": [
            "EPIPE"
          ],
          "line": 3287
        },
        "resolved": true,
        "details": {
          "function_name": "virLastErrorIsSystemErrno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1432-1442",
          "snippet": "bool virLastErrorIsSystemErrno(int errnum)\n{\n    virErrorPtr err = virGetLastError();\n    if (!err)\n        return false;\n    if (err->code != VIR_ERR_SYSTEM_ERROR)\n        return false;\n    if (errnum != 0 && err->int1 != errnum)\n        return false;\n    return true;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nbool virLastErrorIsSystemErrno(int errnum)\n{\n    virErrorPtr err = virGetLastError();\n    if (!err)\n        return false;\n    if (err->code != VIR_ERR_SYSTEM_ERROR)\n        return false;\n    if (errnum != 0 && err->int1 != errnum)\n        return false;\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "data->sock"
          ],
          "line": 3286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 3281
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamAbort",
          "args": [
            "data->st"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1221-1248",
          "snippet": "int\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamAbort(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (!stream->driver) {\n        VIR_DEBUG(\"aborting unused stream\");\n        return 0;\n    }\n\n    if (stream->driver->streamAbort) {\n        int ret;\n        ret = (stream->driver->streamAbort)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFreeError",
          "args": [
            "err"
          ],
          "line": 3277
        },
        "resolved": true,
        "details": {
          "function_name": "virFreeError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "484-489",
          "snippet": "void\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirFreeError(virErrorPtr err)\n{\n    virResetError(err);\n    VIR_FREE(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 3275
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "buffer"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "data->sock"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStreamFinish",
          "args": [
            "data->st"
          ],
          "line": 3266
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "1179-1202",
          "snippet": "int\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamFinish(virStreamPtr stream)\n{\n    VIR_DEBUG(\"stream=%p\", stream);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n\n    if (stream->driver &&\n        stream->driver->streamFinish) {\n        int ret;\n        ret = (stream->driver->streamFinish)(stream);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(stream->conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"tunnelled migration failed to read from qemu\")"
          ],
          "line": 3256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"tunnelled migration failed to read from qemu\""
          ],
          "line": 3257
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStreamSend",
          "args": [
            "data->st",
            "buffer",
            "nbytes"
          ],
          "line": 3253
        },
        "resolved": true,
        "details": {
          "function_name": "virStreamSendAll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-stream.c",
          "lines": "571-631",
          "snippet": "int\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"rpc/virnetprotocol.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rpc/virnetprotocol.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nint\nvirStreamSendAll(virStreamPtr stream,\n                 virStreamSourceFunc handler,\n                 void *opaque)\n{\n    char *bytes = NULL;\n    size_t want = VIR_NET_MESSAGE_LEGACY_PAYLOAD_MAX;\n    int ret = -1;\n    VIR_DEBUG(\"stream=%p, handler=%p, opaque=%p\", stream, handler, opaque);\n\n    virResetLastError();\n\n    virCheckStreamReturn(stream, -1);\n    virCheckNonNullArgGoto(handler, cleanup);\n\n    if (stream->flags & VIR_STREAM_NONBLOCK) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"data sources cannot be used for non-blocking streams\"));\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(bytes, want) < 0)\n        goto cleanup;\n\n    errno = 0;\n    for (;;) {\n        int got, offset = 0;\n\n        got = (handler)(stream, bytes, want, opaque);\n        if (got < 0) {\n            if (errno == 0)\n                errno = EIO;\n            virReportSystemError(errno, \"%s\", _(\"send handler failed\"));\n            goto cleanup;\n        }\n        if (got == 0)\n            break;\n        while (offset < got) {\n            int done;\n            done = virStreamSend(stream, bytes + offset, got - offset);\n            if (done < 0)\n                goto cleanup;\n            offset += done;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    VIR_FREE(bytes);\n\n    if (ret != 0) {\n        virErrorPtr orig_err;\n\n        virErrorPreserveLast(&orig_err);\n        virStreamAbort(stream);\n        virErrorRestore(&orig_err);\n        virDispatchError(stream->conn);\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "data->sock",
            "buffer",
            "TUNNEL_SEND_BUF_SIZE"
          ],
          "line": 3251
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Migration tunnel was asked to %s\"",
            "stop ? \"abort\" : \"finish\""
          ],
          "line": 3239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"failed to read from wakeup fd\")"
          ],
          "line": 3234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"QEMU forgot to close migration fd\""
          ],
          "line": 3226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"poll failed in migration tunnel\")"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "fds",
            "G_N_ELEMENTS(fds)",
            "timeout"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "fds"
          ],
          "line": 3211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "buffer",
            "TUNNEL_SEND_BUF_SIZE"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Running migration tunnel; stream=%p, sock=%d\"",
            "data->st",
            "data->sock"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\n#define TUNNEL_SEND_BUF_SIZE 65536\n\nstatic void qemuMigrationSrcIOFunc(void *arg)\n{\n    qemuMigrationIOThreadPtr data = arg;\n    char *buffer = NULL;\n    struct pollfd fds[2];\n    int timeout = -1;\n    virErrorPtr err = NULL;\n\n    VIR_DEBUG(\"Running migration tunnel; stream=%p, sock=%d\",\n              data->st, data->sock);\n\n    if (VIR_ALLOC_N(buffer, TUNNEL_SEND_BUF_SIZE) < 0)\n        goto abrt;\n\n    fds[0].fd = data->sock;\n    fds[1].fd = data->wakeupRecvFD;\n\n    for (;;) {\n        int ret;\n\n        fds[0].events = fds[1].events = POLLIN;\n        fds[0].revents = fds[1].revents = 0;\n\n        ret = poll(fds, G_N_ELEMENTS(fds), timeout);\n\n        if (ret < 0) {\n            if (errno == EAGAIN || errno == EINTR)\n                continue;\n            virReportSystemError(errno, \"%s\",\n                                 _(\"poll failed in migration tunnel\"));\n            goto abrt;\n        }\n\n        if (ret == 0) {\n            /* We were asked to gracefully stop but reading would block. This\n             * can only happen if qemu told us migration finished but didn't\n             * close the migration fd. We handle this in the same way as EOF.\n             */\n            VIR_DEBUG(\"QEMU forgot to close migration fd\");\n            break;\n        }\n\n        if (fds[1].revents & (POLLIN | POLLERR | POLLHUP)) {\n            char stop = 0;\n\n            if (saferead(data->wakeupRecvFD, &stop, 1) != 1) {\n                virReportSystemError(errno, \"%s\",\n                                     _(\"failed to read from wakeup fd\"));\n                goto abrt;\n            }\n\n            VIR_DEBUG(\"Migration tunnel was asked to %s\",\n                      stop ? \"abort\" : \"finish\");\n            if (stop) {\n                goto abrt;\n            } else {\n                timeout = 0;\n            }\n        }\n\n        if (fds[0].revents & (POLLIN | POLLERR | POLLHUP)) {\n            int nbytes;\n\n            nbytes = saferead(data->sock, buffer, TUNNEL_SEND_BUF_SIZE);\n            if (nbytes > 0) {\n                if (virStreamSend(data->st, buffer, nbytes) < 0)\n                    goto error;\n            } else if (nbytes < 0) {\n                virReportSystemError(errno, \"%s\",\n                        _(\"tunnelled migration failed to read from qemu\"));\n                goto abrt;\n            } else {\n                /* EOF; get out of here */\n                break;\n            }\n        }\n    }\n\n    if (virStreamFinish(data->st) < 0)\n        goto error;\n\n    VIR_FORCE_CLOSE(data->sock);\n    VIR_FREE(buffer);\n\n    return;\n\n abrt:\n    virErrorPreserveLast(&err);\n    if (err && err->code == VIR_ERR_OK) {\n        virFreeError(err);\n        err = NULL;\n    }\n    virStreamAbort(data->st);\n    virErrorRestore(&err);\n\n error:\n    /* Let the source qemu know that the transfer cant continue anymore.\n     * Don't copy the error for EPIPE as destination has the actual error. */\n    VIR_FORCE_CLOSE(data->sock);\n    if (!virLastErrorIsSystemErrno(EPIPE))\n        virCopyLastError(&data->err);\n    virResetLastError();\n    VIR_FREE(buffer);\n}"
  },
  {
    "function_name": "qemuMigrationSrcConfirm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "3095-3138",
    "snippet": "int\nqemuMigrationSrcConfirm(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *cookiein,\n                        int cookieinlen,\n                        unsigned int flags,\n                        int cancelled)\n{\n    qemuMigrationJobPhase phase;\n    virQEMUDriverConfigPtr cfg = NULL;\n    int ret = -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT))\n        goto cleanup;\n\n    if (cancelled)\n        phase = QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED;\n    else\n        phase = QEMU_MIGRATION_PHASE_CONFIRM3;\n\n    qemuMigrationJobStartPhase(driver, vm, phase);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm)) {\n        if (!cancelled && ret == 0 && flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectUnref(cfg);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 3136
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainRemoveInactiveJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3131
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainRemoveInactiveJobLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11335-11347",
          "snippet": "void\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDeleteConfig",
          "args": [
            "cfg->configDir",
            "cfg->autostartDir",
            "vm"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDeleteConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29726-29753",
          "snippet": "int\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDeleteConfig(const char *configDir,\n                      const char *autostartDir,\n                      virDomainObjPtr dom)\n{\n    g_autofree char *configFile = NULL;\n    g_autofree char *autostartLink = NULL;\n\n    if ((configFile = virDomainConfigFile(configDir, dom->def->name)) == NULL)\n        return -1;\n    if ((autostartLink = virDomainConfigFile(autostartDir,\n                                             dom->def->name)) == NULL)\n        return -1;\n\n    /* Not fatal if this doesn't work */\n    unlink(autostartLink);\n    dom->autostart = 0;\n\n    if (unlink(configFile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"cannot remove config %s\"),\n                             configFile);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 3126
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3125
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcConfirmPhase",
          "args": [
            "driver",
            "vm",
            "cookiein",
            "cookieinlen",
            "flags",
            "cancelled"
          ],
          "line": 3121
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcConfirmPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2982-3093",
          "snippet": "static int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksUnset",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "qemuMigrationSrcCleanup"
          ],
          "line": 3118
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksUnset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "142-178",
          "snippet": "int\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksUnset(virCloseCallbacksPtr closeCallbacks,\n                       virDomainObjPtr vm,\n                       virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, cb=%p\",\n              vm->def->name, uuidstr, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (!closeDef)\n        goto cleanup;\n\n    if (closeDef->cb && closeDef->cb != cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Trying to remove mismatching close callback for\"\n                         \" domain %s\"), vm->def->name);\n        goto cleanup;\n    }\n\n    if (virHashRemoveEntry(closeCallbacks->list, uuidstr) < 0)\n        goto cleanup;\n\n    virObjectUnref(vm);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    if (!ret)\n        virObjectUnref(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStartPhase",
          "args": [
            "driver",
            "vm",
            "phase"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStartPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5464-5470",
          "snippet": "static void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobStartPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuMigrationJobPhase phase)\n{\n    qemuMigrationJobSetPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobIsActive",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5478-5496",
          "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 3107
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcConfirm(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        const char *cookiein,\n                        int cookieinlen,\n                        unsigned int flags,\n                        int cancelled)\n{\n    qemuMigrationJobPhase phase;\n    virQEMUDriverConfigPtr cfg = NULL;\n    int ret = -1;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT))\n        goto cleanup;\n\n    if (cancelled)\n        phase = QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED;\n    else\n        phase = QEMU_MIGRATION_PHASE_CONFIRM3;\n\n    qemuMigrationJobStartPhase(driver, vm, phase);\n    virCloseCallbacksUnset(driver->closeCallbacks, vm,\n                           qemuMigrationSrcCleanup);\n\n    ret = qemuMigrationSrcConfirmPhase(driver, vm,\n                                       cookiein, cookieinlen,\n                                       flags, cancelled);\n\n    qemuMigrationJobFinish(driver, vm);\n    if (!virDomainObjIsActive(vm)) {\n        if (!cancelled && ret == 0 && flags & VIR_MIGRATE_UNDEFINE_SOURCE) {\n            virDomainDeleteConfig(cfg->configDir, cfg->autostartDir, vm);\n            vm->persistent = 0;\n        }\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    virObjectUnref(cfg);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcConfirmPhase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2982-3093",
    "snippet": "static int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 3091
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 3087
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to save status on vm %s\"",
            "vm->def->name"
          ],
          "line": 3083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcRestoreDomainState",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3077
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcRestoreDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "128-168",
          "snippet": "static bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyPostcopyFailed",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyPostcopyFailed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1386-1415",
          "snippet": "void\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "&reason"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&orig_err"
          ],
          "line": 3071
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDCopyCancel",
          "args": [
            "driver",
            "vm",
            "false",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "NULL"
          ],
          "line": 3068
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDCopyCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "694-777",
          "snippet": "static int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&orig_err"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainEventEmitJobCompleted",
          "args": [
            "driver",
            "vm"
          ],
          "line": 3060
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainEventEmitJobCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "307-328",
          "snippet": "void\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nvoid\nqemuDomainEventEmitJobCompleted(virQEMUDriverPtr driver,\n                                virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virObjectEventPtr event;\n    virTypedParameterPtr params = NULL;\n    int nparams = 0;\n    int type;\n\n    if (!priv->job.completed)\n        return;\n\n    if (qemuDomainJobInfoToParams(priv->job.completed, &type,\n                                  &params, &nparams) < 0) {\n        VIR_WARN(\"Could not get stats for completed job; domain %s\",\n                 vm->def->name);\n    }\n\n    event = virDomainEventJobCompletedNewFromObj(vm, params, nparams);\n    virObjectEventStateQueue(driver->domainEventState, event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 3059
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STOPPED",
            "VIR_DOMAIN_EVENT_STOPPED_MIGRATED"
          ],
          "line": 3056
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStop",
          "args": [
            "vm",
            "\"migrated\""
          ],
          "line": 3054
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "866-870",
          "snippet": "void\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStop(virDomainObjPtr vm, const char *reason)\n{\n    virDomainAuditLifecycle(vm, \"stop\", reason, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_MIGRATED",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "VIR_QEMU_PROCESS_STOP_MIGRATED"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7306-7649",
          "snippet": "void qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcWaitForSpice",
          "args": [
            "vm"
          ],
          "line": 3049
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcWaitForSpice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1418-1432",
          "snippet": "static int\nqemuMigrationSrcWaitForSpice(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.spiceMigration)\n        return 0;\n\n    VIR_DEBUG(\"Waiting for SPICE to finish migration\");\n    while (!priv->job.spiceMigrated && !priv->job.abortJob) {\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcWaitForSpice(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.spiceMigration)\n        return 0;\n\n    VIR_DEBUG(\"Waiting for SPICE to finish migration\");\n    while (!priv->job.spiceMigrated && !priv->job.abortJob) {\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "jobInfo"
          ],
          "line": 3033
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not refresh migration statistics\""
          ],
          "line": 3031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyFetchStats",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "jobInfo",
            "NULL"
          ],
          "line": 3029
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyFetchStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1477-1499",
          "snippet": "int\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->job.completed"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationEatCookie",
          "args": [
            "driver",
            "vm->def",
            "priv->origname",
            "priv",
            "cookiein",
            "cookieinlen",
            "QEMU_MIGRATION_COOKIE_STATS"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1462-1527",
          "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "QEMU_MIGRATION_FLAGS",
            "-1"
          ],
          "line": 3002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\"",
            "driver",
            "vm",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "flags",
            "retcode"
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcConfirmPhase(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *cookiein,\n                             int cookieinlen,\n                             unsigned int flags,\n                             int retcode)\n{\n    qemuMigrationCookiePtr mig;\n    virObjectEventPtr event;\n    int rv = -1;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = NULL;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, cookiein=%s, cookieinlen=%d, \"\n              \"flags=0x%x, retcode=%d\",\n              driver, vm, NULLSTR(cookiein), cookieinlen,\n              flags, retcode);\n\n    virCheckFlags(QEMU_MIGRATION_FLAGS, -1);\n\n    qemuMigrationJobSetPhase(driver, vm,\n                             retcode == 0\n                             ? QEMU_MIGRATION_PHASE_CONFIRM3\n                             : QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED);\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def, priv->origname, priv,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_STATS)))\n        goto cleanup;\n\n    if (retcode == 0)\n        jobInfo = priv->job.completed;\n    else\n        VIR_FREE(priv->job.completed);\n\n    /* Update times with the values sent by the destination daemon */\n    if (mig->jobInfo && jobInfo) {\n        int reason;\n\n        /* We need to refresh migration statistics after a completed post-copy\n         * migration since priv->job.completed contains obsolete data from the\n         * time we switched to post-copy mode.\n         */\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY &&\n            qemuMigrationAnyFetchStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                       jobInfo, NULL) < 0)\n            VIR_WARN(\"Could not refresh migration statistics\");\n\n        qemuDomainJobInfoUpdateTime(jobInfo);\n        jobInfo->timeDeltaSet = mig->jobInfo->timeDeltaSet;\n        jobInfo->timeDelta = mig->jobInfo->timeDelta;\n        jobInfo->stats.mig.downtime_set = mig->jobInfo->stats.mig.downtime_set;\n        jobInfo->stats.mig.downtime = mig->jobInfo->stats.mig.downtime;\n    }\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    /* Did the migration go as planned?  If yes, kill off the domain object.\n     * If something failed, resume CPUs, but only if we didn't use post-copy.\n     */\n    if (retcode == 0) {\n        /* If guest uses SPICE and supports seamless migration we have to hold\n         * up domain shutdown until SPICE server transfers its data */\n        qemuMigrationSrcWaitForSpice(vm);\n\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_MIGRATED,\n                        QEMU_ASYNC_JOB_MIGRATION_OUT,\n                        VIR_QEMU_PROCESS_STOP_MIGRATED);\n        virDomainAuditStop(vm, \"migrated\");\n\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STOPPED,\n                                         VIR_DOMAIN_EVENT_STOPPED_MIGRATED);\n        virObjectEventStateQueue(driver->domainEventState, event);\n        qemuDomainEventEmitJobCompleted(driver, vm);\n    } else {\n        virErrorPtr orig_err;\n        int reason;\n\n        virErrorPreserveLast(&orig_err);\n\n        /* cancel any outstanding NBD jobs */\n        qemuMigrationSrcNBDCopyCancel(driver, vm, false,\n                                      QEMU_ASYNC_JOB_MIGRATION_OUT, NULL);\n\n        virErrorRestore(&orig_err);\n\n        if (virDomainObjGetState(vm, &reason) == VIR_DOMAIN_PAUSED &&\n            reason == VIR_DOMAIN_PAUSED_POSTCOPY)\n            qemuMigrationAnyPostcopyFailed(driver, vm);\n        else\n            qemuMigrationSrcRestoreDomainState(driver, vm);\n\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n    }\n\n done:\n    qemuMigrationCookieFree(mig);\n    rv = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return rv;\n}"
  },
  {
    "function_name": "qemuMigrationAnyPrepareDef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2946-2979",
    "snippet": "virDomainDefPtr\nqemuMigrationAnyPrepareDef(virQEMUDriverPtr driver,\n                           virQEMUCapsPtr qemuCaps,\n                           const char *dom_xml,\n                           const char *dname,\n                           char **origname)\n{\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        qemuCaps,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    if (def && origname)\n        *origname = name;\n    else\n        VIR_FREE(name);\n    return def;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 2977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dname"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "dom_xml",
            "driver->xmlopt",
            "qemuCaps",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no domain XML passed\")"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no domain XML passed\""
          ],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvirDomainDefPtr\nqemuMigrationAnyPrepareDef(virQEMUDriverPtr driver,\n                           virQEMUCapsPtr qemuCaps,\n                           const char *dom_xml,\n                           const char *dname,\n                           char **origname)\n{\n    virDomainDefPtr def;\n    char *name = NULL;\n\n    if (!dom_xml) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no domain XML passed\"));\n        return NULL;\n    }\n\n    if (!(def = virDomainDefParseString(dom_xml, driver->xmlopt,\n                                        qemuCaps,\n                                        VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                        VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n        goto cleanup;\n\n    if (dname) {\n        name = def->name;\n        def->name = g_strdup(dname);\n    }\n\n cleanup:\n    if (def && origname)\n        *origname = name;\n    else\n        VIR_FREE(name);\n    return def;\n}"
  },
  {
    "function_name": "qemuMigrationDstPrepareDirect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2796-2943",
    "snippet": "int\nqemuMigrationDstPrepareDirect(virQEMUDriverPtr driver,\n                              virConnectPtr dconn,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              const char *uri_in,\n                              char **uri_out,\n                              virDomainDefPtr *def,\n                              const char *origname,\n                              const char *listenAddress,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              int nbdPort,\n                              qemuMigrationParamsPtr migParams,\n                              unsigned long flags)\n{\n    unsigned short port = 0;\n    bool autoPort = true;\n    char *hostname = NULL;\n    int ret = -1;\n    virURIPtr uri = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *migrateHost = cfg->migrateHost;\n\n    VIR_DEBUG(\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, uri_in=%s, uri_out=%p, \"\n              \"def=%p, origname=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, flags=0x%lx\",\n              driver, dconn, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, NULLSTR(uri_in), uri_out,\n              *def, origname, NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags);\n\n    *uri_out = NULL;\n\n    /* The URI passed in may be NULL or a string \"tcp://somehostname:port\".\n     *\n     * If the URI passed in is NULL then we allocate a port number\n     * from our pool of port numbers, and if the migrateHost is configured,\n     * we return a URI of \"tcp://migrateHost:port\", otherwise return a URI\n     * of \"tcp://ourhostname:port\".\n     *\n     * If the URI passed in is not NULL then we try to parse out the\n     * port number and use that (note that the hostname is assumed\n     * to be a correct hostname which refers to the target machine).\n     */\n    if (uri_in == NULL) {\n        bool encloseAddress = false;\n        const char *incFormat;\n\n        if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n            goto cleanup;\n\n        if (migrateHost != NULL) {\n            if (virSocketAddrNumericFamily(migrateHost) == AF_INET6)\n                encloseAddress = true;\n\n            hostname = g_strdup(migrateHost);\n        } else {\n            if ((hostname = virGetHostname()) == NULL)\n                goto cleanup;\n        }\n\n        if (STRPREFIX(hostname, \"localhost\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\"));\n            goto cleanup;\n        }\n\n        /* XXX this really should have been a properly well-formed\n         * URI, but we can't add in tcp:// now without breaking\n         * compatibility with old targets. We at least make the\n         * new targets accept both syntaxes though.\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n\n        *uri_out = g_strdup_printf(incFormat, \"tcp\", hostname, port);\n    } else {\n        bool well_formed_uri;\n\n        if (!(uri = qemuMigrationAnyParseURI(uri_in, &well_formed_uri)))\n            goto cleanup;\n\n        if (uri->scheme == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"missing scheme in migration URI: %s\"),\n                           uri_in);\n            goto cleanup;\n        }\n\n        if (STRNEQ(uri->scheme, \"tcp\") &&\n            STRNEQ(uri->scheme, \"rdma\")) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"unsupported scheme %s in migration URI %s\"),\n                           uri->scheme, uri_in);\n            goto cleanup;\n        }\n\n        if (uri->server == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG, _(\"missing host in migration\"\n                                                  \" URI: %s\"), uri_in);\n            goto cleanup;\n        }\n\n        if (uri->port == 0) {\n            if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto cleanup;\n\n            /* Send well-formed URI only if uri_in was well-formed */\n            if (well_formed_uri) {\n                uri->port = port;\n                if (!(*uri_out = virURIFormat(uri)))\n                    goto cleanup;\n            } else {\n                *uri_out = g_strdup_printf(\"%s:%d\", uri_in, port);\n            }\n        } else {\n            port = uri->port;\n            autoPort = false;\n        }\n    }\n\n    if (*uri_out)\n        VIR_DEBUG(\"Generated uri_out=%s\", *uri_out);\n\n    ret = qemuMigrationDstPrepareAny(driver, dconn, cookiein, cookieinlen,\n                                     cookieout, cookieoutlen, def, origname,\n                                     NULL, uri ? uri->scheme : \"tcp\",\n                                     port, autoPort, listenAddress,\n                                     nmigrate_disks, migrate_disks, nbdPort,\n                                     migParams, flags);\n cleanup:\n    virURIFree(uri);\n    VIR_FREE(hostname);\n    virObjectUnref(cfg);\n    if (ret != 0) {\n        VIR_FREE(*uri_out);\n        if (autoPort)\n            virPortAllocatorRelease(port);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "port"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*uri_out"
          ],
          "line": 2938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfg"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hostname"
          ],
          "line": 2935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uri"
          ],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstPrepareAny",
          "args": [
            "driver",
            "dconn",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "def",
            "origname",
            "NULL",
            "uri ? uri->scheme : \"tcp\"",
            "port",
            "autoPort",
            "listenAddress",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "migParams",
            "flags"
          ],
          "line": 2927
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPrepareAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2362-2735",
          "snippet": "static int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Generated uri_out=%s\"",
            "*uri_out"
          ],
          "line": 2925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s:%d\"",
            "uri_in",
            "port"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIFormat",
          "args": [
            "uri"
          ],
          "line": 2913
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFormatParams",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "253-269",
          "snippet": "char *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nchar *virURIFormatParams(virURIPtr uri)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    bool amp = false;\n\n    for (i = 0; i < uri->paramsCount; ++i) {\n        if (!uri->params[i].ignore) {\n            if (amp) virBufferAddChar(&buf, '&');\n            virBufferStrcat(&buf, uri->params[i].name, \"=\", NULL);\n            virBufferURIEncodeString(&buf, uri->params[i].value);\n            amp = true;\n        }\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "driver->migrationPorts",
            "&port"
          ],
          "line": 2907
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"missing host in migration\"\n                                                  \" URI: %s\")",
            "uri_in"
          ],
          "line": 2901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing host in migration\"\n                                                  \" URI: %s\""
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "_(\"unsupported scheme %s in migration URI %s\")",
            "uri->scheme",
            "uri_in"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uri->scheme",
            "\"rdma\""
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "uri->scheme",
            "\"tcp\""
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"missing scheme in migration URI: %s\")",
            "uri_in"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyParseURI",
          "args": [
            "uri_in",
            "&well_formed_uri"
          ],
          "line": 2882
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyParseURI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2774-2793",
          "snippet": "static virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\")"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "hostname",
            "\"localhost\""
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetHostname",
          "args": [],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostnameQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "560-564",
          "snippet": "char *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirGetHostnameQuiet(void)\n{\n    return virGetHostnameImpl(true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrNumericFamily",
          "args": [
            "migrateHost"
          ],
          "line": 2852
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrNumericFamily",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1209-1221",
          "snippet": "int\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, uri_in=%s, uri_out=%p, \"\n              \"def=%p, origname=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, flags=0x%lx\"",
            "driver",
            "dconn",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "NULLSTR(uri_in)",
            "uri_out",
            "*def",
            "origname",
            "NULLSTR(listenAddress)",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "flags"
          ],
          "line": 2822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "listenAddress"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "uri_in"
          ],
          "line": 2827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstPrepareDirect(virQEMUDriverPtr driver,\n                              virConnectPtr dconn,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              const char *uri_in,\n                              char **uri_out,\n                              virDomainDefPtr *def,\n                              const char *origname,\n                              const char *listenAddress,\n                              size_t nmigrate_disks,\n                              const char **migrate_disks,\n                              int nbdPort,\n                              qemuMigrationParamsPtr migParams,\n                              unsigned long flags)\n{\n    unsigned short port = 0;\n    bool autoPort = true;\n    char *hostname = NULL;\n    int ret = -1;\n    virURIPtr uri = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *migrateHost = cfg->migrateHost;\n\n    VIR_DEBUG(\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, uri_in=%s, uri_out=%p, \"\n              \"def=%p, origname=%s, listenAddress=%s, \"\n              \"nmigrate_disks=%zu, migrate_disks=%p, nbdPort=%d, flags=0x%lx\",\n              driver, dconn, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, NULLSTR(uri_in), uri_out,\n              *def, origname, NULLSTR(listenAddress),\n              nmigrate_disks, migrate_disks, nbdPort, flags);\n\n    *uri_out = NULL;\n\n    /* The URI passed in may be NULL or a string \"tcp://somehostname:port\".\n     *\n     * If the URI passed in is NULL then we allocate a port number\n     * from our pool of port numbers, and if the migrateHost is configured,\n     * we return a URI of \"tcp://migrateHost:port\", otherwise return a URI\n     * of \"tcp://ourhostname:port\".\n     *\n     * If the URI passed in is not NULL then we try to parse out the\n     * port number and use that (note that the hostname is assumed\n     * to be a correct hostname which refers to the target machine).\n     */\n    if (uri_in == NULL) {\n        bool encloseAddress = false;\n        const char *incFormat;\n\n        if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n            goto cleanup;\n\n        if (migrateHost != NULL) {\n            if (virSocketAddrNumericFamily(migrateHost) == AF_INET6)\n                encloseAddress = true;\n\n            hostname = g_strdup(migrateHost);\n        } else {\n            if ((hostname = virGetHostname()) == NULL)\n                goto cleanup;\n        }\n\n        if (STRPREFIX(hostname, \"localhost\")) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"hostname on destination resolved to localhost,\"\n                             \" but migration requires an FQDN\"));\n            goto cleanup;\n        }\n\n        /* XXX this really should have been a properly well-formed\n         * URI, but we can't add in tcp:// now without breaking\n         * compatibility with old targets. We at least make the\n         * new targets accept both syntaxes though.\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n\n        *uri_out = g_strdup_printf(incFormat, \"tcp\", hostname, port);\n    } else {\n        bool well_formed_uri;\n\n        if (!(uri = qemuMigrationAnyParseURI(uri_in, &well_formed_uri)))\n            goto cleanup;\n\n        if (uri->scheme == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"missing scheme in migration URI: %s\"),\n                           uri_in);\n            goto cleanup;\n        }\n\n        if (STRNEQ(uri->scheme, \"tcp\") &&\n            STRNEQ(uri->scheme, \"rdma\")) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"unsupported scheme %s in migration URI %s\"),\n                           uri->scheme, uri_in);\n            goto cleanup;\n        }\n\n        if (uri->server == NULL) {\n            virReportError(VIR_ERR_INVALID_ARG, _(\"missing host in migration\"\n                                                  \" URI: %s\"), uri_in);\n            goto cleanup;\n        }\n\n        if (uri->port == 0) {\n            if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto cleanup;\n\n            /* Send well-formed URI only if uri_in was well-formed */\n            if (well_formed_uri) {\n                uri->port = port;\n                if (!(*uri_out = virURIFormat(uri)))\n                    goto cleanup;\n            } else {\n                *uri_out = g_strdup_printf(\"%s:%d\", uri_in, port);\n            }\n        } else {\n            port = uri->port;\n            autoPort = false;\n        }\n    }\n\n    if (*uri_out)\n        VIR_DEBUG(\"Generated uri_out=%s\", *uri_out);\n\n    ret = qemuMigrationDstPrepareAny(driver, dconn, cookiein, cookieinlen,\n                                     cookieout, cookieoutlen, def, origname,\n                                     NULL, uri ? uri->scheme : \"tcp\",\n                                     port, autoPort, listenAddress,\n                                     nmigrate_disks, migrate_disks, nbdPort,\n                                     migParams, flags);\n cleanup:\n    virURIFree(uri);\n    VIR_FREE(hostname);\n    virObjectUnref(cfg);\n    if (ret != 0) {\n        VIR_FREE(*uri_out);\n        if (autoPort)\n            virPortAllocatorRelease(port);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationAnyParseURI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2774-2793",
    "snippet": "static virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tmp"
          ],
          "line": 2790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uri"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"tcp://%s\"",
            "uri + 4"
          ],
          "line": 2783
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "uri + 4",
            "\"//\""
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "uri",
            "\"tcp:\""
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virURIPtr\nqemuMigrationAnyParseURI(const char *uri, bool *wellFormed)\n{\n    char *tmp = NULL;\n    virURIPtr parsed;\n\n    /* For compatibility reasons tcp://... URIs are sent as tcp:...\n     * We need to transform them to a well-formed URI before parsing. */\n    if (STRPREFIX(uri, \"tcp:\") && !STRPREFIX(uri + 4, \"//\")) {\n        tmp = g_strdup_printf(\"tcp://%s\", uri + 4);\n        uri = tmp;\n    }\n\n    parsed = virURIParse(uri);\n    if (parsed && wellFormed)\n        *wellFormed = !tmp;\n    VIR_FREE(tmp);\n\n    return parsed;\n}"
  },
  {
    "function_name": "qemuMigrationDstPrepareTunnel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2742-2771",
    "snippet": "int\nqemuMigrationDstPrepareTunnel(virQEMUDriverPtr driver,\n                              virConnectPtr dconn,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              virStreamPtr st,\n                              virDomainDefPtr *def,\n                              const char *origname,\n                              qemuMigrationParamsPtr migParams,\n                              unsigned long flags)\n{\n    VIR_DEBUG(\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, st=%p, def=%p, \"\n              \"origname=%s, flags=0x%lx\",\n              driver, dconn, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, st, *def, origname, flags);\n\n    if (st == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"tunnelled migration requested but NULL stream passed\"));\n        return -1;\n    }\n\n    return qemuMigrationDstPrepareAny(driver, dconn, cookiein, cookieinlen,\n                                      cookieout, cookieoutlen, def, origname,\n                                      st, NULL, 0, false, NULL, 0, NULL, 0,\n                                      migParams, flags);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationDstPrepareAny",
          "args": [
            "driver",
            "dconn",
            "cookiein",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "def",
            "origname",
            "st",
            "NULL",
            "0",
            "false",
            "NULL",
            "0",
            "NULL",
            "0",
            "migParams",
            "flags"
          ],
          "line": 2767
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPrepareAny",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2362-2735",
          "snippet": "static int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"tunnelled migration requested but NULL stream passed\")"
          ],
          "line": 2762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"tunnelled migration requested but NULL stream passed\""
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, st=%p, def=%p, \"\n              \"origname=%s, flags=0x%lx\"",
            "driver",
            "dconn",
            "NULLSTR(cookiein)",
            "cookieinlen",
            "cookieout",
            "cookieoutlen",
            "st",
            "*def",
            "origname",
            "flags"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "cookiein"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstPrepareTunnel(virQEMUDriverPtr driver,\n                              virConnectPtr dconn,\n                              const char *cookiein,\n                              int cookieinlen,\n                              char **cookieout,\n                              int *cookieoutlen,\n                              virStreamPtr st,\n                              virDomainDefPtr *def,\n                              const char *origname,\n                              qemuMigrationParamsPtr migParams,\n                              unsigned long flags)\n{\n    VIR_DEBUG(\"driver=%p, dconn=%p, cookiein=%s, cookieinlen=%d, \"\n              \"cookieout=%p, cookieoutlen=%p, st=%p, def=%p, \"\n              \"origname=%s, flags=0x%lx\",\n              driver, dconn, NULLSTR(cookiein), cookieinlen,\n              cookieout, cookieoutlen, st, *def, origname, flags);\n\n    if (st == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"tunnelled migration requested but NULL stream passed\"));\n        return -1;\n    }\n\n    return qemuMigrationDstPrepareAny(driver, dconn, cookiein, cookieinlen,\n                                      cookieout, cookieoutlen, def, origname,\n                                      st, NULL, 0, false, NULL, 0, NULL, 0,\n                                      migParams, flags);\n}"
  },
  {
    "function_name": "qemuMigrationDstPrepareAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2362-2735",
    "snippet": "static int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStop",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_SHUTOFF_FAILED",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "stopFlags"
          ],
          "line": 2729
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7306-7649",
          "snippet": "void qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid qemuProcessStop(virQEMUDriverPtr driver,\n                     virDomainObjPtr vm,\n                     virDomainShutoffReason reason,\n                     qemuDomainAsyncJob asyncJob,\n                     unsigned int flags)\n{\n    int ret;\n    int retries = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virErrorPtr orig_err;\n    virDomainDefPtr def = vm->def;\n    const virNetDevVPortProfile *vport = NULL;\n    size_t i;\n    g_autofree char *timestamp = NULL;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virConnect) conn = NULL;\n\n    VIR_DEBUG(\"Shutting down vm=%p name=%s id=%d pid=%lld, \"\n              \"reason=%s, asyncJob=%s, flags=0x%x\",\n              vm, vm->def->name, vm->def->id,\n              (long long)vm->pid,\n              virDomainShutoffReasonTypeToString(reason),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              flags);\n\n    /* This method is routinely used in clean up paths. Disable error\n     * reporting so we don't squash a legit error. */\n    virErrorPreserveLast(&orig_err);\n\n    if (asyncJob != QEMU_ASYNC_JOB_NONE) {\n        if (qemuDomainObjBeginNestedJob(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    } else if (priv->job.asyncJob != QEMU_ASYNC_JOB_NONE &&\n               priv->job.asyncOwner == virThreadSelfID() &&\n               priv->job.active != QEMU_JOB_ASYNC_NESTED) {\n        VIR_WARN(\"qemuProcessStop called without a nested job (async=%s)\",\n                 qemuDomainAsyncJobTypeToString(asyncJob));\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        VIR_DEBUG(\"VM '%s' not active\", vm->def->name);\n        goto endjob;\n    }\n\n    qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, false);\n\n    if (!!g_atomic_int_dec_and_test(&driver->nactive) && driver->inhibitCallback)\n        driver->inhibitCallback(false, driver->inhibitOpaque);\n\n    /* Wake up anything waiting on domain condition */\n    virDomainObjBroadcast(vm);\n\n    if ((timestamp = virTimeStringNow()) != NULL) {\n        qemuDomainLogAppendMessage(driver, vm, \"%s: shutting down, reason=%s\\n\",\n                                   timestamp,\n                                   virDomainShutoffReasonTypeToString(reason));\n    }\n\n    /* Clear network bandwidth */\n    virDomainClearNetBandwidth(vm->def);\n\n    virDomainConfVMNWFilterTeardown(vm);\n\n    if (cfg->macFilter) {\n        for (i = 0; i < def->nnets; i++) {\n            virDomainNetDefPtr net = def->nets[i];\n            if (net->ifname == NULL)\n                continue;\n            ignore_value(ebtablesRemoveForwardAllowIn(driver->ebtables,\n                                                      net->ifname,\n                                                      &net->mac));\n        }\n    }\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n\n    if (priv->agent) {\n        qemuAgentClose(priv->agent);\n        priv->agent = NULL;\n    }\n    priv->agentError = false;\n\n    if (priv->mon) {\n        qemuMonitorClose(priv->mon);\n        priv->mon = NULL;\n    }\n\n    if (priv->monConfig) {\n        if (priv->monConfig->type == VIR_DOMAIN_CHR_TYPE_UNIX)\n            unlink(priv->monConfig->data.nix.path);\n        virObjectUnref(priv->monConfig);\n        priv->monConfig = NULL;\n    }\n\n    /*\n     * We cannot stop the event thread at this time. When\n     * we are in this code, we may not yet have processed the\n     * STOP event or EOF from the monitor. So the event loop\n     * may have pending input that we need to process still.\n     * The qemuProcessHandleMonitorEOF method will kill\n     * the event thread because at that point we don't\n     * expect any more I/O from the QEMU monitor. We are\n     * assuming we don't need to get any more events from the\n     * QEMU agent at that time.\n     */\n\n    /* Remove the master key */\n    qemuDomainMasterKeyRemove(priv);\n\n    /* Do this before we delete the tree and remove pidfile. */\n    qemuProcessKillManagedPRDaemon(vm);\n\n    virFileDeleteTree(priv->libDir);\n    virFileDeleteTree(priv->channelTargetDir);\n\n    ignore_value(virDomainChrDefForeach(vm->def,\n                                        false,\n                                        qemuProcessCleanupChardevDevice,\n                                        NULL));\n\n\n    /* shut it off for sure */\n    ignore_value(qemuProcessKill(vm,\n                                 VIR_QEMU_PROCESS_KILL_FORCE|\n                                 VIR_QEMU_PROCESS_KILL_NOCHECK));\n\n    qemuDomainCleanupRun(driver, vm);\n\n    qemuExtDevicesStop(driver, vm);\n\n    vm->def->id = -1;\n\n    /* Stop autodestroy in case guest is restarted */\n    qemuProcessAutoDestroyRemove(driver, vm);\n\n    /* now that we know it's stopped call the hook if present */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        ignore_value(virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                                 VIR_HOOK_QEMU_OP_STOPPED, VIR_HOOK_SUBOP_END,\n                                 NULL, xml, NULL));\n    }\n\n    /* Reset Security Labels unless caller don't want us to */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL))\n        qemuSecurityRestoreAllLabel(driver, vm,\n                                    !!(flags & VIR_QEMU_PROCESS_STOP_MIGRATED));\n\n    qemuSecurityReleaseLabel(driver->securityManager, vm->def);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDeviceDef dev;\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        dev.type = VIR_DOMAIN_DEVICE_DISK;\n        dev.data.disk = disk;\n        ignore_value(qemuRemoveSharedDevice(driver, &dev, vm->def->name));\n    }\n\n    /* Clear out dynamically assigned labels */\n    for (i = 0; i < vm->def->nseclabels; i++) {\n        if (vm->def->seclabels[i]->type == VIR_DOMAIN_SECLABEL_DYNAMIC)\n            VIR_FREE(vm->def->seclabels[i]->label);\n        VIR_FREE(vm->def->seclabels[i]->imagelabel);\n    }\n\n    qemuHostdevReAttachDomainDevices(driver, vm->def);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        vport = virDomainNetGetActualVirtPortProfile(net);\n\n        switch (virDomainNetGetActualType(net)) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n            ignore_value(virNetDevMacVLanDeleteWithVPortProfile(\n                             net->ifname, &net->mac,\n                             virDomainNetGetActualDirectDev(net),\n                             virDomainNetGetActualDirectMode(net),\n                             virDomainNetGetActualVirtPortProfile(net),\n                             cfg->stateDir));\n            break;\n        case VIR_DOMAIN_NET_TYPE_ETHERNET:\n            if (net->managed_tap != VIR_TRISTATE_BOOL_NO && net->ifname) {\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n                VIR_FREE(net->ifname);\n            }\n            break;\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_NETWORK:\n#ifdef VIR_NETDEV_TAP_REQUIRE_MANUAL_CLEANUP\n            if (!(vport && vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH))\n                ignore_value(virNetDevTapDelete(net->ifname, net->backend.tap));\n#endif\n            break;\n        case VIR_DOMAIN_NET_TYPE_USER:\n        case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n        case VIR_DOMAIN_NET_TYPE_SERVER:\n        case VIR_DOMAIN_NET_TYPE_CLIENT:\n        case VIR_DOMAIN_NET_TYPE_MCAST:\n        case VIR_DOMAIN_NET_TYPE_INTERNAL:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        case VIR_DOMAIN_NET_TYPE_UDP:\n        case VIR_DOMAIN_NET_TYPE_LAST:\n            /* No special cleanup procedure for these types. */\n            break;\n        }\n        /* release the physical device (or any other resources used by\n         * this interface in the network driver\n         */\n        if (vport) {\n            if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_MIDONET) {\n                ignore_value(virNetDevMidonetUnbindPort(vport));\n            } else if (vport->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH) {\n                ignore_value(virNetDevOpenvswitchRemovePort(\n                                 virDomainNetGetActualBridgeName(net),\n                                 net->ifname));\n            }\n        }\n\n        /* kick the device out of the hostdev list too */\n        virDomainNetRemoveHostdev(def, net);\n        if (net->type == VIR_DOMAIN_NET_TYPE_NETWORK) {\n            if (conn || (conn = virGetConnectNetwork()))\n                virDomainNetReleaseActualDevice(conn, vm->def, net);\n            else\n                VIR_WARN(\"Unable to release network device '%s'\", NULLSTR(net->ifname));\n        }\n    }\n\n retry:\n    if ((ret = qemuRemoveCgroup(vm)) < 0) {\n        if (ret == -EBUSY && (retries++ < 5)) {\n            g_usleep(200*1000);\n            goto retry;\n        }\n        VIR_WARN(\"Failed to remove cgroup for %s\",\n                 vm->def->name);\n    }\n\n    /* Remove resctrl allocation after cgroups are cleaned up which makes it\n     * kind of safer (although removing the allocation should work even with\n     * pids in tasks file */\n    for (i = 0; i < vm->def->nresctrls; i++) {\n        size_t j = 0;\n\n        for (j = 0; j < vm->def->resctrls[i]->nmonitors; j++) {\n            virDomainResctrlMonDefPtr mon = NULL;\n\n            mon = vm->def->resctrls[i]->monitors[j];\n            virResctrlMonitorRemove(mon->instance);\n        }\n\n        virResctrlAllocRemove(vm->def->resctrls[i]->alloc);\n    }\n\n    /* clean up a possible backup job */\n    if (priv->backup)\n        qemuBackupJobTerminate(vm, QEMU_DOMAIN_JOB_STATUS_CANCELED);\n\n    qemuProcessRemoveDomainStatus(driver, vm);\n\n    /* Remove VNC and Spice ports from port reservation bitmap, but only if\n       they were reserved by the driver (autoport=yes)\n    */\n    for (i = 0; i < vm->def->ngraphics; ++i) {\n        virDomainGraphicsDefPtr graphics = vm->def->graphics[i];\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_VNC) {\n            if (graphics->data.vnc.autoport) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n            } else if (graphics->data.vnc.portReserved) {\n                virPortAllocatorRelease(graphics->data.vnc.port);\n                graphics->data.vnc.portReserved = false;\n            }\n            if (graphics->data.vnc.websocketGenerated) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n                graphics->data.vnc.websocketGenerated = false;\n                graphics->data.vnc.websocket = -1;\n            } else if (graphics->data.vnc.websocket) {\n                virPortAllocatorRelease(graphics->data.vnc.websocket);\n            }\n        }\n        if (graphics->type == VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n            if (graphics->data.spice.autoport) {\n                virPortAllocatorRelease(graphics->data.spice.port);\n                virPortAllocatorRelease(graphics->data.spice.tlsPort);\n            } else {\n                if (graphics->data.spice.portReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.port);\n                    graphics->data.spice.portReserved = false;\n                }\n\n                if (graphics->data.spice.tlsPortReserved) {\n                    virPortAllocatorRelease(graphics->data.spice.tlsPort);\n                    graphics->data.spice.tlsPortReserved = false;\n                }\n            }\n        }\n    }\n\n    vm->taint = 0;\n    vm->pid = -1;\n    virDomainObjSetState(vm, VIR_DOMAIN_SHUTOFF, reason);\n    for (i = 0; i < vm->def->niothreadids; i++)\n        vm->def->iothreadids[i]->thread_id = 0;\n\n    /* Do this explicitly after vm->pid is reset so that security drivers don't\n     * try to enter the domain's namespace which is non-existent by now as qemu\n     * is no longer running. */\n    if (!(flags & VIR_QEMU_PROCESS_STOP_NO_RELABEL)) {\n        for (i = 0; i < def->ndisks; i++) {\n            virDomainDiskDefPtr disk = def->disks[i];\n\n            if (disk->mirror)\n                qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n        }\n    }\n\n    /* clear all private data entries which are no longer needed */\n    qemuDomainObjPrivateDataClear(priv);\n\n    /* The \"release\" hook cleans up additional resources */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        g_autofree char *xml = qemuDomainDefFormatXML(driver, NULL, vm->def, 0);\n\n        /* we can't stop the operation even if the script raised an error */\n        virHookCall(VIR_HOOK_DRIVER_QEMU, vm->def->name,\n                    VIR_HOOK_QEMU_OP_RELEASE, VIR_HOOK_SUBOP_END,\n                    NULL, xml, NULL);\n    }\n\n    virDomainObjRemoveTransientDef(vm);\n\n endjob:\n    if (asyncJob != QEMU_ASYNC_JOB_NONE)\n        qemuDomainObjEndJob(driver, vm);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainAuditStart",
          "args": [
            "vm",
            "\"migrated\"",
            "false"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainAuditStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_audit.c",
          "lines": "771-840",
          "snippet": "void\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"viruuid.h\"",
            "#include \"viraudit.h\"",
            "#include \"domain_audit.h\"",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"viruuid.h\"\n#include \"viraudit.h\"\n#include \"domain_audit.h\"\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nvirDomainAuditStart(virDomainObjPtr vm, const char *reason, bool success)\n{\n    size_t i;\n\n    for (i = 0; i < vm->def->ndisks; i++)\n        virDomainAuditDisk(vm, NULL, vm->def->disks[i]->src, \"start\", true);\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n        virDomainAuditFS(vm, NULL, fs, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nnets; i++) {\n        virDomainNetDefPtr net = vm->def->nets[i];\n        virDomainAuditNet(vm, NULL, net, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = vm->def->hostdevs[i];\n        virDomainAuditHostdev(vm, hostdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nredirdevs; i++) {\n        virDomainRedirdevDefPtr redirdev = vm->def->redirdevs[i];\n        virDomainAuditRedirdev(vm, redirdev, \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nserials; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->serials[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nparallels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->parallels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nchannels; i++)\n        virDomainAuditChardev(vm, NULL, vm->def->channels[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nconsoles; i++) {\n        if (i == 0 &&\n            (vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_SERIAL ||\n             vm->def->consoles[i]->targetType == VIR_DOMAIN_CHR_CONSOLE_TARGET_TYPE_NONE) &&\n             vm->def->os.type == VIR_DOMAIN_OSTYPE_HVM)\n            continue;\n\n        virDomainAuditChardev(vm, NULL, vm->def->consoles[i], \"start\", true);\n    }\n\n    for (i = 0; i < vm->def->nsmartcards; i++)\n        virDomainAuditSmartcard(vm, vm->def->smartcards[i], \"start\", true);\n\n    for (i = 0; i < vm->def->nrngs; i++)\n        virDomainAuditRNG(vm, NULL, vm->def->rngs[i], \"start\", true);\n\n    if (vm->def->tpm)\n        virDomainAuditTPM(vm, vm->def->tpm, \"start\", true);\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        virDomainAuditShmem(vm, vm->def->shmems[i], \"start\", true);\n\n    for (i = 0; i < vm->def->ninputs; i++)\n        virDomainAuditInput(vm, vm->def->inputs[i], \"start\", true);\n\n    virDomainAuditMemory(vm, 0, virDomainDefGetMemoryTotal(vm->def),\n                         \"start\", true);\n    virDomainAuditVcpu(vm, 0, virDomainDefGetVcpus(vm->def), \"start\", true);\n    if (vm->def->niothreadids)\n        virDomainAuditIOThread(vm, 0, vm->def->niothreadids, \"start\", true);\n\n    virDomainAuditLifecycle(vm, \"start\", reason, success);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&origErr"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNWFilterUnlockFilterUpdates",
          "args": [],
          "line": 2716
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterUnlockFilterUpdates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "174-178",
          "snippet": "void\nvirNWFilterUnlockFilterUpdates(void)\n{\n    virRWLockUnlock(&updateLock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virRWLock updateLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\n\nvoid\nvirNWFilterUnlockFilterUpdates(void)\n{\n    virRWLockUnlock(&updateLock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainRemoveInactiveJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainRemoveInactiveJobLocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11335-11347",
          "snippet": "void\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainRemoveInactiveJobLocked(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    bool haveJob;\n\n    haveJob = qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) >= 0;\n\n    qemuDomainRemoveInactiveLocked(driver, vm);\n\n    if (haveJob)\n        qemuDomainObjEndJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjRemoveTransientDef",
          "args": [
            "vm"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjRemoveTransientDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3735-3745",
          "snippet": "void\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjRemoveTransientDef(virDomainObjPtr domain)\n{\n    if (!domain->newDef)\n        return;\n\n    virDomainDefFree(domain->def);\n    domain->def = domain->newDef;\n    domain->def->id = -1;\n    domain->newDef = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "priv->nbdPort"
          ],
          "line": 2708
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->origname"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "dataFD[1]"
          ],
          "line": 2699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "dataFD[0]"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xmlout"
          ],
          "line": 2697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuProcessIncomingDefFree",
          "args": [
            "incoming"
          ],
          "line": 2696
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessIncomingDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "4525-4535",
          "snippet": "void\nqemuProcessIncomingDefFree(qemuProcessIncomingDefPtr inc)\n{\n    if (!inc)\n        return;\n\n    VIR_FREE(inc->address);\n    VIR_FREE(inc->launchURI);\n    VIR_FREE(inc->deferredURI);\n    VIR_FREE(inc);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nqemuProcessIncomingDefFree(qemuProcessIncomingDefPtr inc)\n{\n    if (!inc)\n        return;\n\n    VIR_FREE(inc->address);\n    VIR_FREE(inc->launchURI);\n    VIR_FREE(inc->deferredURI);\n    VIR_FREE(inc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "tlsAlias"
          ],
          "line": 2695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&origErr"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobContinue",
          "args": [
            "vm"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5472-5476",
          "snippet": "static void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventLifecycleNewFromObj",
          "args": [
            "vm",
            "VIR_DOMAIN_EVENT_STARTED",
            "VIR_DOMAIN_EVENT_STARTED_MIGRATED"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventLifecycleNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "610-616",
          "snippet": "virObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventLifecycleNewFromObj(virDomainObjPtr obj,\n                                  int type,\n                                  int detail)\n{\n    return virDomainEventLifecycleNewFromDef(obj->def, type, detail);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainCleanupAdd",
          "args": [
            "vm",
            "qemuMigrationDstPrepareCleanup"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainCleanupAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11464-11485",
          "snippet": "int\nqemuDomainCleanupAdd(virDomainObjPtr vm,\n                     qemuDomainCleanupCallback cb)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    VIR_DEBUG(\"vm=%s, cb=%p\", vm->def->name, cb);\n\n    for (i = 0; i < priv->ncleanupCallbacks; i++) {\n        if (priv->cleanupCallbacks[i] == cb)\n            return 0;\n    }\n\n    if (VIR_RESIZE_N(priv->cleanupCallbacks,\n                     priv->ncleanupCallbacks_max,\n                     priv->ncleanupCallbacks, 1) < 0)\n        return -1;\n\n    priv->cleanupCallbacks[priv->ncleanupCallbacks++] = cb;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nint\nqemuDomainCleanupAdd(virDomainObjPtr vm,\n                     qemuDomainCleanupCallback cb)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    size_t i;\n\n    VIR_DEBUG(\"vm=%s, cb=%p\", vm->def->name, cb);\n\n    for (i = 0; i < priv->ncleanupCallbacks; i++) {\n        if (priv->cleanupCallbacks[i] == cb)\n            return 0;\n    }\n\n    if (VIR_RESIZE_N(priv->cleanupCallbacks,\n                     priv->ncleanupCallbacks_max,\n                     priv->ncleanupCallbacks, 1) < 0)\n        return -1;\n\n    priv->cleanupCallbacks[priv->ncleanupCallbacks++] = cb;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to encode migration cookie\""
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationBakeCookie",
          "args": [
            "mig",
            "driver",
            "vm",
            "QEMU_MIGRATION_DESTINATION",
            "cookieout",
            "cookieoutlen",
            "cookieFlags"
          ],
          "line": 2658
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationBakeCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1397-1459",
          "snippet": "int\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessFinishStartup",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "false",
            "VIR_DOMAIN_PAUSED_MIGRATION"
          ],
          "line": 2653
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessFinishStartup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7058-7091",
          "snippet": "int\nqemuProcessFinishStartup(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         bool startCPUs,\n                         virDomainPausedReason pausedReason)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (startCPUs) {\n        VIR_DEBUG(\"Starting domain CPUs\");\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_BOOTED,\n                                 asyncJob) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"resume operation failed\"));\n            return -1;\n        }\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, pausedReason);\n    }\n\n    VIR_DEBUG(\"Writing domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        return -1;\n\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_STARTED,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessFinishStartup(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob,\n                         bool startCPUs,\n                         virDomainPausedReason pausedReason)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (startCPUs) {\n        VIR_DEBUG(\"Starting domain CPUs\");\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_BOOTED,\n                                 asyncJob) < 0) {\n            if (virGetLastErrorCode() == VIR_ERR_OK)\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"resume operation failed\"));\n            return -1;\n        }\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, pausedReason);\n    }\n\n    VIR_DEBUG(\"Writing domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        return -1;\n\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_STARTED,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstRun",
          "args": [
            "driver",
            "vm",
            "incoming->deferredURI",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstRun",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1945-1973",
          "snippet": "int\nqemuMigrationDstRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *uri,\n                    qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rv;\n\n    VIR_DEBUG(\"Setting up incoming migration with URI %s\", uri);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorMigrateIncoming(priv->mon, uri);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        /* qemuMigrationDstWaitForCompletion is called from the Finish phase */\n        return 0;\n    }\n\n    if (qemuMigrationDstWaitForCompletion(driver, vm, asyncJob, false) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *uri,\n                    qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rv;\n\n    VIR_DEBUG(\"Setting up incoming migration with URI %s\", uri);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorMigrateIncoming(priv->mon, uri);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        /* qemuMigrationDstWaitForCompletion is called from the Finish phase */\n        return 0;\n    }\n\n    if (qemuMigrationDstWaitForCompletion(driver, vm, asyncJob, false) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Received no lockstate\""
          ],
          "line": 2645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->lockState"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Received lockstate %s\"",
            "mig->lockState"
          ],
          "line": 2640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstStartNBDServer",
          "args": [
            "driver",
            "vm",
            "incoming->address",
            "nmigrate_disks",
            "migrate_disks",
            "nbdPort",
            "nbdTLSAlias"
          ],
          "line": 2631
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstStartNBDServer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "369-453",
          "snippet": "static int\nqemuMigrationDstStartNBDServer(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const char *listenAddr,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               int nbdPort,\n                               const char *tls_alias)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned short port = 0;\n    size_t i;\n    virStorageNetHostDef server = {\n        .name = (char *)listenAddr, /* cast away const */\n        .transport = VIR_STORAGE_NET_HOST_TRANS_TCP,\n    };\n\n    if (nbdPort < 0 || nbdPort > USHRT_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nbd port must be in range 0-65535\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        g_autofree char *diskAlias = NULL;\n        const char *exportname = NULL;\n        const char *devicename = NULL;\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (disk->src->readonly || virStorageSourceIsEmpty(disk->src)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"Cannot migrate empty or read-only disk %s\"),\n                           disk->dst);\n            goto cleanup;\n        }\n\n        if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n            goto cleanup;\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            exportname = diskAlias;\n            devicename = disk->src->nodeformat;\n        } else {\n            exportname = NULL;\n            devicename = diskAlias;\n        }\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            goto cleanup;\n\n        if (port == 0) {\n            if (nbdPort)\n                port = nbdPort;\n            else if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto exit_monitor;\n\n            server.port = port;\n            if (qemuMonitorNBDServerStart(priv->mon, &server, tls_alias) < 0)\n                goto exit_monitor;\n        }\n\n        if (qemuMonitorNBDServerAdd(priv->mon, devicename, exportname, true, NULL) < 0)\n            goto exit_monitor;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    priv->nbdPort = port;\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && nbdPort == 0)\n        virPortAllocatorRelease(port);\n    return ret;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstStartNBDServer(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const char *listenAddr,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               int nbdPort,\n                               const char *tls_alias)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned short port = 0;\n    size_t i;\n    virStorageNetHostDef server = {\n        .name = (char *)listenAddr, /* cast away const */\n        .transport = VIR_STORAGE_NET_HOST_TRANS_TCP,\n    };\n\n    if (nbdPort < 0 || nbdPort > USHRT_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nbd port must be in range 0-65535\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        g_autofree char *diskAlias = NULL;\n        const char *exportname = NULL;\n        const char *devicename = NULL;\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (disk->src->readonly || virStorageSourceIsEmpty(disk->src)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"Cannot migrate empty or read-only disk %s\"),\n                           disk->dst);\n            goto cleanup;\n        }\n\n        if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n            goto cleanup;\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            exportname = diskAlias;\n            devicename = disk->src->nodeformat;\n        } else {\n            exportname = NULL;\n            devicename = diskAlias;\n        }\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            goto cleanup;\n\n        if (port == 0) {\n            if (nbdPort)\n                port = nbdPort;\n            else if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto exit_monitor;\n\n            server.port = port;\n            if (qemuMonitorNBDServerStart(priv->mon, &server, tls_alias) < 0)\n                goto exit_monitor;\n        }\n\n        if (qemuMonitorNBDServerAdd(priv->mon, devicename, exportname, true, NULL) < 0)\n            goto exit_monitor;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    priv->nbdPort = port;\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && nbdPort == 0)\n        virPortAllocatorRelease(port);\n    return ret;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"QEMU NBD server does not support TLS transport\")"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QEMU NBD server does not support TLS transport\""
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_NBD_TLS"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsApply",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "migParams"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "832-905",
          "snippet": "int\nqemuMigrationParamsApply(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool xbzrleCacheSize_old = false;\n    virJSONValuePtr params = NULL;\n    virJSONValuePtr caps = NULL;\n    qemuMigrationParam xbzrle = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE;\n    int ret = -1;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_NONE) {\n        if (!virBitmapIsAllClear(migParams->caps)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Migration capabilities can only be set by \"\n                             \"a migration job\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(caps = qemuMigrationCapsToJSON(priv->migrationCaps, migParams->caps)))\n            goto cleanup;\n\n        if (virJSONValueArraySize(caps) > 0) {\n            rc = qemuMonitorSetMigrationCapabilities(priv->mon, caps);\n            caps = NULL;\n            if (rc < 0)\n                goto cleanup;\n        }\n    }\n\n    /* If QEMU is too old to support xbzrle-cache-size migration parameter,\n     * we need to set it via migrate-set-cache-size and tell\n     * qemuMonitorSetMigrationParams to ignore this parameter.\n     */\n    if (migParams->params[xbzrle].set &&\n        (!priv->job.migParams ||\n         !priv->job.migParams->params[xbzrle].set)) {\n        if (qemuMonitorSetMigrationCacheSize(priv->mon,\n                                             migParams->params[xbzrle].value.ull) < 0)\n            goto cleanup;\n        xbzrleCacheSize_old = true;\n        migParams->params[xbzrle].set = false;\n    }\n\n    if (!(params = qemuMigrationParamsToJSON(migParams)))\n        goto cleanup;\n\n    if (virJSONValueObjectKeysNumber(params) > 0) {\n        rc = qemuMonitorSetMigrationParams(priv->mon, params);\n        params = NULL;\n        if (rc < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (xbzrleCacheSize_old)\n        migParams->params[xbzrle].set = true;\n\n    virJSONValueFree(params);\n    virJSONValueFree(caps);\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nqemuMigrationParamsApply(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool xbzrleCacheSize_old = false;\n    virJSONValuePtr params = NULL;\n    virJSONValuePtr caps = NULL;\n    qemuMigrationParam xbzrle = QEMU_MIGRATION_PARAM_XBZRLE_CACHE_SIZE;\n    int ret = -1;\n    int rc;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_NONE) {\n        if (!virBitmapIsAllClear(migParams->caps)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Migration capabilities can only be set by \"\n                             \"a migration job\"));\n            goto cleanup;\n        }\n    } else {\n        if (!(caps = qemuMigrationCapsToJSON(priv->migrationCaps, migParams->caps)))\n            goto cleanup;\n\n        if (virJSONValueArraySize(caps) > 0) {\n            rc = qemuMonitorSetMigrationCapabilities(priv->mon, caps);\n            caps = NULL;\n            if (rc < 0)\n                goto cleanup;\n        }\n    }\n\n    /* If QEMU is too old to support xbzrle-cache-size migration parameter,\n     * we need to set it via migrate-set-cache-size and tell\n     * qemuMonitorSetMigrationParams to ignore this parameter.\n     */\n    if (migParams->params[xbzrle].set &&\n        (!priv->job.migParams ||\n         !priv->job.migParams->params[xbzrle].set)) {\n        if (qemuMonitorSetMigrationCacheSize(priv->mon,\n                                             migParams->params[xbzrle].value.ull) < 0)\n            goto cleanup;\n        xbzrleCacheSize_old = true;\n        migParams->params[xbzrle].set = false;\n    }\n\n    if (!(params = qemuMigrationParamsToJSON(migParams)))\n        goto cleanup;\n\n    if (virJSONValueObjectKeysNumber(params) > 0) {\n        rc = qemuMonitorSetMigrationParams(priv->mon, params);\n        params = NULL;\n        if (rc < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (xbzrleCacheSize_old)\n        migParams->params[xbzrle].set = true;\n\n    virJSONValueFree(params);\n    virJSONValueFree(caps);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsDisableTLS",
          "args": [
            "vm",
            "migParams"
          ],
          "line": 2608
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsDisableTLS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1038-1054",
          "snippet": "int\nqemuMigrationParamsDisableTLS(virDomainObjPtr vm,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set)\n        return 0;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS, \"\") < 0 ||\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME, \"\") < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nqemuMigrationParamsDisableTLS(virDomainObjPtr vm,\n                              qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set)\n        return 0;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS, \"\") < 0 ||\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME, \"\") < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsEnableTLS",
          "args": [
            "driver",
            "vm",
            "true",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "&tlsAlias",
            "NULL",
            "migParams"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsEnableTLS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "948-1025",
          "snippet": "int\nqemuMigrationParamsEnableTLS(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             bool tlsListen,\n                             int asyncJob,\n                             char **tlsAlias,\n                             const char *hostname,\n                             qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virJSONValuePtr tlsProps = NULL;\n    virJSONValuePtr secProps = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *secAlias = NULL;\n    int ret = -1;\n\n    if (!cfg->migrateTLSx509certdir) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"host migration TLS directory not configured\"));\n        goto error;\n    }\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"TLS migration is not supported with this \"\n                         \"QEMU binary\"));\n        goto error;\n    }\n\n    /* If there's a secret, then grab/store it now using the connection */\n    if (cfg->migrateTLSx509secretUUID) {\n        if (!(priv->migSecinfo =\n              qemuDomainSecretInfoTLSNew(priv, QEMU_MIGRATION_TLS_ALIAS_BASE,\n                                         cfg->migrateTLSx509secretUUID)))\n            goto error;\n        secAlias = priv->migSecinfo->s.aes.alias;\n    }\n\n    if (!(*tlsAlias = qemuAliasTLSObjFromSrcAlias(QEMU_MIGRATION_TLS_ALIAS_BASE)))\n        goto error;\n\n    if (qemuDomainGetTLSObjects(priv->qemuCaps, priv->migSecinfo,\n                                cfg->migrateTLSx509certdir, tlsListen,\n                                cfg->migrateTLSx509verify,\n                                *tlsAlias, &tlsProps, &secProps) < 0)\n        goto error;\n\n    /* Ensure the domain doesn't already have the TLS objects defined...\n     * This should prevent any issues just in case some cleanup wasn't\n     * properly completed (both src and dst use the same alias) or\n     * some other error path between now and perform . */\n    qemuDomainDelTLSObjects(driver, vm, asyncJob, secAlias, *tlsAlias);\n\n    if (qemuDomainAddTLSObjects(driver, vm, asyncJob, &secProps, &tlsProps) < 0)\n        goto error;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS,\n                                     *tlsAlias) < 0)\n        goto error;\n\n    if (!migParams->params[QEMU_MIGRATION_PARAM_TLS_HOSTNAME].set &&\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n                                     NULLSTR_EMPTY(hostname)) < 0)\n        goto error;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virJSONValueFree(tlsProps);\n    virJSONValueFree(secProps);\n    goto cleanup;\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_MIGRATION_TLS_ALIAS_BASE \"libvirt_migrate\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\n#define QEMU_MIGRATION_TLS_ALIAS_BASE \"libvirt_migrate\"\n\nint\nqemuMigrationParamsEnableTLS(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             bool tlsListen,\n                             int asyncJob,\n                             char **tlsAlias,\n                             const char *hostname,\n                             qemuMigrationParamsPtr migParams)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virJSONValuePtr tlsProps = NULL;\n    virJSONValuePtr secProps = NULL;\n    virQEMUDriverConfigPtr cfg = virQEMUDriverGetConfig(driver);\n    const char *secAlias = NULL;\n    int ret = -1;\n\n    if (!cfg->migrateTLSx509certdir) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"host migration TLS directory not configured\"));\n        goto error;\n    }\n\n    if (!priv->job.migParams->params[QEMU_MIGRATION_PARAM_TLS_CREDS].set) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"TLS migration is not supported with this \"\n                         \"QEMU binary\"));\n        goto error;\n    }\n\n    /* If there's a secret, then grab/store it now using the connection */\n    if (cfg->migrateTLSx509secretUUID) {\n        if (!(priv->migSecinfo =\n              qemuDomainSecretInfoTLSNew(priv, QEMU_MIGRATION_TLS_ALIAS_BASE,\n                                         cfg->migrateTLSx509secretUUID)))\n            goto error;\n        secAlias = priv->migSecinfo->s.aes.alias;\n    }\n\n    if (!(*tlsAlias = qemuAliasTLSObjFromSrcAlias(QEMU_MIGRATION_TLS_ALIAS_BASE)))\n        goto error;\n\n    if (qemuDomainGetTLSObjects(priv->qemuCaps, priv->migSecinfo,\n                                cfg->migrateTLSx509certdir, tlsListen,\n                                cfg->migrateTLSx509verify,\n                                *tlsAlias, &tlsProps, &secProps) < 0)\n        goto error;\n\n    /* Ensure the domain doesn't already have the TLS objects defined...\n     * This should prevent any issues just in case some cleanup wasn't\n     * properly completed (both src and dst use the same alias) or\n     * some other error path between now and perform . */\n    qemuDomainDelTLSObjects(driver, vm, asyncJob, secAlias, *tlsAlias);\n\n    if (qemuDomainAddTLSObjects(driver, vm, asyncJob, &secProps, &tlsProps) < 0)\n        goto error;\n\n    if (qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_CREDS,\n                                     *tlsAlias) < 0)\n        goto error;\n\n    if (!migParams->params[QEMU_MIGRATION_PARAM_TLS_HOSTNAME].set &&\n        qemuMigrationParamsSetString(migParams,\n                                     QEMU_MIGRATION_PARAM_TLS_HOSTNAME,\n                                     NULLSTR_EMPTY(hostname)) < 0)\n        goto error;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnref(cfg);\n    return ret;\n\n error:\n    virJSONValueFree(tlsProps);\n    virJSONValueFree(secProps);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsCheck",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "migParams",
            "mig->caps->automatic"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsCheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1165-1227",
          "snippet": "int\nqemuMigrationParamsCheck(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams,\n                         virBitmapPtr remoteCaps)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCapability cap;\n    qemuMigrationParty party;\n    size_t i;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        party = QEMU_MIGRATION_SOURCE;\n    else\n        party = QEMU_MIGRATION_DESTINATION;\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool state = false;\n\n        ignore_value(virBitmapGetBit(migParams->caps, cap, &state));\n\n        if (state && !qemuMigrationCapsGet(vm, cap)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"Migration option '%s' is not supported by QEMU binary\"),\n                           qemuMigrationCapabilityTypeToString(cap));\n            return -1;\n        }\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        cap = qemuMigrationParamsAlwaysOn[i].cap;\n\n        if (qemuMigrationParamsAlwaysOn[i].party & party &&\n            qemuMigrationCapsGet(vm, cap)) {\n            if (qemuMigrationParamsAlwaysOn[i].party != party) {\n                bool remote = false;\n\n                if (remoteCaps)\n                    ignore_value(virBitmapGetBit(remoteCaps, cap, &remote));\n\n                if (!remote) {\n                    VIR_DEBUG(\"Not enabling migration capability '%s'; it is \"\n                              \"not supported or automatically enabled by the \"\n                              \"other side of migration\",\n                              qemuMigrationCapabilityTypeToString(cap));\n                    continue;\n                }\n            }\n\n            VIR_DEBUG(\"Enabling migration capability '%s'\",\n                      qemuMigrationCapabilityTypeToString(cap));\n            ignore_value(virBitmapSetBit(migParams->caps, cap));\n        }\n    }\n\n    /*\n     * We want to disable all migration capabilities after migration, no need\n     * to ask QEMU for their current settings.\n     */\n\n    return qemuMigrationParamsFetch(driver, vm, asyncJob, &priv->job.migParams);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const qemuMigrationParamsAlwaysOnItem qemuMigrationParamsAlwaysOn[] = {\n    {QEMU_MIGRATION_CAP_PAUSE_BEFORE_SWITCHOVER,\n     QEMU_MIGRATION_SOURCE},\n\n    {QEMU_MIGRATION_CAP_LATE_BLOCK_ACTIVATE,\n     QEMU_MIGRATION_DESTINATION},\n};\n\nint\nqemuMigrationParamsCheck(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr migParams,\n                         virBitmapPtr remoteCaps)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMigrationCapability cap;\n    qemuMigrationParty party;\n    size_t i;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        party = QEMU_MIGRATION_SOURCE;\n    else\n        party = QEMU_MIGRATION_DESTINATION;\n\n    for (cap = 0; cap < QEMU_MIGRATION_CAP_LAST; cap++) {\n        bool state = false;\n\n        ignore_value(virBitmapGetBit(migParams->caps, cap, &state));\n\n        if (state && !qemuMigrationCapsGet(vm, cap)) {\n            virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                           _(\"Migration option '%s' is not supported by QEMU binary\"),\n                           qemuMigrationCapabilityTypeToString(cap));\n            return -1;\n        }\n    }\n\n    for (i = 0; i < G_N_ELEMENTS(qemuMigrationParamsAlwaysOn); i++) {\n        cap = qemuMigrationParamsAlwaysOn[i].cap;\n\n        if (qemuMigrationParamsAlwaysOn[i].party & party &&\n            qemuMigrationCapsGet(vm, cap)) {\n            if (qemuMigrationParamsAlwaysOn[i].party != party) {\n                bool remote = false;\n\n                if (remoteCaps)\n                    ignore_value(virBitmapGetBit(remoteCaps, cap, &remote));\n\n                if (!remote) {\n                    VIR_DEBUG(\"Not enabling migration capability '%s'; it is \"\n                              \"not supported or automatically enabled by the \"\n                              \"other side of migration\",\n                              qemuMigrationCapabilityTypeToString(cap));\n                    continue;\n                }\n            }\n\n            VIR_DEBUG(\"Enabling migration capability '%s'\",\n                      qemuMigrationCapabilityTypeToString(cap));\n            ignore_value(virBitmapSetBit(migParams->caps, cap));\n        }\n    }\n\n    /*\n     * We want to disable all migration capabilities after migration, no need\n     * to ask QEMU for their current settings.\n     */\n\n    return qemuMigrationParamsFetch(driver, vm, asyncJob, &priv->job.migParams);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virProcessSetMaxMemLock",
          "args": [
            "vm->pid",
            "vm->def->mem.hard_limit << 10"
          ],
          "line": 2591
        },
        "resolved": true,
        "details": {
          "function_name": "virProcessSetMaxMemLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virprocess.c",
          "lines": "772-780",
          "snippet": "int\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#   include <sys/syscall.h>",
            "#include \"vircommand.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virprocess.h\"",
            "# include <windows.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "# include <sys/param.h>",
            "# include <sched.h>",
            "# include <sys/resource.h>",
            "# include <sys/time.h>",
            "# include <sys/mount.h>",
            "#include <unistd.h>",
            "# include <sys/wait.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#   include <sys/syscall.h>\n#include \"vircommand.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virprocess.h\"\n# include <windows.h>\n# include <sys/cpuset.h>\n# include <sys/user.h>\n# include <sys/sysctl.h>\n# include <sys/param.h>\n# include <sched.h>\n# include <sys/resource.h>\n# include <sys/time.h>\n# include <sys/mount.h>\n#include <unistd.h>\n# include <sys/wait.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirProcessSetMaxMemLock(pid_t pid G_GNUC_UNUSED, unsigned long long bytes)\n{\n    if (bytes == 0)\n        return 0;\n\n    virReportSystemError(ENOSYS, \"%s\", _(\"Not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "protocol",
            "\"rdma\""
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "\"%s\"",
            "_(\"cannot pass pipe for tunnelled migration\")"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFDStreamOpen",
          "args": [
            "st",
            "dataFD[1]"
          ],
          "line": 2582
        },
        "resolved": true,
        "details": {
          "function_name": "virFDStreamOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfdstream.c",
          "lines": "1425-1432",
          "snippet": "int\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virfdstream.h\"",
            "# include <termios.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virprocess.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virfdstream.h\"\n# include <termios.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirFDStreamOpen(virStreamPtr st G_GNUC_UNUSED,\n                int fd G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"File streams are not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessLaunch",
          "args": [
            "dconn",
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "incoming",
            "NULL",
            "VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START",
            "startFlags"
          ],
          "line": 2570
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessLaunch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "6674-7010",
          "snippet": "int\nqemuProcessLaunch(virConnectPtr conn,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  qemuDomainAsyncJob asyncJob,\n                  qemuProcessIncomingDefPtr incoming,\n                  virDomainMomentObjPtr snapshot,\n                  virNetDevVPortProfileOp vmop,\n                  unsigned int flags)\n{\n    int ret = -1;\n    int rv;\n    int logfile = -1;\n    g_autoptr(qemuDomainLogContext) logCtxt = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCommand) cmd = NULL;\n    struct qemuProcessHookData hookData;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t nnicindexes = 0;\n    g_autofree int *nicindexes = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s if=%d asyncJob=%d \"\n              \"incoming.launchURI=%s incoming.deferredURI=%s \"\n              \"incoming.fd=%d incoming.path=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id, asyncJob,\n              NULLSTR(incoming ? incoming->launchURI : NULL),\n              NULLSTR(incoming ? incoming->deferredURI : NULL),\n              incoming ? incoming->fd : -1,\n              NULLSTR(incoming ? incoming->path : NULL),\n              snapshot, vmop, flags);\n\n    /* Okay, these are just internal flags,\n     * but doesn't hurt to check */\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY |\n                  VIR_QEMU_PROCESS_START_NEW |\n                  VIR_QEMU_PROCESS_START_GEN_VMID, -1);\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY) {\n        if (!conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy requires a connection handle\"));\n            return -1;\n        }\n        if (driver->embeddedRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy not supported for embedded drivers yet\"));\n            return -1;\n        }\n    }\n\n    hookData.vm = vm;\n    hookData.driver = driver;\n    /* We don't increase cfg's reference counter here. */\n    hookData.cfg = cfg;\n\n    VIR_DEBUG(\"Creating domain log file\");\n    if (!(logCtxt = qemuDomainLogContextNew(driver, vm,\n                                            QEMU_DOMAIN_LOG_CONTEXT_MODE_START))) {\n        virLastErrorPrefixMessage(\"%s\", _(\"can't connect to virtlogd\"));\n        goto cleanup;\n    }\n    logfile = qemuDomainLogContextGetWriteFD(logCtxt);\n\n    if (qemuProcessGenID(vm, flags) < 0)\n        goto cleanup;\n\n    if (qemuExtDevicesStart(driver, vm,\n                            qemuDomainLogContextGetManager(logCtxt),\n                            incoming != NULL) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    if (!(cmd = qemuBuildCommandLine(driver,\n                                     qemuDomainLogContextGetManager(logCtxt),\n                                     driver->securityManager,\n                                     vm,\n                                     incoming ? incoming->launchURI : NULL,\n                                     snapshot, vmop,\n                                     false,\n                                     qemuCheckFips(),\n                                     &nnicindexes, &nicindexes)))\n        goto cleanup;\n\n    if (incoming && incoming->fd != -1)\n        virCommandPassFD(cmd, incoming->fd, 0);\n\n    /* now that we know it is about to start call the hook if present */\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_START,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    qemuLogOperation(vm, \"starting up\", cmd, logCtxt);\n\n    qemuDomainObjCheckTaint(driver, vm, logCtxt);\n\n    qemuDomainLogContextMarkPosition(logCtxt);\n\n    VIR_DEBUG(\"Building mount namespace\");\n\n    if (qemuDomainCreateNamespace(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up raw IO\");\n    if (qemuProcessSetupRawIO(driver, vm, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetPreExecHook(cmd, qemuProcessHook, &hookData);\n    virCommandSetMaxProcesses(cmd, cfg->maxProcesses);\n    virCommandSetMaxFiles(cmd, cfg->maxFiles);\n    virCommandSetMaxCoreSize(cmd, cfg->maxCore);\n    virCommandSetUmask(cmd, 0x002);\n\n    VIR_DEBUG(\"Setting up security labelling\");\n    if (qemuSecuritySetChildProcessLabel(driver->securityManager,\n                                         vm->def, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfile);\n    virCommandSetErrorFD(cmd, &logfile);\n    virCommandNonblockingFDs(cmd);\n    virCommandSetPidFile(cmd, priv->pidfile);\n    virCommandDaemonize(cmd);\n    virCommandRequireHandshake(cmd);\n\n    if (qemuSecurityPreFork(driver->securityManager) < 0)\n        goto cleanup;\n    rv = virCommandRun(cmd, NULL);\n    qemuSecurityPostFork(driver->securityManager);\n\n    /* wait for qemu process to show up */\n    if (rv == 0) {\n        if ((rv = virPidFileReadPath(priv->pidfile, &vm->pid)) < 0) {\n            virReportSystemError(-rv,\n                                 _(\"Domain %s didn't show up\"),\n                                 vm->def->name);\n            goto cleanup;\n        }\n        VIR_DEBUG(\"QEMU vm=%p name=%s running with pid=%lld\",\n                  vm, vm->def->name, (long long)vm->pid);\n    } else {\n        VIR_DEBUG(\"QEMU vm=%p name=%s failed to spawn\",\n                  vm, vm->def->name);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Writing early domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for handshake from child\");\n    if (virCommandHandshakeWait(cmd) < 0) {\n        /* Read errors from child that occurred between fork and exec. */\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"Process exited prior to exec\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Setting up domain cgroup (if required)\");\n    if (qemuSetupCgroup(vm, nnicindexes, nicindexes) < 0)\n        goto cleanup;\n\n    if (!(priv->perf = virPerfNew()))\n        goto cleanup;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (vm->def->perf.events[i] == VIR_TRISTATE_BOOL_YES &&\n            virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n            goto cleanup;\n    }\n\n    /* This must be done after cgroup placement to avoid resetting CPU\n     * affinity */\n    if (qemuProcessInitCpuAffinity(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator tuning/settings\");\n    if (qemuProcessSetupEmulator(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting cgroup for external devices (if required)\");\n    if (qemuSetupCgroupForExtDevices(vm, driver) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up resctrl\");\n    if (qemuProcessResctrlCreate(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up managed PR daemon\");\n    if (virDomainDefHasManagedPR(vm->def) &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (qemuSecuritySetAllLabel(driver,\n                                vm,\n                                incoming ? incoming->path : NULL,\n                                incoming != NULL) < 0)\n        goto cleanup;\n\n    /* Security manager labeled all devices, therefore\n     * if any operation from now on fails, we need to ask the caller to\n     * restore labels.\n     */\n    ret = -2;\n\n    if (incoming && incoming->fd != -1) {\n        /* if there's an fd to migrate from, and it's a pipe, put the\n         * proper security label on it\n         */\n        struct stat stdin_sb;\n\n        VIR_DEBUG(\"setting security label on pipe used for migration\");\n\n        if (fstat(incoming->fd, &stdin_sb) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot stat fd %d\"), incoming->fd);\n            goto cleanup;\n        }\n        if (S_ISFIFO(stdin_sb.st_mode) &&\n            qemuSecuritySetImageFDLabel(driver->securityManager,\n                                        vm->def, incoming->fd) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Labelling done, completing handshake to child\");\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n    VIR_DEBUG(\"Handshake complete, child running\");\n\n    if (rv == -1) /* The VM failed to start; tear filters before taps */\n        virDomainConfVMNWFilterTeardown(vm);\n\n    if (rv == -1) /* The VM failed to start */\n        goto cleanup;\n\n    if (qemuDomainObjStartWorker(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for monitor to show up\");\n    if (qemuProcessWaitForMonitor(driver, vm, asyncJob, logCtxt) < 0)\n        goto cleanup;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Verifying and updating provided guest CPU\");\n    if (qemuProcessUpdateAndVerifyCPU(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"setting up hotpluggable cpus\");\n    if (qemuDomainHasHotpluggableStartupVcpus(vm->def)) {\n        if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n            goto cleanup;\n\n        if (qemuProcessValidateHotpluggableVcpus(vm->def) < 0)\n            goto cleanup;\n\n        if (qemuProcessSetupHotpluggableVcpus(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Refreshing VCPU info\");\n    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n        goto cleanup;\n\n    if (qemuDomainValidateVcpuInfo(vm) < 0)\n        goto cleanup;\n\n    qemuDomainVcpuPersistOrder(vm->def);\n\n    VIR_DEBUG(\"Detecting IOThread PIDs\");\n    if (qemuProcessDetectIOThreadPIDs(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting global CPU cgroup (if required)\");\n    if (qemuSetupGlobalCpuCgroup(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting vCPU tuning/settings\");\n    if (qemuProcessSetupVcpus(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting IOThread tuning/settings\");\n    if (qemuProcessSetupIOThreads(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator scheduler\");\n    if (vm->def->cputune.emulatorsched &&\n        virProcessSetScheduler(vm->pid,\n                               vm->def->cputune.emulatorsched->policy,\n                               vm->def->cputune.emulatorsched->priority) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting any required VM passwords\");\n    if (qemuProcessInitPasswords(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* set default link states */\n    /* qemu doesn't support setting this on the command line, so\n     * enter the monitor */\n    VIR_DEBUG(\"Setting network link states\");\n    if (qemuProcessSetLinkStates(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting initial memory amount\");\n    if (qemuProcessSetupBalloon(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuProcessSetupDiskThrottlingBlockdev(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* Since CPUs were not started yet, the balloon could not return the memory\n     * to the host and thus cur_balloon needs to be updated so that GetXMLdesc\n     * and friends return the correct size in case they can't grab the job */\n    if (!incoming && !snapshot &&\n        qemuProcessRefreshBalloonState(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY &&\n        qemuProcessAutoDestroyAdd(driver, vm, conn) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        qemuExtDevicesStop(driver, vm);\n    qemuDomainSecretDestroy(vm);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessLaunch(virConnectPtr conn,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  qemuDomainAsyncJob asyncJob,\n                  qemuProcessIncomingDefPtr incoming,\n                  virDomainMomentObjPtr snapshot,\n                  virNetDevVPortProfileOp vmop,\n                  unsigned int flags)\n{\n    int ret = -1;\n    int rv;\n    int logfile = -1;\n    g_autoptr(qemuDomainLogContext) logCtxt = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virCommand) cmd = NULL;\n    struct qemuProcessHookData hookData;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    size_t nnicindexes = 0;\n    g_autofree int *nicindexes = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"conn=%p driver=%p vm=%p name=%s if=%d asyncJob=%d \"\n              \"incoming.launchURI=%s incoming.deferredURI=%s \"\n              \"incoming.fd=%d incoming.path=%s \"\n              \"snapshot=%p vmop=%d flags=0x%x\",\n              conn, driver, vm, vm->def->name, vm->def->id, asyncJob,\n              NULLSTR(incoming ? incoming->launchURI : NULL),\n              NULLSTR(incoming ? incoming->deferredURI : NULL),\n              incoming ? incoming->fd : -1,\n              NULLSTR(incoming ? incoming->path : NULL),\n              snapshot, vmop, flags);\n\n    /* Okay, these are just internal flags,\n     * but doesn't hurt to check */\n    virCheckFlags(VIR_QEMU_PROCESS_START_COLD |\n                  VIR_QEMU_PROCESS_START_PAUSED |\n                  VIR_QEMU_PROCESS_START_AUTODESTROY |\n                  VIR_QEMU_PROCESS_START_NEW |\n                  VIR_QEMU_PROCESS_START_GEN_VMID, -1);\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY) {\n        if (!conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy requires a connection handle\"));\n            return -1;\n        }\n        if (driver->embeddedRoot) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Domain autodestroy not supported for embedded drivers yet\"));\n            return -1;\n        }\n    }\n\n    hookData.vm = vm;\n    hookData.driver = driver;\n    /* We don't increase cfg's reference counter here. */\n    hookData.cfg = cfg;\n\n    VIR_DEBUG(\"Creating domain log file\");\n    if (!(logCtxt = qemuDomainLogContextNew(driver, vm,\n                                            QEMU_DOMAIN_LOG_CONTEXT_MODE_START))) {\n        virLastErrorPrefixMessage(\"%s\", _(\"can't connect to virtlogd\"));\n        goto cleanup;\n    }\n    logfile = qemuDomainLogContextGetWriteFD(logCtxt);\n\n    if (qemuProcessGenID(vm, flags) < 0)\n        goto cleanup;\n\n    if (qemuExtDevicesStart(driver, vm,\n                            qemuDomainLogContextGetManager(logCtxt),\n                            incoming != NULL) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Building emulator command line\");\n    if (!(cmd = qemuBuildCommandLine(driver,\n                                     qemuDomainLogContextGetManager(logCtxt),\n                                     driver->securityManager,\n                                     vm,\n                                     incoming ? incoming->launchURI : NULL,\n                                     snapshot, vmop,\n                                     false,\n                                     qemuCheckFips(),\n                                     &nnicindexes, &nicindexes)))\n        goto cleanup;\n\n    if (incoming && incoming->fd != -1)\n        virCommandPassFD(cmd, incoming->fd, 0);\n\n    /* now that we know it is about to start call the hook if present */\n    if (qemuProcessStartHook(driver, vm,\n                             VIR_HOOK_QEMU_OP_START,\n                             VIR_HOOK_SUBOP_BEGIN) < 0)\n        goto cleanup;\n\n    qemuLogOperation(vm, \"starting up\", cmd, logCtxt);\n\n    qemuDomainObjCheckTaint(driver, vm, logCtxt);\n\n    qemuDomainLogContextMarkPosition(logCtxt);\n\n    VIR_DEBUG(\"Building mount namespace\");\n\n    if (qemuDomainCreateNamespace(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up raw IO\");\n    if (qemuProcessSetupRawIO(driver, vm, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetPreExecHook(cmd, qemuProcessHook, &hookData);\n    virCommandSetMaxProcesses(cmd, cfg->maxProcesses);\n    virCommandSetMaxFiles(cmd, cfg->maxFiles);\n    virCommandSetMaxCoreSize(cmd, cfg->maxCore);\n    virCommandSetUmask(cmd, 0x002);\n\n    VIR_DEBUG(\"Setting up security labelling\");\n    if (qemuSecuritySetChildProcessLabel(driver->securityManager,\n                                         vm->def, cmd) < 0)\n        goto cleanup;\n\n    virCommandSetOutputFD(cmd, &logfile);\n    virCommandSetErrorFD(cmd, &logfile);\n    virCommandNonblockingFDs(cmd);\n    virCommandSetPidFile(cmd, priv->pidfile);\n    virCommandDaemonize(cmd);\n    virCommandRequireHandshake(cmd);\n\n    if (qemuSecurityPreFork(driver->securityManager) < 0)\n        goto cleanup;\n    rv = virCommandRun(cmd, NULL);\n    qemuSecurityPostFork(driver->securityManager);\n\n    /* wait for qemu process to show up */\n    if (rv == 0) {\n        if ((rv = virPidFileReadPath(priv->pidfile, &vm->pid)) < 0) {\n            virReportSystemError(-rv,\n                                 _(\"Domain %s didn't show up\"),\n                                 vm->def->name);\n            goto cleanup;\n        }\n        VIR_DEBUG(\"QEMU vm=%p name=%s running with pid=%lld\",\n                  vm, vm->def->name, (long long)vm->pid);\n    } else {\n        VIR_DEBUG(\"QEMU vm=%p name=%s failed to spawn\",\n                  vm, vm->def->name);\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Writing early domain status to disk\");\n    if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for handshake from child\");\n    if (virCommandHandshakeWait(cmd) < 0) {\n        /* Read errors from child that occurred between fork and exec. */\n        qemuProcessReportLogError(logCtxt,\n                                  _(\"Process exited prior to exec\"));\n        goto cleanup;\n    }\n\n    VIR_DEBUG(\"Setting up domain cgroup (if required)\");\n    if (qemuSetupCgroup(vm, nnicindexes, nicindexes) < 0)\n        goto cleanup;\n\n    if (!(priv->perf = virPerfNew()))\n        goto cleanup;\n\n    for (i = 0; i < VIR_PERF_EVENT_LAST; i++) {\n        if (vm->def->perf.events[i] == VIR_TRISTATE_BOOL_YES &&\n            virPerfEventEnable(priv->perf, i, vm->pid) < 0)\n            goto cleanup;\n    }\n\n    /* This must be done after cgroup placement to avoid resetting CPU\n     * affinity */\n    if (qemuProcessInitCpuAffinity(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator tuning/settings\");\n    if (qemuProcessSetupEmulator(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting cgroup for external devices (if required)\");\n    if (qemuSetupCgroupForExtDevices(vm, driver) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up resctrl\");\n    if (qemuProcessResctrlCreate(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting up managed PR daemon\");\n    if (virDomainDefHasManagedPR(vm->def) &&\n        qemuProcessStartManagedPRDaemon(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting domain security labels\");\n    if (qemuSecuritySetAllLabel(driver,\n                                vm,\n                                incoming ? incoming->path : NULL,\n                                incoming != NULL) < 0)\n        goto cleanup;\n\n    /* Security manager labeled all devices, therefore\n     * if any operation from now on fails, we need to ask the caller to\n     * restore labels.\n     */\n    ret = -2;\n\n    if (incoming && incoming->fd != -1) {\n        /* if there's an fd to migrate from, and it's a pipe, put the\n         * proper security label on it\n         */\n        struct stat stdin_sb;\n\n        VIR_DEBUG(\"setting security label on pipe used for migration\");\n\n        if (fstat(incoming->fd, &stdin_sb) < 0) {\n            virReportSystemError(errno,\n                                 _(\"cannot stat fd %d\"), incoming->fd);\n            goto cleanup;\n        }\n        if (S_ISFIFO(stdin_sb.st_mode) &&\n            qemuSecuritySetImageFDLabel(driver->securityManager,\n                                        vm->def, incoming->fd) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Labelling done, completing handshake to child\");\n    if (virCommandHandshakeNotify(cmd) < 0)\n        goto cleanup;\n    VIR_DEBUG(\"Handshake complete, child running\");\n\n    if (rv == -1) /* The VM failed to start; tear filters before taps */\n        virDomainConfVMNWFilterTeardown(vm);\n\n    if (rv == -1) /* The VM failed to start */\n        goto cleanup;\n\n    if (qemuDomainObjStartWorker(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Waiting for monitor to show up\");\n    if (qemuProcessWaitForMonitor(driver, vm, asyncJob, logCtxt) < 0)\n        goto cleanup;\n\n    if (qemuConnectAgent(driver, vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Verifying and updating provided guest CPU\");\n    if (qemuProcessUpdateAndVerifyCPU(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"setting up hotpluggable cpus\");\n    if (qemuDomainHasHotpluggableStartupVcpus(vm->def)) {\n        if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n            goto cleanup;\n\n        if (qemuProcessValidateHotpluggableVcpus(vm->def) < 0)\n            goto cleanup;\n\n        if (qemuProcessSetupHotpluggableVcpus(driver, vm, asyncJob) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Refreshing VCPU info\");\n    if (qemuDomainRefreshVcpuInfo(driver, vm, asyncJob, false) < 0)\n        goto cleanup;\n\n    if (qemuDomainValidateVcpuInfo(vm) < 0)\n        goto cleanup;\n\n    qemuDomainVcpuPersistOrder(vm->def);\n\n    VIR_DEBUG(\"Detecting IOThread PIDs\");\n    if (qemuProcessDetectIOThreadPIDs(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting global CPU cgroup (if required)\");\n    if (qemuSetupGlobalCpuCgroup(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting vCPU tuning/settings\");\n    if (qemuProcessSetupVcpus(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting IOThread tuning/settings\");\n    if (qemuProcessSetupIOThreads(vm) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting emulator scheduler\");\n    if (vm->def->cputune.emulatorsched &&\n        virProcessSetScheduler(vm->pid,\n                               vm->def->cputune.emulatorsched->policy,\n                               vm->def->cputune.emulatorsched->priority) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting any required VM passwords\");\n    if (qemuProcessInitPasswords(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* set default link states */\n    /* qemu doesn't support setting this on the command line, so\n     * enter the monitor */\n    VIR_DEBUG(\"Setting network link states\");\n    if (qemuProcessSetLinkStates(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    VIR_DEBUG(\"Setting initial memory amount\");\n    if (qemuProcessSetupBalloon(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (qemuProcessSetupDiskThrottlingBlockdev(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* Since CPUs were not started yet, the balloon could not return the memory\n     * to the host and thus cur_balloon needs to be updated so that GetXMLdesc\n     * and friends return the correct size in case they can't grab the job */\n    if (!incoming && !snapshot &&\n        qemuProcessRefreshBalloonState(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_AUTODESTROY &&\n        qemuProcessAutoDestroyAdd(driver, vm, conn) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        qemuExtDevicesStop(driver, vm);\n    qemuDomainSecretDestroy(vm);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessPrepareHost",
          "args": [
            "driver",
            "vm",
            "startFlags"
          ],
          "line": 2567
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessPrepareHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "6483-6578",
          "snippet": "int\nqemuProcessPrepareHost(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       unsigned int flags)\n{\n    unsigned int hostdev_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (qemuPrepareNVRAM(cfg, vm) < 0)\n        return -1;\n\n    if (vm->def->vsock) {\n        if (qemuProcessOpenVhostVsock(vm->def->vsock) < 0)\n            return -1;\n    }\n    /* network devices must be \"prepared\" before hostdevs, because\n     * setting up a network device might create a new hostdev that\n     * will need to be setup.\n     */\n    VIR_DEBUG(\"Preparing network devices\");\n    if (qemuProcessNetworkPrepareDevices(driver, vm) < 0)\n        return -1;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (!cfg->relaxedACS)\n        hostdev_flags |= VIR_HOSTDEV_STRICT_ACS_CHECK;\n    if (flags & VIR_QEMU_PROCESS_START_NEW)\n        hostdev_flags |= VIR_HOSTDEV_COLD_BOOT;\n    if (qemuHostdevPrepareDomainDevices(driver, vm->def, priv->qemuCaps,\n                                        hostdev_flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing chr devices\");\n    if (virDomainChrDefForeach(vm->def,\n                               true,\n                               qemuProcessPrepareChardevDevice,\n                               NULL) < 0)\n        return -1;\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, true) < 0)\n        return -1;\n\n    /* Ensure no historical cgroup for this VM is lying around bogus\n     * settings */\n    VIR_DEBUG(\"Ensuring no historical cgroup is lying around\");\n    qemuRemoveCgroup(vm);\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create log directory %s\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    VIR_FREE(priv->pidfile);\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path.\"));\n        return -1;\n    }\n\n    if (unlink(priv->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove stale PID file %s\"),\n                             priv->pidfile);\n        return -1;\n    }\n\n    /*\n     * Create all per-domain directories in order to make sure domain\n     * with any possible seclabels can access it.\n     */\n    if (qemuProcessMakeDir(driver, vm, priv->libDir) < 0 ||\n        qemuProcessMakeDir(driver, vm, priv->channelTargetDir) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Write domain masterKey\");\n    if (qemuDomainWriteMasterKeyFile(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing disks (host)\");\n    if (qemuProcessPrepareHostStorage(driver, vm, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareHost(driver, vm) < 0)\n        return -1;\n\n    if (qemuProcessPrepareSEVGuestInput(vm) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessPrepareHost(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       unsigned int flags)\n{\n    unsigned int hostdev_flags = 0;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    if (qemuPrepareNVRAM(cfg, vm) < 0)\n        return -1;\n\n    if (vm->def->vsock) {\n        if (qemuProcessOpenVhostVsock(vm->def->vsock) < 0)\n            return -1;\n    }\n    /* network devices must be \"prepared\" before hostdevs, because\n     * setting up a network device might create a new hostdev that\n     * will need to be setup.\n     */\n    VIR_DEBUG(\"Preparing network devices\");\n    if (qemuProcessNetworkPrepareDevices(driver, vm) < 0)\n        return -1;\n\n    /* Must be run before security labelling */\n    VIR_DEBUG(\"Preparing host devices\");\n    if (!cfg->relaxedACS)\n        hostdev_flags |= VIR_HOSTDEV_STRICT_ACS_CHECK;\n    if (flags & VIR_QEMU_PROCESS_START_NEW)\n        hostdev_flags |= VIR_HOSTDEV_COLD_BOOT;\n    if (qemuHostdevPrepareDomainDevices(driver, vm->def, priv->qemuCaps,\n                                        hostdev_flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing chr devices\");\n    if (virDomainChrDefForeach(vm->def,\n                               true,\n                               qemuProcessPrepareChardevDevice,\n                               NULL) < 0)\n        return -1;\n\n    if (qemuProcessBuildDestroyMemoryPaths(driver, vm, NULL, true) < 0)\n        return -1;\n\n    /* Ensure no historical cgroup for this VM is lying around bogus\n     * settings */\n    VIR_DEBUG(\"Ensuring no historical cgroup is lying around\");\n    qemuRemoveCgroup(vm);\n\n    if (virFileMakePath(cfg->logDir) < 0) {\n        virReportSystemError(errno,\n                             _(\"cannot create log directory %s\"),\n                             cfg->logDir);\n        return -1;\n    }\n\n    VIR_FREE(priv->pidfile);\n    if (!(priv->pidfile = virPidFileBuildPath(cfg->stateDir, vm->def->name))) {\n        virReportSystemError(errno,\n                             \"%s\", _(\"Failed to build pidfile path.\"));\n        return -1;\n    }\n\n    if (unlink(priv->pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Cannot remove stale PID file %s\"),\n                             priv->pidfile);\n        return -1;\n    }\n\n    /*\n     * Create all per-domain directories in order to make sure domain\n     * with any possible seclabels can access it.\n     */\n    if (qemuProcessMakeDir(driver, vm, priv->libDir) < 0 ||\n        qemuProcessMakeDir(driver, vm, priv->channelTargetDir) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Write domain masterKey\");\n    if (qemuDomainWriteMasterKeyFile(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing disks (host)\");\n    if (qemuProcessPrepareHostStorage(driver, vm, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareHost(driver, vm) < 0)\n        return -1;\n\n    if (qemuProcessPrepareSEVGuestInput(vm) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessPrepareDomain",
          "args": [
            "driver",
            "vm",
            "startFlags"
          ],
          "line": 2564
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessPrepareDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "6227-6337",
          "snippet": "int\nqemuProcessPrepareDomain(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         unsigned int flags)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    priv->machineName = qemuDomainGetMachineName(vm);\n    if (!priv->machineName)\n        return -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        /* If you are using a SecurityDriver with dynamic labelling,\n           then generate a security label for isolation */\n        VIR_DEBUG(\"Generating domain security label (if required)\");\n        if (qemuSecurityGenLabel(driver->securityManager, vm->def) < 0) {\n            virDomainAuditSecurityLabel(vm, false);\n            return -1;\n        }\n        virDomainAuditSecurityLabel(vm, true);\n\n        if (qemuProcessPrepareDomainNUMAPlacement(driver, vm) < 0)\n            return -1;\n    }\n\n    /* Whether we should use virtlogd as stdio handler for character\n     * devices source backend. */\n    if (cfg->stdioLogD &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FILE_APPEND)) {\n        priv->chardevStdioLogd = true;\n    }\n\n    /* Track if this domain remembers original owner */\n    priv->rememberOwner = cfg->rememberOwner;\n\n    qemuProcessPrepareAllowReboot(vm);\n\n    /*\n     * Normally PCI addresses are assigned in the virDomainCreate\n     * or virDomainDefine methods. We might still need to assign\n     * some here to cope with the question of upgrades. Regardless\n     * we also need to populate the PCI address set cache for later\n     * use in hotplug\n     */\n    VIR_DEBUG(\"Assigning domain PCI addresses\");\n    if ((qemuDomainAssignAddresses(vm->def, priv->qemuCaps, driver, vm,\n                                   !!(flags & VIR_QEMU_PROCESS_START_NEW))) < 0) {\n        return -1;\n    }\n\n    if (qemuAssignDeviceAliases(vm->def, priv->qemuCaps) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting graphics devices\");\n    if (qemuProcessSetupGraphics(driver, vm, priv->qemuCaps, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Create domain masterKey\");\n    if (qemuDomainMasterKeyCreate(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up storage\");\n    if (qemuProcessPrepareDomainStorage(driver, vm, priv, cfg, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare chardev source backends for TLS\");\n    qemuDomainPrepareChardevSource(vm->def, cfg);\n\n    VIR_DEBUG(\"Prepare device secrets\");\n    if (qemuDomainSecretPrepare(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare bios/uefi paths\");\n    if (qemuFirmwareFillDomain(driver, vm->def, flags) < 0)\n        return -1;\n    if (qemuDomainInitializePflashStorageSource(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareDomain(driver, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        if (qemuDomainPrepareChannel(vm->def->channels[i],\n                                     priv->channelTargetDir) < 0)\n            return -1;\n    }\n\n    if (!(priv->monConfig = virDomainChrSourceDefNew(driver->xmlopt)))\n        return -1;\n\n    VIR_DEBUG(\"Preparing monitor state\");\n    if (qemuProcessPrepareMonitorChr(priv->monConfig, priv->libDir) < 0)\n        return -1;\n\n    priv->monError = false;\n    priv->monStart = 0;\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    VIR_DEBUG(\"Updating guest CPU definition\");\n    if (qemuProcessUpdateGuestCPU(vm->def, priv->qemuCaps, driver->hostarch, flags) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        qemuDomainPrepareShmemChardev(vm->def->shmems[i]);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessPrepareDomain(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         unsigned int flags)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    priv->machineName = qemuDomainGetMachineName(vm);\n    if (!priv->machineName)\n        return -1;\n\n    if (!(flags & VIR_QEMU_PROCESS_START_PRETEND)) {\n        /* If you are using a SecurityDriver with dynamic labelling,\n           then generate a security label for isolation */\n        VIR_DEBUG(\"Generating domain security label (if required)\");\n        if (qemuSecurityGenLabel(driver->securityManager, vm->def) < 0) {\n            virDomainAuditSecurityLabel(vm, false);\n            return -1;\n        }\n        virDomainAuditSecurityLabel(vm, true);\n\n        if (qemuProcessPrepareDomainNUMAPlacement(driver, vm) < 0)\n            return -1;\n    }\n\n    /* Whether we should use virtlogd as stdio handler for character\n     * devices source backend. */\n    if (cfg->stdioLogD &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_CHARDEV_FILE_APPEND)) {\n        priv->chardevStdioLogd = true;\n    }\n\n    /* Track if this domain remembers original owner */\n    priv->rememberOwner = cfg->rememberOwner;\n\n    qemuProcessPrepareAllowReboot(vm);\n\n    /*\n     * Normally PCI addresses are assigned in the virDomainCreate\n     * or virDomainDefine methods. We might still need to assign\n     * some here to cope with the question of upgrades. Regardless\n     * we also need to populate the PCI address set cache for later\n     * use in hotplug\n     */\n    VIR_DEBUG(\"Assigning domain PCI addresses\");\n    if ((qemuDomainAssignAddresses(vm->def, priv->qemuCaps, driver, vm,\n                                   !!(flags & VIR_QEMU_PROCESS_START_NEW))) < 0) {\n        return -1;\n    }\n\n    if (qemuAssignDeviceAliases(vm->def, priv->qemuCaps) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting graphics devices\");\n    if (qemuProcessSetupGraphics(driver, vm, priv->qemuCaps, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Create domain masterKey\");\n    if (qemuDomainMasterKeyCreate(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Setting up storage\");\n    if (qemuProcessPrepareDomainStorage(driver, vm, priv, cfg, flags) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare chardev source backends for TLS\");\n    qemuDomainPrepareChardevSource(vm->def, cfg);\n\n    VIR_DEBUG(\"Prepare device secrets\");\n    if (qemuDomainSecretPrepare(driver, vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Prepare bios/uefi paths\");\n    if (qemuFirmwareFillDomain(driver, vm->def, flags) < 0)\n        return -1;\n    if (qemuDomainInitializePflashStorageSource(vm) < 0)\n        return -1;\n\n    VIR_DEBUG(\"Preparing external devices\");\n    if (qemuExtDevicesPrepareDomain(driver, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nchannels; i++) {\n        if (qemuDomainPrepareChannel(vm->def->channels[i],\n                                     priv->channelTargetDir) < 0)\n            return -1;\n    }\n\n    if (!(priv->monConfig = virDomainChrSourceDefNew(driver->xmlopt)))\n        return -1;\n\n    VIR_DEBUG(\"Preparing monitor state\");\n    if (qemuProcessPrepareMonitorChr(priv->monConfig, priv->libDir) < 0)\n        return -1;\n\n    priv->monError = false;\n    priv->monStart = 0;\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    VIR_DEBUG(\"Updating guest CPU definition\");\n    if (qemuProcessUpdateGuestCPU(vm->def, priv->qemuCaps, driver->hostarch, flags) < 0)\n        return -1;\n\n    for (i = 0; i < vm->def->nshmems; i++)\n        qemuDomainPrepareShmemChardev(vm->def->shmems[i]);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstPrepare",
          "args": [
            "vm",
            "tunnel",
            "protocol",
            "listenAddress",
            "port",
            "dataFD[0]"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPrepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2293-2360",
          "snippet": "static qemuProcessIncomingDefPtr\nqemuMigrationDstPrepare(virDomainObjPtr vm,\n                        bool tunnel,\n                        const char *protocol,\n                        const char *listenAddress,\n                        unsigned short port,\n                        int fd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr inc = NULL;\n    char *migrateFrom = NULL;\n\n    if (tunnel) {\n        migrateFrom = g_strdup(\"stdio\");\n    } else {\n        bool encloseAddress = false;\n        bool hostIPv6Capable = false;\n        struct addrinfo *info = NULL;\n        struct addrinfo hints = { .ai_flags = AI_ADDRCONFIG,\n                                  .ai_socktype = SOCK_STREAM };\n        const char *incFormat;\n\n        if (getaddrinfo(\"::\", NULL, &hints, &info) == 0) {\n            freeaddrinfo(info);\n            hostIPv6Capable = true;\n        }\n\n        if (listenAddress) {\n            if (virSocketAddrNumericFamily(listenAddress) == AF_INET6) {\n                if (!hostIPv6Capable) {\n                    virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                                   _(\"host isn't capable of IPv6\"));\n                    goto cleanup;\n                }\n                /* IPv6 address must be escaped in brackets on the cmd line */\n                encloseAddress = true;\n            } else {\n                /* listenAddress is a hostname or IPv4 */\n            }\n        } else if (hostIPv6Capable) {\n            /* Listen on :: instead of 0.0.0.0 if QEMU understands it\n             * and there is at least one IPv6 address configured\n             */\n            listenAddress = \"::\";\n            encloseAddress = true;\n        } else {\n            listenAddress = \"0.0.0.0\";\n        }\n\n        /* QEMU will be started with\n         *   -incoming protocol:[<IPv6 addr>]:port,\n         *   -incoming protocol:<IPv4 addr>:port, or\n         *   -incoming protocol:<hostname>:port\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n        migrateFrom = g_strdup_printf(incFormat, protocol, listenAddress, port);\n    }\n\n    inc = qemuProcessIncomingDefNew(priv->qemuCaps, listenAddress,\n                                    migrateFrom, fd, NULL);\n\n cleanup:\n    VIR_FREE(migrateFrom);\n    return inc;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic qemuProcessIncomingDefPtr\nqemuMigrationDstPrepare(virDomainObjPtr vm,\n                        bool tunnel,\n                        const char *protocol,\n                        const char *listenAddress,\n                        unsigned short port,\n                        int fd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr inc = NULL;\n    char *migrateFrom = NULL;\n\n    if (tunnel) {\n        migrateFrom = g_strdup(\"stdio\");\n    } else {\n        bool encloseAddress = false;\n        bool hostIPv6Capable = false;\n        struct addrinfo *info = NULL;\n        struct addrinfo hints = { .ai_flags = AI_ADDRCONFIG,\n                                  .ai_socktype = SOCK_STREAM };\n        const char *incFormat;\n\n        if (getaddrinfo(\"::\", NULL, &hints, &info) == 0) {\n            freeaddrinfo(info);\n            hostIPv6Capable = true;\n        }\n\n        if (listenAddress) {\n            if (virSocketAddrNumericFamily(listenAddress) == AF_INET6) {\n                if (!hostIPv6Capable) {\n                    virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                                   _(\"host isn't capable of IPv6\"));\n                    goto cleanup;\n                }\n                /* IPv6 address must be escaped in brackets on the cmd line */\n                encloseAddress = true;\n            } else {\n                /* listenAddress is a hostname or IPv4 */\n            }\n        } else if (hostIPv6Capable) {\n            /* Listen on :: instead of 0.0.0.0 if QEMU understands it\n             * and there is at least one IPv6 address configured\n             */\n            listenAddress = \"::\";\n            encloseAddress = true;\n        } else {\n            listenAddress = \"0.0.0.0\";\n        }\n\n        /* QEMU will be started with\n         *   -incoming protocol:[<IPv6 addr>]:port,\n         *   -incoming protocol:<IPv4 addr>:port, or\n         *   -incoming protocol:<hostname>:port\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n        migrateFrom = g_strdup_printf(incFormat, protocol, listenAddress, port);\n    }\n\n    inc = qemuProcessIncomingDefNew(priv->qemuCaps, listenAddress,\n                                    migrateFrom, fd, NULL);\n\n cleanup:\n    VIR_FREE(migrateFrom);\n    return inc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessInit",
          "args": [
            "driver",
            "vm",
            "mig->cpu",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "true",
            "startFlags"
          ],
          "line": 2552
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "5543-5632",
          "snippet": "int\nqemuProcessInit(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                virCPUDefPtr updatedCPU,\n                qemuDomainAsyncJob asyncJob,\n                bool migration,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int stopFlags;\n    virCPUDefPtr origCPU = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vm=%p name=%s id=%d migration=%d\",\n              vm, vm->def->name, vm->def->id, migration);\n\n    VIR_DEBUG(\"Beginning VM startup process\");\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"VM is already active\"));\n        goto cleanup;\n    }\n\n    /* in case when the post parse callback failed we need to re-run it on the\n     * old config prior we start the VM */\n    if (vm->def->postParseFailed) {\n        VIR_DEBUG(\"re-running the post parse callback\");\n\n        /* we don't have the private copy of qemuCaps at this point */\n        if (virDomainDefPostParse(vm->def, 0, driver->xmlopt, NULL) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Determining emulator version\");\n    if (qemuProcessPrepareQEMUCaps(vm, driver->qemuCapsCache, flags) < 0)\n        goto cleanup;\n\n    if (qemuDomainUpdateCPU(vm, updatedCPU, &origCPU) < 0)\n        goto cleanup;\n\n    if (qemuProcessStartValidate(driver, vm, priv->qemuCaps, flags) < 0)\n        goto cleanup;\n\n    /* Do this upfront, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, priv->qemuCaps) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_PRETEND) {\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0) {\n            virDomainObjRemoveTransientDef(vm);\n            goto cleanup;\n        }\n    } else {\n        vm->def->id = qemuDriverAllocateID(driver);\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_STARTING_UP);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        /* Run an early hook to set-up missing devices */\n        if (qemuProcessStartHook(driver, vm,\n                                 VIR_HOOK_QEMU_OP_PREPARE,\n                                 VIR_HOOK_SUBOP_BEGIN) < 0)\n            goto stop;\n\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0)\n            goto stop;\n\n        priv->origCPU = g_steal_pointer(&origCPU);\n    }\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(origCPU);\n    return ret;\n\n stop:\n    stopFlags = VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migration)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessInit(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                virCPUDefPtr updatedCPU,\n                qemuDomainAsyncJob asyncJob,\n                bool migration,\n                unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int stopFlags;\n    virCPUDefPtr origCPU = NULL;\n    int ret = -1;\n\n    VIR_DEBUG(\"vm=%p name=%s id=%d migration=%d\",\n              vm, vm->def->name, vm->def->id, migration);\n\n    VIR_DEBUG(\"Beginning VM startup process\");\n\n    if (virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"VM is already active\"));\n        goto cleanup;\n    }\n\n    /* in case when the post parse callback failed we need to re-run it on the\n     * old config prior we start the VM */\n    if (vm->def->postParseFailed) {\n        VIR_DEBUG(\"re-running the post parse callback\");\n\n        /* we don't have the private copy of qemuCaps at this point */\n        if (virDomainDefPostParse(vm->def, 0, driver->xmlopt, NULL) < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"Determining emulator version\");\n    if (qemuProcessPrepareQEMUCaps(vm, driver->qemuCapsCache, flags) < 0)\n        goto cleanup;\n\n    if (qemuDomainUpdateCPU(vm, updatedCPU, &origCPU) < 0)\n        goto cleanup;\n\n    if (qemuProcessStartValidate(driver, vm, priv->qemuCaps, flags) < 0)\n        goto cleanup;\n\n    /* Do this upfront, so any part of the startup process can add\n     * runtime state to vm->def that won't be persisted. This let's us\n     * report implicit runtime defaults in the XML, like vnc listen/socket\n     */\n    VIR_DEBUG(\"Setting current domain def as transient\");\n    if (virDomainObjSetDefTransient(driver->xmlopt, vm, priv->qemuCaps) < 0)\n        goto cleanup;\n\n    if (flags & VIR_QEMU_PROCESS_START_PRETEND) {\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0) {\n            virDomainObjRemoveTransientDef(vm);\n            goto cleanup;\n        }\n    } else {\n        vm->def->id = qemuDriverAllocateID(driver);\n        qemuDomainSetFakeReboot(driver, vm, false);\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED, VIR_DOMAIN_PAUSED_STARTING_UP);\n\n        if (g_atomic_int_add(&driver->nactive, 1) == 0 && driver->inhibitCallback)\n            driver->inhibitCallback(true, driver->inhibitOpaque);\n\n        /* Run an early hook to set-up missing devices */\n        if (qemuProcessStartHook(driver, vm,\n                                 VIR_HOOK_QEMU_OP_PREPARE,\n                                 VIR_HOOK_SUBOP_BEGIN) < 0)\n            goto stop;\n\n        if (qemuDomainSetPrivatePaths(driver, vm) < 0)\n            goto stop;\n\n        priv->origCPU = g_steal_pointer(&origCPU);\n    }\n\n    ret = 0;\n\n cleanup:\n    virCPUDefFree(origCPU);\n    return ret;\n\n stop:\n    stopFlags = VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n    if (migration)\n        stopFlags |= VIR_QEMU_PROCESS_STOP_MIGRATED;\n    qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED, asyncJob, stopFlags);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPipe",
          "args": [
            "dataFD"
          ],
          "line": 2547
        },
        "resolved": true,
        "details": {
          "function_name": "virPipeNonBlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1813-1817",
          "snippet": "int\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPipeNonBlock(int fds[2])\n{\n    return virPipeImpl(fds, true, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_PREPARE"
          ],
          "line": 2538
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStart",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN",
            "flags"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5418-5445",
          "snippet": "static int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstPrecreateStorage",
          "args": [
            "vm",
            "mig->nbd",
            "nmigrate_disks",
            "migrate_disks",
            "!!(flags & VIR_MIGRATE_NON_SHARED_INC)"
          ],
          "line": 2530
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPrecreateStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "298-354",
          "snippet": "static int\nqemuMigrationDstPrecreateStorage(virDomainObjPtr vm,\n                                 qemuMigrationCookieNBDPtr nbd,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 bool incremental)\n{\n    int ret = -1;\n    size_t i = 0;\n    virConnectPtr conn;\n\n    if (!nbd || !nbd->ndisks)\n        return 0;\n\n    if (!(conn = virGetConnectStorage()))\n        return -1;\n\n    for (i = 0; i < nbd->ndisks; i++) {\n        virDomainDiskDefPtr disk;\n        const char *diskSrcPath;\n\n        VIR_DEBUG(\"Looking up disk target '%s' (capacity=%llu)\",\n                  nbd->disks[i].target, nbd->disks[i].capacity);\n\n        if (!(disk = virDomainDiskByTarget(vm->def, nbd->disks[i].target))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to find disk by target: %s\"),\n                           nbd->disks[i].target);\n            goto cleanup;\n        }\n\n        diskSrcPath = virDomainDiskGetSource(disk);\n\n        /* Skip disks we don't want to migrate and already existing disks. */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks) ||\n            (diskSrcPath && virFileExists(diskSrcPath))) {\n            continue;\n        }\n\n        if (incremental) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\"));\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Proceeding with disk source %s\", NULLSTR(diskSrcPath));\n\n        if (qemuMigrationDstPrecreateDisk(conn, disk, nbd->disks[i].capacity) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrecreateStorage(virDomainObjPtr vm,\n                                 qemuMigrationCookieNBDPtr nbd,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 bool incremental)\n{\n    int ret = -1;\n    size_t i = 0;\n    virConnectPtr conn;\n\n    if (!nbd || !nbd->ndisks)\n        return 0;\n\n    if (!(conn = virGetConnectStorage()))\n        return -1;\n\n    for (i = 0; i < nbd->ndisks; i++) {\n        virDomainDiskDefPtr disk;\n        const char *diskSrcPath;\n\n        VIR_DEBUG(\"Looking up disk target '%s' (capacity=%llu)\",\n                  nbd->disks[i].target, nbd->disks[i].capacity);\n\n        if (!(disk = virDomainDiskByTarget(vm->def, nbd->disks[i].target))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to find disk by target: %s\"),\n                           nbd->disks[i].target);\n            goto cleanup;\n        }\n\n        diskSrcPath = virDomainDiskGetSource(disk);\n\n        /* Skip disks we don't want to migrate and already existing disks. */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks) ||\n            (diskSrcPath && virFileExists(diskSrcPath))) {\n            continue;\n        }\n\n        if (incremental) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\"));\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Proceeding with disk source %s\", NULLSTR(diskSrcPath));\n\n        if (qemuMigrationDstPrecreateDisk(conn, disk, nbd->disks[i].capacity) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\")"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMemoryLimitIsSet",
          "args": [
            "vm->def->mem.hard_limit"
          ],
          "line": 2523
        },
        "resolved": true,
        "details": {
          "function_name": "virMemoryLimitIsSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "1628-1632",
          "snippet": "bool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nbool\nvirMemoryLimitIsSet(unsigned long long value)\n{\n    return value < VIR_DOMAIN_MEMORY_PARAM_UNLIMITED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "protocol",
            "\"rdma\""
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "origname"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjListAdd",
          "args": [
            "driver->domains",
            "*def",
            "driver->xmlopt",
            "VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE",
            "NULL"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainobjlist.c",
          "lines": "354-366",
          "snippet": "virDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"checkpoint_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainObjPtr virDomainObjListAdd(virDomainObjListPtr doms,\n                                    virDomainDefPtr def,\n                                    virDomainXMLOptionPtr xmlopt,\n                                    unsigned int flags,\n                                    virDomainDefPtr *oldDef)\n{\n    virDomainObjPtr ret;\n\n    virObjectRWLockWrite(doms);\n    ret = virDomainObjListAddLocked(doms, def, xmlopt, flags, oldDef);\n    virObjectRWUnlock(doms);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationEatCookie",
          "args": [
            "driver",
            "*def",
            "origname",
            "NULL",
            "cookiein",
            "cookieinlen",
            "QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS"
          ],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1462-1527",
          "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "*def"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDefCheckABIStability",
          "args": [
            "driver",
            "NULL",
            "*def",
            "newdef"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDefCheckABIStability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12493-12515",
          "snippet": "bool\nqemuDomainDefCheckABIStability(virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainDefPtr src,\n                               virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = qemuDomainDefCopy(driver, qemuCaps, src, COPY_FLAGS)) ||\n        !(migratableDefDst = qemuDomainDefCopy(driver, qemuCaps, dst, COPY_FLAGS)))\n        goto cleanup;\n\n    ret = qemuDomainMigratableDefCheckABIStability(driver,\n                                                   src, migratableDefSrc,\n                                                   dst, migratableDefDst);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define COPY_FLAGS (VIR_DOMAIN_XML_SECURE | \\\n                    VIR_DOMAIN_XML_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\n#define COPY_FLAGS (VIR_DOMAIN_XML_SECURE | \\\n                    VIR_DOMAIN_XML_MIGRATABLE)\n\nbool\nqemuDomainDefCheckABIStability(virQEMUDriverPtr driver,\n                               virQEMUCapsPtr qemuCaps,\n                               virDomainDefPtr src,\n                               virDomainDefPtr dst)\n{\n    virDomainDefPtr migratableDefSrc = NULL;\n    virDomainDefPtr migratableDefDst = NULL;\n    bool ret = false;\n\n    if (!(migratableDefSrc = qemuDomainDefCopy(driver, qemuCaps, src, COPY_FLAGS)) ||\n        !(migratableDefDst = qemuDomainDefCopy(driver, qemuCaps, dst, COPY_FLAGS)))\n        goto cleanup;\n\n    ret = qemuDomainMigratableDefCheckABIStability(driver,\n                                                   src, migratableDefSrc,\n                                                   dst, migratableDefDst);\n\n cleanup:\n    virDomainDefFree(migratableDefSrc);\n    virDomainDefFree(migratableDefDst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xmlout",
            "driver->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Using hook-filtered domain XML: %s\"",
            "xmlout"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\""
          ],
          "line": 2465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringIsEmpty",
          "args": [
            "xmlout"
          ],
          "line": 2464
        },
        "resolved": true,
        "details": {
          "function_name": "virStringIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "882-890",
          "snippet": "bool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringIsEmpty(const char *str)\n{\n    if (!str)\n        return true;\n\n    virSkipSpaces(&str);\n    return str[0] == '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 2459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHookCall",
          "args": [
            "VIR_HOOK_DRIVER_QEMU",
            "(*def)->name",
            "VIR_HOOK_QEMU_OP_MIGRATE",
            "VIR_HOOK_SUBOP_BEGIN",
            "NULL",
            "xml",
            "&xmlout"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "virHookCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "243-341",
          "snippet": "int\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\""
          ],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define LIBVIRT_HOOK_DIR SYSCONFDIR \"/libvirt/hooks\"\n\nstatic int virHooksFound = -1;\n\nint\nvirHookCall(int driver,\n            const char *id,\n            int op,\n            int sub_op,\n            const char *extra,\n            const char *input,\n            char **output)\n{\n    int ret;\n    g_autofree char *path = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    const char *drvstr;\n    const char *opstr;\n    const char *subopstr;\n\n    if (output)\n        *output = NULL;\n\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 1;\n\n    /*\n     * We cache the availability of the script to minimize impact at\n     * runtime if no script is defined, this is being reset on SIGHUP\n     */\n    if ((virHooksFound == -1) ||\n        ((driver == VIR_HOOK_DRIVER_DAEMON) &&\n         (op == VIR_HOOK_DAEMON_OP_RELOAD ||\n          op == VIR_HOOK_DAEMON_OP_SHUTDOWN)))\n        virHookInitialize();\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 1;\n\n    drvstr = virHookDriverTypeToString(driver);\n\n    opstr = NULL;\n    switch (driver) {\n        case VIR_HOOK_DRIVER_DAEMON:\n            opstr = virHookDaemonOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_QEMU:\n            opstr = virHookQemuOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LXC:\n            opstr = virHookLxcOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_LIBXL:\n            opstr = virHookLibxlOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_NETWORK:\n            opstr = virHookNetworkOpTypeToString(op);\n            break;\n        case VIR_HOOK_DRIVER_BHYVE:\n            opstr = virHookBhyveOpTypeToString(op);\n            break;\n    }\n    if (opstr == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Hook for %s, failed to find operation #%d\"),\n                       drvstr, op);\n        return 1;\n    }\n    subopstr = virHookSubopTypeToString(sub_op);\n    if (subopstr == NULL)\n        subopstr = \"-\";\n    if (extra == NULL)\n        extra = \"-\";\n\n    if (virBuildPath(&path, LIBVIRT_HOOK_DIR, drvstr) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to build path for %s hook\"),\n                       drvstr);\n        return -1;\n    }\n\n    VIR_DEBUG(\"Calling hook opstr=%s subopstr=%s extra=%s\",\n              opstr, subopstr, extra);\n\n    cmd = virCommandNewArgList(path, id, opstr, subopstr, extra, NULL);\n\n    virCommandAddEnvPassCommon(cmd);\n\n    if (input)\n        virCommandSetInputBuffer(cmd, input);\n    if (output)\n        virCommandSetOutputBuffer(cmd, output);\n\n    ret = virCommandRun(cmd, NULL);\n    if (ret < 0) {\n        /* Convert INTERNAL_ERROR into known error.  */\n        virReportError(VIR_ERR_HOOK_SCRIPT_FAILED, \"%s\",\n                       virGetLastErrorMessage());\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDefFormatXML",
          "args": [
            "driver",
            "NULL",
            "*def",
            "VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDefFormatXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10565-10572",
          "snippet": "char *\nqemuDomainDefFormatXML(virQEMUDriverPtr driver,\n                       virQEMUCapsPtr qemuCaps,\n                       virDomainDefPtr def,\n                       unsigned int flags)\n{\n    return qemuDomainDefFormatXMLInternal(driver, qemuCaps, def, NULL, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nchar *\nqemuDomainDefFormatXML(virQEMUDriverPtr driver,\n                       virQEMUCapsPtr qemuCaps,\n                       virDomainDefPtr def,\n                       unsigned int flags)\n{\n    return qemuDomainDefFormatXMLInternal(driver, qemuCaps, def, NULL, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHookPresent",
          "args": [
            "VIR_HOOK_DRIVER_QEMU"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "virHookPresent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhook.c",
          "lines": "210-222",
          "snippet": "int\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}",
          "includes": [
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virhook.h\"",
            "#include \"virerror.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virHooksFound = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virhook.h\"\n#include \"virerror.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virHooksFound = -1;\n\nint\nvirHookPresent(int driver)\n{\n    if ((driver < VIR_HOOK_DRIVER_DAEMON) ||\n        (driver >= VIR_HOOK_DRIVER_LAST))\n        return 0;\n    if (virHooksFound == -1)\n        return 0;\n\n    if ((virHooksFound & (1 << driver)) == 0)\n        return 0;\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsAllowedHostdev",
          "args": [
            "*def"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsAllowedHostdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1087-1149",
          "snippet": "static bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"post-copy is not supported with tunnelled migration\")"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\")"
          ],
          "line": 2431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"tunnelled offline migration does not \"\n                             \"make sense\")"
          ],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"offline migration must be specified with \"\n                             \"the persistent flag set\")"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"offline migration cannot handle \"\n                             \"non-shared storage\")"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNWFilterReadLockFilterUpdates",
          "args": [],
          "line": 2400
        },
        "resolved": true,
        "details": {
          "function_name": "virNWFilterReadLockFilterUpdates",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/nwfilter_conf.c",
          "lines": "160-164",
          "snippet": "void\nvirNWFilterReadLockFilterUpdates(void)\n{\n    virRWLockRead(&updateLock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "# include <net/ethernet.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virRWLock updateLock;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"domain_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"internal.h\"\n#include <unistd.h>\n# include <net/ethernet.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virRWLock updateLock;\n\nvoid\nvirNWFilterReadLockFilterUpdates(void)\n{\n    virRWLockRead(&updateLock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrepareAny(virQEMUDriverPtr driver,\n                           virConnectPtr dconn,\n                           const char *cookiein,\n                           int cookieinlen,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           virDomainDefPtr *def,\n                           const char *origname,\n                           virStreamPtr st,\n                           const char *protocol,\n                           unsigned short port,\n                           bool autoPort,\n                           const char *listenAddress,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           int nbdPort,\n                           qemuMigrationParamsPtr migParams,\n                           unsigned long flags)\n{\n    virDomainObjPtr vm = NULL;\n    virObjectEventPtr event = NULL;\n    virErrorPtr origErr;\n    int ret = -1;\n    int dataFD[2] = { -1, -1 };\n    qemuDomainObjPrivatePtr priv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    bool tunnel = !!st;\n    char *xmlout = NULL;\n    unsigned int cookieFlags;\n    unsigned int startFlags;\n    qemuProcessIncomingDefPtr incoming = NULL;\n    bool taint_hook = false;\n    bool stopProcess = false;\n    bool relabel = false;\n    int rv;\n    char *tlsAlias = NULL;\n\n    virNWFilterReadLockFilterUpdates();\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (tunnel) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n        cookieFlags = 0;\n    } else {\n        cookieFlags = QEMU_MIGRATION_COOKIE_GRAPHICS |\n                      QEMU_MIGRATION_COOKIE_CAPS;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (!qemuMigrationSrcIsAllowedHostdev(*def))\n        goto cleanup;\n\n    /* Let migration hook filter domain XML */\n    if (virHookPresent(VIR_HOOK_DRIVER_QEMU)) {\n        char *xml;\n        int hookret;\n\n        if (!(xml = qemuDomainDefFormatXML(driver, NULL, *def,\n                                           VIR_DOMAIN_XML_SECURE |\n                                           VIR_DOMAIN_XML_MIGRATABLE)))\n            goto cleanup;\n\n        hookret = virHookCall(VIR_HOOK_DRIVER_QEMU, (*def)->name,\n                              VIR_HOOK_QEMU_OP_MIGRATE, VIR_HOOK_SUBOP_BEGIN,\n                              NULL, xml, &xmlout);\n        VIR_FREE(xml);\n\n        if (hookret < 0) {\n            goto cleanup;\n        } else if (hookret == 0) {\n            if (virStringIsEmpty(xmlout)) {\n                VIR_DEBUG(\"Migrate hook filter returned nothing; using the\"\n                          \" original XML\");\n            } else {\n                virDomainDefPtr newdef;\n\n                VIR_DEBUG(\"Using hook-filtered domain XML: %s\", xmlout);\n                newdef = virDomainDefParseString(xmlout, driver->xmlopt, NULL,\n                                                 VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                                 VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE);\n                if (!newdef)\n                    goto cleanup;\n\n                if (!qemuDomainDefCheckABIStability(driver, NULL, *def, newdef)) {\n                    virDomainDefFree(newdef);\n                    goto cleanup;\n                }\n\n                virDomainDefFree(*def);\n                *def = newdef;\n                /* We should taint the domain here. However, @vm and therefore\n                 * privateData too are still NULL, so just notice the fact and\n                 * taint it later. */\n                taint_hook = true;\n            }\n        }\n    }\n\n    /* Parse cookie earlier than adding the domain onto the\n     * domain list. Parsing/validation may fail and there's no\n     * point in having the domain in the list at that point. */\n    if (!(mig = qemuMigrationEatCookie(driver, *def, origname, NULL,\n                                       cookiein, cookieinlen,\n                                       QEMU_MIGRATION_COOKIE_LOCKSTATE |\n                                       QEMU_MIGRATION_COOKIE_NBD |\n                                       QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU_HOTPLUG |\n                                       QEMU_MIGRATION_COOKIE_CPU |\n                                       QEMU_MIGRATION_COOKIE_ALLOW_REBOOT |\n                                       QEMU_MIGRATION_COOKIE_CAPS)))\n        goto cleanup;\n\n    if (!(vm = virDomainObjListAdd(driver->domains, *def,\n                                   driver->xmlopt,\n                                   VIR_DOMAIN_OBJ_LIST_ADD_LIVE |\n                                   VIR_DOMAIN_OBJ_LIST_ADD_CHECK_LIVE,\n                                   NULL)))\n        goto cleanup;\n    *def = NULL;\n\n    priv = vm->privateData;\n    priv->origname = g_strdup(origname);\n\n    if (taint_hook) {\n        /* Domain XML has been altered by a hook script. */\n        priv->hookRun = true;\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        !virMemoryLimitIsSet(vm->def->mem.hard_limit)) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"cannot start RDMA migration with no memory hard \"\n                         \"limit set\"));\n        goto cleanup;\n    }\n\n    if (qemuMigrationDstPrecreateStorage(vm, mig->nbd,\n                                         nmigrate_disks, migrate_disks,\n                                         !!(flags & VIR_MIGRATE_NON_SHARED_INC)) < 0)\n        goto cleanup;\n\n    if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                              flags) < 0)\n        goto cleanup;\n    qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_PREPARE);\n\n    /* Domain starts inactive, even if the domain XML had an id field. */\n    vm->def->id = -1;\n\n    if (flags & VIR_MIGRATE_OFFLINE)\n        goto done;\n\n    if (tunnel &&\n        virPipe(dataFD) < 0)\n        goto stopjob;\n\n    startFlags = VIR_QEMU_PROCESS_START_AUTODESTROY;\n\n    if (qemuProcessInit(driver, vm, mig->cpu, QEMU_ASYNC_JOB_MIGRATION_IN,\n                        true, startFlags) < 0)\n        goto stopjob;\n    stopProcess = true;\n\n    priv->allowReboot = mig->allowReboot;\n\n    if (!(incoming = qemuMigrationDstPrepare(vm, tunnel, protocol,\n                                             listenAddress, port,\n                                             dataFD[0])))\n        goto stopjob;\n\n    if (qemuProcessPrepareDomain(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    if (qemuProcessPrepareHost(driver, vm, startFlags) < 0)\n        goto stopjob;\n\n    rv = qemuProcessLaunch(dconn, driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                           incoming, NULL,\n                           VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START,\n                           startFlags);\n    if (rv < 0) {\n        if (rv == -2)\n            relabel = true;\n        goto stopjob;\n    }\n    relabel = true;\n\n    if (tunnel) {\n        if (virFDStreamOpen(st, dataFD[1]) < 0) {\n            virReportSystemError(errno, \"%s\",\n                                 _(\"cannot pass pipe for tunnelled migration\"));\n            goto stopjob;\n        }\n        dataFD[1] = -1; /* 'st' owns the FD now & will close it */\n    }\n\n    if (STREQ_NULLABLE(protocol, \"rdma\") &&\n        virProcessSetMaxMemLock(vm->pid, vm->def->mem.hard_limit << 10) < 0) {\n        goto stopjob;\n    }\n\n    if (qemuMigrationParamsCheck(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams, mig->caps->automatic) < 0)\n        goto stopjob;\n\n    /* Migrations using TLS need to add the \"tls-creds-x509\" object and\n     * set the migration TLS parameters */\n    if (flags & VIR_MIGRATE_TLS) {\n        if (qemuMigrationParamsEnableTLS(driver, vm, true,\n                                         QEMU_ASYNC_JOB_MIGRATION_IN,\n                                         &tlsAlias, NULL,\n                                         migParams) < 0)\n            goto stopjob;\n    } else {\n        if (qemuMigrationParamsDisableTLS(vm, migParams) < 0)\n            goto stopjob;\n    }\n\n    if (qemuMigrationParamsApply(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 migParams) < 0)\n        goto stopjob;\n\n    if (mig->nbd &&\n        flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC) &&\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_SERVER)) {\n        const char *nbdTLSAlias = NULL;\n\n        if (flags & VIR_MIGRATE_TLS) {\n            if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_NBD_TLS)) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"QEMU NBD server does not support TLS transport\"));\n                goto stopjob;\n            }\n\n            nbdTLSAlias = tlsAlias;\n        }\n\n        if (qemuMigrationDstStartNBDServer(driver, vm, incoming->address,\n                                           nmigrate_disks, migrate_disks,\n                                           nbdPort, nbdTLSAlias) < 0) {\n            goto stopjob;\n        }\n        cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n    }\n\n    if (mig->lockState) {\n        VIR_DEBUG(\"Received lockstate %s\", mig->lockState);\n        VIR_FREE(priv->lockState);\n        priv->lockState = mig->lockState;\n        mig->lockState = NULL;\n    } else {\n        VIR_DEBUG(\"Received no lockstate\");\n    }\n\n    if (incoming->deferredURI &&\n        qemuMigrationDstRun(driver, vm, incoming->deferredURI,\n                            QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        goto stopjob;\n\n    if (qemuProcessFinishStartup(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                                 false, VIR_DOMAIN_PAUSED_MIGRATION) < 0)\n        goto stopjob;\n\n done:\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_DESTINATION,\n                                cookieout, cookieoutlen, cookieFlags) < 0) {\n        /* We could tear down the whole guest here, but\n         * cookie data is (so far) non-critical, so that\n         * seems a little harsh. We'll just warn for now.\n         */\n        VIR_WARN(\"Unable to encode migration cookie\");\n    }\n\n    if (qemuDomainCleanupAdd(vm, qemuMigrationDstPrepareCleanup) < 0)\n        goto stopjob;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        virDomainAuditStart(vm, \"migrated\", true);\n        event = virDomainEventLifecycleNewFromObj(vm,\n                                         VIR_DOMAIN_EVENT_STARTED,\n                                         VIR_DOMAIN_EVENT_STARTED_MIGRATED);\n    }\n\n    /* We keep the job active across API calls until the finish() call.\n     * This prevents any other APIs being invoked while incoming\n     * migration is taking place.\n     */\n    qemuMigrationJobContinue(vm);\n\n    if (autoPort)\n        priv->migrationPort = port;\n    /* in this case port is not auto selected and we don't need to manage it\n     * anymore after cookie is baked\n     */\n    if (nbdPort != 0)\n        priv->nbdPort = 0;\n    ret = 0;\n\n cleanup:\n    virErrorPreserveLast(&origErr);\n    VIR_FREE(tlsAlias);\n    qemuProcessIncomingDefFree(incoming);\n    VIR_FREE(xmlout);\n    VIR_FORCE_CLOSE(dataFD[0]);\n    VIR_FORCE_CLOSE(dataFD[1]);\n    if (ret < 0 && priv) {\n        /* priv is set right after vm is added to the list of domains\n         * and there is no 'goto cleanup;' in the middle of those */\n        VIR_FREE(priv->origname);\n        /* release if port is auto selected which is not the case if\n         * it is given in parameters\n         */\n        if (nbdPort == 0)\n            virPortAllocatorRelease(priv->nbdPort);\n        priv->nbdPort = 0;\n        virDomainObjRemoveTransientDef(vm);\n        qemuDomainRemoveInactiveJob(driver, vm);\n    }\n    virDomainObjEndAPI(&vm);\n    virObjectEventStateQueue(driver->domainEventState, event);\n    qemuMigrationCookieFree(mig);\n    virNWFilterUnlockFilterUpdates();\n    virErrorRestore(&origErr);\n    return ret;\n\n stopjob:\n    qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_IN,\n                             priv->job.migParams, priv->job.apiFlags);\n\n    if (stopProcess) {\n        unsigned int stopFlags = VIR_QEMU_PROCESS_STOP_MIGRATED;\n        if (!relabel)\n            stopFlags |= VIR_QEMU_PROCESS_STOP_NO_RELABEL;\n        virDomainAuditStart(vm, \"migrated\", false);\n        qemuProcessStop(driver, vm, VIR_DOMAIN_SHUTOFF_FAILED,\n                        QEMU_ASYNC_JOB_MIGRATION_IN, stopFlags);\n    }\n\n    qemuMigrationJobFinish(driver, vm);\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuMigrationDstPrepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2293-2360",
    "snippet": "static qemuProcessIncomingDefPtr\nqemuMigrationDstPrepare(virDomainObjPtr vm,\n                        bool tunnel,\n                        const char *protocol,\n                        const char *listenAddress,\n                        unsigned short port,\n                        int fd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr inc = NULL;\n    char *migrateFrom = NULL;\n\n    if (tunnel) {\n        migrateFrom = g_strdup(\"stdio\");\n    } else {\n        bool encloseAddress = false;\n        bool hostIPv6Capable = false;\n        struct addrinfo *info = NULL;\n        struct addrinfo hints = { .ai_flags = AI_ADDRCONFIG,\n                                  .ai_socktype = SOCK_STREAM };\n        const char *incFormat;\n\n        if (getaddrinfo(\"::\", NULL, &hints, &info) == 0) {\n            freeaddrinfo(info);\n            hostIPv6Capable = true;\n        }\n\n        if (listenAddress) {\n            if (virSocketAddrNumericFamily(listenAddress) == AF_INET6) {\n                if (!hostIPv6Capable) {\n                    virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                                   _(\"host isn't capable of IPv6\"));\n                    goto cleanup;\n                }\n                /* IPv6 address must be escaped in brackets on the cmd line */\n                encloseAddress = true;\n            } else {\n                /* listenAddress is a hostname or IPv4 */\n            }\n        } else if (hostIPv6Capable) {\n            /* Listen on :: instead of 0.0.0.0 if QEMU understands it\n             * and there is at least one IPv6 address configured\n             */\n            listenAddress = \"::\";\n            encloseAddress = true;\n        } else {\n            listenAddress = \"0.0.0.0\";\n        }\n\n        /* QEMU will be started with\n         *   -incoming protocol:[<IPv6 addr>]:port,\n         *   -incoming protocol:<IPv4 addr>:port, or\n         *   -incoming protocol:<hostname>:port\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n        migrateFrom = g_strdup_printf(incFormat, protocol, listenAddress, port);\n    }\n\n    inc = qemuProcessIncomingDefNew(priv->qemuCaps, listenAddress,\n                                    migrateFrom, fd, NULL);\n\n cleanup:\n    VIR_FREE(migrateFrom);\n    return inc;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "migrateFrom"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuProcessIncomingDefNew",
          "args": [
            "priv->qemuCaps",
            "listenAddress",
            "migrateFrom",
            "fd",
            "NULL"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessIncomingDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "4546-4580",
          "snippet": "qemuProcessIncomingDefPtr\nqemuProcessIncomingDefNew(virQEMUCapsPtr qemuCaps,\n                          const char *listenAddress,\n                          const char *migrateFrom,\n                          int fd,\n                          const char *path)\n{\n    qemuProcessIncomingDefPtr inc = NULL;\n\n    if (qemuMigrationDstCheckProtocol(qemuCaps, migrateFrom) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(inc) < 0)\n        return NULL;\n\n    inc->address = g_strdup(listenAddress);\n\n    inc->launchURI = qemuMigrationDstGetURI(migrateFrom, fd);\n    if (!inc->launchURI)\n        goto error;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_INCOMING_DEFER)) {\n        inc->deferredURI = inc->launchURI;\n        inc->launchURI = g_strdup(\"defer\");\n    }\n\n    inc->fd = fd;\n    inc->path = path;\n\n    return inc;\n\n error:\n    qemuProcessIncomingDefFree(inc);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nqemuProcessIncomingDefPtr\nqemuProcessIncomingDefNew(virQEMUCapsPtr qemuCaps,\n                          const char *listenAddress,\n                          const char *migrateFrom,\n                          int fd,\n                          const char *path)\n{\n    qemuProcessIncomingDefPtr inc = NULL;\n\n    if (qemuMigrationDstCheckProtocol(qemuCaps, migrateFrom) < 0)\n        return NULL;\n\n    if (VIR_ALLOC(inc) < 0)\n        return NULL;\n\n    inc->address = g_strdup(listenAddress);\n\n    inc->launchURI = qemuMigrationDstGetURI(migrateFrom, fd);\n    if (!inc->launchURI)\n        goto error;\n\n    if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_INCOMING_DEFER)) {\n        inc->deferredURI = inc->launchURI;\n        inc->launchURI = g_strdup(\"defer\");\n    }\n\n    inc->fd = fd;\n    inc->path = path;\n\n    return inc;\n\n error:\n    qemuProcessIncomingDefFree(inc);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "incFormat",
            "protocol",
            "listenAddress",
            "port"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"host isn't capable of IPv6\")"
          ],
          "line": 2323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"host isn't capable of IPv6\""
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrNumericFamily",
          "args": [
            "listenAddress"
          ],
          "line": 2321
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrNumericFamily",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1209-1221",
          "snippet": "int\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "info"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "\"::\"",
            "NULL",
            "&hints",
            "&info"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic qemuProcessIncomingDefPtr\nqemuMigrationDstPrepare(virDomainObjPtr vm,\n                        bool tunnel,\n                        const char *protocol,\n                        const char *listenAddress,\n                        unsigned short port,\n                        int fd)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuProcessIncomingDefPtr inc = NULL;\n    char *migrateFrom = NULL;\n\n    if (tunnel) {\n        migrateFrom = g_strdup(\"stdio\");\n    } else {\n        bool encloseAddress = false;\n        bool hostIPv6Capable = false;\n        struct addrinfo *info = NULL;\n        struct addrinfo hints = { .ai_flags = AI_ADDRCONFIG,\n                                  .ai_socktype = SOCK_STREAM };\n        const char *incFormat;\n\n        if (getaddrinfo(\"::\", NULL, &hints, &info) == 0) {\n            freeaddrinfo(info);\n            hostIPv6Capable = true;\n        }\n\n        if (listenAddress) {\n            if (virSocketAddrNumericFamily(listenAddress) == AF_INET6) {\n                if (!hostIPv6Capable) {\n                    virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                                   _(\"host isn't capable of IPv6\"));\n                    goto cleanup;\n                }\n                /* IPv6 address must be escaped in brackets on the cmd line */\n                encloseAddress = true;\n            } else {\n                /* listenAddress is a hostname or IPv4 */\n            }\n        } else if (hostIPv6Capable) {\n            /* Listen on :: instead of 0.0.0.0 if QEMU understands it\n             * and there is at least one IPv6 address configured\n             */\n            listenAddress = \"::\";\n            encloseAddress = true;\n        } else {\n            listenAddress = \"0.0.0.0\";\n        }\n\n        /* QEMU will be started with\n         *   -incoming protocol:[<IPv6 addr>]:port,\n         *   -incoming protocol:<IPv4 addr>:port, or\n         *   -incoming protocol:<hostname>:port\n         */\n        if (encloseAddress)\n            incFormat = \"%s:[%s]:%d\";\n        else\n            incFormat = \"%s:%s:%d\";\n        migrateFrom = g_strdup_printf(incFormat, protocol, listenAddress, port);\n    }\n\n    inc = qemuProcessIncomingDefNew(priv->qemuCaps, listenAddress,\n                                    migrateFrom, fd, NULL);\n\n cleanup:\n    VIR_FREE(migrateFrom);\n    return inc;\n}"
  },
  {
    "function_name": "qemuMigrationDstPrepareCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2273-2291",
    "snippet": "static void\nqemuMigrationDstPrepareCleanup(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"driver=%p, vm=%s, job=%s, asyncJob=%s\",\n              driver,\n              vm->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    virPortAllocatorRelease(priv->migrationPort);\n    priv->migrationPort = 0;\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_IN))\n        return;\n    qemuDomainObjDiscardAsyncJob(driver, vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjDiscardAsyncJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjDiscardAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9636-9645",
          "snippet": "void\nqemuDomainObjDiscardAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (priv->job.active == QEMU_JOB_ASYNC_NESTED)\n        qemuDomainObjResetJob(priv);\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainObjDiscardAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (priv->job.active == QEMU_JOB_ASYNC_NESTED)\n        qemuDomainObjResetJob(priv);\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobIsActive",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5478-5496",
          "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "priv->migrationPort"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%s, job=%s, asyncJob=%s\"",
            "driver",
            "vm->def->name",
            "qemuDomainJobTypeToString(priv->job.active)",
            "qemuDomainAsyncJobTypeToString(priv->job.asyncJob)"
          ],
          "line": 2279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAsyncJobTypeToString",
          "args": [
            "priv->job.asyncJob"
          ],
          "line": 2283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainJobTypeToString",
          "args": [
            "priv->job.active"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationDstPrepareCleanup(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"driver=%p, vm=%s, job=%s, asyncJob=%s\",\n              driver,\n              vm->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\n    virPortAllocatorRelease(priv->migrationPort);\n    priv->migrationPort = 0;\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_IN))\n        return;\n    qemuDomainObjDiscardAsyncJob(driver, vm);\n}"
  },
  {
    "function_name": "qemuMigrationSrcBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2199-2267",
    "snippet": "char *\nqemuMigrationSrcBegin(virConnectPtr conn,\n                      virDomainObjPtr vm,\n                      const char *xmlin,\n                      const char *dname,\n                      char **cookieout,\n                      int *cookieoutlen,\n                      size_t nmigrate_disks,\n                      const char **migrate_disks,\n                      unsigned long flags)\n{\n    virQEMUDriverPtr driver = conn->privateData;\n    char *xml = NULL;\n    qemuDomainAsyncJob asyncJob;\n\n    if ((flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            goto cleanup;\n        asyncJob = QEMU_ASYNC_JOB_MIGRATION_OUT;\n    } else {\n        if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n            goto cleanup;\n        asyncJob = QEMU_ASYNC_JOB_NONE;\n    }\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    /* Check if there is any ejected media.\n     * We don't want to require them on the destination.\n     */\n    if (!(flags & VIR_MIGRATE_OFFLINE) &&\n        qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        goto endjob;\n\n    if (!(xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                           cookieout, cookieoutlen,\n                                           nmigrate_disks, migrate_disks, flags)))\n        goto endjob;\n\n    if ((flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        /* We keep the job active across API calls until the confirm() call.\n         * This prevents any other APIs being invoked while migration is taking\n         * place.\n         */\n        if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                                 qemuMigrationSrcCleanup) < 0) {\n            VIR_FREE(xml);\n            goto endjob;\n        }\n        qemuMigrationJobContinue(vm);\n    } else {\n        goto endjob;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return xml;\n\n endjob:\n    if (flags & VIR_MIGRATE_CHANGE_PROTECTION)\n        qemuMigrationJobFinish(driver, vm);\n    else\n        qemuDomainObjEndJob(driver, vm);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjEndJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEndJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10032-10051",
          "snippet": "void\nqemuDomainObjEndJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    qemuDomainJob job = priv->job.active;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping job: %s (async=%s vm=%p name=%s)\",\n              qemuDomainJobTypeToString(job),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetJob(priv);\n    if (qemuDomainTrackJob(job))\n        qemuDomainObjSaveStatus(driver, obj);\n    /* We indeed need to wake up ALL threads waiting because\n     * grabbing a job requires checking more variables. */\n    virCondBroadcast(&priv->job.cond);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\nobj, obj->def->name);\n\nvoid\nqemuDomainObjEndJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n    qemuDomainJob job = priv->job.active;\n\n    priv->jobs_queued--;\n\n    VIR_DEBUG(\"Stopping job: %s (async=%s vm=%p name=%s)\",\n              qemuDomainJobTypeToString(job),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              obj, obj->def->name);\n\n    qemuDomainObjResetJob(priv);\n    if (qemuDomainTrackJob(job))\n        qemuDomainObjSaveStatus(driver, obj);\n    /* We indeed need to wake up ALL threads waiting because\n     * grabbing a job requires checking more variables. */\n    virCondBroadcast(&priv->job.cond);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobFinish",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5498-5502",
          "snippet": "static void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobFinish(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjEndAsyncJob(driver, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjEndAPI",
          "args": [
            "&vm"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjEndAPI",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3640-3649",
          "snippet": "void\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjEndAPI(virDomainObjPtr *vm)\n{\n    if (!*vm)\n        return;\n\n    virObjectUnlock(*vm);\n    virObjectUnref(*vm);\n    *vm = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobContinue",
          "args": [
            "vm"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobContinue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5472-5476",
          "snippet": "static void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobContinue(virDomainObjPtr vm)\n{\n    qemuDomainObjReleaseAsyncJob(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "xml"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCloseCallbacksSet",
          "args": [
            "driver->closeCallbacks",
            "vm",
            "conn",
            "qemuMigrationSrcCleanup"
          ],
          "line": 2247
        },
        "resolved": true,
        "details": {
          "function_name": "virCloseCallbacksSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virclosecallbacks.c",
          "lines": "89-140",
          "snippet": "int\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virlog.h\"",
            "#include \"virclosecallbacks.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virlog.h\"\n#include \"virclosecallbacks.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint\nvirCloseCallbacksSet(virCloseCallbacksPtr closeCallbacks,\n                     virDomainObjPtr vm,\n                     virConnectPtr conn,\n                     virCloseCallback cb)\n{\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    virDriverCloseDefPtr closeDef;\n    int ret = -1;\n\n    virUUIDFormat(vm->def->uuid, uuidstr);\n    VIR_DEBUG(\"vm=%s, uuid=%s, conn=%p, cb=%p\",\n              vm->def->name, uuidstr, conn, cb);\n\n    virObjectLock(closeCallbacks);\n\n    closeDef = virHashLookup(closeCallbacks->list, uuidstr);\n    if (closeDef) {\n        if (closeDef->conn != conn) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Close callback for domain %s already registered\"\n                             \" with another connection %p\"),\n                           vm->def->name, closeDef->conn);\n            goto cleanup;\n        }\n        if (closeDef->cb && closeDef->cb != cb) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Another close callback is already defined for\"\n                             \" domain %s\"), vm->def->name);\n            goto cleanup;\n        }\n\n        closeDef->cb = cb;\n    } else {\n        if (VIR_ALLOC(closeDef) < 0)\n            goto cleanup;\n\n        closeDef->conn = conn;\n        closeDef->cb = cb;\n        if (virHashAddEntry(closeCallbacks->list, uuidstr, closeDef) < 0) {\n            VIR_FREE(closeDef);\n            goto cleanup;\n        }\n        virObjectRef(vm);\n    }\n\n    virObjectRef(closeCallbacks);\n    ret = 0;\n cleanup:\n    virObjectUnlock(closeCallbacks);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcBeginPhase",
          "args": [
            "driver",
            "vm",
            "xmlin",
            "dname",
            "cookieout",
            "cookieoutlen",
            "nmigrate_disks",
            "migrate_disks",
            "flags"
          ],
          "line": 2237
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcBeginPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "2039-2197",
          "snippet": "static char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessRefreshDisks",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessRefreshDisks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7720-7774",
          "snippet": "int\nqemuProcessRefreshDisks(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    virHashTablePtr table = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        table = qemuMonitorGetBlockInfo(priv->mon);\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    if (!table)\n        goto cleanup;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskpriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        struct qemuDomainDiskInfo *info;\n        const char *entryname = disk->info.alias;\n\n        if (blockdev)\n            entryname = diskpriv->qomName;\n\n        if (!(info = virHashLookup(table, entryname)))\n            continue;\n\n        if (info->removable) {\n            if (info->empty)\n                virDomainDiskEmptySource(disk);\n\n            if (info->tray) {\n                if (info->tray_open)\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n                else\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n            }\n        }\n\n        /* fill in additional data */\n        diskpriv->removable = info->removable;\n        diskpriv->tray = info->tray;\n    }\n\n    ret = 0;\n\n cleanup:\n    virHashFree(table);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessRefreshDisks(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool blockdev = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV);\n    virHashTablePtr table = NULL;\n    int ret = -1;\n    size_t i;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) == 0) {\n        table = qemuMonitorGetBlockInfo(priv->mon);\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    if (!table)\n        goto cleanup;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskpriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        struct qemuDomainDiskInfo *info;\n        const char *entryname = disk->info.alias;\n\n        if (blockdev)\n            entryname = diskpriv->qomName;\n\n        if (!(info = virHashLookup(table, entryname)))\n            continue;\n\n        if (info->removable) {\n            if (info->empty)\n                virDomainDiskEmptySource(disk);\n\n            if (info->tray) {\n                if (info->tray_open)\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_OPEN;\n                else\n                    disk->tray_status = VIR_DOMAIN_DISK_TRAY_CLOSED;\n            }\n        }\n\n        /* fill in additional data */\n        diskpriv->removable = info->removable;\n        diskpriv->tray = info->tray;\n    }\n\n    ret = 0;\n\n cleanup:\n    virHashFree(table);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjCheckActive",
          "args": [
            "vm"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjCheckActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "7294-7303",
          "snippet": "int\nvirDomainObjCheckActive(virDomainObjPtr dom)\n{\n    if (!virDomainObjIsActive(dom)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"domain is not running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjCheckActive(virDomainObjPtr dom)\n{\n    if (!virDomainObjIsActive(dom)) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       \"%s\", _(\"domain is not running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcStoreDomainState",
          "args": [
            "vm"
          ],
          "line": 2225
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcStoreDomainState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "117-125",
          "snippet": "static void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjBeginJob",
          "args": [
            "driver",
            "vm",
            "QEMU_JOB_MODIFY"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjBeginJobNowait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10016-10024",
          "snippet": "int\nqemuDomainObjBeginJobNowait(virQEMUDriverPtr driver,\n                            virDomainObjPtr obj,\n                            qemuDomainJob job)\n{\n    return qemuDomainObjBeginJobInternal(driver, obj, job,\n                                         QEMU_AGENT_JOB_NONE,\n                                         QEMU_ASYNC_JOB_NONE, true);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint\nqemuDomainObjBeginJobNowait(virQEMUDriverPtr driver,\n                            virDomainObjPtr obj,\n                            qemuDomainJob job)\n{\n    return qemuDomainObjBeginJobInternal(driver, obj, job,\n                                         QEMU_AGENT_JOB_NONE,\n                                         QEMU_ASYNC_JOB_NONE, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobStart",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "flags"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5418-5445",
          "snippet": "static int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobStart(virQEMUDriverPtr driver,\n                      virDomainObjPtr vm,\n                      qemuDomainAsyncJob job,\n                      unsigned long apiFlags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainJobOperation op;\n    unsigned long long mask;\n\n    if (job == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_IN;\n        mask = QEMU_JOB_NONE;\n    } else {\n        op = VIR_DOMAIN_JOB_OPERATION_MIGRATION_OUT;\n        mask = QEMU_JOB_DEFAULT_MASK |\n               JOB_MASK(QEMU_JOB_SUSPEND) |\n               JOB_MASK(QEMU_JOB_MIGRATION_OP);\n    }\n\n    if (qemuDomainObjBeginAsyncJob(driver, vm, job, op, apiFlags) < 0)\n        return -1;\n\n    priv->job.current->statsType = QEMU_DOMAIN_JOB_STATS_TYPE_MIGRATION;\n\n    qemuDomainObjSetAsyncJobMask(vm, mask);\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nchar *\nqemuMigrationSrcBegin(virConnectPtr conn,\n                      virDomainObjPtr vm,\n                      const char *xmlin,\n                      const char *dname,\n                      char **cookieout,\n                      int *cookieoutlen,\n                      size_t nmigrate_disks,\n                      const char **migrate_disks,\n                      unsigned long flags)\n{\n    virQEMUDriverPtr driver = conn->privateData;\n    char *xml = NULL;\n    qemuDomainAsyncJob asyncJob;\n\n    if ((flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        if (qemuMigrationJobStart(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                  flags) < 0)\n            goto cleanup;\n        asyncJob = QEMU_ASYNC_JOB_MIGRATION_OUT;\n    } else {\n        if (qemuDomainObjBeginJob(driver, vm, QEMU_JOB_MODIFY) < 0)\n            goto cleanup;\n        asyncJob = QEMU_ASYNC_JOB_NONE;\n    }\n\n    qemuMigrationSrcStoreDomainState(vm);\n\n    if (!(flags & VIR_MIGRATE_OFFLINE) && virDomainObjCheckActive(vm) < 0)\n        goto endjob;\n\n    /* Check if there is any ejected media.\n     * We don't want to require them on the destination.\n     */\n    if (!(flags & VIR_MIGRATE_OFFLINE) &&\n        qemuProcessRefreshDisks(driver, vm, asyncJob) < 0)\n        goto endjob;\n\n    if (!(xml = qemuMigrationSrcBeginPhase(driver, vm, xmlin, dname,\n                                           cookieout, cookieoutlen,\n                                           nmigrate_disks, migrate_disks, flags)))\n        goto endjob;\n\n    if ((flags & VIR_MIGRATE_CHANGE_PROTECTION)) {\n        /* We keep the job active across API calls until the confirm() call.\n         * This prevents any other APIs being invoked while migration is taking\n         * place.\n         */\n        if (virCloseCallbacksSet(driver->closeCallbacks, vm, conn,\n                                 qemuMigrationSrcCleanup) < 0) {\n            VIR_FREE(xml);\n            goto endjob;\n        }\n        qemuMigrationJobContinue(vm);\n    } else {\n        goto endjob;\n    }\n\n cleanup:\n    virDomainObjEndAPI(&vm);\n    return xml;\n\n endjob:\n    if (flags & VIR_MIGRATE_CHANGE_PROTECTION)\n        qemuMigrationJobFinish(driver, vm);\n    else\n        qemuDomainObjEndJob(driver, vm);\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuMigrationSrcBeginPhase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "2039-2197",
    "snippet": "static char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationCookieFree",
          "args": [
            "mig"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationCookieFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "110-130",
          "snippet": "void\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nvoid\nqemuMigrationCookieFree(qemuMigrationCookiePtr mig)\n{\n    if (!mig)\n        return;\n\n    qemuMigrationCookieGraphicsFree(mig->graphics);\n    virDomainDefFree(mig->persistent);\n    qemuMigrationCookieNetworkFree(mig->network);\n    qemuMigrationCookieNBDFree(mig->nbd);\n\n    VIR_FREE(mig->localHostname);\n    VIR_FREE(mig->remoteHostname);\n    VIR_FREE(mig->name);\n    VIR_FREE(mig->lockState);\n    VIR_FREE(mig->lockDriver);\n    VIR_FREE(mig->jobInfo);\n    virCPUDefFree(mig->cpu);\n    qemuMigrationCookieCapsFree(mig->caps);\n    VIR_FREE(mig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDefFormatLive",
          "args": [
            "driver",
            "priv->qemuCaps",
            "vm->def",
            "priv->origCPU",
            "false",
            "true"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDefFormatLive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10593-10609",
          "snippet": "char *\nqemuDomainDefFormatLive(virQEMUDriverPtr driver,\n                        virQEMUCapsPtr qemuCaps,\n                        virDomainDefPtr def,\n                        virCPUDefPtr origCPU,\n                        bool inactive,\n                        bool compatible)\n{\n    unsigned int flags = QEMU_DOMAIN_FORMAT_LIVE_FLAGS;\n\n    if (inactive)\n        flags |= VIR_DOMAIN_XML_INACTIVE;\n    if (compatible)\n        flags |= VIR_DOMAIN_XML_MIGRATABLE;\n\n    return qemuDomainDefFormatXMLInternal(driver, qemuCaps, def, origCPU, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nchar *\nqemuDomainDefFormatLive(virQEMUDriverPtr driver,\n                        virQEMUCapsPtr qemuCaps,\n                        virDomainDefPtr def,\n                        virCPUDefPtr origCPU,\n                        bool inactive,\n                        bool compatible)\n{\n    unsigned int flags = QEMU_DOMAIN_FORMAT_LIVE_FLAGS;\n\n    if (inactive)\n        flags |= VIR_DOMAIN_XML_INACTIVE;\n    if (compatible)\n        flags |= VIR_DOMAIN_XML_MIGRATABLE;\n\n    return qemuDomainDefFormatXMLInternal(driver, qemuCaps, def, origCPU, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainCheckABIStability",
          "args": [
            "driver",
            "vm",
            "def"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainCheckABIStability",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12518-12542",
          "snippet": "bool\nqemuDomainCheckABIStability(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            virDomainDefPtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr migratableSrc = NULL;\n    virDomainDefPtr migratableDst = NULL;\n    g_autofree char *xml = NULL;\n    bool ret = false;\n\n    if (!(xml = qemuDomainFormatXML(driver, vm, COPY_FLAGS)) ||\n        !(migratableSrc = qemuDomainDefFromXML(driver, priv->qemuCaps, xml)) ||\n        !(migratableDst = qemuDomainDefCopy(driver, priv->qemuCaps, dst, COPY_FLAGS)))\n        goto cleanup;\n\n    ret = qemuDomainMigratableDefCheckABIStability(driver,\n                                                   vm->def, migratableSrc,\n                                                   dst, migratableDst);\n\n cleanup:\n    virDomainDefFree(migratableSrc);\n    virDomainDefFree(migratableDst);\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define COPY_FLAGS (VIR_DOMAIN_XML_SECURE | \\\n                    VIR_DOMAIN_XML_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\n#define COPY_FLAGS (VIR_DOMAIN_XML_SECURE | \\\n                    VIR_DOMAIN_XML_MIGRATABLE)\n\nbool\nqemuDomainCheckABIStability(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            virDomainDefPtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virDomainDefPtr migratableSrc = NULL;\n    virDomainDefPtr migratableDst = NULL;\n    g_autofree char *xml = NULL;\n    bool ret = false;\n\n    if (!(xml = qemuDomainFormatXML(driver, vm, COPY_FLAGS)) ||\n        !(migratableSrc = qemuDomainDefFromXML(driver, priv->qemuCaps, xml)) ||\n        !(migratableDst = qemuDomainDefCopy(driver, priv->qemuCaps, dst, COPY_FLAGS)))\n        goto cleanup;\n\n    ret = qemuDomainMigratableDefCheckABIStability(driver,\n                                                   vm->def, migratableSrc,\n                                                   dst, migratableDst);\n\n cleanup:\n    virDomainDefFree(migratableSrc);\n    virDomainDefFree(migratableDst);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xmlin",
            "driver->xmlopt",
            "priv->qemuCaps",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE"
          ],
          "line": 2179
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"tunnelled offline migration does not \"\n                             \"make sense\")"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"tunnelled offline migration does not \"\n                             \"make sense\""
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"offline migration must be specified with \"\n                             \"the persistent flag set\")"
          ],
          "line": 2165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"offline migration cannot handle \"\n                             \"non-shared storage\")"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationBakeCookie",
          "args": [
            "mig",
            "driver",
            "vm",
            "QEMU_MIGRATION_SOURCE",
            "cookieout",
            "cookieoutlen",
            "cookieFlags"
          ],
          "line": 2150
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationBakeCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1397-1459",
          "snippet": "int\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nint\nqemuMigrationBakeCookie(qemuMigrationCookiePtr mig,\n                        virQEMUDriverPtr driver,\n                        virDomainObjPtr dom,\n                        qemuMigrationParty party,\n                        char **cookieout,\n                        int *cookieoutlen,\n                        unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = dom->privateData;\n\n    if (!cookieout || !cookieoutlen)\n        return 0;\n\n    *cookieoutlen = 0;\n\n    if (flags & QEMU_MIGRATION_COOKIE_GRAPHICS &&\n        qemuMigrationCookieAddGraphics(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_LOCKSTATE &&\n        qemuMigrationCookieAddLockstate(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_NETWORK &&\n        qemuMigrationCookieAddNetwork(mig, driver, dom) < 0) {\n        return -1;\n    }\n\n    if ((flags & QEMU_MIGRATION_COOKIE_NBD) &&\n        qemuMigrationCookieAddNBD(mig, driver, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS &&\n        qemuMigrationCookieAddStatistics(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU_HOTPLUG)\n        mig->flagsMandatory |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (flags & QEMU_MIGRATION_COOKIE_CPU &&\n        qemuMigrationCookieAddCPU(mig, dom) < 0)\n        return -1;\n\n    if (flags & QEMU_MIGRATION_COOKIE_ALLOW_REBOOT)\n        qemuMigrationCookieAddAllowReboot(mig, dom);\n\n    if (flags & QEMU_MIGRATION_COOKIE_CAPS &&\n        qemuMigrationCookieAddCaps(mig, dom, party) < 0)\n        return -1;\n\n    if (!(*cookieout = qemuMigrationCookieXMLFormatStr(driver, priv->qemuCaps, mig)))\n        return -1;\n\n    *cookieoutlen = strlen(*cookieout) + 1;\n\n    VIR_DEBUG(\"cookielen=%d cookie=%s\", *cookieoutlen, *cookieout);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationEatCookie",
          "args": [
            "driver",
            "vm->def",
            "priv->origname",
            "priv",
            "NULL",
            "0",
            "0"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationEatCookie",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_cookie.c",
          "lines": "1462-1527",
          "snippet": "qemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}",
          "includes": [
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include <gnutls/x509.h>",
            "#include <gnutls/gnutls.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_domain.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include <gnutls/x509.h>\n#include <gnutls/gnutls.h>\n#include <config.h>\n\nqemuMigrationCookiePtr\nqemuMigrationEatCookie(virQEMUDriverPtr driver,\n                       const virDomainDef *def,\n                       const char *origname,\n                       qemuDomainObjPrivatePtr priv,\n                       const char *cookiein,\n                       int cookieinlen,\n                       unsigned int flags)\n{\n    qemuMigrationCookiePtr mig = NULL;\n\n    /* Parse & validate incoming cookie (if any) */\n    if (cookiein && cookieinlen &&\n        cookiein[cookieinlen-1] != '\\0') {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Migration cookie was not NULL terminated\"));\n        goto error;\n    }\n\n    VIR_DEBUG(\"cookielen=%d cookie='%s'\", cookieinlen, NULLSTR(cookiein));\n\n    if (!(mig = qemuMigrationCookieNew(def, origname)))\n        return NULL;\n\n    if (cookiein && cookieinlen &&\n        qemuMigrationCookieXMLParseStr(mig,\n                                       driver,\n                                       priv ? priv->qemuCaps : NULL,\n                                       cookiein,\n                                       flags) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COOKIE_PERSISTENT &&\n        mig->persistent &&\n        STRNEQ(def->name, mig->persistent->name)) {\n        VIR_FREE(mig->persistent->name);\n        mig->persistent->name = g_strdup(def->name);\n    }\n\n    if (mig->flags & QEMU_MIGRATION_COOKIE_LOCKSTATE) {\n        if (!mig->lockDriver) {\n            if (virLockManagerPluginUsesState(driver->lockManager)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Missing %s lock state for migration cookie\"),\n                               virLockManagerPluginGetName(driver->lockManager));\n                goto error;\n            }\n        } else if (STRNEQ(mig->lockDriver,\n                          virLockManagerPluginGetName(driver->lockManager))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Source host lock driver %s different from target %s\"),\n                           mig->lockDriver,\n                           virLockManagerPluginGetName(driver->lockManager));\n            goto error;\n        }\n    }\n\n    if (flags & QEMU_MIGRATION_COOKIE_STATS && mig->jobInfo)\n        mig->jobInfo->operation = priv->job.current->operation;\n\n    return mig;\n\n error:\n    qemuMigrationCookieFree(mig);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainVcpuHotplugIsInOrder",
          "args": [
            "vm->newDef"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainVcpuHotplugIsInOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "14133-14158",
          "snippet": "bool\nqemuDomainVcpuHotplugIsInOrder(virDomainDefPtr def)\n{\n    size_t maxvcpus = virDomainDefGetVcpusMax(def);\n    virDomainVcpuDefPtr vcpu;\n    unsigned int prevorder = 0;\n    size_t seenonlinevcpus = 0;\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n\n        if (!vcpu->online)\n            break;\n\n        if (vcpu->order < prevorder)\n            break;\n\n        if (vcpu->order > prevorder)\n            prevorder = vcpu->order;\n\n        seenonlinevcpus++;\n    }\n\n    return seenonlinevcpus == virDomainDefGetVcpus(def);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainVcpuHotplugIsInOrder(virDomainDefPtr def)\n{\n    size_t maxvcpus = virDomainDefGetVcpusMax(def);\n    virDomainVcpuDefPtr vcpu;\n    unsigned int prevorder = 0;\n    size_t seenonlinevcpus = 0;\n    size_t i;\n\n    for (i = 0; i < maxvcpus; i++) {\n        vcpu = virDomainDefGetVcpu(def, i);\n\n        if (!vcpu->online)\n            break;\n\n        if (vcpu->order < prevorder)\n            break;\n\n        if (vcpu->order > prevorder)\n            prevorder = vcpu->order;\n\n        seenonlinevcpus++;\n    }\n\n    return seenonlinevcpus == virDomainDefGetVcpus(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefHasMemoryHotplug",
          "args": [
            "vm->newDef"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefHasMemoryHotplug",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "10896-10900",
          "snippet": "bool\nvirDomainDefHasMemoryHotplug(const virDomainDef *def)\n{\n    return def->mem.memory_slots > 0 || def->mem.max_memory > 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirDomainDefHasMemoryHotplug(const virDomainDef *def)\n{\n    return def->mem.memory_slots > 0 || def->mem.max_memory > 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"NBD in tunnelled migration is currently not supported\""
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\")"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"disk target %s not found\")",
            "migrate_disks[i]"
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "vm->def->disks[j]->dst",
            "migrate_disks[i]"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"post-copy is not supported with tunnelled migration\")"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_ARGUMENT_UNSUPPORTED",
            "\"%s\"",
            "_(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\")"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsSafe",
          "args": [
            "vm->def",
            "priv->qemuCaps",
            "nmigrate_disks",
            "migrate_disks",
            "flags"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsSafe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1299-1383",
          "snippet": "static bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsAllowed",
          "args": [
            "driver",
            "vm",
            "true",
            "flags"
          ],
          "line": 2070
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsAllowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1166-1297",
          "snippet": "bool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nbool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobSetPhase",
          "args": [
            "driver",
            "vm",
            "QEMU_MIGRATION_PHASE_BEGIN3"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobSetPhase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5447-5462",
          "snippet": "static void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationJobSetPhase(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuMigrationJobPhase phase)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (phase < priv->job.phase) {\n        VIR_ERROR(_(\"migration protocol going backwards %s => %s\"),\n                  qemuMigrationJobPhaseTypeToString(priv->job.phase),\n                  qemuMigrationJobPhaseTypeToString(phase));\n        return;\n    }\n\n    qemuDomainObjSetJobPhase(driver, vm, phase);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\"",
            "driver",
            "vm",
            "NULLSTR(xmlin)",
            "NULLSTR(dname)",
            "cookieout",
            "cookieoutlen",
            "nmigrate_disks",
            "migrate_disks",
            "flags"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dname"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "xmlin"
          ],
          "line": 2059
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic char *\nqemuMigrationSrcBeginPhase(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *xmlin,\n                           const char *dname,\n                           char **cookieout,\n                           int *cookieoutlen,\n                           size_t nmigrate_disks,\n                           const char **migrate_disks,\n                           unsigned long flags)\n{\n    char *rv = NULL;\n    qemuMigrationCookiePtr mig = NULL;\n    virDomainDefPtr def = NULL;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int cookieFlags = QEMU_MIGRATION_COOKIE_LOCKSTATE;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, xmlin=%s, dname=%s,\"\n              \" cookieout=%p, cookieoutlen=%p,\"\n              \" nmigrate_disks=%zu, migrate_disks=%p, flags=0x%lx\",\n              driver, vm, NULLSTR(xmlin), NULLSTR(dname),\n              cookieout, cookieoutlen, nmigrate_disks,\n              migrate_disks, flags);\n\n    /* Only set the phase if we are inside QEMU_ASYNC_JOB_MIGRATION_OUT.\n     * Otherwise we will start the async job later in the perform phase losing\n     * change protection.\n     */\n    if (priv->job.asyncJob == QEMU_ASYNC_JOB_MIGRATION_OUT)\n        qemuMigrationJobSetPhase(driver, vm, QEMU_MIGRATION_PHASE_BEGIN3);\n\n    if (!qemuMigrationSrcIsAllowed(driver, vm, true, flags))\n        goto cleanup;\n\n    if (!(flags & (VIR_MIGRATE_UNSAFE | VIR_MIGRATE_OFFLINE)) &&\n        !qemuMigrationSrcIsSafe(vm->def, priv->qemuCaps,\n                                nmigrate_disks, migrate_disks, flags))\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_POSTCOPY &&\n        (!(flags & VIR_MIGRATE_LIVE) ||\n         flags & VIR_MIGRATE_PAUSED)) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy migration is not supported with non-live \"\n                         \"or paused migration\"));\n        goto cleanup;\n    }\n\n    if (flags & VIR_MIGRATE_POSTCOPY && flags & VIR_MIGRATE_TUNNELLED) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED, \"%s\",\n                       _(\"post-copy is not supported with tunnelled migration\"));\n        goto cleanup;\n    }\n\n    if (flags & (VIR_MIGRATE_NON_SHARED_DISK | VIR_MIGRATE_NON_SHARED_INC)) {\n        if (nmigrate_disks) {\n            size_t i, j;\n            /* Check user requested only known disk targets. */\n            for (i = 0; i < nmigrate_disks; i++) {\n                for (j = 0; j < vm->def->ndisks; j++) {\n                    if (STREQ(vm->def->disks[j]->dst, migrate_disks[i]))\n                        break;\n                }\n\n                if (j == vm->def->ndisks) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"disk target %s not found\"),\n                                   migrate_disks[i]);\n                    goto cleanup;\n                }\n            }\n\n            if (flags & VIR_MIGRATE_TUNNELLED) {\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                               _(\"Selecting disks to migrate is not \"\n                                 \"implemented for tunnelled migration\"));\n                goto cleanup;\n            }\n        }\n\n        /* TODO support NBD for TUNNELLED migration */\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            VIR_WARN(\"NBD in tunnelled migration is currently not supported\");\n        } else {\n            cookieFlags |= QEMU_MIGRATION_COOKIE_NBD;\n            priv->nbdPort = 0;\n        }\n    }\n\n    if (virDomainDefHasMemoryHotplug(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && virDomainDefHasMemoryHotplug(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_MEMORY_HOTPLUG;\n\n    if (!qemuDomainVcpuHotplugIsInOrder(vm->def) ||\n        ((flags & VIR_MIGRATE_PERSIST_DEST) &&\n         vm->newDef && !qemuDomainVcpuHotplugIsInOrder(vm->newDef)))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU_HOTPLUG;\n\n    if (priv->origCPU)\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CPU;\n\n    cookieFlags |= QEMU_MIGRATION_COOKIE_ALLOW_REBOOT;\n\n    if (!(flags & VIR_MIGRATE_OFFLINE))\n        cookieFlags |= QEMU_MIGRATION_COOKIE_CAPS;\n\n    if (!(mig = qemuMigrationEatCookie(driver, vm->def,\n                                       priv->origname, priv, NULL, 0, 0)))\n        goto cleanup;\n\n    if (qemuMigrationBakeCookie(mig, driver, vm,\n                                QEMU_MIGRATION_SOURCE,\n                                cookieout, cookieoutlen,\n                                cookieFlags) < 0)\n        goto cleanup;\n\n    if (flags & VIR_MIGRATE_OFFLINE) {\n        if (flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                     VIR_MIGRATE_NON_SHARED_INC)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration cannot handle \"\n                             \"non-shared storage\"));\n            goto cleanup;\n        }\n        if (!(flags & VIR_MIGRATE_PERSIST_DEST)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"offline migration must be specified with \"\n                             \"the persistent flag set\"));\n            goto cleanup;\n        }\n        if (flags & VIR_MIGRATE_TUNNELLED) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"tunnelled offline migration does not \"\n                             \"make sense\"));\n            goto cleanup;\n        }\n    }\n\n    if (xmlin) {\n        if (!(def = virDomainDefParseString(xmlin, driver->xmlopt, priv->qemuCaps,\n                                            VIR_DOMAIN_DEF_PARSE_INACTIVE |\n                                            VIR_DOMAIN_DEF_PARSE_SKIP_VALIDATE)))\n            goto cleanup;\n\n        if (!qemuDomainCheckABIStability(driver, vm, def))\n            goto cleanup;\n\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, def, NULL, false, true);\n    } else {\n        rv = qemuDomainDefFormatLive(driver, priv->qemuCaps, vm->def, priv->origCPU,\n                                     false, true);\n    }\n\n cleanup:\n    qemuMigrationCookieFree(mig);\n    virDomainDefFree(def);\n    return rv;\n}"
  },
  {
    "function_name": "qemuMigrationSrcCleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1982-2035",
    "snippet": "static void\nqemuMigrationSrcCleanup(virDomainObjPtr vm,\n                        virConnectPtr conn,\n                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"vm=%s, conn=%p, asyncJob=%s, phase=%s\",\n              vm->def->name, conn,\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              qemuDomainAsyncJobPhaseToString(priv->job.asyncJob,\n                                              priv->job.phase));\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT))\n        return;\n\n    VIR_DEBUG(\"The connection which started outgoing migration of domain %s\"\n              \" was closed; canceling the migration\",\n              vm->def->name);\n\n    switch ((qemuMigrationJobPhase) priv->job.phase) {\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n        /* just forget we were about to migrate */\n        qemuDomainObjDiscardAsyncJob(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n        VIR_WARN(\"Migration of domain %s finished but we don't know if the\"\n                 \" domain was successfully started on destination or not\",\n                 vm->def->name);\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        /* clear the job and let higher levels decide what to do */\n        qemuDomainObjDiscardAsyncJob(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n        /* cannot be seen without an active migration API; unreachable */\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n        /* all done; unreachable */\n    case QEMU_MIGRATION_PHASE_PREPARE:\n    case QEMU_MIGRATION_PHASE_FINISH2:\n    case QEMU_MIGRATION_PHASE_FINISH3:\n        /* incoming migration; unreachable */\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n        /* single phase outgoing migration; unreachable */\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* unreachable */\n        ;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjDiscardAsyncJob",
          "args": [
            "driver",
            "vm"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjDiscardAsyncJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9636-9645",
          "snippet": "void\nqemuDomainObjDiscardAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (priv->job.active == QEMU_JOB_ASYNC_NESTED)\n        qemuDomainObjResetJob(priv);\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainObjDiscardAsyncJob(virQEMUDriverPtr driver, virDomainObjPtr obj)\n{\n    qemuDomainObjPrivatePtr priv = obj->privateData;\n\n    if (priv->job.active == QEMU_JOB_ASYNC_NESTED)\n        qemuDomainObjResetJob(priv);\n    qemuDomainObjResetAsyncJob(priv);\n    qemuDomainObjSaveStatus(driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationParamsReset",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "priv->job.migParams",
            "priv->job.apiFlags"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationParamsReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration_params.c",
          "lines": "1236-1260",
          "snippet": "void\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}",
          "includes": [
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_paramspriv.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor.h\"\n#include \"qemu_migration_paramspriv.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_alias.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nqemuMigrationParamsReset(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         int asyncJob,\n                         qemuMigrationParamsPtr origParams,\n                         unsigned long apiFlags)\n{\n    virErrorPtr err;\n\n    virErrorPreserveLast(&err);\n\n    VIR_DEBUG(\"Resetting migration parameters %p, flags 0x%lx\",\n              origParams, apiFlags);\n\n    if (!virDomainObjIsActive(vm) || !origParams)\n        goto cleanup;\n\n    if (qemuMigrationParamsApply(driver, vm, asyncJob, origParams) < 0)\n        goto cleanup;\n\n    qemuMigrationParamsResetTLS(driver, vm, asyncJob, origParams, apiFlags);\n\n cleanup:\n    virErrorRestore(&err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Migration of domain %s finished but we don't know if the\"\n                 \" domain was successfully started on destination or not\"",
            "vm->def->name"
          ],
          "line": 2010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"The connection which started outgoing migration of domain %s\"\n              \" was closed; canceling the migration\"",
            "vm->def->name"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobIsActive",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5478-5496",
          "snippet": "static bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationJobIsActive(virDomainObjPtr vm,\n                         qemuDomainAsyncJob job)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (priv->job.asyncJob != job) {\n        const char *msg;\n\n        if (job == QEMU_ASYNC_JOB_MIGRATION_IN)\n            msg = _(\"domain '%s' is not processing incoming migration\");\n        else\n            msg = _(\"domain '%s' is not being migrated\");\n\n        virReportError(VIR_ERR_OPERATION_INVALID, msg, vm->def->name);\n        return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"vm=%s, conn=%p, asyncJob=%s, phase=%s\"",
            "vm->def->name",
            "conn",
            "qemuDomainAsyncJobTypeToString(priv->job.asyncJob)",
            "qemuDomainAsyncJobPhaseToString(priv->job.asyncJob,\n                                              priv->job.phase)"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAsyncJobPhaseToString",
          "args": [
            "priv->job.asyncJob",
            "priv->job.phase"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainAsyncJobPhaseToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "206-227",
          "snippet": "const char *\nqemuDomainAsyncJobPhaseToString(qemuDomainAsyncJob job,\n                                int phase G_GNUC_UNUSED)\n{\n    switch (job) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return qemuMigrationJobPhaseTypeToString(phase);\n\n    case QEMU_ASYNC_JOB_SAVE:\n    case QEMU_ASYNC_JOB_DUMP:\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n    case QEMU_ASYNC_JOB_START:\n    case QEMU_ASYNC_JOB_NONE:\n    case QEMU_ASYNC_JOB_BACKUP:\n        G_GNUC_FALLTHROUGH;\n    case QEMU_ASYNC_JOB_LAST:\n        break;\n    }\n\n    return \"none\";\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nconst char *\nqemuDomainAsyncJobPhaseToString(qemuDomainAsyncJob job,\n                                int phase G_GNUC_UNUSED)\n{\n    switch (job) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return qemuMigrationJobPhaseTypeToString(phase);\n\n    case QEMU_ASYNC_JOB_SAVE:\n    case QEMU_ASYNC_JOB_DUMP:\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n    case QEMU_ASYNC_JOB_START:\n    case QEMU_ASYNC_JOB_NONE:\n    case QEMU_ASYNC_JOB_BACKUP:\n        G_GNUC_FALLTHROUGH;\n    case QEMU_ASYNC_JOB_LAST:\n        break;\n    }\n\n    return \"none\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainAsyncJobTypeToString",
          "args": [
            "priv->job.asyncJob"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcCleanup(virDomainObjPtr vm,\n                        virConnectPtr conn,\n                        void *opaque)\n{\n    virQEMUDriverPtr driver = opaque;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_DEBUG(\"vm=%s, conn=%p, asyncJob=%s, phase=%s\",\n              vm->def->name, conn,\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n              qemuDomainAsyncJobPhaseToString(priv->job.asyncJob,\n                                              priv->job.phase));\n\n    if (!qemuMigrationJobIsActive(vm, QEMU_ASYNC_JOB_MIGRATION_OUT))\n        return;\n\n    VIR_DEBUG(\"The connection which started outgoing migration of domain %s\"\n              \" was closed; canceling the migration\",\n              vm->def->name);\n\n    switch ((qemuMigrationJobPhase) priv->job.phase) {\n    case QEMU_MIGRATION_PHASE_BEGIN3:\n        /* just forget we were about to migrate */\n        qemuDomainObjDiscardAsyncJob(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3_DONE:\n        VIR_WARN(\"Migration of domain %s finished but we don't know if the\"\n                 \" domain was successfully started on destination or not\",\n                 vm->def->name);\n        qemuMigrationParamsReset(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                 priv->job.migParams, priv->job.apiFlags);\n        /* clear the job and let higher levels decide what to do */\n        qemuDomainObjDiscardAsyncJob(driver, vm);\n        break;\n\n    case QEMU_MIGRATION_PHASE_PERFORM3:\n        /* cannot be seen without an active migration API; unreachable */\n    case QEMU_MIGRATION_PHASE_CONFIRM3:\n    case QEMU_MIGRATION_PHASE_CONFIRM3_CANCELLED:\n        /* all done; unreachable */\n    case QEMU_MIGRATION_PHASE_PREPARE:\n    case QEMU_MIGRATION_PHASE_FINISH2:\n    case QEMU_MIGRATION_PHASE_FINISH3:\n        /* incoming migration; unreachable */\n    case QEMU_MIGRATION_PHASE_PERFORM2:\n        /* single phase outgoing migration; unreachable */\n    case QEMU_MIGRATION_PHASE_NONE:\n    case QEMU_MIGRATION_PHASE_LAST:\n        /* unreachable */\n        ;\n    }\n}"
  },
  {
    "function_name": "qemuMigrationDstRun",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1945-1973",
    "snippet": "int\nqemuMigrationDstRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *uri,\n                    qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rv;\n\n    VIR_DEBUG(\"Setting up incoming migration with URI %s\", uri);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorMigrateIncoming(priv->mon, uri);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        /* qemuMigrationDstWaitForCompletion is called from the Finish phase */\n        return 0;\n    }\n\n    if (qemuMigrationDstWaitForCompletion(driver, vm, asyncJob, false) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationDstWaitForCompletion",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "false"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstWaitForCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1744-1769",
          "snippet": "static int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1961
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorMigrateIncoming",
          "args": [
            "priv->mon",
            "uri"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorMigrateIncoming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4159-4168",
          "snippet": "int\nqemuMonitorMigrateIncoming(qemuMonitorPtr mon,\n                           const char *uri)\n{\n    VIR_DEBUG(\"uri=%s\", uri);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateIncoming(mon, uri);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorMigrateIncoming(qemuMonitorPtr mon,\n                           const char *uri)\n{\n    VIR_DEBUG(\"uri=%s\", uri);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONMigrateIncoming(mon, uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting up incoming migration with URI %s\"",
            "uri"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstRun(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    const char *uri,\n                    qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int rv;\n\n    VIR_DEBUG(\"Setting up incoming migration with URI %s\", uri);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorMigrateIncoming(priv->mon, uri);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    if (asyncJob == QEMU_ASYNC_JOB_MIGRATION_IN) {\n        /* qemuMigrationDstWaitForCompletion is called from the Finish phase */\n        return 0;\n    }\n\n    if (qemuMigrationDstWaitForCompletion(driver, vm, asyncJob, false) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationDstGetURI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1930-1942",
    "snippet": "char *\nqemuMigrationDstGetURI(const char *migrateFrom,\n                       int migrateFd)\n{\n    char *uri = NULL;\n\n    if (STREQ(migrateFrom, \"stdio\"))\n        uri = g_strdup_printf(\"fd:%d\", migrateFd);\n    else\n        uri = g_strdup(migrateFrom);\n\n    return uri;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "migrateFrom"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "migrateFrom",
            "\"stdio\""
          ],
          "line": 1936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nchar *\nqemuMigrationDstGetURI(const char *migrateFrom,\n                       int migrateFd)\n{\n    char *uri = NULL;\n\n    if (STREQ(migrateFrom, \"stdio\"))\n        uri = g_strdup_printf(\"fd:%d\", migrateFd);\n    else\n        uri = g_strdup(migrateFrom);\n\n    return uri;\n}"
  },
  {
    "function_name": "qemuMigrationDstCheckProtocol",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1905-1927",
    "snippet": "int\nqemuMigrationDstCheckProtocol(virQEMUCapsPtr qemuCaps,\n                              const char *migrateFrom)\n{\n    if (STRPREFIX(migrateFrom, \"rdma\")) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"incoming RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            return -1;\n        }\n    } else if (!STRPREFIX(migrateFrom, \"tcp\") &&\n               !STRPREFIX(migrateFrom, \"exec\") &&\n               !STRPREFIX(migrateFrom, \"fd\") &&\n               !STRPREFIX(migrateFrom, \"unix\") &&\n               STRNEQ(migrateFrom, \"stdio\")) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"unknown migration protocol\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"unknown migration protocol\")"
          ],
          "line": 1921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown migration protocol\""
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "migrateFrom",
            "\"stdio\""
          ],
          "line": 1920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "migrateFrom",
            "\"unix\""
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "migrateFrom",
            "\"fd\""
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "migrateFrom",
            "\"exec\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "migrateFrom",
            "\"tcp\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"incoming RDMA migration is not supported \"\n                             \"with this QEMU binary\")"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_MIGRATE_RDMA"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "migrateFrom",
            "\"rdma\""
          ],
          "line": 1909
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationDstCheckProtocol(virQEMUCapsPtr qemuCaps,\n                              const char *migrateFrom)\n{\n    if (STRPREFIX(migrateFrom, \"rdma\")) {\n        if (!virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATE_RDMA)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"incoming RDMA migration is not supported \"\n                             \"with this QEMU binary\"));\n            return -1;\n        }\n    } else if (!STRPREFIX(migrateFrom, \"tcp\") &&\n               !STRPREFIX(migrateFrom, \"exec\") &&\n               !STRPREFIX(migrateFrom, \"fd\") &&\n               !STRPREFIX(migrateFrom, \"unix\") &&\n               STRNEQ(migrateFrom, \"stdio\")) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"unknown migration protocol\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationDstOPDRelocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1871-1902",
    "snippet": "static int\nqemuMigrationDstOPDRelocate(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMigrationCookiePtr cookie)\n{\n    virDomainNetDefPtr netptr;\n    size_t i;\n\n    for (i = 0; i < cookie->network->nnets; i++) {\n        netptr = vm->def->nets[i];\n\n        switch (cookie->network->net[i].vporttype) {\n        case VIR_NETDEV_VPORT_PROFILE_NONE:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n           break;\n        case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n            if (virNetDevOpenvswitchSetMigrateData(cookie->network->net[i].portdata,\n                                                   netptr->ifname) != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\"), netptr->ifname);\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\")",
            "netptr->ifname"
          ],
          "line": 1890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\""
          ],
          "line": 1891
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevOpenvswitchSetMigrateData",
          "args": [
            "cookie->network->net[i].portdata",
            "netptr->ifname"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevOpenvswitchSetMigrateData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevopenvswitch.c",
          "lines": "268-291",
          "snippet": "int virNetDevOpenvswitchSetMigrateData(char *migrate, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!migrate) {\n        VIR_DEBUG(\"No OVS port data for interface %s\", ifname);\n        return 0;\n    }\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"set\", \"Interface\", ifname, NULL);\n    virCommandAddArgFormat(cmd, \"external_ids:PortData=%s\", migrate);\n\n    /* Run the command */\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to run command to set OVS port data for \"\n                         \"interface %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virjson.h\"",
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virjson.h\"\n#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"virmacaddr.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"virnetdevopenvswitch.h\"\n#include <config.h>\n\nint virNetDevOpenvswitchSetMigrateData(char *migrate, const char *ifname)\n{\n    g_autoptr(virCommand) cmd = NULL;\n\n    if (!migrate) {\n        VIR_DEBUG(\"No OVS port data for interface %s\", ifname);\n        return 0;\n    }\n\n    cmd = virCommandNew(OVSVSCTL);\n    virNetDevOpenvswitchAddTimeout(cmd);\n    virCommandAddArgList(cmd, \"set\", \"Interface\", ifname, NULL);\n    virCommandAddArgFormat(cmd, \"external_ids:PortData=%s\", migrate);\n\n    /* Run the command */\n    if (virCommandRun(cmd, NULL) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to run command to set OVS port data for \"\n                         \"interface %s\"), ifname);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstOPDRelocate(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                            virDomainObjPtr vm,\n                            qemuMigrationCookiePtr cookie)\n{\n    virDomainNetDefPtr netptr;\n    size_t i;\n\n    for (i = 0; i < cookie->network->nnets; i++) {\n        netptr = vm->def->nets[i];\n\n        switch (cookie->network->net[i].vporttype) {\n        case VIR_NETDEV_VPORT_PROFILE_NONE:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n           break;\n        case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n            if (virNetDevOpenvswitchSetMigrateData(cookie->network->net[i].portdata,\n                                                   netptr->ifname) != 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Unable to run command to set OVS port data for \"\n                                 \"interface %s\"), netptr->ifname);\n                return -1;\n            }\n            break;\n        default:\n            break;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcGraphicsRelocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1772-1868",
    "snippet": "static int\nqemuMigrationSrcGraphicsRelocate(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuMigrationCookiePtr cookie,\n                                 const char *graphicsuri)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    const char *listenAddress = NULL;\n    virSocketAddr addr;\n    virURIPtr uri = NULL;\n    int type = -1;\n    int port = -1;\n    int tlsPort = -1;\n    const char *tlsSubject = NULL;\n\n    if (!cookie || (!cookie->graphics && !graphicsuri))\n        return 0;\n\n    if (graphicsuri && !(uri = virURIParse(graphicsuri)))\n        goto cleanup;\n\n    if (cookie->graphics) {\n        type = cookie->graphics->type;\n\n        listenAddress = cookie->graphics->listen;\n\n        if (!listenAddress ||\n            (virSocketAddrParse(&addr, listenAddress, AF_UNSPEC) > 0 &&\n             virSocketAddrIsWildcard(&addr)))\n            listenAddress = cookie->remoteHostname;\n\n        port = cookie->graphics->port;\n        tlsPort = cookie->graphics->tlsPort;\n        tlsSubject = cookie->graphics->tlsSubject;\n    }\n\n    if (uri) {\n        size_t i;\n\n        if ((type = virDomainGraphicsTypeFromString(uri->scheme)) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unknown graphics type %s\"), uri->scheme);\n            goto cleanup;\n        }\n\n        if (uri->server)\n            listenAddress = uri->server;\n        if (uri->port > 0)\n            port = uri->port;\n\n        for (i = 0; i < uri->paramsCount; i++) {\n            virURIParamPtr param = uri->params + i;\n\n            if (STRCASEEQ(param->name, \"tlsPort\")) {\n                if (virStrToLong_i(param->value, NULL, 10, &tlsPort) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"invalid tlsPort number: %s\"),\n                                   param->value);\n                    goto cleanup;\n                }\n            } else if (STRCASEEQ(param->name, \"tlsSubject\")) {\n                tlsSubject = param->value;\n            }\n        }\n    }\n\n    /* QEMU doesn't support VNC relocation yet, so\n     * skip it to avoid generating an error\n     */\n    if (type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Older libvirt sends port == 0 for listen type='none' graphics. It's\n     * safe to ignore such requests since relocation to unknown port does\n     * not make sense in general.\n     */\n    if (port <= 0 && tlsPort <= 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n        ret = qemuMonitorGraphicsRelocate(priv->mon, type, listenAddress,\n                                          port, tlsPort, tlsSubject);\n        priv->job.spiceMigration = !ret;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            ret = -1;\n    }\n\n cleanup:\n    virURIFree(uri);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "uri"
          ],
          "line": 1866
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGraphicsRelocate",
          "args": [
            "priv->mon",
            "type",
            "listenAddress",
            "port",
            "tlsPort",
            "tlsSubject"
          ],
          "line": 1858
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGraphicsRelocate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2585-2604",
          "snippet": "int\nqemuMonitorGraphicsRelocate(qemuMonitorPtr mon,\n                            int type,\n                            const char *hostname,\n                            int port,\n                            int tlsPort,\n                            const char *tlsSubject)\n{\n    VIR_DEBUG(\"type=%d hostname=%s port=%d tlsPort=%d tlsSubject=%s\",\n              type, hostname, port, tlsPort, NULLSTR(tlsSubject));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGraphicsRelocate(mon,\n                                           type,\n                                           hostname,\n                                           port,\n                                           tlsPort,\n                                           tlsSubject);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGraphicsRelocate(qemuMonitorPtr mon,\n                            int type,\n                            const char *hostname,\n                            int port,\n                            int tlsPort,\n                            const char *tlsSubject)\n{\n    VIR_DEBUG(\"type=%d hostname=%s port=%d tlsPort=%d tlsSubject=%s\",\n              type, hostname, port, tlsPort, NULLSTR(tlsSubject));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGraphicsRelocate(mon,\n                                           type,\n                                           hostname,\n                                           port,\n                                           tlsPort,\n                                           tlsSubject);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "param->name",
            "\"tlsSubject\""
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"invalid tlsPort number: %s\")",
            "param->value"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid tlsPort number: %s\""
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "param->value",
            "NULL",
            "10",
            "&tlsPort"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "param->name",
            "\"tlsPort\""
          ],
          "line": 1826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"unknown graphics type %s\")",
            "uri->scheme"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainGraphicsTypeFromString",
          "args": [
            "uri->scheme"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrIsWildcard",
          "args": [
            "&addr"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrIsWildcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "419-431",
          "snippet": "bool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&addr",
            "listenAddress",
            "AF_UNSPEC"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "graphicsuri"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcGraphicsRelocate(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuMigrationCookiePtr cookie,\n                                 const char *graphicsuri)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int ret = -1;\n    const char *listenAddress = NULL;\n    virSocketAddr addr;\n    virURIPtr uri = NULL;\n    int type = -1;\n    int port = -1;\n    int tlsPort = -1;\n    const char *tlsSubject = NULL;\n\n    if (!cookie || (!cookie->graphics && !graphicsuri))\n        return 0;\n\n    if (graphicsuri && !(uri = virURIParse(graphicsuri)))\n        goto cleanup;\n\n    if (cookie->graphics) {\n        type = cookie->graphics->type;\n\n        listenAddress = cookie->graphics->listen;\n\n        if (!listenAddress ||\n            (virSocketAddrParse(&addr, listenAddress, AF_UNSPEC) > 0 &&\n             virSocketAddrIsWildcard(&addr)))\n            listenAddress = cookie->remoteHostname;\n\n        port = cookie->graphics->port;\n        tlsPort = cookie->graphics->tlsPort;\n        tlsSubject = cookie->graphics->tlsSubject;\n    }\n\n    if (uri) {\n        size_t i;\n\n        if ((type = virDomainGraphicsTypeFromString(uri->scheme)) < 0) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"unknown graphics type %s\"), uri->scheme);\n            goto cleanup;\n        }\n\n        if (uri->server)\n            listenAddress = uri->server;\n        if (uri->port > 0)\n            port = uri->port;\n\n        for (i = 0; i < uri->paramsCount; i++) {\n            virURIParamPtr param = uri->params + i;\n\n            if (STRCASEEQ(param->name, \"tlsPort\")) {\n                if (virStrToLong_i(param->value, NULL, 10, &tlsPort) < 0) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"invalid tlsPort number: %s\"),\n                                   param->value);\n                    goto cleanup;\n                }\n            } else if (STRCASEEQ(param->name, \"tlsSubject\")) {\n                tlsSubject = param->value;\n            }\n        }\n    }\n\n    /* QEMU doesn't support VNC relocation yet, so\n     * skip it to avoid generating an error\n     */\n    if (type != VIR_DOMAIN_GRAPHICS_TYPE_SPICE) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* Older libvirt sends port == 0 for listen type='none' graphics. It's\n     * safe to ignore such requests since relocation to unknown port does\n     * not make sense in general.\n     */\n    if (port <= 0 && tlsPort <= 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) == 0) {\n        ret = qemuMonitorGraphicsRelocate(priv->mon, type, listenAddress,\n                                          port, tlsPort, tlsSubject);\n        priv->job.spiceMigration = !ret;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            ret = -1;\n    }\n\n cleanup:\n    virURIFree(uri);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationDstWaitForCompletion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1744-1769",
    "snippet": "static int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCompleted",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "NULL",
            "flags"
          ],
          "line": 1762
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1599-1684",
          "snippet": "static int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waiting for incoming migration to complete\""
          ],
          "line": 1757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_MIGRATION_EVENT"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  bool postcopy)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned int flags = 0;\n    int rv;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT))\n        return 0;\n\n    VIR_DEBUG(\"Waiting for incoming migration to complete\");\n\n    if (postcopy)\n        flags = QEMU_MIGRATION_COMPLETED_POSTCOPY;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           NULL, flags)) != 1) {\n        if (rv < 0 || virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcWaitForCompletion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1690-1741",
    "snippet": "static int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv->job.completed"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "priv->job.completed"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateDowntime",
          "args": [
            "jobInfo"
          ],
          "line": 1729
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateDowntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "451-471",
          "snippet": "int\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateDowntime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->stopped)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->stopped) {\n        VIR_WARN(\"Guest's CPUs stopped in the future\");\n        jobInfo->stopped = 0;\n        return 0;\n    }\n\n    jobInfo->stats.mig.downtime = now - jobInfo->stopped;\n    jobInfo->stats.mig.downtime_set = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainJobInfoUpdateTime",
          "args": [
            "jobInfo"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainJobInfoUpdateTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "430-449",
          "snippet": "int\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainJobInfoUpdateTime(qemuDomainJobInfoPtr jobInfo)\n{\n    unsigned long long now;\n\n    if (!jobInfo->started)\n        return 0;\n\n    if (virTimeMillisNow(&now) < 0)\n        return -1;\n\n    if (now < jobInfo->started) {\n        VIR_WARN(\"Async job starts in the future\");\n        jobInfo->started = 0;\n        return 0;\n    }\n\n    jobInfo->timeElapsed = now - jobInfo->started;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL)"
          ],
          "line": 1726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyFetchStats",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "jobInfo",
            "NULL"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyFetchStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1477-1499",
          "snippet": "int\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "vm"
          ],
          "line": 1721
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nanosleep",
          "args": [
            "&ts",
            "NULL"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "vm"
          ],
          "line": 1719
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjIsActive",
          "args": [
            "vm"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjIsActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.h",
          "lines": "2845-2849",
          "snippet": "static inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virresctrl.h\"",
            "#include \"virsavecookie.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virperf.h\"",
            "#include \"virgic.h\"",
            "#include \"virprocess.h\"",
            "#include \"virseclabel.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virbitmap.h\"",
            "#include \"device_conf.h\"",
            "#include \"virobject.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"virnetdevvlan.h\"",
            "#include \"virnetdevbandwidth.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include \"virnetdevip.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"numa_conf.h\"",
            "#include \"nwfilter_params.h\"",
            "#include \"networkcommon_conf.h\"",
            "#include \"virsocketaddr.h\"",
            "#include \"virhash.h\"",
            "#include \"virthread.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"capabilities.h\"",
            "#include \"virconftypes.h\"",
            "#include \"internal.h\"",
            "#include <libxml/xpath.h>",
            "#include <libxml/tree.h>",
            "#include <libxml/parser.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void virDomainMemoryDefFree(virDomainMemoryDefPtr def);",
            "void virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);",
            "unsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);",
            "unsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);",
            "bool virDomainDefHasMemoryHotplug(const virDomainDef *def);",
            "int virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);",
            "bool virDomainDefHasUSB(const virDomainDef *def);",
            "int virDomainObjCheckActive(virDomainObjPtr dom);",
            "bool virDomainDefHasVcpusOffline(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpusMax(const virDomainDef *def);",
            "unsigned int virDomainDefGetVcpus(const virDomainDef *def);",
            "virBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);",
            "void virDomainDefVcpuOrderClear(virDomainDefPtr def);",
            "void virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);",
            "void virDomainInputDefFree(virDomainInputDefPtr def);",
            "void virDomainDiskDefFree(virDomainDiskDefPtr def);",
            "void virDomainLeaseDefFree(virDomainLeaseDefPtr def);",
            "int virDomainDiskGetType(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetSource(virDomainDiskDef const *def);",
            "void virDomainDiskEmptySource(virDomainDiskDefPtr def);",
            "const char *virDomainDiskGetDriver(const virDomainDiskDef *def);",
            "int virDomainDiskGetFormat(virDomainDiskDefPtr def);",
            "void virDomainControllerDefFree(virDomainControllerDefPtr def);",
            "void virDomainFSDefFree(virDomainFSDefPtr def);",
            "void virDomainActualNetDefFree(virDomainActualNetDefPtr def);",
            "void virDomainNetDefClear(virDomainNetDefPtr def);",
            "void virDomainNetDefFree(virDomainNetDefPtr def);",
            "void virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);",
            "void virDomainChrDefFree(virDomainChrDefPtr def);",
            "void virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);",
            "void virDomainSoundDefFree(virDomainSoundDefPtr def);",
            "void virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);",
            "void virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);",
            "void virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);",
            "void virDomainVideoDefFree(virDomainVideoDefPtr def);",
            "void virDomainVideoDefClear(virDomainVideoDefPtr def);",
            "void virDomainHostdevDefClear(virDomainHostdevDefPtr def);",
            "void virDomainHostdevDefFree(virDomainHostdevDefPtr def);",
            "void virDomainHubDefFree(virDomainHubDefPtr def);",
            "void virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);",
            "void virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);",
            "void virDomainShmemDefFree(virDomainShmemDefPtr def);",
            "void virDomainDeviceDefFree(virDomainDeviceDefPtr def);",
            "void virDomainTPMDefFree(virDomainTPMDefPtr def);",
            "void virDomainRNGDefFree(virDomainRNGDefPtr def);",
            "int virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);",
            "int virDomainVideoDefaultType(const virDomainDef *def);",
            "void virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);",
            "int virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);",
            "bool\nvirDomainDefHasManagedPR(const virDomainDef *def);",
            "bool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);",
            "bool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);",
            "bool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);",
            "bool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virresctrl.h\"\n#include \"virsavecookie.h\"\n#include \"virtypedparam.h\"\n#include \"virperf.h\"\n#include \"virgic.h\"\n#include \"virprocess.h\"\n#include \"virseclabel.h\"\n#include \"virstoragefile.h\"\n#include \"virbitmap.h\"\n#include \"device_conf.h\"\n#include \"virobject.h\"\n#include \"virnetworkportdef.h\"\n#include \"virnetdevvlan.h\"\n#include \"virnetdevbandwidth.h\"\n#include \"virnetdevvportprofile.h\"\n#include \"virnetdevip.h\"\n#include \"virnetdev.h\"\n#include \"virsysinfo.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"numa_conf.h\"\n#include \"nwfilter_params.h\"\n#include \"networkcommon_conf.h\"\n#include \"virsocketaddr.h\"\n#include \"virhash.h\"\n#include \"virthread.h\"\n#include \"cpu_conf.h\"\n#include \"virstorageencryption.h\"\n#include \"capabilities.h\"\n#include \"virconftypes.h\"\n#include \"internal.h\"\n#include <libxml/xpath.h>\n#include <libxml/tree.h>\n#include <libxml/parser.h>\n\nvoid virDomainMemoryDefFree(virDomainMemoryDefPtr def);\nvoid virDomainIOThreadIDDefFree(virDomainIOThreadIDDefPtr def);\nunsigned long long virDomainDefGetMemoryInitial(const virDomainDef *def);\nunsigned long long virDomainDefGetMemoryTotal(const virDomainDef *def);\nbool virDomainDefHasMemoryHotplug(const virDomainDef *def);\nint virDomainXMLOptionRunMomentPostParse(virDomainXMLOptionPtr xmlopt,\n                                         virDomainMomentDefPtr def);\nbool virDomainDefHasUSB(const virDomainDef *def);\nint virDomainObjCheckActive(virDomainObjPtr dom);\nbool virDomainDefHasVcpusOffline(const virDomainDef *def);\nunsigned int virDomainDefGetVcpusMax(const virDomainDef *def);\nunsigned int virDomainDefGetVcpus(const virDomainDef *def);\nvirBitmapPtr virDomainDefGetOnlineVcpumap(const virDomainDef *def);\nvoid virDomainDefVcpuOrderClear(virDomainDefPtr def);\nvoid virDomainGraphicsDefFree(virDomainGraphicsDefPtr def);\nvoid virDomainInputDefFree(virDomainInputDefPtr def);\nvoid virDomainDiskDefFree(virDomainDiskDefPtr def);\nvoid virDomainLeaseDefFree(virDomainLeaseDefPtr def);\nint virDomainDiskGetType(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetSource(virDomainDiskDef const *def);\nvoid virDomainDiskEmptySource(virDomainDiskDefPtr def);\nconst char *virDomainDiskGetDriver(const virDomainDiskDef *def);\nint virDomainDiskGetFormat(virDomainDiskDefPtr def);\nvoid virDomainControllerDefFree(virDomainControllerDefPtr def);\nvoid virDomainFSDefFree(virDomainFSDefPtr def);\nvoid virDomainActualNetDefFree(virDomainActualNetDefPtr def);\nvoid virDomainNetDefClear(virDomainNetDefPtr def);\nvoid virDomainNetDefFree(virDomainNetDefPtr def);\nvoid virDomainSmartcardDefFree(virDomainSmartcardDefPtr def);\nvoid virDomainChrDefFree(virDomainChrDefPtr def);\nvoid virDomainSoundCodecDefFree(virDomainSoundCodecDefPtr def);\nvoid virDomainSoundDefFree(virDomainSoundDefPtr def);\nvoid virDomainMemballoonDefFree(virDomainMemballoonDefPtr def);\nvoid virDomainNVRAMDefFree(virDomainNVRAMDefPtr def);\nvoid virDomainWatchdogDefFree(virDomainWatchdogDefPtr def);\nvoid virDomainVideoDefFree(virDomainVideoDefPtr def);\nvoid virDomainVideoDefClear(virDomainVideoDefPtr def);\nvoid virDomainHostdevDefClear(virDomainHostdevDefPtr def);\nvoid virDomainHostdevDefFree(virDomainHostdevDefPtr def);\nvoid virDomainHubDefFree(virDomainHubDefPtr def);\nvoid virDomainRedirdevDefFree(virDomainRedirdevDefPtr def);\nvoid virDomainRedirFilterDefFree(virDomainRedirFilterDefPtr def);\nvoid virDomainShmemDefFree(virDomainShmemDefPtr def);\nvoid virDomainDeviceDefFree(virDomainDeviceDefPtr def);\nvoid virDomainTPMDefFree(virDomainTPMDefPtr def);\nvoid virDomainRNGDefFree(virDomainRNGDefPtr def);\nint virDomainDeleteConfig(const char *configDir,\n                          const char *autostartDir,\n                          virDomainObjPtr dom);\nint virDomainVideoDefaultType(const virDomainDef *def);\nvoid virDomainChrSourceDefClear(virDomainChrSourceDefPtr def);\nint virDomainDiskTranslateSourcePool(virDomainDiskDefPtr def);\nbool\nvirDomainDefHasManagedPR(const virDomainDef *def);\nbool\nvirDomainDefHasNVMeDisk(const virDomainDef *def);\nbool\nvirDomainDefHasVFIOHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasMdevHostdev(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleUEFI(const virDomainDef *def);\nbool\nvirDomainDefHasOldStyleROUEFI(const virDomainDef *def);\nbool\nvirDomainGraphicsDefHasOpenGL(const virDomainDef *def);\n\nstatic inline bool\nvirDomainObjIsActive(virDomainObjPtr dom)\n{\n    return dom->def->id != -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCompleted",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "dconn",
            "flags"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1599-1684",
          "snippet": "static int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_MIGRATION_EVENT"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcWaitForCompletion(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob,\n                                  virConnectPtr dconn,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int rv;\n\n    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n\n    while ((rv = qemuMigrationAnyCompleted(driver, vm, asyncJob,\n                                           dconn, flags)) != 1) {\n        if (rv < 0)\n            return rv;\n\n        if (events) {\n            if (virDomainObjWait(vm) < 0) {\n                if (virDomainObjIsActive(vm))\n                    jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n                return -2;\n            }\n        } else {\n            /* Poll every 50ms for progress & to allow cancellation */\n            struct timespec ts = { .tv_sec = 0, .tv_nsec = 50 * 1000 * 1000ull };\n\n            virObjectUnlock(vm);\n            nanosleep(&ts, NULL);\n            virObjectLock(vm);\n        }\n    }\n\n    if (events)\n        ignore_value(qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, NULL));\n\n    qemuDomainJobInfoUpdateTime(jobInfo);\n    qemuDomainJobInfoUpdateDowntime(jobInfo);\n    VIR_FREE(priv->job.completed);\n    if (VIR_ALLOC(priv->job.completed) == 0) {\n        *priv->job.completed = *jobInfo;\n        priv->job.completed->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    }\n\n    if (asyncJob != QEMU_ASYNC_JOB_MIGRATION_OUT &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationAnyCompleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1599-1684",
    "snippet": "static int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Migration switched to post-copy\""
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Migration paused before switchover\""
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Lost connection to destination host\")"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lost connection to destination host\""
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectIsAlive",
          "args": [
            "dconn"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectIsAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1389-1409",
          "snippet": "int\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"%s: %s\")",
            "qemuMigrationJobName(vm)",
            "_(\"failed due to I/O error\")"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobName",
          "args": [
            "vm"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1502-1528",
          "snippet": "static const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "&pauseReason"
          ],
          "line": 1619
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyReady",
          "args": [
            "vm",
            "asyncJob"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "507-549",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobCheckStatus",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobCheckStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1531-1581",
          "snippet": "static int\nqemuMigrationJobCheckStatus(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    char *error = NULL;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int ret = -1;\n\n    if (!events ||\n        jobInfo->stats.mig.status == QEMU_MONITOR_MIGRATION_STATUS_ERROR) {\n        if (qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, &error) < 0)\n            return -1;\n    }\n\n    qemuMigrationUpdateJobType(jobInfo);\n\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"is not active\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm),\n                       error ? error : _(\"unexpectedly failed\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"canceled by client\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(error);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobCheckStatus(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    char *error = NULL;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int ret = -1;\n\n    if (!events ||\n        jobInfo->stats.mig.status == QEMU_MONITOR_MIGRATION_STATUS_ERROR) {\n        if (qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, &error) < 0)\n            return -1;\n    }\n\n    qemuMigrationUpdateJobType(jobInfo);\n\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"is not active\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm),\n                       error ? error : _(\"unexpectedly failed\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"canceled by client\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(error);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationAnyCompleted(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob,\n                          virConnectPtr dconn,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    int pauseReason;\n\n    if (qemuMigrationJobCheckStatus(driver, vm, asyncJob) < 0)\n        goto error;\n\n    /* This flag should only be set when run on src host */\n    if (flags & QEMU_MIGRATION_COMPLETED_CHECK_STORAGE &&\n        qemuMigrationSrcNBDStorageCopyReady(vm, asyncJob) < 0)\n        goto error;\n\n    if (flags & QEMU_MIGRATION_COMPLETED_ABORT_ON_ERROR &&\n        virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n        pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"failed due to I/O error\"));\n        goto error;\n    }\n\n    if (dconn && virConnectIsAlive(dconn) <= 0) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"Lost connection to destination host\"));\n        goto error;\n    }\n\n    /* Migration was paused before serializing device state, let's return to\n     * the caller so that it can finish all block jobs, resume migration, and\n     * wait again for the real end of the migration.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_PRE_SWITCHOVER &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_PAUSED) {\n        VIR_DEBUG(\"Migration paused before switchover\");\n        return 1;\n    }\n\n    /* In case of postcopy the source considers migration completed at the\n     * moment it switched from active to postcopy-active state. The destination\n     * will continue waiting until the migrate state changes to completed.\n     */\n    if (flags & QEMU_MIGRATION_COMPLETED_POSTCOPY &&\n        jobInfo->status == QEMU_DOMAIN_JOB_STATUS_POSTCOPY) {\n        VIR_DEBUG(\"Migration switched to post-copy\");\n        return 1;\n    }\n\n    if (jobInfo->status == QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED)\n        return 1;\n    else\n        return 0;\n\n error:\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        /* The migration was aborted by us rather than QEMU itself. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -2;\n\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n        /* Something failed after QEMU already finished the migration. */\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        /* QEMU aborted the migration. */\n        return -1;\n\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        /* Impossible. */\n        break;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "qemuMigrationJobCheckStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1531-1581",
    "snippet": "static int\nqemuMigrationJobCheckStatus(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    char *error = NULL;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int ret = -1;\n\n    if (!events ||\n        jobInfo->stats.mig.status == QEMU_MONITOR_MIGRATION_STATUS_ERROR) {\n        if (qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, &error) < 0)\n            return -1;\n    }\n\n    qemuMigrationUpdateJobType(jobInfo);\n\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"is not active\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm),\n                       error ? error : _(\"unexpectedly failed\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"canceled by client\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(error);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "error"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_ABORTED",
            "_(\"%s: %s\")",
            "qemuMigrationJobName(vm)",
            "_(\"canceled by client\")"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"canceled by client\""
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationJobName",
          "args": [
            "vm"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationJobName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1502-1528",
          "snippet": "static const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"%s: %s\")",
            "qemuMigrationJobName(vm)",
            "error ? error : _(\"unexpectedly failed\")"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"%s: %s\")",
            "qemuMigrationJobName(vm)",
            "_(\"is not active\")"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationUpdateJobType",
          "args": [
            "jobInfo"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationUpdateJobType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1435-1474",
          "snippet": "static void\nqemuMigrationUpdateJobType(qemuDomainJobInfoPtr jobInfo)\n{\n    switch ((qemuMonitorMigrationStatus) jobInfo->stats.mig.status) {\n    case QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_POSTCOPY;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_COMPLETED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_INACTIVE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_NONE;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_ERROR:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_PAUSED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_DEVICE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_SETUP:\n    case QEMU_MONITOR_MIGRATION_STATUS_ACTIVE:\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLING:\n    case QEMU_MONITOR_MIGRATION_STATUS_WAIT_UNPLUG:\n    case QEMU_MONITOR_MIGRATION_STATUS_LAST:\n        break;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationUpdateJobType(qemuDomainJobInfoPtr jobInfo)\n{\n    switch ((qemuMonitorMigrationStatus) jobInfo->stats.mig.status) {\n    case QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_POSTCOPY;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_COMPLETED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_INACTIVE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_NONE;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_ERROR:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_PAUSED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_DEVICE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_SETUP:\n    case QEMU_MONITOR_MIGRATION_STATUS_ACTIVE:\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLING:\n    case QEMU_MONITOR_MIGRATION_STATUS_WAIT_UNPLUG:\n    case QEMU_MONITOR_MIGRATION_STATUS_LAST:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyFetchStats",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "jobInfo",
            "&error"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyFetchStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1477-1499",
          "snippet": "int\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_MIGRATION_EVENT"
          ],
          "line": 1539
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationJobCheckStatus(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm,\n                            qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainJobInfoPtr jobInfo = priv->job.current;\n    char *error = NULL;\n    bool events = virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_MIGRATION_EVENT);\n    int ret = -1;\n\n    if (!events ||\n        jobInfo->stats.mig.status == QEMU_MONITOR_MIGRATION_STATUS_ERROR) {\n        if (qemuMigrationAnyFetchStats(driver, vm, asyncJob, jobInfo, &error) < 0)\n            return -1;\n    }\n\n    qemuMigrationUpdateJobType(jobInfo);\n\n    switch (jobInfo->status) {\n    case QEMU_DOMAIN_JOB_STATUS_NONE:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"is not active\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_FAILED:\n        virReportError(VIR_ERR_OPERATION_FAILED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm),\n                       error ? error : _(\"unexpectedly failed\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_CANCELED:\n        virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                       qemuMigrationJobName(vm), _(\"canceled by client\"));\n        goto cleanup;\n\n    case QEMU_DOMAIN_JOB_STATUS_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_ACTIVE:\n    case QEMU_DOMAIN_JOB_STATUS_MIGRATING:\n    case QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED:\n    case QEMU_DOMAIN_JOB_STATUS_POSTCOPY:\n    case QEMU_DOMAIN_JOB_STATUS_PAUSED:\n        break;\n    }\n\n    ret = 0;\n\n cleanup:\n    VIR_FREE(error);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationJobName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1502-1528",
    "snippet": "static const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"job\""
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic const char *\nqemuMigrationJobName(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    switch (priv->job.asyncJob) {\n    case QEMU_ASYNC_JOB_MIGRATION_OUT:\n        return _(\"migration out job\");\n    case QEMU_ASYNC_JOB_SAVE:\n        return _(\"domain save job\");\n    case QEMU_ASYNC_JOB_DUMP:\n        return _(\"domain core dump job\");\n    case QEMU_ASYNC_JOB_NONE:\n        return _(\"undefined\");\n    case QEMU_ASYNC_JOB_MIGRATION_IN:\n        return _(\"migration in job\");\n    case QEMU_ASYNC_JOB_SNAPSHOT:\n        return _(\"snapshot job\");\n    case QEMU_ASYNC_JOB_START:\n        return _(\"start job\");\n    case QEMU_ASYNC_JOB_BACKUP:\n        return _(\"backup job\");\n    case QEMU_ASYNC_JOB_LAST:\n    default:\n        return _(\"job\");\n    }\n}"
  },
  {
    "function_name": "qemuMigrationAnyFetchStats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1477-1499",
    "snippet": "int\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetMigrationStats",
          "args": [
            "priv->mon",
            "&stats",
            "error"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetMigrationStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "2464-2475",
          "snippet": "int\nqemuMonitorGetMigrationStats(qemuMonitorPtr mon,\n                             qemuMonitorMigrationStatsPtr stats,\n                             char **error)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    if (error)\n        *error = NULL;\n\n    return qemuMonitorJSONGetMigrationStats(mon, stats, error);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetMigrationStats(qemuMonitorPtr mon,\n                             qemuMonitorMigrationStatsPtr stats,\n                             char **error)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    if (error)\n        *error = NULL;\n\n    return qemuMonitorJSONGetMigrationStats(mon, stats, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationAnyFetchStats(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           qemuDomainAsyncJob asyncJob,\n                           qemuDomainJobInfoPtr jobInfo,\n                           char **error)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorMigrationStats stats;\n    int rv;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorGetMigrationStats(priv->mon, &stats, error);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    jobInfo->stats.mig = stats;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationUpdateJobType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1435-1474",
    "snippet": "static void\nqemuMigrationUpdateJobType(qemuDomainJobInfoPtr jobInfo)\n{\n    switch ((qemuMonitorMigrationStatus) jobInfo->stats.mig.status) {\n    case QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_POSTCOPY;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_COMPLETED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_INACTIVE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_NONE;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_ERROR:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_PAUSED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_DEVICE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_SETUP:\n    case QEMU_MONITOR_MIGRATION_STATUS_ACTIVE:\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLING:\n    case QEMU_MONITOR_MIGRATION_STATUS_WAIT_UNPLUG:\n    case QEMU_MONITOR_MIGRATION_STATUS_LAST:\n        break;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationUpdateJobType(qemuDomainJobInfoPtr jobInfo)\n{\n    switch ((qemuMonitorMigrationStatus) jobInfo->stats.mig.status) {\n    case QEMU_MONITOR_MIGRATION_STATUS_POSTCOPY:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_POSTCOPY;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_COMPLETED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_QEMU_COMPLETED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_INACTIVE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_NONE;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_ERROR:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLED:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_PRE_SWITCHOVER:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_PAUSED;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_DEVICE:\n        jobInfo->status = QEMU_DOMAIN_JOB_STATUS_MIGRATING;\n        break;\n\n    case QEMU_MONITOR_MIGRATION_STATUS_SETUP:\n    case QEMU_MONITOR_MIGRATION_STATUS_ACTIVE:\n    case QEMU_MONITOR_MIGRATION_STATUS_CANCELLING:\n    case QEMU_MONITOR_MIGRATION_STATUS_WAIT_UNPLUG:\n    case QEMU_MONITOR_MIGRATION_STATUS_LAST:\n        break;\n    }\n}"
  },
  {
    "function_name": "qemuMigrationSrcWaitForSpice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1418-1432",
    "snippet": "static int\nqemuMigrationSrcWaitForSpice(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.spiceMigration)\n        return 0;\n\n    VIR_DEBUG(\"Waiting for SPICE to finish migration\");\n    while (!priv->job.spiceMigrated && !priv->job.abortJob) {\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waiting for SPICE to finish migration\""
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcWaitForSpice(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!priv->job.spiceMigration)\n        return 0;\n\n    VIR_DEBUG(\"Waiting for SPICE to finish migration\");\n    while (!priv->job.spiceMigrated && !priv->job.abortJob) {\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationAnyPostcopyFailed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1386-1415",
    "snippet": "void\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainObjSetState",
          "args": [
            "vm",
            "VIR_DOMAIN_PAUSED",
            "VIR_DOMAIN_PAUSED_POSTCOPY_FAILED"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30048-30089",
          "snippet": "void\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirDomainObjSetState(virDomainObjPtr dom, virDomainState state, int reason)\n{\n    int last;\n\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        last = VIR_DOMAIN_NOSTATE_LAST;\n        break;\n    case VIR_DOMAIN_RUNNING:\n        last = VIR_DOMAIN_RUNNING_LAST;\n        break;\n    case VIR_DOMAIN_BLOCKED:\n        last = VIR_DOMAIN_BLOCKED_LAST;\n        break;\n    case VIR_DOMAIN_PAUSED:\n        last = VIR_DOMAIN_PAUSED_LAST;\n        break;\n    case VIR_DOMAIN_SHUTDOWN:\n        last = VIR_DOMAIN_SHUTDOWN_LAST;\n        break;\n    case VIR_DOMAIN_SHUTOFF:\n        last = VIR_DOMAIN_SHUTOFF_LAST;\n        break;\n    case VIR_DOMAIN_CRASHED:\n        last = VIR_DOMAIN_CRASHED_LAST;\n        break;\n    case VIR_DOMAIN_PMSUSPENDED:\n        last = VIR_DOMAIN_PMSUSPENDED_LAST;\n        break;\n    case VIR_DOMAIN_LAST:\n    default:\n        VIR_ERROR(_(\"invalid domain state: %d\"), state);\n        return;\n    }\n\n    dom->state.state = state;\n    if (reason > 0 && reason < last)\n        dom->state.reason = reason;\n    else\n        dom->state.reason = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to pause guest CPUs for %s\"",
            "vm->def->name"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuProcessStopCPUs",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_PAUSED_POSTCOPY_FAILED",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStopCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "3262-3304",
          "snippet": "int qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint qemuProcessStopCPUs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virDomainPausedReason reason,\n                        qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    VIR_FREE(priv->lockState);\n\n    priv->pausedReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    ret = qemuMonitorStopCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto cleanup;\n\n    /* de-activate netdevs after stopping CPUs */\n    ignore_value(qemuInterfaceStopDevices(vm->def));\n\n    if (priv->job.current)\n        ignore_value(virTimeMillisNow(&priv->job.current->stopped));\n\n    /* The STOP event handler will change the domain state with the reason\n     * saved in priv->pausedReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n\n cleanup:\n    if (ret < 0)\n        priv->pausedReason = VIR_DOMAIN_PAUSED_UNKNOWN;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\"",
            "vm->def->name"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "&reason"
          ],
          "line": 1393
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nvoid\nqemuMigrationAnyPostcopyFailed(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm)\n{\n    virDomainState state;\n    int reason;\n\n    state = virDomainObjGetState(vm, &reason);\n\n    if (state != VIR_DOMAIN_PAUSED &&\n        state != VIR_DOMAIN_RUNNING)\n        return;\n\n    if (state == VIR_DOMAIN_PAUSED &&\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        return;\n\n    VIR_WARN(\"Migration of domain %s failed during post-copy; \"\n             \"leaving the domain paused\", vm->def->name);\n\n    if (state == VIR_DOMAIN_RUNNING) {\n        if (qemuProcessStopCPUs(driver, vm,\n                                VIR_DOMAIN_PAUSED_POSTCOPY_FAILED,\n                                QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            VIR_WARN(\"Unable to pause guest CPUs for %s\", vm->def->name);\n    } else {\n        virDomainObjSetState(vm, VIR_DOMAIN_PAUSED,\n                             VIR_DOMAIN_PAUSED_POSTCOPY_FAILED);\n    }\n}"
  },
  {
    "function_name": "qemuMigrationSrcIsSafe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1299-1383",
    "snippet": "static bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_MIGRATE_UNSAFE",
            "\"%s\"",
            "_(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\")"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\""
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"QEMU supports flushing caches; migration is safe\""
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "qemuCaps",
            "QEMU_CAPS_MIGRATION_FILE_DROP_CACHE"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_MIGRATE_UNSAFE",
            "\"%s\"",
            "_(\"Migration without shared storage is unsafe\")"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileIsClusterFS",
          "args": [
            "src"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageFileIsClusterFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1291-1300",
          "snippet": "int virStorageFileIsClusterFS(const char *path)\n{\n    /* These are coherent cluster filesystems known to be safe for\n     * migration with cache != none\n     */\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_CEPH);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint virStorageFileIsClusterFS(const char *path)\n{\n    /* These are coherent cluster filesystems known to be safe for\n     * migration with cache != none\n     */\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_CEPH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsSharedFS",
          "args": [
            "src"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3699-3712",
          "snippet": "int virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCopyDisk",
          "args": [
            "disk",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCopyDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "276-295",
          "snippet": "static bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "disk->src"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "disk->src"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsSafe(virDomainDefPtr def,\n                       virQEMUCapsPtr qemuCaps,\n                       size_t nmigrate_disks,\n                       const char **migrate_disks,\n                       unsigned int flags)\n\n{\n    bool storagemigration = flags & (VIR_MIGRATE_NON_SHARED_DISK |\n                                     VIR_MIGRATE_NON_SHARED_INC);\n    size_t i;\n    int rc;\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainDiskDefPtr disk = def->disks[i];\n        const char *src = virDomainDiskGetSource(disk);\n        int actualType = virStorageSourceGetActualType(disk->src);\n        bool unsafe = false;\n\n        /* Disks without any source (i.e. floppies and CD-ROMs)\n         * OR readonly are safe. */\n        if (virStorageSourceIsEmpty(disk->src) ||\n            disk->src->readonly)\n            continue;\n\n        /* Disks which are migrated by qemu are safe too. */\n        if (storagemigration &&\n            qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        /* However, disks on local FS (e.g. ext4) are not safe. */\n        switch ((virStorageType) actualType) {\n        case VIR_STORAGE_TYPE_FILE:\n            if ((rc = virFileIsSharedFS(src)) < 0) {\n                return false;\n            } else if (rc == 0) {\n                unsafe = true;\n            }\n            if ((rc = virStorageFileIsClusterFS(src)) < 0)\n                return false;\n            else if (rc == 1)\n                continue;\n            break;\n        case VIR_STORAGE_TYPE_NETWORK:\n            /* But network disks are safe again. */\n            continue;\n\n        case VIR_STORAGE_TYPE_NVME:\n            unsafe = true;\n            break;\n\n        case VIR_STORAGE_TYPE_NONE:\n        case VIR_STORAGE_TYPE_BLOCK:\n        case VIR_STORAGE_TYPE_DIR:\n        case VIR_STORAGE_TYPE_VOLUME:\n        case VIR_STORAGE_TYPE_LAST:\n            break;\n        }\n\n        if (unsafe) {\n            virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                           _(\"Migration without shared storage is unsafe\"));\n            return false;\n        }\n\n        /* Our code elsewhere guarantees shared disks are either readonly (in\n         * which case cache mode doesn't matter) or used with cache=none or used with cache=directsync */\n        if (disk->src->shared ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DISABLE ||\n            disk->cachemode == VIR_DOMAIN_DISK_CACHE_DIRECTSYNC)\n            continue;\n\n        if (virQEMUCapsGet(qemuCaps, QEMU_CAPS_MIGRATION_FILE_DROP_CACHE)) {\n            VIR_DEBUG(\"QEMU supports flushing caches; migration is safe\");\n            continue;\n        }\n\n        virReportError(VIR_ERR_MIGRATE_UNSAFE, \"%s\",\n                       _(\"Migration may lead to data corruption if disks\"\n                         \" use cache other than none or directsync\"));\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "qemuMigrationSrcIsAllowed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1166-1297",
    "snippet": "bool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"migration with virtiofs device is not supported\")"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"migration with virtiofs device is not supported\""
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"a slirp-helper cannot be migrated\")"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSlirpHasFeature",
          "args": [
            "slirp",
            "QEMU_SLIRP_FEATURE_MIGRATE"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpHasFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "73-78",
          "snippet": "bool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nbool\nqemuSlirpHasFeature(const qemuSlirp *slirp,\n                    qemuSlirpFeature feature)\n{\n    return virBitmapIsBitSet(slirp->features, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_NETWORK_PRIVATE",
          "args": [
            "net"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain requires dbus-vmstate support\")"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_DBUS_VMSTATE"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashSize",
          "args": [
            "priv->dbusVMStates"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "547-553",
          "snippet": "ssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nssize_t\nvirHashSize(const virHashTable *table)\n{\n    if (table == NULL)\n        return -1;\n    return table->nbElems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"migration with shmem device is not supported\")"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\")"
          ],
          "line": 1253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\")"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUCheckFeature",
          "args": [
            "vm->def->os.arch",
            "vm->def->cpu",
            "\"invtsc\""
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUCheckFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "674-695",
          "snippet": "int\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\nvirCPUCheckFeature(virArch arch,\n                   const virCPUDef *cpu,\n                   const char *feature)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"arch=%s, cpu=%p, feature=%s\",\n              virArchToString(arch), cpu, feature);\n\n    if (!(driver = cpuGetSubDriver(arch)))\n        return -1;\n\n    if (!driver->checkFeature) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot check guest CPU feature for %s architecture\"),\n                       virArchToString(arch));\n        return -1;\n    }\n\n    return driver->checkFeature(cpu, feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcIsAllowedHostdev",
          "args": [
            "vm->def"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcIsAllowedHostdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "1087-1149",
          "snippet": "static bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain has active block job\")"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainHasBlockjob",
          "args": [
            "vm",
            "false"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainHasBlockjob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12339-12357",
          "snippet": "bool\nqemuDomainHasBlockjob(virDomainObjPtr vm,\n                      bool copy_only)\n{\n    size_t i;\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!copy_only && diskPriv->blockjob &&\n            qemuBlockJobIsRunning(diskPriv->blockjob))\n            return true;\n\n        if (disk->mirror && disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_COPY)\n            return true;\n    }\n\n    return false;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nbool\nqemuDomainHasBlockjob(virDomainObjPtr vm,\n                      bool copy_only)\n{\n    size_t i;\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!copy_only && diskPriv->blockjob &&\n            qemuBlockJobIsRunning(diskPriv->blockjob))\n            return true;\n\n        if (disk->mirror && disk->mirrorJob == VIR_DOMAIN_BLOCK_JOB_TYPE_COPY)\n            return true;\n    }\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"domain is marked for auto destroy\")"
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuProcessAutoDestroyActive",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessAutoDestroyActive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "7710-7717",
          "snippet": "bool qemuProcessAutoDestroyActive(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    virCloseCallback cb;\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    cb = virCloseCallbacksGet(driver->closeCallbacks, vm, NULL);\n    return cb == qemuProcessAutoDestroy;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool qemuProcessAutoDestroyActive(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm)\n{\n    virCloseCallback cb;\n    VIR_DEBUG(\"vm=%s\", vm->def->name);\n    cb = virCloseCallbacksGet(driver->closeCallbacks, vm, NULL);\n    return cb == qemuProcessAutoDestroy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"cannot migrate domain with I/O error\")"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "&pauseReason"
          ],
          "line": 1196
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"cannot migrate domain with %d snapshots\")",
            "nsnapshots"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotObjListNum",
          "args": [
            "vm->snapshots",
            "NULL",
            "0"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotObjListNum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/virdomainsnapshotobjlist.c",
          "lines": "158-164",
          "snippet": "int\nvirDomainSnapshotObjListNum(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr from,\n                            unsigned int flags)\n{\n    return virDomainSnapshotObjListGetNames(snapshots, from, NULL, 0, flags);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDomainSnapshotObjListNum(virDomainSnapshotObjListPtr snapshots,\n                            virDomainMomentObjPtr from,\n                            unsigned int flags)\n{\n    return virDomainSnapshotObjListGetNames(snapshots, from, NULL, 0, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nbool\nqemuMigrationSrcIsAllowed(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          bool remote,\n                          unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int nsnapshots;\n    int pauseReason;\n    size_t i;\n\n    /* perform these checks only when migrating to remote hosts */\n    if (remote) {\n        nsnapshots = virDomainSnapshotObjListNum(vm->snapshots, NULL, 0);\n        if (nsnapshots < 0)\n            return false;\n\n        if (nsnapshots > 0) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"cannot migrate domain with %d snapshots\"),\n                           nsnapshots);\n            return false;\n        }\n    }\n\n    /* following checks don't make sense for offline migration */\n    if (!(flags & VIR_MIGRATE_OFFLINE)) {\n        if (remote) {\n            /* cancel migration if disk I/O error is emitted while migrating */\n            if (flags & VIR_MIGRATE_ABORT_ON_ERROR &&\n                virDomainObjGetState(vm, &pauseReason) == VIR_DOMAIN_PAUSED &&\n                pauseReason == VIR_DOMAIN_PAUSED_IOERROR) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"cannot migrate domain with I/O error\"));\n                return false;\n            }\n\n            if (qemuProcessAutoDestroyActive(driver, vm)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               \"%s\", _(\"domain is marked for auto destroy\"));\n                return false;\n            }\n        }\n\n\n        if (qemuDomainHasBlockjob(vm, false)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain has active block job\"));\n            return false;\n        }\n\n        if (!qemuMigrationSrcIsAllowedHostdev(vm->def))\n            return false;\n\n        if (vm->def->cpu) {\n            /* QEMU blocks migration and save with invariant TSC enabled\n             * unless TSC frequency is explicitly set.\n             */\n            if (virCPUCheckFeature(vm->def->os.arch, vm->def->cpu,\n                                   \"invtsc\") == 1) {\n                bool block = true;\n\n                for (i = 0; i < vm->def->clock.ntimers; i++) {\n                    virDomainTimerDefPtr timer = vm->def->clock.timers[i];\n\n                    if (timer->name == VIR_DOMAIN_TIMER_NAME_TSC &&\n                        timer->frequency > 0) {\n                        block = false;\n                        break;\n                    }\n                }\n\n                if (block) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"domain has 'invtsc' CPU feature but \"\n                                     \"TSC frequency is not specified\"));\n                    return false;\n                }\n            }\n        }\n\n        /* Verify that memory device config can be transferred reliably */\n        for (i = 0; i < vm->def->nmems; i++) {\n            virDomainMemoryDefPtr mem = vm->def->mems[i];\n\n            if (mem->model == VIR_DOMAIN_MEMORY_MODEL_DIMM &&\n                mem->info.type != VIR_DOMAIN_DEVICE_ADDRESS_TYPE_DIMM) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"domain's dimm info lacks slot ID \"\n                                 \"or base address\"));\n\n                return false;\n            }\n        }\n\n        if (vm->def->nshmems) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"migration with shmem device is not supported\"));\n            return false;\n        }\n\n        if (virHashSize(priv->dbusVMStates) > 0 &&\n            !virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_DBUS_VMSTATE)) {\n            virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                           _(\"domain requires dbus-vmstate support\"));\n            return false;\n        }\n\n        for (i = 0; i < vm->def->nnets; i++) {\n            virDomainNetDefPtr net = vm->def->nets[i];\n            qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n            if (slirp && !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"a slirp-helper cannot be migrated\"));\n                return false;\n            }\n        }\n\n        for (i = 0; i < vm->def->nfss; i++) {\n            virDomainFSDefPtr fs = vm->def->fss[i];\n\n            if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n                virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                               _(\"migration with virtiofs device is not supported\"));\n                return false;\n            }\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "qemuMigrationSrcIsAllowedHostdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "1087-1149",
    "snippet": "static bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid hostdev mode\")"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"invalid hostdev mode\""
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"invalid hostdev subsystem type\")"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\")",
            "virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type)"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevSubsysTypeToString",
          "args": [
            "hostdev->source.subsys.type"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\")",
            "virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type)"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevSubsysTypeToString",
          "args": [
            "hostdev->source.subsys.type"
          ],
          "line": 1113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"cannot migrate a domain with <hostdev mode='capabilities'>\")"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcIsAllowedHostdev(const virDomainDef *def)\n{\n    size_t i;\n\n    /* Migration with USB host devices is allowed, all other devices are\n     * forbidden. */\n    for (i = 0; i < def->nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = def->hostdevs[i];\n        switch ((virDomainHostdevMode)hostdev->mode) {\n        case VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES:\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"cannot migrate a domain with <hostdev mode='capabilities'>\"));\n            return false;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_SUBSYS:\n            switch ((virDomainHostdevSubsysType)hostdev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB:\n                /* USB devices can be \"migrated\" */\n                continue;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST:\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV:\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI:\n                /*\n                 * if this is a network interface with <teaming\n                 * type='transient'>, migration *is* allowed because\n                 * the device will be auto-unplugged by QEMU during\n                 * migration.\n                 */\n                if (hostdev->parentnet &&\n                    hostdev->parentnet->teaming.type == VIR_DOMAIN_NET_TEAMING_TYPE_TRANSIENT) {\n                    continue;\n                }\n\n                /* all other PCI hostdevs can't be migrated */\n                virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                               _(\"cannot migrate a domain with <hostdev mode='subsystem' type='%s'>\"),\n                               virDomainHostdevSubsysTypeToString(hostdev->source.subsys.type));\n                return false;\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_LAST:\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"invalid hostdev subsystem type\"));\n                return false;\n            }\n            break;\n\n        case VIR_DOMAIN_HOSTDEV_MODE_LAST:\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid hostdev mode\"));\n            return false;\n        }\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "994-1077",
    "snippet": "static int\nqemuMigrationSrcNBDStorageCopy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuMigrationCookiePtr mig,\n                               const char *host,\n                               unsigned long speed,\n                               unsigned int *migrate_flags,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               virConnectPtr dconn,\n                               const char *tlsAlias,\n                               unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int port;\n    size_t i;\n    unsigned long long mirror_speed = speed;\n    bool mirror_shallow = *migrate_flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n    int rv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    VIR_DEBUG(\"Starting drive mirrors for domain %s\", vm->def->name);\n\n    if (mirror_speed > LLONG_MAX >> 20) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       LLONG_MAX >> 20);\n        return -1;\n    }\n    mirror_speed <<= 20;\n\n    /* steal NBD port and thus prevent its propagation back to destination */\n    port = mig->nbd->port;\n    mig->nbd->port = 0;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (qemuMigrationSrcNBDStorageCopyOne(driver, vm, disk, host, port,\n                                              mirror_speed, mirror_shallow,\n                                              tlsAlias, flags) < 0)\n            return -1;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n            return -1;\n        }\n    }\n\n    while ((rv = qemuMigrationSrcNBDStorageCopyReady(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) != 1) {\n        if (rv < 0)\n            return -1;\n\n        if (priv->job.abortJob) {\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n            virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                           qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                           _(\"canceled by client\"));\n            return -1;\n        }\n\n        if (dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            return -1;\n        }\n\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    qemuMigrationSrcFetchMirrorStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                     priv->job.current);\n\n    /* Okay, all disks are ready. Modify migrate_flags */\n    *migrate_flags &= ~(QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                        QEMU_MONITOR_MIGRATE_NON_SHARED_INC);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuMigrationSrcFetchMirrorStats",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT",
            "priv->job.current"
          ],
          "line": 1069
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcFetchMirrorStats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "5557-5605",
          "snippet": "int\nqemuMigrationSrcFetchMirrorStats(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 qemuDomainJobInfoPtr jobInfo)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool nbd = false;\n    virHashTablePtr blockinfo = NULL;\n    qemuDomainMirrorStatsPtr stats = &jobInfo->mirrorStats;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        if (QEMU_DOMAIN_DISK_PRIVATE(disk)->migrating) {\n            nbd = true;\n            break;\n        }\n    }\n\n    if (!nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    blockinfo = qemuMonitorGetAllBlockJobInfo(priv->mon, false);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockinfo)\n        return -1;\n\n    memset(stats, 0, sizeof(*stats));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuMonitorBlockJobInfoPtr data;\n\n        if (!diskPriv->migrating ||\n            !(data = virHashLookup(blockinfo, disk->info.alias)))\n            continue;\n\n        stats->transferred += data->cur;\n        stats->total += data->end;\n    }\n\n    virHashFree(blockinfo);\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nint\nqemuMigrationSrcFetchMirrorStats(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 qemuDomainJobInfoPtr jobInfo)\n{\n    size_t i;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool nbd = false;\n    virHashTablePtr blockinfo = NULL;\n    qemuDomainMirrorStatsPtr stats = &jobInfo->mirrorStats;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        if (QEMU_DOMAIN_DISK_PRIVATE(disk)->migrating) {\n            nbd = true;\n            break;\n        }\n    }\n\n    if (!nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    blockinfo = qemuMonitorGetAllBlockJobInfo(priv->mon, false);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockinfo)\n        return -1;\n\n    memset(stats, 0, sizeof(*stats));\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuMonitorBlockJobInfoPtr data;\n\n        if (!diskPriv->migrating ||\n            !(data = virHashLookup(blockinfo, disk->info.alias)))\n            continue;\n\n        stats->transferred += data->cur;\n        stats->total += data->end;\n    }\n\n    virHashFree(blockinfo);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Lost connection to destination host\")"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lost connection to destination host\""
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectIsAlive",
          "args": [
            "dconn"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectIsAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1389-1409",
          "snippet": "int\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_ABORTED",
            "_(\"%s: %s\")",
            "qemuDomainAsyncJobTypeToString(priv->job.asyncJob)",
            "_(\"canceled by client\")"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainAsyncJobTypeToString",
          "args": [
            "priv->job.asyncJob"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyReady",
          "args": [
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyReady",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "507-549",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to save status on vm %s\"",
            "vm->def->name"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjSave",
          "args": [
            "vm",
            "driver->xmlopt",
            "cfg->stateDir"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjSave",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29706-29723",
          "snippet": "int\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainObjDispose(void *obj);",
            "static void virDomainXMLOptionDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virDomainObjDispose(void *obj);\nstatic void virDomainXMLOptionDispose(void *obj);\n\nint\nvirDomainObjSave(virDomainObjPtr obj,\n                 virDomainXMLOptionPtr xmlopt,\n                 const char *statusDir)\n{\n    unsigned int flags = (VIR_DOMAIN_DEF_FORMAT_SECURE |\n                          VIR_DOMAIN_DEF_FORMAT_STATUS |\n                          VIR_DOMAIN_DEF_FORMAT_ACTUAL_NET |\n                          VIR_DOMAIN_DEF_FORMAT_PCI_ORIG_STATES |\n                          VIR_DOMAIN_DEF_FORMAT_CLOCK_ADJUST);\n\n    g_autofree char *xml = NULL;\n\n    if (!(xml = virDomainObjFormat(obj, xmlopt, flags)))\n        return -1;\n\n    return virDomainDefSaveXML(obj->def, statusDir, xml);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyOne",
          "args": [
            "driver",
            "vm",
            "disk",
            "host",
            "port",
            "mirror_speed",
            "mirror_shallow",
            "tlsAlias",
            "flags"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "905-972",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopyOne(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  virDomainDiskDefPtr disk,\n                                  const char *host,\n                                  int port,\n                                  unsigned long long mirror_speed,\n                                  bool mirror_shallow,\n                                  const char *tlsAlias,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    qemuBlockJobDataPtr job = NULL;\n    char *diskAlias = NULL;\n    const char *jobname = NULL;\n    const char *sourcename = NULL;\n    bool persistjob = false;\n    int rc;\n    int ret = -1;\n\n    if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n        goto cleanup;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, QEMU_BLOCKJOB_TYPE_COPY, diskAlias)))\n        goto cleanup;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = diskAlias;\n        sourcename = qemuDomainDiskGetTopNodename(disk);\n        persistjob = true;\n    } else {\n        jobname = NULL;\n        sourcename = diskAlias;\n        persistjob = false;\n    }\n\n    qemuBlockJobSyncBegin(job);\n\n    if (flags & VIR_MIGRATE_TLS ||\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        rc = qemuMigrationSrcNBDStorageCopyBlockdev(driver, vm,\n                                                    disk, jobname,\n                                                    sourcename, persistjob,\n                                                    host, port,\n                                                    mirror_speed,\n                                                    mirror_shallow,\n                                                    tlsAlias);\n    } else {\n        rc = qemuMigrationSrcNBDStorageCopyDriveMirror(driver, vm, diskAlias,\n                                                       host, port,\n                                                       mirror_speed,\n                                                       mirror_shallow);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    diskPriv->migrating = true;\n    qemuBlockJobStarted(job, vm);\n\n    ret = 0;\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n    VIR_FREE(diskAlias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyOne(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  virDomainDiskDefPtr disk,\n                                  const char *host,\n                                  int port,\n                                  unsigned long long mirror_speed,\n                                  bool mirror_shallow,\n                                  const char *tlsAlias,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    qemuBlockJobDataPtr job = NULL;\n    char *diskAlias = NULL;\n    const char *jobname = NULL;\n    const char *sourcename = NULL;\n    bool persistjob = false;\n    int rc;\n    int ret = -1;\n\n    if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n        goto cleanup;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, QEMU_BLOCKJOB_TYPE_COPY, diskAlias)))\n        goto cleanup;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = diskAlias;\n        sourcename = qemuDomainDiskGetTopNodename(disk);\n        persistjob = true;\n    } else {\n        jobname = NULL;\n        sourcename = diskAlias;\n        persistjob = false;\n    }\n\n    qemuBlockJobSyncBegin(job);\n\n    if (flags & VIR_MIGRATE_TLS ||\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        rc = qemuMigrationSrcNBDStorageCopyBlockdev(driver, vm,\n                                                    disk, jobname,\n                                                    sourcename, persistjob,\n                                                    host, port,\n                                                    mirror_speed,\n                                                    mirror_shallow,\n                                                    tlsAlias);\n    } else {\n        rc = qemuMigrationSrcNBDStorageCopyDriveMirror(driver, vm, diskAlias,\n                                                       host, port,\n                                                       mirror_speed,\n                                                       mirror_shallow);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    diskPriv->migrating = true;\n    qemuBlockJobStarted(job, vm);\n\n    ret = 0;\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n    VIR_FREE(diskAlias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCopyDisk",
          "args": [
            "disk",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCopyDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "276-295",
          "snippet": "static bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OVERFLOW",
            "_(\"bandwidth must be less than %llu\")",
            "LLONG_MAX >> 20"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Starting drive mirrors for domain %s\"",
            "vm->def->name"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuMigrationCookiePtr mig,\n                               const char *host,\n                               unsigned long speed,\n                               unsigned int *migrate_flags,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               virConnectPtr dconn,\n                               const char *tlsAlias,\n                               unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int port;\n    size_t i;\n    unsigned long long mirror_speed = speed;\n    bool mirror_shallow = *migrate_flags & QEMU_MONITOR_MIGRATE_NON_SHARED_INC;\n    int rv;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    VIR_DEBUG(\"Starting drive mirrors for domain %s\", vm->def->name);\n\n    if (mirror_speed > LLONG_MAX >> 20) {\n        virReportError(VIR_ERR_OVERFLOW,\n                       _(\"bandwidth must be less than %llu\"),\n                       LLONG_MAX >> 20);\n        return -1;\n    }\n    mirror_speed <<= 20;\n\n    /* steal NBD port and thus prevent its propagation back to destination */\n    port = mig->nbd->port;\n    mig->nbd->port = 0;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (qemuMigrationSrcNBDStorageCopyOne(driver, vm, disk, host, port,\n                                              mirror_speed, mirror_shallow,\n                                              tlsAlias, flags) < 0)\n            return -1;\n\n        if (virDomainObjSave(vm, driver->xmlopt, cfg->stateDir) < 0) {\n            VIR_WARN(\"Failed to save status on vm %s\", vm->def->name);\n            return -1;\n        }\n    }\n\n    while ((rv = qemuMigrationSrcNBDStorageCopyReady(vm, QEMU_ASYNC_JOB_MIGRATION_OUT)) != 1) {\n        if (rv < 0)\n            return -1;\n\n        if (priv->job.abortJob) {\n            priv->job.current->status = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n            virReportError(VIR_ERR_OPERATION_ABORTED, _(\"%s: %s\"),\n                           qemuDomainAsyncJobTypeToString(priv->job.asyncJob),\n                           _(\"canceled by client\"));\n            return -1;\n        }\n\n        if (dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            return -1;\n        }\n\n        if (virDomainObjWait(vm) < 0)\n            return -1;\n    }\n\n    qemuMigrationSrcFetchMirrorStats(driver, vm, QEMU_ASYNC_JOB_MIGRATION_OUT,\n                                     priv->job.current);\n\n    /* Okay, all disks are ready. Modify migrate_flags */\n    *migrate_flags &= ~(QEMU_MONITOR_MIGRATE_NON_SHARED_DISK |\n                        QEMU_MONITOR_MIGRATE_NON_SHARED_INC);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopyOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "905-972",
    "snippet": "static int\nqemuMigrationSrcNBDStorageCopyOne(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  virDomainDiskDefPtr disk,\n                                  const char *host,\n                                  int port,\n                                  unsigned long long mirror_speed,\n                                  bool mirror_shallow,\n                                  const char *tlsAlias,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    qemuBlockJobDataPtr job = NULL;\n    char *diskAlias = NULL;\n    const char *jobname = NULL;\n    const char *sourcename = NULL;\n    bool persistjob = false;\n    int rc;\n    int ret = -1;\n\n    if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n        goto cleanup;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, QEMU_BLOCKJOB_TYPE_COPY, diskAlias)))\n        goto cleanup;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = diskAlias;\n        sourcename = qemuDomainDiskGetTopNodename(disk);\n        persistjob = true;\n    } else {\n        jobname = NULL;\n        sourcename = diskAlias;\n        persistjob = false;\n    }\n\n    qemuBlockJobSyncBegin(job);\n\n    if (flags & VIR_MIGRATE_TLS ||\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        rc = qemuMigrationSrcNBDStorageCopyBlockdev(driver, vm,\n                                                    disk, jobname,\n                                                    sourcename, persistjob,\n                                                    host, port,\n                                                    mirror_speed,\n                                                    mirror_shallow,\n                                                    tlsAlias);\n    } else {\n        rc = qemuMigrationSrcNBDStorageCopyDriveMirror(driver, vm, diskAlias,\n                                                       host, port,\n                                                       mirror_speed,\n                                                       mirror_shallow);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    diskPriv->migrating = true;\n    qemuBlockJobStarted(job, vm);\n\n    ret = 0;\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n    VIR_FREE(diskAlias);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "diskAlias"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobStartupFinalize",
          "args": [
            "vm",
            "job"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobStartupFinalize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "459-470",
          "snippet": "void\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobStarted",
          "args": [
            "job",
            "vm"
          ],
          "line": 964
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobStarted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "440-448",
          "snippet": "void\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyDriveMirror",
          "args": [
            "driver",
            "vm",
            "diskAlias",
            "host",
            "port",
            "mirror_speed",
            "mirror_shallow"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyDriveMirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "870-902",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopyDriveMirror(virQEMUDriverPtr driver,\n                                          virDomainObjPtr vm,\n                                          const char *diskAlias,\n                                          const char *host,\n                                          int port,\n                                          unsigned long long mirror_speed,\n                                          bool mirror_shallow)\n{\n    g_autofree char *nbd_dest = NULL;\n    int mon_ret;\n\n    if (strchr(host, ':')) {\n        nbd_dest = g_strdup_printf(\"nbd:[%s]:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    } else {\n        nbd_dest = g_strdup_printf(\"nbd:%s:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuMonitorDriveMirror(qemuDomainGetMonitor(vm),\n                                     diskAlias, nbd_dest, \"raw\",\n                                     mirror_speed, 0, 0, mirror_shallow, true);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyDriveMirror(virQEMUDriverPtr driver,\n                                          virDomainObjPtr vm,\n                                          const char *diskAlias,\n                                          const char *host,\n                                          int port,\n                                          unsigned long long mirror_speed,\n                                          bool mirror_shallow)\n{\n    g_autofree char *nbd_dest = NULL;\n    int mon_ret;\n\n    if (strchr(host, ':')) {\n        nbd_dest = g_strdup_printf(\"nbd:[%s]:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    } else {\n        nbd_dest = g_strdup_printf(\"nbd:%s:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuMonitorDriveMirror(qemuDomainGetMonitor(vm),\n                                     diskAlias, nbd_dest, \"raw\",\n                                     mirror_speed, 0, 0, mirror_shallow, true);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyBlockdev",
          "args": [
            "driver",
            "vm",
            "disk",
            "jobname",
            "sourcename",
            "persistjob",
            "host",
            "port",
            "mirror_speed",
            "mirror_shallow",
            "tlsAlias"
          ],
          "line": 946
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "817-867",
          "snippet": "static int\nqemuMigrationSrcNBDStorageCopyBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       virDomainDiskDefPtr disk,\n                                       const char *jobname,\n                                       const char *sourcename,\n                                       bool persistjob,\n                                       const char *host,\n                                       int port,\n                                       unsigned long long mirror_speed,\n                                       unsigned int mirror_shallow,\n                                       const char *tlsAlias)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    int mon_ret = 0;\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    VIR_DEBUG(\"starting blockdev mirror for disk=%s to host=%s\", disk->dst, host);\n\n    if (!(copysrc = qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(disk, host, port, tlsAlias)))\n        return -1;\n\n    /* Migration via blockdev-mirror was supported sooner than the auto-read-only\n     * feature was added to qemu */\n    if (!(data = qemuBlockStorageSourceAttachPrepareBlockdev(copysrc,\n                                                             copysrc->backingStore,\n                                                             false)))\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuBlockStorageSourceAttachApply(qemuDomainGetMonitor(vm), data);\n\n    if (mon_ret == 0)\n        mon_ret = qemuMonitorBlockdevMirror(qemuDomainGetMonitor(vm), jobname, persistjob,\n                                            sourcename, copysrc->nodeformat,\n                                            mirror_speed, 0, 0, mirror_shallow);\n\n    if (mon_ret != 0)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), data);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    diskPriv->migrSource = g_steal_pointer(&copysrc);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       virDomainDiskDefPtr disk,\n                                       const char *jobname,\n                                       const char *sourcename,\n                                       bool persistjob,\n                                       const char *host,\n                                       int port,\n                                       unsigned long long mirror_speed,\n                                       unsigned int mirror_shallow,\n                                       const char *tlsAlias)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    int mon_ret = 0;\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    VIR_DEBUG(\"starting blockdev mirror for disk=%s to host=%s\", disk->dst, host);\n\n    if (!(copysrc = qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(disk, host, port, tlsAlias)))\n        return -1;\n\n    /* Migration via blockdev-mirror was supported sooner than the auto-read-only\n     * feature was added to qemu */\n    if (!(data = qemuBlockStorageSourceAttachPrepareBlockdev(copysrc,\n                                                             copysrc->backingStore,\n                                                             false)))\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuBlockStorageSourceAttachApply(qemuDomainGetMonitor(vm), data);\n\n    if (mon_ret == 0)\n        mon_ret = qemuMonitorBlockdevMirror(qemuDomainGetMonitor(vm), jobname, persistjob,\n                                            sourcename, copysrc->nodeformat,\n                                            mirror_speed, 0, 0, mirror_shallow);\n\n    if (mon_ret != 0)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), data);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    diskPriv->migrSource = g_steal_pointer(&copysrc);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobSyncBegin",
          "args": [
            "job"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobSyncBegin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1697-1707",
          "snippet": "void\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainDiskGetTopNodename",
          "args": [
            "disk"
          ],
          "line": 934
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDiskGetTopNodename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11806-11818",
          "snippet": "const char *\nqemuDomainDiskGetTopNodename(virDomainDiskDefPtr disk)\n{\n    qemuDomainDiskPrivatePtr priv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n    if (virStorageSourceIsEmpty(disk->src))\n        return NULL;\n\n    if (disk->copy_on_read == VIR_TRISTATE_SWITCH_ON)\n        return priv->nodeCopyOnRead;\n\n    return disk->src->nodeformat;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nconst char *\nqemuDomainDiskGetTopNodename(virDomainDiskDefPtr disk)\n{\n    qemuDomainDiskPrivatePtr priv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n    if (virStorageSourceIsEmpty(disk->src))\n        return NULL;\n\n    if (disk->copy_on_read == VIR_TRISTATE_SWITCH_ON)\n        return priv->nodeCopyOnRead;\n\n    return disk->src->nodeformat;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskNew",
          "args": [
            "vm",
            "disk",
            "QEMU_BLOCKJOB_TYPE_COPY",
            "diskAlias"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskNewBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "390-413",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyOne(virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  virDomainDiskDefPtr disk,\n                                  const char *host,\n                                  int port,\n                                  unsigned long long mirror_speed,\n                                  bool mirror_shallow,\n                                  const char *tlsAlias,\n                                  unsigned int flags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    qemuBlockJobDataPtr job = NULL;\n    char *diskAlias = NULL;\n    const char *jobname = NULL;\n    const char *sourcename = NULL;\n    bool persistjob = false;\n    int rc;\n    int ret = -1;\n\n    if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n        goto cleanup;\n\n    if (!(job = qemuBlockJobDiskNew(vm, disk, QEMU_BLOCKJOB_TYPE_COPY, diskAlias)))\n        goto cleanup;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = diskAlias;\n        sourcename = qemuDomainDiskGetTopNodename(disk);\n        persistjob = true;\n    } else {\n        jobname = NULL;\n        sourcename = diskAlias;\n        persistjob = false;\n    }\n\n    qemuBlockJobSyncBegin(job);\n\n    if (flags & VIR_MIGRATE_TLS ||\n        virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        rc = qemuMigrationSrcNBDStorageCopyBlockdev(driver, vm,\n                                                    disk, jobname,\n                                                    sourcename, persistjob,\n                                                    host, port,\n                                                    mirror_speed,\n                                                    mirror_shallow,\n                                                    tlsAlias);\n    } else {\n        rc = qemuMigrationSrcNBDStorageCopyDriveMirror(driver, vm, diskAlias,\n                                                       host, port,\n                                                       mirror_speed,\n                                                       mirror_shallow);\n    }\n\n    if (rc < 0)\n        goto cleanup;\n\n    diskPriv->migrating = true;\n    qemuBlockJobStarted(job, vm);\n\n    ret = 0;\n\n cleanup:\n    qemuBlockJobStartupFinalize(vm, job);\n    VIR_FREE(diskAlias);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopyDriveMirror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "870-902",
    "snippet": "static int\nqemuMigrationSrcNBDStorageCopyDriveMirror(virQEMUDriverPtr driver,\n                                          virDomainObjPtr vm,\n                                          const char *diskAlias,\n                                          const char *host,\n                                          int port,\n                                          unsigned long long mirror_speed,\n                                          bool mirror_shallow)\n{\n    g_autofree char *nbd_dest = NULL;\n    int mon_ret;\n\n    if (strchr(host, ':')) {\n        nbd_dest = g_strdup_printf(\"nbd:[%s]:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    } else {\n        nbd_dest = g_strdup_printf(\"nbd:%s:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuMonitorDriveMirror(qemuDomainGetMonitor(vm),\n                                     diskAlias, nbd_dest, \"raw\",\n                                     mirror_speed, 0, 0, mirror_shallow, true);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorDriveMirror",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "diskAlias",
            "nbd_dest",
            "\"raw\"",
            "mirror_speed",
            "0",
            "0",
            "mirror_shallow",
            "true"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorDriveMirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3029-3046",
          "snippet": "int\nqemuMonitorDriveMirror(qemuMonitorPtr mon,\n                       const char *device, const char *file,\n                       const char *format, unsigned long long bandwidth,\n                       unsigned int granularity, unsigned long long buf_size,\n                       bool shallow,\n                       bool reuse)\n{\n    VIR_DEBUG(\"device=%s, file=%s, format=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d, reuse=%d\",\n              device, file, NULLSTR(format), bandwidth, granularity,\n              buf_size, shallow, reuse);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDriveMirror(mon, device, file, format, bandwidth,\n                                      granularity, buf_size, shallow, reuse);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorDriveMirror(qemuMonitorPtr mon,\n                       const char *device, const char *file,\n                       const char *format, unsigned long long bandwidth,\n                       unsigned int granularity, unsigned long long buf_size,\n                       bool shallow,\n                       bool reuse)\n{\n    VIR_DEBUG(\"device=%s, file=%s, format=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d, reuse=%d\",\n              device, file, NULLSTR(format), bandwidth, granularity,\n              buf_size, shallow, reuse);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONDriveMirror(mon, device, file, format, bandwidth,\n                                      granularity, buf_size, shallow, reuse);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 894
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"nbd:%s:%d:exportname=%s\"",
            "host",
            "port",
            "diskAlias"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "host",
            "':'"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyDriveMirror(virQEMUDriverPtr driver,\n                                          virDomainObjPtr vm,\n                                          const char *diskAlias,\n                                          const char *host,\n                                          int port,\n                                          unsigned long long mirror_speed,\n                                          bool mirror_shallow)\n{\n    g_autofree char *nbd_dest = NULL;\n    int mon_ret;\n\n    if (strchr(host, ':')) {\n        nbd_dest = g_strdup_printf(\"nbd:[%s]:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    } else {\n        nbd_dest = g_strdup_printf(\"nbd:%s:%d:exportname=%s\", host, port,\n                                   diskAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuMonitorDriveMirror(qemuDomainGetMonitor(vm),\n                                     diskAlias, nbd_dest, \"raw\",\n                                     mirror_speed, 0, 0, mirror_shallow, true);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopyBlockdev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "817-867",
    "snippet": "static int\nqemuMigrationSrcNBDStorageCopyBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       virDomainDiskDefPtr disk,\n                                       const char *jobname,\n                                       const char *sourcename,\n                                       bool persistjob,\n                                       const char *host,\n                                       int port,\n                                       unsigned long long mirror_speed,\n                                       unsigned int mirror_shallow,\n                                       const char *tlsAlias)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    int mon_ret = 0;\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    VIR_DEBUG(\"starting blockdev mirror for disk=%s to host=%s\", disk->dst, host);\n\n    if (!(copysrc = qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(disk, host, port, tlsAlias)))\n        return -1;\n\n    /* Migration via blockdev-mirror was supported sooner than the auto-read-only\n     * feature was added to qemu */\n    if (!(data = qemuBlockStorageSourceAttachPrepareBlockdev(copysrc,\n                                                             copysrc->backingStore,\n                                                             false)))\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuBlockStorageSourceAttachApply(qemuDomainGetMonitor(vm), data);\n\n    if (mon_ret == 0)\n        mon_ret = qemuMonitorBlockdevMirror(qemuDomainGetMonitor(vm), jobname, persistjob,\n                                            sourcename, copysrc->nodeformat,\n                                            mirror_speed, 0, 0, mirror_shallow);\n\n    if (mon_ret != 0)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), data);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    diskPriv->migrSource = g_steal_pointer(&copysrc);\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&copysrc"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachRollback",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "data"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1724-1764",
          "snippet": "void\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorBlockdevMirror",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "jobname",
            "persistjob",
            "sourcename",
            "copysrc->nodeformat",
            "mirror_speed",
            "0",
            "0",
            "mirror_shallow"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorBlockdevMirror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3049-3069",
          "snippet": "int\nqemuMonitorBlockdevMirror(qemuMonitorPtr mon,\n                          const char *jobname,\n                          bool persistjob,\n                          const char *device,\n                          const char *target,\n                          unsigned long long bandwidth,\n                          unsigned int granularity,\n                          unsigned long long buf_size,\n                          bool shallow)\n{\n    VIR_DEBUG(\"jobname=%s, persistjob=%d, device=%s, target=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d\",\n              NULLSTR(jobname), persistjob, device, target, bandwidth, granularity,\n              buf_size, shallow);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMirror(mon, jobname, persistjob, device, target,\n                                         bandwidth, granularity, buf_size, shallow);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockdevMirror(qemuMonitorPtr mon,\n                          const char *jobname,\n                          bool persistjob,\n                          const char *device,\n                          const char *target,\n                          unsigned long long bandwidth,\n                          unsigned int granularity,\n                          unsigned long long buf_size,\n                          bool shallow)\n{\n    VIR_DEBUG(\"jobname=%s, persistjob=%d, device=%s, target=%s, bandwidth=%lld, \"\n              \"granularity=%#x, buf_size=%lld, shallow=%d\",\n              NULLSTR(jobname), persistjob, device, target, bandwidth, granularity,\n              buf_size, shallow);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockdevMirror(mon, jobname, persistjob, device, target,\n                                         bandwidth, granularity, buf_size, shallow);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachApply",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "data"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachApply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1692-1711",
          "snippet": "int\nqemuBlockStorageSourceAttachApply(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceAttachDataPtr data)\n{\n    if (qemuBlockStorageSourceAttachApplyStorageDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorage(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorageSlice(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormatDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormat(mon, data) < 0)\n        return -1;\n\n    if (data->driveCmd) {\n        if (qemuMonitorAddDrive(mon, data->driveCmd) < 0)\n            return -1;\n\n        data->driveAdded = true;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockStorageSourceAttachApply(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceAttachDataPtr data)\n{\n    if (qemuBlockStorageSourceAttachApplyStorageDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorage(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyStorageSlice(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormatDeps(mon, data) < 0 ||\n        qemuBlockStorageSourceAttachApplyFormat(mon, data) < 0)\n        return -1;\n\n    if (data->driveCmd) {\n        if (qemuMonitorAddDrive(mon, data->driveCmd) < 0)\n            return -1;\n\n        data->driveAdded = true;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachPrepareBlockdev",
          "args": [
            "copysrc",
            "copysrc->backingStore",
            "false"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachPrepareBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1564-1592",
          "snippet": "qemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceAttachPrepareBlockdev(virStorageSourcePtr src,\n                                            virStorageSourcePtr backingStore,\n                                            bool autoreadonly)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    if (!(data->formatProps = qemuBlockStorageSourceGetBlockdevProps(src,\n                                                                     backingStore)) ||\n        !(data->storageProps = qemuBlockStorageSourceGetBackendProps(src, false,\n                                                                     false,\n                                                                     autoreadonly)))\n        return NULL;\n\n    data->storageNodeName = src->nodestorage;\n    data->formatNodeName = src->nodeformat;\n\n    if (qemuBlockStorageSourceNeedsStorageSliceLayer(src)) {\n        if (!(data->storageSliceProps = qemuBlockStorageSourceGetBlockdevStorageSliceProps(src)))\n            return NULL;\n\n        data->storageSliceNodeName = src->sliceStorage->nodename;\n    }\n\n    return g_steal_pointer(&data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nqemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceAttachPrepareBlockdev(virStorageSourcePtr src,\n                                            virStorageSourcePtr backingStore,\n                                            bool autoreadonly)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    if (!(data->formatProps = qemuBlockStorageSourceGetBlockdevProps(src,\n                                                                     backingStore)) ||\n        !(data->storageProps = qemuBlockStorageSourceGetBackendProps(src, false,\n                                                                     false,\n                                                                     autoreadonly)))\n        return NULL;\n\n    data->storageNodeName = src->nodestorage;\n    data->formatNodeName = src->nodeformat;\n\n    if (qemuBlockStorageSourceNeedsStorageSliceLayer(src)) {\n        if (!(data->storageSliceProps = qemuBlockStorageSourceGetBlockdevStorageSliceProps(src)))\n            return NULL;\n\n        data->storageSliceNodeName = src->sliceStorage->nodename;\n    }\n\n    return g_steal_pointer(&data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource",
          "args": [
            "disk",
            "host",
            "port",
            "tlsAlias"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "780-814",
          "snippet": "static virStorageSourcePtr\nqemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(virDomainDiskDefPtr disk,\n                                                    const char *host,\n                                                    int port,\n                                                    const char *tlsAlias)\n{\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    if (!(copysrc = virStorageSourceNew()))\n        return NULL;\n\n    copysrc->type = VIR_STORAGE_TYPE_NETWORK;\n    copysrc->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n    copysrc->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(copysrc->backingStore = virStorageSourceNew()))\n        return NULL;\n\n    if (!(copysrc->path = qemuAliasDiskDriveFromDisk(disk)))\n        return NULL;\n\n    copysrc->hosts = g_new0(virStorageNetHostDef, 1);\n\n    copysrc->nhosts = 1;\n    copysrc->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    copysrc->hosts->port = port;\n    copysrc->hosts->name = g_strdup(host);\n\n    copysrc->tlsAlias = g_strdup(tlsAlias);\n\n    copysrc->nodestorage = g_strdup_printf(\"migration-%s-storage\", disk->dst);\n    copysrc->nodeformat = g_strdup_printf(\"migration-%s-format\", disk->dst);\n\n    return g_steal_pointer(&copysrc);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virStorageSourcePtr\nqemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(virDomainDiskDefPtr disk,\n                                                    const char *host,\n                                                    int port,\n                                                    const char *tlsAlias)\n{\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    if (!(copysrc = virStorageSourceNew()))\n        return NULL;\n\n    copysrc->type = VIR_STORAGE_TYPE_NETWORK;\n    copysrc->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n    copysrc->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(copysrc->backingStore = virStorageSourceNew()))\n        return NULL;\n\n    if (!(copysrc->path = qemuAliasDiskDriveFromDisk(disk)))\n        return NULL;\n\n    copysrc->hosts = g_new0(virStorageNetHostDef, 1);\n\n    copysrc->nhosts = 1;\n    copysrc->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    copysrc->hosts->port = port;\n    copysrc->hosts->name = g_strdup(host);\n\n    copysrc->tlsAlias = g_strdup(tlsAlias);\n\n    copysrc->nodestorage = g_strdup_printf(\"migration-%s-storage\", disk->dst);\n    copysrc->nodeformat = g_strdup_printf(\"migration-%s-format\", disk->dst);\n\n    return g_steal_pointer(&copysrc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"starting blockdev mirror for disk=%s to host=%s\"",
            "disk->dst",
            "host"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyBlockdev(virQEMUDriverPtr driver,\n                                       virDomainObjPtr vm,\n                                       virDomainDiskDefPtr disk,\n                                       const char *jobname,\n                                       const char *sourcename,\n                                       bool persistjob,\n                                       const char *host,\n                                       int port,\n                                       unsigned long long mirror_speed,\n                                       unsigned int mirror_shallow,\n                                       const char *tlsAlias)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n    qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n    int mon_ret = 0;\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    VIR_DEBUG(\"starting blockdev mirror for disk=%s to host=%s\", disk->dst, host);\n\n    if (!(copysrc = qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(disk, host, port, tlsAlias)))\n        return -1;\n\n    /* Migration via blockdev-mirror was supported sooner than the auto-read-only\n     * feature was added to qemu */\n    if (!(data = qemuBlockStorageSourceAttachPrepareBlockdev(copysrc,\n                                                             copysrc->backingStore,\n                                                             false)))\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_OUT) < 0)\n        return -1;\n\n    mon_ret = qemuBlockStorageSourceAttachApply(qemuDomainGetMonitor(vm), data);\n\n    if (mon_ret == 0)\n        mon_ret = qemuMonitorBlockdevMirror(qemuDomainGetMonitor(vm), jobname, persistjob,\n                                            sourcename, copysrc->nodeformat,\n                                            mirror_speed, 0, 0, mirror_shallow);\n\n    if (mon_ret != 0)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), data);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || mon_ret < 0)\n        return -1;\n\n    diskPriv->migrSource = g_steal_pointer(&copysrc);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopyBlockdevPrepareSource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "780-814",
    "snippet": "static virStorageSourcePtr\nqemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(virDomainDiskDefPtr disk,\n                                                    const char *host,\n                                                    int port,\n                                                    const char *tlsAlias)\n{\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    if (!(copysrc = virStorageSourceNew()))\n        return NULL;\n\n    copysrc->type = VIR_STORAGE_TYPE_NETWORK;\n    copysrc->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n    copysrc->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(copysrc->backingStore = virStorageSourceNew()))\n        return NULL;\n\n    if (!(copysrc->path = qemuAliasDiskDriveFromDisk(disk)))\n        return NULL;\n\n    copysrc->hosts = g_new0(virStorageNetHostDef, 1);\n\n    copysrc->nhosts = 1;\n    copysrc->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    copysrc->hosts->port = port;\n    copysrc->hosts->name = g_strdup(host);\n\n    copysrc->tlsAlias = g_strdup(tlsAlias);\n\n    copysrc->nodestorage = g_strdup_printf(\"migration-%s-storage\", disk->dst);\n    copysrc->nodeformat = g_strdup_printf(\"migration-%s-format\", disk->dst);\n\n    return g_steal_pointer(&copysrc);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&copysrc"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"migration-%s-format\"",
            "disk->dst"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageNetHostDef",
            "1"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic virStorageSourcePtr\nqemuMigrationSrcNBDStorageCopyBlockdevPrepareSource(virDomainDiskDefPtr disk,\n                                                    const char *host,\n                                                    int port,\n                                                    const char *tlsAlias)\n{\n    g_autoptr(virStorageSource) copysrc = NULL;\n\n    if (!(copysrc = virStorageSourceNew()))\n        return NULL;\n\n    copysrc->type = VIR_STORAGE_TYPE_NETWORK;\n    copysrc->protocol = VIR_STORAGE_NET_PROTOCOL_NBD;\n    copysrc->format = VIR_STORAGE_FILE_RAW;\n\n    if (!(copysrc->backingStore = virStorageSourceNew()))\n        return NULL;\n\n    if (!(copysrc->path = qemuAliasDiskDriveFromDisk(disk)))\n        return NULL;\n\n    copysrc->hosts = g_new0(virStorageNetHostDef, 1);\n\n    copysrc->nhosts = 1;\n    copysrc->hosts->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n    copysrc->hosts->port = port;\n    copysrc->hosts->name = g_strdup(host);\n\n    copysrc->tlsAlias = g_strdup(tlsAlias);\n\n    copysrc->nodestorage = g_strdup_printf(\"migration-%s-storage\", disk->dst);\n    copysrc->nodeformat = g_strdup_printf(\"migration-%s-format\", disk->dst);\n\n    return g_steal_pointer(&copysrc);\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDCopyCancel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "694-777",
    "snippet": "static int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virErrorRestore",
          "args": [
            "&err"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorRestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "445-457",
          "snippet": "void\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorRestore(virErrorPtr *savederr)\n{\n    int saved_errno = errno;\n\n    if (!*savederr)\n        return;\n\n    virSetError(*savederr);\n    virFreeError(*savederr);\n    *savederr = NULL;\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "diskPriv->migrSource"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceDetachOneBlockdev",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "diskPriv->migrSource"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceDetachOneBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1951-1971",
          "snippet": "int\nqemuBlockStorageSourceDetachOneBlockdev(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuDomainAsyncJob asyncJob,\n                                        virStorageSourcePtr src)\n{\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorBlockdevDel(qemuDomainGetMonitor(vm), src->nodeformat);\n\n    if (ret == 0)\n        ret = qemuMonitorBlockdevDel(qemuDomainGetMonitor(vm), src->nodestorage);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockStorageSourceDetachOneBlockdev(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuDomainAsyncJob asyncJob,\n                                        virStorageSourcePtr src)\n{\n    int ret;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    ret = qemuMonitorBlockdevDel(qemuDomainGetMonitor(vm), src->nodeformat);\n\n    if (ret == 0)\n        ret = qemuMonitorBlockdevDel(qemuDomainGetMonitor(vm), src->nodestorage);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjWait",
          "args": [
            "vm"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjWait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3659-3675",
          "snippet": "int\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainObjWait(virDomainObjPtr vm)\n{\n    if (virCondWait(&vm->cond, &vm->parent.lock) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"failed to wait for domain condition\"));\n        return -1;\n    }\n\n    if (!virDomainObjIsActive(vm)) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"domain is not running\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virErrorPreserveLast",
          "args": [
            "&err"
          ],
          "line": 753
        },
        "resolved": true,
        "details": {
          "function_name": "virErrorPreserveLast",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "424-436",
          "snippet": "void\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirErrorPreserveLast(virErrorPtr *saveerr)\n{\n    int saved_errno = errno;\n    virErrorPtr lasterr = virGetLastError();\n\n    *saveerr = NULL;\n\n    if (lasterr)\n        *saveerr = virErrorCopyNew(lasterr);\n\n    errno = saved_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"Lost connection to destination host\")"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Lost connection to destination host\""
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virConnectIsAlive",
          "args": [
            "dconn"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "virConnectIsAlive",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-host.c",
          "lines": "1389-1409",
          "snippet": "int\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include <sys/stat.h>\n#include <config.h>\n\nint\nvirConnectIsAlive(virConnectPtr conn)\n{\n    VIR_DEBUG(\"conn=%p\", conn);\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, -1);\n    if (conn->driver->connectIsAlive) {\n        int ret;\n        ret = conn->driver->connectIsAlive(conn);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n error:\n    virDispatchError(conn);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDCopyCancelled",
          "args": [
            "vm",
            "asyncJob",
            "check"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDCopyCancelled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "562-636",
          "snippet": "static int\nqemuMigrationSrcNBDCopyCancelled(virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 bool check)\n{\n    size_t i;\n    size_t active = 0;\n    size_t completed = 0;\n    int status;\n    bool failed = false;\n\n retry:\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        switch (status) {\n        case VIR_DOMAIN_BLOCK_JOB_FAILED:\n            if (check) {\n                qemuMigrationNBDReportMirrorError(job, disk->dst);\n                failed = true;\n            }\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n            diskPriv->migrating = false;\n            break;\n\n        default:\n            active++;\n        }\n\n        if (status == VIR_DOMAIN_BLOCK_JOB_COMPLETED)\n            completed++;\n\n        virObjectUnref(job);\n    }\n\n    /* Updating completed block job drops the lock thus we have to recheck\n     * block jobs for disks that reside before the disk(s) with completed\n     * block job.\n     */\n    if (completed > 0) {\n        completed = 0;\n        active = 0;\n        goto retry;\n    }\n\n    if (failed) {\n        if (active) {\n            VIR_DEBUG(\"Some disk mirrors failed; still waiting for %zu \"\n                      \"disk mirrors to finish\", active);\n            return -1;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone; some of them failed\");\n            return -2;\n        }\n    } else {\n        if (active) {\n            VIR_DEBUG(\"Waiting for %zu disk mirrors to finish\", active);\n            return 0;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone\");\n            return 1;\n        }\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancelled(virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 bool check)\n{\n    size_t i;\n    size_t active = 0;\n    size_t completed = 0;\n    int status;\n    bool failed = false;\n\n retry:\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        switch (status) {\n        case VIR_DOMAIN_BLOCK_JOB_FAILED:\n            if (check) {\n                qemuMigrationNBDReportMirrorError(job, disk->dst);\n                failed = true;\n            }\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n            diskPriv->migrating = false;\n            break;\n\n        default:\n            active++;\n        }\n\n        if (status == VIR_DOMAIN_BLOCK_JOB_COMPLETED)\n            completed++;\n\n        virObjectUnref(job);\n    }\n\n    /* Updating completed block job drops the lock thus we have to recheck\n     * block jobs for disks that reside before the disk(s) with completed\n     * block job.\n     */\n    if (completed > 0) {\n        completed = 0;\n        active = 0;\n        goto retry;\n    }\n\n    if (failed) {\n        if (active) {\n            VIR_DEBUG(\"Some disk mirrors failed; still waiting for %zu \"\n                      \"disk mirrors to finish\", active);\n            return -1;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone; some of them failed\");\n            return -2;\n        }\n    } else {\n        if (active) {\n            VIR_DEBUG(\"Waiting for %zu disk mirrors to finish\", active);\n            return 0;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone\");\n            return 1;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobSyncEnd",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobSyncEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1720-1733",
          "snippet": "void\nqemuBlockJobSyncEnd(virDomainObjPtr vm,\n                    qemuBlockJobDataPtr job,\n                    int asyncJob)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = false;\n    qemuBlockJobUpdate(vm, job, asyncJob);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobSyncEnd(virDomainObjPtr vm,\n                    qemuBlockJobDataPtr job,\n                    int asyncJob)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = false;\n    qemuBlockJobUpdate(vm, job, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationSrcNBDCopyCancelOne",
          "args": [
            "driver",
            "vm",
            "disk",
            "job",
            "check",
            "asyncJob"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationSrcNBDCopyCancelOne",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "644-678",
          "snippet": "static int\nqemuMigrationSrcNBDCopyCancelOne(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainDiskDefPtr disk,\n                                 qemuBlockJobDataPtr job,\n                                 bool failNoJob,\n                                 qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int status;\n    int rv;\n\n    status = qemuBlockJobUpdate(vm, job, asyncJob);\n    switch (status) {\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (failNoJob) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            return -1;\n        }\n        G_GNUC_FALLTHROUGH;\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        return 1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorBlockJobCancel(priv->mon, job->name);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancelOne(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainDiskDefPtr disk,\n                                 qemuBlockJobDataPtr job,\n                                 bool failNoJob,\n                                 qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int status;\n    int rv;\n\n    status = qemuBlockJobUpdate(vm, job, asyncJob);\n    switch (status) {\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (failNoJob) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            return -1;\n        }\n        G_GNUC_FALLTHROUGH;\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        return 1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorBlockJobCancel(priv->mon, job->name);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobIsRunning",
          "args": [
            "job"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobIsRunning",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "473-480",
          "snippet": "bool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nbool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "disk"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cancelling drive mirrors for domain %s\"",
            "vm->def->name"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancel(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              bool check,\n                              qemuDomainAsyncJob asyncJob,\n                              virConnectPtr dconn)\n{\n    virErrorPtr err = NULL;\n    int ret = -1;\n    size_t i;\n    int rv;\n    bool failed = false;\n\n    VIR_DEBUG(\"Cancelling drive mirrors for domain %s\", vm->def->name);\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)) ||\n            !qemuBlockJobIsRunning(job))\n            diskPriv->migrating = false;\n\n        if (!diskPriv->migrating) {\n            virObjectUnref(job);\n            continue;\n        }\n\n        rv = qemuMigrationSrcNBDCopyCancelOne(driver, vm, disk, job,\n                                              check, asyncJob);\n        if (rv != 0) {\n            if (rv < 0) {\n                if (!err)\n                    virErrorPreserveLast(&err);\n                failed = true;\n            }\n            qemuBlockJobSyncEnd(vm, job, asyncJob);\n            diskPriv->migrating = false;\n        }\n\n        virObjectUnref(job);\n    }\n\n    while ((rv = qemuMigrationSrcNBDCopyCancelled(vm, asyncJob, check)) != 1) {\n        if (check && !failed &&\n            dconn && virConnectIsAlive(dconn) <= 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"Lost connection to destination host\"));\n            failed = true;\n        }\n\n        if (rv < 0) {\n            failed = true;\n            if (rv == -2)\n                break;\n        }\n\n        if (failed && !err)\n            virErrorPreserveLast(&err);\n\n        if (virDomainObjWait(vm) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n\n        if (!diskPriv->migrSource)\n            continue;\n\n        qemuBlockStorageSourceDetachOneBlockdev(driver, vm, asyncJob,\n                                                diskPriv->migrSource);\n        virObjectUnref(diskPriv->migrSource);\n        diskPriv->migrSource = NULL;\n    }\n\n    ret = failed ? -1 : 0;\n\n cleanup:\n    virErrorRestore(&err);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDCopyCancelOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "644-678",
    "snippet": "static int\nqemuMigrationSrcNBDCopyCancelOne(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainDiskDefPtr disk,\n                                 qemuBlockJobDataPtr job,\n                                 bool failNoJob,\n                                 qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int status;\n    int rv;\n\n    status = qemuBlockJobUpdate(vm, job, asyncJob);\n    switch (status) {\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (failNoJob) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            return -1;\n        }\n        G_GNUC_FALLTHROUGH;\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        return 1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorBlockJobCancel(priv->mon, job->name);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorBlockJobCancel",
          "args": [
            "priv->mon",
            "job->name"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorBlockJobCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3231-3240",
          "snippet": "int\nqemuMonitorBlockJobCancel(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobCancel(mon, jobname);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorBlockJobCancel(qemuMonitorPtr mon,\n                          const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONBlockJobCancel(mon, jobname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationNBDReportMirrorError",
          "args": [
            "job",
            "disk->dst"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationNBDReportMirrorError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "481-493",
          "snippet": "static void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUpdate",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1664-1680",
          "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancelOne(virQEMUDriverPtr driver,\n                                 virDomainObjPtr vm,\n                                 virDomainDiskDefPtr disk,\n                                 qemuBlockJobDataPtr job,\n                                 bool failNoJob,\n                                 qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int status;\n    int rv;\n\n    status = qemuBlockJobUpdate(vm, job, asyncJob);\n    switch (status) {\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (failNoJob) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            return -1;\n        }\n        G_GNUC_FALLTHROUGH;\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        return 1;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    rv = qemuMonitorBlockJobCancel(priv->mon, job->name);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rv < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDCopyCancelled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "562-636",
    "snippet": "static int\nqemuMigrationSrcNBDCopyCancelled(virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 bool check)\n{\n    size_t i;\n    size_t active = 0;\n    size_t completed = 0;\n    int status;\n    bool failed = false;\n\n retry:\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        switch (status) {\n        case VIR_DOMAIN_BLOCK_JOB_FAILED:\n            if (check) {\n                qemuMigrationNBDReportMirrorError(job, disk->dst);\n                failed = true;\n            }\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n            diskPriv->migrating = false;\n            break;\n\n        default:\n            active++;\n        }\n\n        if (status == VIR_DOMAIN_BLOCK_JOB_COMPLETED)\n            completed++;\n\n        virObjectUnref(job);\n    }\n\n    /* Updating completed block job drops the lock thus we have to recheck\n     * block jobs for disks that reside before the disk(s) with completed\n     * block job.\n     */\n    if (completed > 0) {\n        completed = 0;\n        active = 0;\n        goto retry;\n    }\n\n    if (failed) {\n        if (active) {\n            VIR_DEBUG(\"Some disk mirrors failed; still waiting for %zu \"\n                      \"disk mirrors to finish\", active);\n            return -1;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone; some of them failed\");\n            return -2;\n        }\n    } else {\n        if (active) {\n            VIR_DEBUG(\"Waiting for %zu disk mirrors to finish\", active);\n            return 0;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone\");\n            return 1;\n        }\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"All disk mirrors are gone\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waiting for %zu disk mirrors to finish\"",
            "active"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"All disk mirrors are gone; some of them failed\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Some disk mirrors failed; still waiting for %zu \"\n                      \"disk mirrors to finish\"",
            "active"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationNBDReportMirrorError",
          "args": [
            "job",
            "disk->dst"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationNBDReportMirrorError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "481-493",
          "snippet": "static void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUpdate",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1664-1680",
          "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "disk"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDCopyCancelled(virDomainObjPtr vm,\n                                 qemuDomainAsyncJob asyncJob,\n                                 bool check)\n{\n    size_t i;\n    size_t active = 0;\n    size_t completed = 0;\n    int status;\n    bool failed = false;\n\n retry:\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk)))\n            continue;\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        switch (status) {\n        case VIR_DOMAIN_BLOCK_JOB_FAILED:\n            if (check) {\n                qemuMigrationNBDReportMirrorError(job, disk->dst);\n                failed = true;\n            }\n            G_GNUC_FALLTHROUGH;\n        case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n            diskPriv->migrating = false;\n            break;\n\n        default:\n            active++;\n        }\n\n        if (status == VIR_DOMAIN_BLOCK_JOB_COMPLETED)\n            completed++;\n\n        virObjectUnref(job);\n    }\n\n    /* Updating completed block job drops the lock thus we have to recheck\n     * block jobs for disks that reside before the disk(s) with completed\n     * block job.\n     */\n    if (completed > 0) {\n        completed = 0;\n        active = 0;\n        goto retry;\n    }\n\n    if (failed) {\n        if (active) {\n            VIR_DEBUG(\"Some disk mirrors failed; still waiting for %zu \"\n                      \"disk mirrors to finish\", active);\n            return -1;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone; some of them failed\");\n            return -2;\n        }\n    } else {\n        if (active) {\n            VIR_DEBUG(\"Waiting for %zu disk mirrors to finish\", active);\n            return 0;\n        } else {\n            VIR_DEBUG(\"All disk mirrors are gone\");\n            return 1;\n        }\n    }\n}"
  },
  {
    "function_name": "qemuMigrationSrcNBDStorageCopyReady",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "507-549",
    "snippet": "static int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"All disk mirrors are ready\""
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Waiting for %zu disk mirrors to get ready\"",
            "notReady"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationNBDReportMirrorError",
          "args": [
            "job",
            "disk->dst"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationNBDReportMirrorError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "481-493",
          "snippet": "static void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUpdate",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1664-1680",
          "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"missing block job data for disk '%s'\")",
            "disk->dst"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing block job data for disk '%s'\""
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDiskGetJob",
          "args": [
            "disk"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDiskGetJob",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "422-431",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationSrcNBDStorageCopyReady(virDomainObjPtr vm,\n                                    qemuDomainAsyncJob asyncJob)\n{\n    size_t i;\n    size_t notReady = 0;\n    int status;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        qemuDomainDiskPrivatePtr diskPriv = QEMU_DOMAIN_DISK_PRIVATE(disk);\n        qemuBlockJobDataPtr job;\n\n        if (!diskPriv->migrating)\n            continue;\n\n        if (!(job = qemuBlockJobDiskGetJob(disk))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"missing block job data for disk '%s'\"), disk->dst);\n            return -1;\n        }\n\n        status = qemuBlockJobUpdate(vm, job, asyncJob);\n        if (status == VIR_DOMAIN_BLOCK_JOB_FAILED) {\n            qemuMigrationNBDReportMirrorError(job, disk->dst);\n            virObjectUnref(job);\n            return -1;\n        }\n\n        virObjectUnref(job);\n\n        if (disk->mirrorState != VIR_DOMAIN_DISK_MIRROR_STATE_READY)\n            notReady++;\n    }\n\n    if (notReady) {\n        VIR_DEBUG(\"Waiting for %zu disk mirrors to get ready\", notReady);\n        return 0;\n    } else {\n        VIR_DEBUG(\"All disk mirrors are ready\");\n        return 1;\n    }\n}"
  },
  {
    "function_name": "qemuMigrationNBDReportMirrorError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "481-493",
    "snippet": "static void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"migration of disk %s failed\")",
            "diskdst"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"migration of disk %s failed\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"migration of disk %s failed: %s\")",
            "diskdst",
            "job->errmsg"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationNBDReportMirrorError(qemuBlockJobDataPtr job,\n                                  const char *diskdst)\n{\n    if (job->errmsg) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed: %s\"),\n                       diskdst, job->errmsg);\n    } else {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"migration of disk %s failed\"), diskdst);\n    }\n}"
  },
  {
    "function_name": "qemuMigrationDstStopNBDServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "456-478",
    "snippet": "static int\nqemuMigrationDstStopNBDServer(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuMigrationCookiePtr mig)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!mig->nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        return -1;\n\n    if (qemuMonitorNBDServerStop(priv->mon) < 0)\n        VIR_WARN(\"Unable to stop NBD server\");\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n    return 0;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "priv->nbdPort"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to stop NBD server\""
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerStop",
          "args": [
            "priv->mon"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3878-3884",
          "snippet": "int\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStop(qemuMonitorPtr mon)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStop(mon);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstStopNBDServer(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              qemuMigrationCookiePtr mig)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (!mig->nbd)\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                       QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n        return -1;\n\n    if (qemuMonitorNBDServerStop(priv->mon) < 0)\n        VIR_WARN(\"Unable to stop NBD server\");\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return -1;\n\n    virPortAllocatorRelease(priv->nbdPort);\n    priv->nbdPort = 0;\n    return 0;\n}"
  },
  {
    "function_name": "qemuMigrationDstStartNBDServer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "369-453",
    "snippet": "static int\nqemuMigrationDstStartNBDServer(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const char *listenAddr,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               int nbdPort,\n                               const char *tls_alias)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned short port = 0;\n    size_t i;\n    virStorageNetHostDef server = {\n        .name = (char *)listenAddr, /* cast away const */\n        .transport = VIR_STORAGE_NET_HOST_TRANS_TCP,\n    };\n\n    if (nbdPort < 0 || nbdPort > USHRT_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nbd port must be in range 0-65535\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        g_autofree char *diskAlias = NULL;\n        const char *exportname = NULL;\n        const char *devicename = NULL;\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (disk->src->readonly || virStorageSourceIsEmpty(disk->src)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"Cannot migrate empty or read-only disk %s\"),\n                           disk->dst);\n            goto cleanup;\n        }\n\n        if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n            goto cleanup;\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            exportname = diskAlias;\n            devicename = disk->src->nodeformat;\n        } else {\n            exportname = NULL;\n            devicename = diskAlias;\n        }\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            goto cleanup;\n\n        if (port == 0) {\n            if (nbdPort)\n                port = nbdPort;\n            else if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto exit_monitor;\n\n            server.port = port;\n            if (qemuMonitorNBDServerStart(priv->mon, &server, tls_alias) < 0)\n                goto exit_monitor;\n        }\n\n        if (qemuMonitorNBDServerAdd(priv->mon, devicename, exportname, true, NULL) < 0)\n            goto exit_monitor;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    priv->nbdPort = port;\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && nbdPort == 0)\n        virPortAllocatorRelease(port);\n    return ret;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto cleanup;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainObjExitMonitor(driver, vm)"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorRelease",
          "args": [
            "port"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorRelease",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "256-281",
          "snippet": "int\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorRelease(unsigned short port)\n{\n    int ret = -1;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    if (!pa)\n        return -1;\n\n    if (!port)\n        return 0;\n\n    virObjectLock(pa);\n\n    if (virBitmapClearBit(pa->bitmap, port) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to release port %d\"),\n                       port);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerAdd",
          "args": [
            "priv->mon",
            "devicename",
            "exportname",
            "true",
            "NULL"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3861-3875",
          "snippet": "int\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerAdd(qemuMonitorPtr mon,\n                        const char *deviceID,\n                        const char *export,\n                        bool writable,\n                        const char *bitmap)\n{\n    VIR_DEBUG(\"deviceID=%s, export=%s, bitmap=%s\", deviceID, NULLSTR(export),\n              NULLSTR(bitmap));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerAdd(mon, deviceID, export, writable,\n                                       bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorNBDServerStart",
          "args": [
            "priv->mon",
            "&server",
            "tls_alias"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorNBDServerStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3842-3858",
          "snippet": "int\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorNBDServerStart(qemuMonitorPtr mon,\n                          const virStorageNetHostDef *server,\n                          const char *tls_alias)\n{\n    /* Peek inside the struct for nicer logging */\n    if (server->transport == VIR_STORAGE_NET_HOST_TRANS_TCP)\n        VIR_DEBUG(\"server={tcp host=%s port=%u} tls_alias=%s\",\n                  NULLSTR(server->name), server->port, NULLSTR(tls_alias));\n    else\n        VIR_DEBUG(\"server={unix socket=%s} tls_alias=%s\",\n                  NULLSTR(server->socket), NULLSTR(tls_alias));\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONNBDServerStart(mon, server, tls_alias);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPortAllocatorAcquire",
          "args": [
            "driver->migrationPorts",
            "&port"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "virPortAllocatorAcquire",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virportallocator.c",
          "lines": "209-254",
          "snippet": "int\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virthread.h\"",
            "#include \"virportallocator.h\"",
            "#include \"virbitmap.h\"",
            "#include \"viralloc.h\"",
            "#include \"virsocket.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virthread.h\"\n#include \"virportallocator.h\"\n#include \"virbitmap.h\"\n#include \"viralloc.h\"\n#include \"virsocket.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirPortAllocatorAcquire(const virPortAllocatorRange *range,\n                        unsigned short *port)\n{\n    int ret = -1;\n    size_t i;\n    virPortAllocatorPtr pa = virPortAllocatorGet();\n\n    *port = 0;\n\n    if (!pa)\n        return -1;\n\n    virObjectLock(pa);\n\n    for (i = range->start; i <= range->end && !*port; i++) {\n        bool used = false, v6used = false;\n\n        if (virBitmapIsBitSet(pa->bitmap, i))\n            continue;\n\n        if (virPortAllocatorBindToPort(&v6used, i, AF_INET6) < 0 ||\n            virPortAllocatorBindToPort(&used, i, AF_INET) < 0)\n            goto cleanup;\n\n        if (!used && !v6used) {\n            /* Add port to bitmap of reserved ports */\n            if (virBitmapSetBit(pa->bitmap, i) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Failed to reserve port %zu\"), i);\n                goto cleanup;\n            }\n            *port = i;\n            ret = 0;\n        }\n    }\n\n    if (*port == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to find an unused port in range '%s' (%d-%d)\"),\n                       range->name, range->start, range->end);\n    }\n cleanup:\n    virObjectUnlock(pa);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "QEMU_ASYNC_JOB_MIGRATION_IN"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "_(\"Cannot migrate empty or read-only disk %s\")",
            "disk->dst"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot migrate empty or read-only disk %s\""
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "disk->src"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCopyDisk",
          "args": [
            "disk",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCopyDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "276-295",
          "snippet": "static bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"nbd port must be in range 0-65535\")"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstStartNBDServer(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               const char *listenAddr,\n                               size_t nmigrate_disks,\n                               const char **migrate_disks,\n                               int nbdPort,\n                               const char *tls_alias)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    unsigned short port = 0;\n    size_t i;\n    virStorageNetHostDef server = {\n        .name = (char *)listenAddr, /* cast away const */\n        .transport = VIR_STORAGE_NET_HOST_TRANS_TCP,\n    };\n\n    if (nbdPort < 0 || nbdPort > USHRT_MAX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"nbd port must be in range 0-65535\"));\n        return -1;\n    }\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = vm->def->disks[i];\n        g_autofree char *diskAlias = NULL;\n        const char *exportname = NULL;\n        const char *devicename = NULL;\n\n        /* check whether disk should be migrated */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks))\n            continue;\n\n        if (disk->src->readonly || virStorageSourceIsEmpty(disk->src)) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED,\n                           _(\"Cannot migrate empty or read-only disk %s\"),\n                           disk->dst);\n            goto cleanup;\n        }\n\n        if (!(diskAlias = qemuAliasDiskDriveFromDisk(disk)))\n            goto cleanup;\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n            exportname = diskAlias;\n            devicename = disk->src->nodeformat;\n        } else {\n            exportname = NULL;\n            devicename = diskAlias;\n        }\n\n        if (qemuDomainObjEnterMonitorAsync(driver, vm,\n                                           QEMU_ASYNC_JOB_MIGRATION_IN) < 0)\n            goto cleanup;\n\n        if (port == 0) {\n            if (nbdPort)\n                port = nbdPort;\n            else if (virPortAllocatorAcquire(driver->migrationPorts, &port) < 0)\n                goto exit_monitor;\n\n            server.port = port;\n            if (qemuMonitorNBDServerStart(priv->mon, &server, tls_alias) < 0)\n                goto exit_monitor;\n        }\n\n        if (qemuMonitorNBDServerAdd(priv->mon, devicename, exportname, true, NULL) < 0)\n            goto exit_monitor;\n        if (qemuDomainObjExitMonitor(driver, vm) < 0)\n            goto cleanup;\n    }\n\n    priv->nbdPort = port;\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && nbdPort == 0)\n        virPortAllocatorRelease(port);\n    return ret;\n\n exit_monitor:\n    ignore_value(qemuDomainObjExitMonitor(driver, vm));\n    goto cleanup;\n}"
  },
  {
    "function_name": "qemuMigrationDstPrecreateStorage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "298-354",
    "snippet": "static int\nqemuMigrationDstPrecreateStorage(virDomainObjPtr vm,\n                                 qemuMigrationCookieNBDPtr nbd,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 bool incremental)\n{\n    int ret = -1;\n    size_t i = 0;\n    virConnectPtr conn;\n\n    if (!nbd || !nbd->ndisks)\n        return 0;\n\n    if (!(conn = virGetConnectStorage()))\n        return -1;\n\n    for (i = 0; i < nbd->ndisks; i++) {\n        virDomainDiskDefPtr disk;\n        const char *diskSrcPath;\n\n        VIR_DEBUG(\"Looking up disk target '%s' (capacity=%llu)\",\n                  nbd->disks[i].target, nbd->disks[i].capacity);\n\n        if (!(disk = virDomainDiskByTarget(vm->def, nbd->disks[i].target))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to find disk by target: %s\"),\n                           nbd->disks[i].target);\n            goto cleanup;\n        }\n\n        diskSrcPath = virDomainDiskGetSource(disk);\n\n        /* Skip disks we don't want to migrate and already existing disks. */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks) ||\n            (diskSrcPath && virFileExists(diskSrcPath))) {\n            continue;\n        }\n\n        if (incremental) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\"));\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Proceeding with disk source %s\", NULLSTR(diskSrcPath));\n\n        if (qemuMigrationDstPrecreateDisk(conn, disk, nbd->disks[i].capacity) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "conn"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationDstPrecreateDisk",
          "args": [
            "conn",
            "disk",
            "nbd->disks[i].capacity"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationDstPrecreateDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "171-274",
          "snippet": "static int\nqemuMigrationDstPrecreateDisk(virConnectPtr conn,\n                              virDomainDiskDefPtr disk,\n                              unsigned long long capacity)\n{\n    int ret = -1;\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    char *volName = NULL, *basePath = NULL;\n    char *volStr = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *format = NULL;\n    unsigned int flags = 0;\n\n    VIR_DEBUG(\"Precreate disk type=%s\", virStorageTypeToString(disk->src->type));\n\n    switch ((virStorageType)disk->src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        if (!virDomainDiskGetSource(disk)) {\n            VIR_DEBUG(\"Dropping sourceless disk '%s'\",\n                      disk->dst);\n            return 0;\n        }\n\n        basePath = g_strdup(disk->src->path);\n\n        if (!(volName = strrchr(basePath, '/'))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed disk path: %s\"),\n                           disk->src->path);\n            goto cleanup;\n        }\n\n        *volName = '\\0';\n        volName++;\n\n        if (!(pool = virStoragePoolLookupByTargetPath(conn, basePath)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (!(pool = virStoragePoolLookupByName(conn, disk->src->srcpool->pool)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        volName = disk->src->srcpool->volume;\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        VIR_DEBUG(\"Skipping creation of network disk '%s'\",\n                  disk->dst);\n        return 0;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot precreate storage for disk type '%s'\"),\n                       virStorageTypeToString(disk->src->type));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByName(pool, volName))) {\n        VIR_DEBUG(\"Skipping creation of already existing volume of name '%s'\",\n                  volName);\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<volume>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", volName);\n    virBufferAsprintf(&buf, \"<capacity>%llu</capacity>\\n\", capacity);\n    virBufferAddLit(&buf, \"<target>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferAsprintf(&buf, \"<format type='%s'/>\\n\", format);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</target>\\n\");\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    if (!(volStr = virBufferContentAndReset(&buf))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to create volume XML\"));\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolCreateXML(pool, volStr, flags)))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(basePath);\n    VIR_FREE(volStr);\n    virObjectUnref(vol);\n    virObjectUnref(pool);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrecreateDisk(virConnectPtr conn,\n                              virDomainDiskDefPtr disk,\n                              unsigned long long capacity)\n{\n    int ret = -1;\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    char *volName = NULL, *basePath = NULL;\n    char *volStr = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *format = NULL;\n    unsigned int flags = 0;\n\n    VIR_DEBUG(\"Precreate disk type=%s\", virStorageTypeToString(disk->src->type));\n\n    switch ((virStorageType)disk->src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        if (!virDomainDiskGetSource(disk)) {\n            VIR_DEBUG(\"Dropping sourceless disk '%s'\",\n                      disk->dst);\n            return 0;\n        }\n\n        basePath = g_strdup(disk->src->path);\n\n        if (!(volName = strrchr(basePath, '/'))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed disk path: %s\"),\n                           disk->src->path);\n            goto cleanup;\n        }\n\n        *volName = '\\0';\n        volName++;\n\n        if (!(pool = virStoragePoolLookupByTargetPath(conn, basePath)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (!(pool = virStoragePoolLookupByName(conn, disk->src->srcpool->pool)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        volName = disk->src->srcpool->volume;\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        VIR_DEBUG(\"Skipping creation of network disk '%s'\",\n                  disk->dst);\n        return 0;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot precreate storage for disk type '%s'\"),\n                       virStorageTypeToString(disk->src->type));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByName(pool, volName))) {\n        VIR_DEBUG(\"Skipping creation of already existing volume of name '%s'\",\n                  volName);\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<volume>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", volName);\n    virBufferAsprintf(&buf, \"<capacity>%llu</capacity>\\n\", capacity);\n    virBufferAddLit(&buf, \"<target>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferAsprintf(&buf, \"<format type='%s'/>\\n\", format);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</target>\\n\");\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    if (!(volStr = virBufferContentAndReset(&buf))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to create volume XML\"));\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolCreateXML(pool, volStr, flags)))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(basePath);\n    VIR_FREE(volStr);\n    virObjectUnref(vol);\n    virObjectUnref(pool);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Proceeding with disk source %s\"",
            "NULLSTR(diskSrcPath)"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "diskSrcPath"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\")"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\""
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "diskSrcPath"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMigrationAnyCopyDisk",
          "args": [
            "disk",
            "nmigrate_disks",
            "migrate_disks"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMigrationAnyCopyDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
          "lines": "276-295",
          "snippet": "static bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virprocess.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virhook.h\"",
            "#include \"viruri.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"rpc/virnetsocket.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"viruuid.h\"",
            "#include \"virfdstream.h\"",
            "#include \"datatypes.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_audit.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration_cookie.h\"",
            "#include \"qemu_migration.h\"",
            "#include <poll.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unable to find disk by target: %s\")",
            "nbd->disks[i].target"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->def",
            "nbd->disks[i].target"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Looking up disk target '%s' (capacity=%llu)\"",
            "nbd->disks[i].target",
            "nbd->disks[i].capacity"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetConnectStorage",
          "args": [],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "virGetConnectStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/driver.c",
          "lines": "189-192",
          "snippet": "virConnectPtr virGetConnectStorage(void)\n{\n    return virGetConnectGeneric(&connectStorage, \"storage\");\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "#include \"virmodule.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"driver.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virThreadLocal connectStorage;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n#include \"virmodule.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"driver.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirThreadLocal connectStorage;\n\nvirConnectPtr virGetConnectStorage(void)\n{\n    return virGetConnectGeneric(&connectStorage, \"storage\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrecreateStorage(virDomainObjPtr vm,\n                                 qemuMigrationCookieNBDPtr nbd,\n                                 size_t nmigrate_disks,\n                                 const char **migrate_disks,\n                                 bool incremental)\n{\n    int ret = -1;\n    size_t i = 0;\n    virConnectPtr conn;\n\n    if (!nbd || !nbd->ndisks)\n        return 0;\n\n    if (!(conn = virGetConnectStorage()))\n        return -1;\n\n    for (i = 0; i < nbd->ndisks; i++) {\n        virDomainDiskDefPtr disk;\n        const char *diskSrcPath;\n\n        VIR_DEBUG(\"Looking up disk target '%s' (capacity=%llu)\",\n                  nbd->disks[i].target, nbd->disks[i].capacity);\n\n        if (!(disk = virDomainDiskByTarget(vm->def, nbd->disks[i].target))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"unable to find disk by target: %s\"),\n                           nbd->disks[i].target);\n            goto cleanup;\n        }\n\n        diskSrcPath = virDomainDiskGetSource(disk);\n\n        /* Skip disks we don't want to migrate and already existing disks. */\n        if (!qemuMigrationAnyCopyDisk(disk, nmigrate_disks, migrate_disks) ||\n            (diskSrcPath && virFileExists(diskSrcPath))) {\n            continue;\n        }\n\n        if (incremental) {\n            virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                           _(\"pre-creation of storage targets for incremental \"\n                             \"storage migration is not supported\"));\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"Proceeding with disk source %s\", NULLSTR(diskSrcPath));\n\n        if (qemuMigrationDstPrecreateDisk(conn, disk, nbd->disks[i].capacity) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnref(conn);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationAnyCopyDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "276-295",
    "snippet": "static bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "disk->src"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "disk->dst",
            "migrate_disks[i]"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationAnyCopyDisk(virDomainDiskDef const *disk,\n                         size_t nmigrate_disks, const char **migrate_disks)\n{\n    size_t i;\n\n    /* Check if the disk alias is in the list */\n    if (nmigrate_disks) {\n        for (i = 0; i < nmigrate_disks; i++) {\n            if (STREQ(disk->dst, migrate_disks[i]))\n                return true;\n        }\n        return false;\n    }\n\n    /* Default is to migrate only non-shared non-readonly disks\n     * with source */\n    return !disk->src->shared && !disk->src->readonly &&\n           !virStorageSourceIsEmpty(disk->src);\n}"
  },
  {
    "function_name": "qemuMigrationDstPrecreateDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "171-274",
    "snippet": "static int\nqemuMigrationDstPrecreateDisk(virConnectPtr conn,\n                              virDomainDiskDefPtr disk,\n                              unsigned long long capacity)\n{\n    int ret = -1;\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    char *volName = NULL, *basePath = NULL;\n    char *volStr = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *format = NULL;\n    unsigned int flags = 0;\n\n    VIR_DEBUG(\"Precreate disk type=%s\", virStorageTypeToString(disk->src->type));\n\n    switch ((virStorageType)disk->src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        if (!virDomainDiskGetSource(disk)) {\n            VIR_DEBUG(\"Dropping sourceless disk '%s'\",\n                      disk->dst);\n            return 0;\n        }\n\n        basePath = g_strdup(disk->src->path);\n\n        if (!(volName = strrchr(basePath, '/'))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed disk path: %s\"),\n                           disk->src->path);\n            goto cleanup;\n        }\n\n        *volName = '\\0';\n        volName++;\n\n        if (!(pool = virStoragePoolLookupByTargetPath(conn, basePath)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (!(pool = virStoragePoolLookupByName(conn, disk->src->srcpool->pool)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        volName = disk->src->srcpool->volume;\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        VIR_DEBUG(\"Skipping creation of network disk '%s'\",\n                  disk->dst);\n        return 0;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot precreate storage for disk type '%s'\"),\n                       virStorageTypeToString(disk->src->type));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByName(pool, volName))) {\n        VIR_DEBUG(\"Skipping creation of already existing volume of name '%s'\",\n                  volName);\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<volume>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", volName);\n    virBufferAsprintf(&buf, \"<capacity>%llu</capacity>\\n\", capacity);\n    virBufferAddLit(&buf, \"<target>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferAsprintf(&buf, \"<format type='%s'/>\\n\", format);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</target>\\n\");\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    if (!(volStr = virBufferContentAndReset(&buf))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to create volume XML\"));\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolCreateXML(pool, volStr, flags)))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(basePath);\n    VIR_FREE(volStr);\n    virObjectUnref(vol);\n    virObjectUnref(pool);\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "pool"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "volStr"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "basePath"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolCreateXML",
          "args": [
            "pool",
            "volStr",
            "flags"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolCreateXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "1498-1524",
          "snippet": "virStorageVolPtr\nvirStorageVolCreateXML(virStoragePoolPtr pool,\n                       const char *xmlDesc,\n                       unsigned int flags)\n{\n    VIR_DEBUG(\"pool=%p, xmlDesc=%s, flags=0x%x\", pool, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(pool->conn->flags, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolCreateXML) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolCreateXML(pool, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStorageVolPtr\nvirStorageVolCreateXML(virStoragePoolPtr pool,\n                       const char *xmlDesc,\n                       unsigned int flags)\n{\n    VIR_DEBUG(\"pool=%p, xmlDesc=%s, flags=0x%x\", pool, NULLSTR(xmlDesc), flags);\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(xmlDesc, error);\n    virCheckReadOnlyGoto(pool->conn->flags, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolCreateXML) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolCreateXML(pool, xmlDesc, flags);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"unable to create volume XML\")"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to create volume XML\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</volume>\\n\""
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "&buf",
            "-2"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"</target>\\n\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"<format type='%s'/>\\n\"",
            "format"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<target>\\n\""
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&buf",
            "\"<name>%s</name>\\n\"",
            "volName"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "\"<volume>\\n\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping creation of already existing volume of name '%s'\"",
            "volName"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageVolLookupByName",
          "args": [
            "pool",
            "volName"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageVolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "1326-1350",
          "snippet": "virStorageVolPtr\nvirStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    VIR_DEBUG(\"pool=%p, name=%s\", pool, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolLookupByName) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolLookupByName(pool, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStorageVolPtr\nvirStorageVolLookupByName(virStoragePoolPtr pool,\n                          const char *name)\n{\n    VIR_DEBUG(\"pool=%p, name=%s\", pool, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckStoragePoolReturn(pool, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (pool->conn->storageDriver && pool->conn->storageDriver->storageVolLookupByName) {\n        virStorageVolPtr ret;\n        ret = pool->conn->storageDriver->storageVolLookupByName(pool, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(pool->conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"cannot precreate storage for disk type '%s'\")",
            "virStorageTypeToString(disk->src->type)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "disk->src->type"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping creation of network disk '%s'\"",
            "disk->dst"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "disk->src->format"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolLookupByName",
          "args": [
            "conn",
            "disk->src->srcpool->pool"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "363-387",
          "snippet": "virStoragePoolPtr\nvirStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByName) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStoragePoolPtr\nvirStoragePoolLookupByName(virConnectPtr conn,\n                           const char *name)\n{\n    VIR_DEBUG(\"conn=%p, name=%s\", conn, NULLSTR(name));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(name, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByName) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByName(conn, name);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "disk->src->format"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStoragePoolLookupByTargetPath",
          "args": [
            "conn",
            "basePath"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virStoragePoolLookupByTargetPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt-storage.c",
          "lines": "518-542",
          "snippet": "virStoragePoolPtr\nvirStoragePoolLookupByTargetPath(virConnectPtr conn,\n                                 const char *path)\n{\n    VIR_DEBUG(\"conn=%p, path=%s\", conn, NULLSTR(path));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(path, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByTargetPath) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByTargetPath(conn, path);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"datatypes.h\"\n#include <config.h>\n\nvirStoragePoolPtr\nvirStoragePoolLookupByTargetPath(virConnectPtr conn,\n                                 const char *path)\n{\n    VIR_DEBUG(\"conn=%p, path=%s\", conn, NULLSTR(path));\n\n    virResetLastError();\n\n    virCheckConnectReturn(conn, NULL);\n    virCheckNonNullArgGoto(path, error);\n\n    if (conn->storageDriver && conn->storageDriver->storagePoolLookupByTargetPath) {\n        virStoragePoolPtr ret;\n        ret = conn->storageDriver->storagePoolLookupByTargetPath(conn, path);\n        if (!ret)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(conn);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"malformed disk path: %s\")",
            "disk->src->path"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "basePath",
            "'/'"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "disk->src->path"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dropping sourceless disk '%s'\"",
            "disk->dst"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Precreate disk type=%s\"",
            "virStorageTypeToString(disk->src->type)"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "disk->src->type"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic int\nqemuMigrationDstPrecreateDisk(virConnectPtr conn,\n                              virDomainDiskDefPtr disk,\n                              unsigned long long capacity)\n{\n    int ret = -1;\n    virStoragePoolPtr pool = NULL;\n    virStorageVolPtr vol = NULL;\n    char *volName = NULL, *basePath = NULL;\n    char *volStr = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    const char *format = NULL;\n    unsigned int flags = 0;\n\n    VIR_DEBUG(\"Precreate disk type=%s\", virStorageTypeToString(disk->src->type));\n\n    switch ((virStorageType)disk->src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        if (!virDomainDiskGetSource(disk)) {\n            VIR_DEBUG(\"Dropping sourceless disk '%s'\",\n                      disk->dst);\n            return 0;\n        }\n\n        basePath = g_strdup(disk->src->path);\n\n        if (!(volName = strrchr(basePath, '/'))) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"malformed disk path: %s\"),\n                           disk->src->path);\n            goto cleanup;\n        }\n\n        *volName = '\\0';\n        volName++;\n\n        if (!(pool = virStoragePoolLookupByTargetPath(conn, basePath)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (!(pool = virStoragePoolLookupByName(conn, disk->src->srcpool->pool)))\n            goto cleanup;\n        format = virStorageFileFormatTypeToString(disk->src->format);\n        volName = disk->src->srcpool->volume;\n        if (disk->src->format == VIR_STORAGE_FILE_QCOW2)\n            flags |= VIR_STORAGE_VOL_CREATE_PREALLOC_METADATA;\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        VIR_DEBUG(\"Skipping creation of network disk '%s'\",\n                  disk->dst);\n        return 0;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot precreate storage for disk type '%s'\"),\n                       virStorageTypeToString(disk->src->type));\n        goto cleanup;\n    }\n\n    if ((vol = virStorageVolLookupByName(pool, volName))) {\n        VIR_DEBUG(\"Skipping creation of already existing volume of name '%s'\",\n                  volName);\n        ret = 0;\n        goto cleanup;\n    }\n\n    virBufferAddLit(&buf, \"<volume>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferEscapeString(&buf, \"<name>%s</name>\\n\", volName);\n    virBufferAsprintf(&buf, \"<capacity>%llu</capacity>\\n\", capacity);\n    virBufferAddLit(&buf, \"<target>\\n\");\n    virBufferAdjustIndent(&buf, 2);\n    virBufferAsprintf(&buf, \"<format type='%s'/>\\n\", format);\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</target>\\n\");\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</volume>\\n\");\n\n    if (!(volStr = virBufferContentAndReset(&buf))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"unable to create volume XML\"));\n        goto cleanup;\n    }\n\n    if (!(vol = virStorageVolCreateXML(pool, volStr, flags)))\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(basePath);\n    VIR_FREE(volStr);\n    virObjectUnref(vol);\n    virObjectUnref(pool);\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcRestoreDomainState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "128-168",
    "snippet": "static bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to resume guest %s after failure\")",
            "vm->def->name"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to resume guest %s after failure\""
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuProcessStartCPUs",
          "args": [
            "driver",
            "vm",
            "VIR_DOMAIN_RUNNING_MIGRATION_CANCELED",
            "QEMU_ASYNC_JOB_MIGRATION_OUT"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "qemuProcessStartCPUs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_process.c",
          "lines": "3210-3259",
          "snippet": "int\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"viridentity.h\"",
            "#include \"virvsock.h\"",
            "#include \"virresctrl.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"configmake.h\"",
            "#include \"virsecret.h\"",
            "#include \"virhostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virnetdevmidonet.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virtime.h\"",
            "#include \"virprocess.h\"",
            "#include \"viruuid.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"domain_audit.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virhook.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"datatypes.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_interface.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_domain_address.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_processpriv.h\"",
            "#include \"qemu_process.h\"",
            "# include <cap-ng.h>",
            "#include <sys/utsname.h>",
            "# include <sys/cpuset.h>",
            "# include <sys/param.h>",
            "# include <linux/capability.h>",
            "#include <sys/stat.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virthreadjob.h\"\n#include \"viridentity.h\"\n#include \"virvsock.h\"\n#include \"virresctrl.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"configmake.h\"\n#include \"virsecret.h\"\n#include \"virhostdev.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virbitmap.h\"\n#include \"virnetdevmidonet.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virtime.h\"\n#include \"virprocess.h\"\n#include \"viruuid.h\"\n#include \"locking/domain_lock.h\"\n#include \"domain_nwfilter.h\"\n#include \"domain_audit.h\"\n#include \"virhostcpu.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virhook.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"datatypes.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_security.h\"\n#include \"qemu_interface.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_command.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_domain_address.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_processpriv.h\"\n#include \"qemu_process.h\"\n# include <cap-ng.h>\n#include <sys/utsname.h>\n# include <sys/cpuset.h>\n# include <sys/param.h>\n# include <linux/capability.h>\n#include <sys/stat.h>\n#include <signal.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nqemuProcessStartCPUs(virQEMUDriverPtr driver, virDomainObjPtr vm,\n                     virDomainRunningReason reason,\n                     qemuDomainAsyncJob asyncJob)\n{\n    int ret = -1;\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    /* Bring up netdevs before starting CPUs */\n    if (qemuInterfaceStartDevices(vm->def) < 0)\n       return -1;\n\n    VIR_DEBUG(\"Using lock state '%s'\", NULLSTR(priv->lockState));\n    if (virDomainLockProcessResume(driver->lockManager, cfg->uri,\n                                   vm, priv->lockState) < 0) {\n        /* Don't free priv->lockState on error, because we need\n         * to make sure we have state still present if the user\n         * tries to resume again\n         */\n        return -1;\n    }\n    VIR_FREE(priv->lockState);\n\n    priv->runningReason = reason;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto release;\n\n    ret = qemuMonitorStartCPUs(priv->mon);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        ret = -1;\n\n    if (ret < 0)\n        goto release;\n\n    /* The RESUME event handler will change the domain state with the reason\n     * saved in priv->runningReason and it will also emit corresponding domain\n     * lifecycle event.\n     */\n\n    return ret;\n\n release:\n    priv->runningReason = VIR_DOMAIN_RUNNING_UNKNOWN;\n    if (virDomainLockProcessPause(driver->lockManager, vm, &priv->lockState) < 0)\n        VIR_WARN(\"Unable to release lease on %s\", vm->def->name);\n    VIR_DEBUG(\"Preserving lock state '%s'\", NULLSTR(priv->lockState));\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Restoring pre-migration state due to migration error\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\"",
            "driver",
            "vm",
            "virDomainStateTypeToString(priv->preMigrationState)",
            "virDomainStateTypeToString(state)",
            "virDomainStateReasonToString(state, reason)"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainStateReasonToString",
          "args": [
            "state",
            "reason"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainStateReasonToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30092-30117",
          "snippet": "const char *\nvirDomainStateReasonToString(virDomainState state, int reason)\n{\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        return virDomainNostateReasonTypeToString(reason);\n    case VIR_DOMAIN_RUNNING:\n        return virDomainRunningReasonTypeToString(reason);\n    case VIR_DOMAIN_BLOCKED:\n        return virDomainBlockedReasonTypeToString(reason);\n    case VIR_DOMAIN_PAUSED:\n        return virDomainPausedReasonTypeToString(reason);\n    case VIR_DOMAIN_SHUTDOWN:\n        return virDomainShutdownReasonTypeToString(reason);\n    case VIR_DOMAIN_SHUTOFF:\n        return virDomainShutoffReasonTypeToString(reason);\n    case VIR_DOMAIN_CRASHED:\n        return virDomainCrashedReasonTypeToString(reason);\n    case VIR_DOMAIN_PMSUSPENDED:\n        return virDomainPMSuspendedReasonTypeToString(reason);\n    case VIR_DOMAIN_LAST:\n        break;\n    }\n    VIR_WARN(\"Unexpected domain state: %d\", state);\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainStateReasonToString(virDomainState state, int reason)\n{\n    switch (state) {\n    case VIR_DOMAIN_NOSTATE:\n        return virDomainNostateReasonTypeToString(reason);\n    case VIR_DOMAIN_RUNNING:\n        return virDomainRunningReasonTypeToString(reason);\n    case VIR_DOMAIN_BLOCKED:\n        return virDomainBlockedReasonTypeToString(reason);\n    case VIR_DOMAIN_PAUSED:\n        return virDomainPausedReasonTypeToString(reason);\n    case VIR_DOMAIN_SHUTDOWN:\n        return virDomainShutdownReasonTypeToString(reason);\n    case VIR_DOMAIN_SHUTOFF:\n        return virDomainShutoffReasonTypeToString(reason);\n    case VIR_DOMAIN_CRASHED:\n        return virDomainCrashedReasonTypeToString(reason);\n    case VIR_DOMAIN_PMSUSPENDED:\n        return virDomainPMSuspendedReasonTypeToString(reason);\n    case VIR_DOMAIN_LAST:\n        break;\n    }\n    VIR_WARN(\"Unexpected domain state: %d\", state);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainStateTypeToString",
          "args": [
            "state"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainStateTypeToString",
          "args": [
            "priv->preMigrationState"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "&reason"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic bool\nqemuMigrationSrcRestoreDomainState(virQEMUDriverPtr driver, virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    int reason;\n    virDomainState state = virDomainObjGetState(vm, &reason);\n    bool ret = false;\n\n    VIR_DEBUG(\"driver=%p, vm=%p, pre-mig-state=%s, state=%s, reason=%s\",\n              driver, vm,\n              virDomainStateTypeToString(priv->preMigrationState),\n              virDomainStateTypeToString(state),\n              virDomainStateReasonToString(state, reason));\n\n    if (state != VIR_DOMAIN_PAUSED ||\n        reason == VIR_DOMAIN_PAUSED_POSTCOPY_FAILED)\n        goto cleanup;\n\n    if (priv->preMigrationState == VIR_DOMAIN_RUNNING) {\n        /* This is basically the only restore possibility that's safe\n         * and we should attempt to do */\n\n        VIR_DEBUG(\"Restoring pre-migration state due to migration error\");\n\n        /* we got here through some sort of failure; start the domain again */\n        if (qemuProcessStartCPUs(driver, vm,\n                                 VIR_DOMAIN_RUNNING_MIGRATION_CANCELED,\n                                 QEMU_ASYNC_JOB_MIGRATION_OUT) < 0) {\n            /* Hm, we already know we are in error here.  We don't want to\n             * overwrite the previous error, though, so we just throw something\n             * to the logs and hope for the best */\n            VIR_ERROR(_(\"Failed to resume guest %s after failure\"), vm->def->name);\n            goto cleanup;\n        }\n        ret = true;\n    }\n\n cleanup:\n    priv->preMigrationState = VIR_DOMAIN_NOSTATE;\n    return ret;\n}"
  },
  {
    "function_name": "qemuMigrationSrcStoreDomainState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_migration.c",
    "lines": "117-125",
    "snippet": "static void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}",
    "includes": [
      "#include \"virutil.h\"",
      "#include \"virsocket.h\"",
      "#include \"virdomainsnapshotobjlist.h\"",
      "#include \"nwfilter_conf.h\"",
      "#include \"virprocess.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"virstring.h\"",
      "#include \"virhook.h\"",
      "#include \"viruri.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"rpc/virnetsocket.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"viruuid.h\"",
      "#include \"virfdstream.h\"",
      "#include \"datatypes.h\"",
      "#include \"virnetdevopenvswitch.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_audit.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_security.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"qemu_hotplug.h\"",
      "#include \"qemu_cgroup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_capabilities.h\"",
      "#include \"qemu_process.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_monitor.h\"",
      "#include \"qemu_migration_params.h\"",
      "#include \"qemu_migration_cookie.h\"",
      "#include \"qemu_migration.h\"",
      "#include <poll.h>",
      "#include <fcntl.h>",
      "#include <sys/time.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Storing pre-migration state=%d domain=%p\"",
            "priv->preMigrationState",
            "vm"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainObjGetState",
          "args": [
            "vm",
            "NULL"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainObjGetState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30038-30045",
          "snippet": "virDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainState\nvirDomainObjGetState(virDomainObjPtr dom, int *reason)\n{\n    if (reason)\n        *reason = dom->state.reason;\n\n    return dom->state.state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"nwfilter_conf.h\"\n#include \"virprocess.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virhook.h\"\n#include \"viruri.h\"\n#include \"virstoragefile.h\"\n#include \"rpc/virnetsocket.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"viruuid.h\"\n#include \"virfdstream.h\"\n#include \"datatypes.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"domain_audit.h\"\n#include \"qemu_block.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration_cookie.h\"\n#include \"qemu_migration.h\"\n#include <poll.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <config.h>\n\nstatic void\nqemuMigrationSrcStoreDomainState(virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    priv->preMigrationState = virDomainObjGetState(vm, NULL);\n\n    VIR_DEBUG(\"Storing pre-migration state=%d domain=%p\",\n              priv->preMigrationState, vm);\n}"
  }
]