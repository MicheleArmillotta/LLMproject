[
  {
    "function_name": "virHostdevUpdateActiveNVMeDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2443-2523",
    "snippet": "int\nvirHostdevUpdateActiveNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainDiskDefPtr *disks,\n                                  size_t ndisks)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    ssize_t lastGoodPCIIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevGetNVMeDeviceList(nvmeDevices, disks[i]->src, drv_name, dom_name) < 0)\n            return -1;\n    }\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n    virObjectLock(hostdev_mgr->activePCIHostdevs);\n    virObjectLock(hostdev_mgr->inactivePCIHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        /* We must restore some attributes that were lost on daemon restart. */\n        virPCIDeviceSetUnbindFromStub(actual, true);\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto rollback;\n\n        if (virPCIDeviceListAddCopy(hostdev_mgr->activePCIHostdevs, actual) < 0)\n            goto rollback;\n\n        lastGoodPCIIdx = i;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->inactivePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    while (lastGoodPCIIdx >= 0) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        virPCIDeviceListDel(hostdev_mgr->activePCIHostdevs, actual);\n\n        lastGoodPCIIdx--;\n    }\n    goto cleanup;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListDel",
          "args": [
            "hostdev_mgr->activePCIHostdevs",
            "actual"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1663-1668",
          "snippet": "void\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pciDevices",
            "i"
          ],
          "line": 2516
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListDel",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "temp"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "204-223",
          "snippet": "int\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListGet",
          "args": [
            "nvmeDevices",
            "lastGoodNVMeIdx"
          ],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "226-231",
          "snippet": "virNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs"
          ],
          "line": 2504
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListAddCopy",
          "args": [
            "hostdev_mgr->activePCIHostdevs",
            "actual"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUsedBy",
          "args": [
            "actual",
            "drv_name",
            "dom_name"
          ],
          "line": 2491
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1544-1555",
          "snippet": "int\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUnbindFromStub",
          "args": [
            "actual",
            "true"
          ],
          "line": 2490
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1514-1518",
          "snippet": "void\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pciDevices"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListAdd",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "temp"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "180-201",
          "snippet": "int\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCount",
          "args": [
            "nvmeDevices"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "173-177",
          "snippet": "size_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nsize_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCreateDetachList",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "nvmeDevices"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCreateDetachList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "323-365",
          "snippet": "virPCIDeviceListPtr\nvirNVMeDeviceListCreateDetachList(virNVMeDeviceListPtr activeList,\n                                  virNVMeDeviceListPtr toDetachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toDetachList->count; i++) {\n        const virNVMeDevice *d = toDetachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        /* If there is a NVMe device with the same PCI address on\n         * the activeList, the device is already detached. */\n        if (virNVMeDeviceListLookupByPCIAddress(activeList, &d->address))\n            continue;\n\n        /* It may happen that we want to detach two namespaces\n         * from the same NVMe device. This will be represented as\n         * two different instances of virNVMeDevice, but\n         * obviously we want to put the PCI device on the detach\n         * list only once. */\n        if (virPCIDeviceListFindByIDs(pciDevices,\n                                      d->address.domain,\n                                      d->address.bus,\n                                      d->address.slot,\n                                      d->address.function))\n            continue;\n\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirPCIDeviceListPtr\nvirNVMeDeviceListCreateDetachList(virNVMeDeviceListPtr activeList,\n                                  virNVMeDeviceListPtr toDetachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toDetachList->count; i++) {\n        const virNVMeDevice *d = toDetachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        /* If there is a NVMe device with the same PCI address on\n         * the activeList, the device is already detached. */\n        if (virNVMeDeviceListLookupByPCIAddress(activeList, &d->address))\n            continue;\n\n        /* It may happen that we want to detach two namespaces\n         * from the same NVMe device. This will be represented as\n         * two different instances of virNVMeDevice, but\n         * obviously we want to put the PCI device on the detach\n         * list only once. */\n        if (virPCIDeviceListFindByIDs(pciDevices,\n                                      d->address.domain,\n                                      d->address.bus,\n                                      d->address.slot,\n                                      d->address.function))\n            continue;\n\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "hostdev_mgr->inactivePCIHostdevs"
          ],
          "line": 2471
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetNVMeDeviceList",
          "args": [
            "nvmeDevices",
            "disks[i]->src",
            "drv_name",
            "dom_name"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetNVMeDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2199-2226",
          "snippet": "static int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListNew",
          "args": [],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "145-157",
          "snippet": "virNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNVMeDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nstatic virClassPtr virNVMeDeviceListClass;\n\nvirNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainDiskDefPtr *disks,\n                                  size_t ndisks)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    ssize_t lastGoodPCIIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevGetNVMeDeviceList(nvmeDevices, disks[i]->src, drv_name, dom_name) < 0)\n            return -1;\n    }\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n    virObjectLock(hostdev_mgr->activePCIHostdevs);\n    virObjectLock(hostdev_mgr->inactivePCIHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        /* We must restore some attributes that were lost on daemon restart. */\n        virPCIDeviceSetUnbindFromStub(actual, true);\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto rollback;\n\n        if (virPCIDeviceListAddCopy(hostdev_mgr->activePCIHostdevs, actual) < 0)\n            goto rollback;\n\n        lastGoodPCIIdx = i;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->inactivePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activePCIHostdevs);\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    while (lastGoodPCIIdx >= 0) {\n        virPCIDevicePtr actual = virPCIDeviceListGet(pciDevices, i);\n\n        virPCIDeviceListDel(hostdev_mgr->activePCIHostdevs, actual);\n\n        lastGoodPCIIdx--;\n    }\n    goto cleanup;\n}"
  },
  {
    "function_name": "virHostdevReAttachNVMeDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2417-2440",
    "snippet": "int\nvirHostdevReAttachNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainDiskDefPtr *disks,\n                              size_t ndisks)\n{\n    size_t i;\n    int ret = 0;\n\n    /* Contrary to virHostdevPrepareNVMeDevices, this is a best\n     * effort approach. Just iterate over all disks and try to\n     * reattach them. Don't stop at the first failure. */\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name,\n                                            dom_name, disks[i]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[i]->dst);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to reattach NVMe for disk target: %s\")",
            "disks[i]->dst"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to reattach NVMe for disk target: %s\""
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachOneNVMeDevice",
          "args": [
            "hostdev_mgr",
            "drv_name",
            "dom_name",
            "disks[i]->src"
          ],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachOneNVMeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2373-2414",
          "snippet": "int\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainDiskDefPtr *disks,\n                              size_t ndisks)\n{\n    size_t i;\n    int ret = 0;\n\n    /* Contrary to virHostdevPrepareNVMeDevices, this is a best\n     * effort approach. Just iterate over all disks and try to\n     * reattach them. Don't stop at the first failure. */\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name,\n                                            dom_name, disks[i]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[i]->dst);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevReAttachOneNVMeDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2373-2414",
    "snippet": "int\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs"
          ],
          "line": 2412
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListDel",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "temp"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "204-223",
          "snippet": "int\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListGet",
          "args": [
            "nvmeDevices",
            "i"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "226-231",
          "snippet": "virNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCount",
          "args": [
            "nvmeDevices"
          ],
          "line": 2403
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "173-177",
          "snippet": "size_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nsize_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachPCIDevicesImpl",
          "args": [
            "hostdev_mgr",
            "drv_name",
            "dom_name",
            "pciDevices",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachPCIDevicesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "964-1068",
          "snippet": "static void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCreateReAttachList",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "nvmeDevices"
          ],
          "line": 2395
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCreateReAttachList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "389-447",
          "snippet": "virPCIDeviceListPtr\nvirNVMeDeviceListCreateReAttachList(virNVMeDeviceListPtr activeList,\n                                    virNVMeDeviceListPtr toReAttachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toReAttachList->count; i++) {\n        const virNVMeDevice *d = toReAttachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n        size_t nused = 0;\n\n        /* Check if there is any other NVMe device with the same PCI address as\n         * @d. To simplify this, let's just count how many NVMe devices with\n         * the same PCI address there are on the @activeList. */\n        for (i = 0; i < activeList->count; i++) {\n            virNVMeDevicePtr other = activeList->devs[i];\n\n            if (!virPCIDeviceAddressEqual(&d->address, &other->address))\n                continue;\n\n            nused++;\n        }\n\n        /* Now, the following cases can happen:\n         * nused > 1  -> there are other NVMe device active, do NOT detach it\n         * nused == 1 -> we've found only @d on the @activeList, detach it\n         * nused == 0 -> huh, wait, what? @d is NOT on the @active list, how can\n         *               we reattach it?\n         */\n\n        if (nused == 0) {\n            /* Shouldn't happen (TM) */\n            g_autofree char *addrStr = virPCIDeviceAddressAsString(&d->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"NVMe device %s namespace %u not found\"),\n                           NULLSTR(addrStr), d->namespace);\n            return NULL;\n        } else if (nused > 1) {\n            /* NVMe device is still in use */\n            continue;\n        }\n\n        /* nused == 1 -> detach the device */\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirPCIDeviceListPtr\nvirNVMeDeviceListCreateReAttachList(virNVMeDeviceListPtr activeList,\n                                    virNVMeDeviceListPtr toReAttachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toReAttachList->count; i++) {\n        const virNVMeDevice *d = toReAttachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n        size_t nused = 0;\n\n        /* Check if there is any other NVMe device with the same PCI address as\n         * @d. To simplify this, let's just count how many NVMe devices with\n         * the same PCI address there are on the @activeList. */\n        for (i = 0; i < activeList->count; i++) {\n            virNVMeDevicePtr other = activeList->devs[i];\n\n            if (!virPCIDeviceAddressEqual(&d->address, &other->address))\n                continue;\n\n            nused++;\n        }\n\n        /* Now, the following cases can happen:\n         * nused > 1  -> there are other NVMe device active, do NOT detach it\n         * nused == 1 -> we've found only @d on the @activeList, detach it\n         * nused == 0 -> huh, wait, what? @d is NOT on the @active list, how can\n         *               we reattach it?\n         */\n\n        if (nused == 0) {\n            /* Shouldn't happen (TM) */\n            g_autofree char *addrStr = virPCIDeviceAddressAsString(&d->address);\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"NVMe device %s namespace %u not found\"),\n                           NULLSTR(addrStr), d->namespace);\n            return NULL;\n        } else if (nused > 1) {\n            /* NVMe device is still in use */\n            continue;\n        }\n\n        /* nused == 1 -> detach the device */\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetNVMeDeviceList",
          "args": [
            "nvmeDevices",
            "src",
            "drv_name",
            "dom_name"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetNVMeDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2199-2226",
          "snippet": "static int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListNew",
          "args": [],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "145-157",
          "snippet": "virNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNVMeDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nstatic virClassPtr virNVMeDeviceListClass;\n\nvirNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevPrepareNVMeDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2338-2370",
    "snippet": "int\nvirHostdevPrepareNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    size_t i;\n    ssize_t lastGoodDiskIdx = -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevPrepareOneNVMeDevice(hostdev_mgr, drv_name,\n                                           dom_name, disks[i]->src) < 0)\n            goto rollback;\n\n        lastGoodDiskIdx = i;\n    }\n\n    return 0;\n\n rollback:\n    while (lastGoodDiskIdx >= 0) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name, dom_name,\n                                            disks[lastGoodDiskIdx]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[lastGoodDiskIdx]->dst);\n        }\n\n        lastGoodDiskIdx--;\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to reattach NVMe for disk target: %s\")",
            "disks[lastGoodDiskIdx]->dst"
          ],
          "line": 2362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to reattach NVMe for disk target: %s\""
          ],
          "line": 2362
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachOneNVMeDevice",
          "args": [
            "hostdev_mgr",
            "drv_name",
            "dom_name",
            "disks[lastGoodDiskIdx]->src"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachOneNVMeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2373-2414",
          "snippet": "int\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevReAttachOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    if (!(pciDevices = virNVMeDeviceListCreateReAttachList(hostdev_mgr->activeNVMeHostdevs,\n                                                           nvmeDevices)))\n        goto cleanup;\n\n    virHostdevReAttachPCIDevicesImpl(hostdev_mgr,\n                                     drv_name, dom_name, pciDevices,\n                                     NULL, 0, NULL);\n\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        virNVMeDevicePtr temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPrepareOneNVMeDevice",
          "args": [
            "hostdev_mgr",
            "drv_name",
            "dom_name",
            "disks[i]->src"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareOneNVMeDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2229-2335",
          "snippet": "int\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareNVMeDevices(virHostdevManagerPtr hostdev_mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainDiskDefPtr *disks,\n                             size_t ndisks)\n{\n    size_t i;\n    ssize_t lastGoodDiskIdx = -1;\n\n    for (i = 0; i < ndisks; i++) {\n        if (virHostdevPrepareOneNVMeDevice(hostdev_mgr, drv_name,\n                                           dom_name, disks[i]->src) < 0)\n            goto rollback;\n\n        lastGoodDiskIdx = i;\n    }\n\n    return 0;\n\n rollback:\n    while (lastGoodDiskIdx >= 0) {\n        if (virHostdevReAttachOneNVMeDevice(hostdev_mgr, drv_name, dom_name,\n                                            disks[lastGoodDiskIdx]->src) < 0) {\n            VIR_ERROR(_(\"Failed to reattach NVMe for disk target: %s\"),\n                      disks[lastGoodDiskIdx]->dst);\n        }\n\n        lastGoodDiskIdx--;\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virHostdevPrepareOneNVMeDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2229-2335",
    "snippet": "int\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNVMeDeviceListDel",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "temp"
          ],
          "line": 2330
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "204-223",
          "snippet": "int\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListDel(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    ssize_t idx;\n    virNVMeDevicePtr tmp = NULL;\n\n    if ((idx = virNVMeDeviceListLookupIndex(list, dev)) < 0) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&dev->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u not found\"),\n                       NULLSTR(addrStr), dev->namespace);\n        return -1;\n    }\n\n    tmp = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    virNVMeDeviceFree(tmp);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListGet",
          "args": [
            "nvmeDevices",
            "lastGoodNVMeIdx"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "226-231",
          "snippet": "virNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirNVMeDevicePtr\nvirNVMeDeviceListGet(virNVMeDeviceListPtr list,\n                     size_t i)\n{\n    return i < list->count ? list->devs[i] : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPreparePCIDevicesImpl",
          "args": [
            "hostdev_mgr",
            "drv_name",
            "dom_name",
            "NULL",
            "pciDevices",
            "NULL",
            "0",
            "pciFlags"
          ],
          "line": 2316
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPreparePCIDevicesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "677-939",
          "snippet": "static int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListAdd",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "temp"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "180-201",
          "snippet": "int\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCount",
          "args": [
            "nvmeDevices"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "173-177",
          "snippet": "size_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nsize_t\nvirNVMeDeviceListCount(const virNVMeDeviceList *list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\"",
            "virPCIDeviceGetName(pci)",
            "NULLSTR(drvName)"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "drvName"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "pci"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "drvName",
            "\"nvme\""
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIStubDriverTypeFromString",
          "args": [
            "drvName"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetDriverPathAndName",
          "args": [
            "pci",
            "&drvPath",
            "&drvName"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetDriverPathAndName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "236-276",
          "snippet": "int\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pciDevices",
            "i"
          ],
          "line": 2284
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pciDevices"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListCreateDetachList",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "nvmeDevices"
          ],
          "line": 2278
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListCreateDetachList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "323-365",
          "snippet": "virPCIDeviceListPtr\nvirNVMeDeviceListCreateDetachList(virNVMeDeviceListPtr activeList,\n                                  virNVMeDeviceListPtr toDetachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toDetachList->count; i++) {\n        const virNVMeDevice *d = toDetachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        /* If there is a NVMe device with the same PCI address on\n         * the activeList, the device is already detached. */\n        if (virNVMeDeviceListLookupByPCIAddress(activeList, &d->address))\n            continue;\n\n        /* It may happen that we want to detach two namespaces\n         * from the same NVMe device. This will be represented as\n         * two different instances of virNVMeDevice, but\n         * obviously we want to put the PCI device on the detach\n         * list only once. */\n        if (virPCIDeviceListFindByIDs(pciDevices,\n                                      d->address.domain,\n                                      d->address.bus,\n                                      d->address.slot,\n                                      d->address.function))\n            continue;\n\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirPCIDeviceListPtr\nvirNVMeDeviceListCreateDetachList(virNVMeDeviceListPtr activeList,\n                                  virNVMeDeviceListPtr toDetachList)\n{\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    size_t i;\n\n    if (!(pciDevices = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < toDetachList->count; i++) {\n        const virNVMeDevice *d = toDetachList->devs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        /* If there is a NVMe device with the same PCI address on\n         * the activeList, the device is already detached. */\n        if (virNVMeDeviceListLookupByPCIAddress(activeList, &d->address))\n            continue;\n\n        /* It may happen that we want to detach two namespaces\n         * from the same NVMe device. This will be represented as\n         * two different instances of virNVMeDevice, but\n         * obviously we want to put the PCI device on the detach\n         * list only once. */\n        if (virPCIDeviceListFindByIDs(pciDevices,\n                                      d->address.domain,\n                                      d->address.bus,\n                                      d->address.slot,\n                                      d->address.function))\n            continue;\n\n        if (!(pci = virNVMeDeviceCreatePCIDevice(d)))\n            return NULL;\n\n        if (virPCIDeviceListAdd(pciDevices, pci) < 0)\n            return NULL;\n\n        /* avoid freeing the device */\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pciDevices);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"NVMe device %s already in use by driver %s domain %s\")",
            "NULLSTR(addrStr)",
            "actual_drvname",
            "actual_domname"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "addrStr"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"NVMe device %s already in use by driver %s domain %s\""
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressAsString",
          "args": [
            "addr"
          ],
          "line": 2270
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressAsString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1351-1362",
          "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceAddressGet",
          "args": [
            "dev"
          ],
          "line": 2269
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceAddressGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "110-114",
          "snippet": "const virPCIDeviceAddress *\nvirNVMeDeviceAddressGet(const virNVMeDevice *dev)\n{\n    return &dev->address;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nconst virPCIDeviceAddress *\nvirNVMeDeviceAddressGet(const virNVMeDevice *dev)\n{\n    return &dev->address;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceUsedByGet",
          "args": [
            "temp",
            "&actual_drvname",
            "&actual_domname"
          ],
          "line": 2268
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceUsedByGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "125-132",
          "snippet": "void\nvirNVMeDeviceUsedByGet(const virNVMeDevice *dev,\n                       const char **drv,\n                       const char **dom)\n{\n    *drv = dev->drvname;\n    *dom = dev->domname;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvoid\nvirNVMeDeviceUsedByGet(const virNVMeDevice *dev,\n                       const char **drv,\n                       const char **dom)\n{\n    *drv = dev->drvname;\n    *dom = dev->domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListLookup",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs",
            "dev"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListLookupByPCIAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "268-285",
          "snippet": "static virNVMeDevicePtr\nvirNVMeDeviceListLookupByPCIAddress(virNVMeDeviceListPtr list,\n                                    const virPCIDeviceAddress *address)\n{\n    size_t i;\n\n    if (!list)\n        return NULL;\n\n    for (i = 0; i < list->count; i++) {\n        virNVMeDevicePtr other = list->devs[i];\n\n        if (virPCIDeviceAddressEqual(address, &other->address))\n            return other;\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nstatic virNVMeDevicePtr\nvirNVMeDeviceListLookupByPCIAddress(virNVMeDeviceListPtr list,\n                                    const virPCIDeviceAddress *address)\n{\n    size_t i;\n\n    if (!list)\n        return NULL;\n\n    for (i = 0; i < list->count; i++) {\n        virNVMeDevicePtr other = list->devs[i];\n\n        if (virPCIDeviceAddressEqual(address, &other->address))\n            return other;\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "hostdev_mgr->activeNVMeHostdevs"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetNVMeDeviceList",
          "args": [
            "nvmeDevices",
            "src",
            "drv_name",
            "dom_name"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetNVMeDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "2199-2226",
          "snippet": "static int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListNew",
          "args": [],
          "line": 2243
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "145-157",
          "snippet": "virNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNVMeDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nstatic virClassPtr virNVMeDeviceListClass;\n\nvirNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareOneNVMeDevice(virHostdevManagerPtr hostdev_mgr,\n                               const char *drv_name,\n                               const char *dom_name,\n                               virStorageSourcePtr src)\n{\n    g_autoptr(virNVMeDeviceList) nvmeDevices = NULL;\n    g_autoptr(virPCIDeviceList) pciDevices = NULL;\n    const unsigned int pciFlags = 0;\n    virNVMeDevicePtr temp = NULL;\n    size_t i;\n    ssize_t lastGoodNVMeIdx = -1;\n    int ret = -1;\n\n    if (!(nvmeDevices = virNVMeDeviceListNew()))\n        return -1;\n\n    if (virHostdevGetNVMeDeviceList(nvmeDevices, src, drv_name, dom_name) < 0)\n        return -1;\n\n    if (virNVMeDeviceListCount(nvmeDevices) == 0)\n        return 0;\n\n    virObjectLock(hostdev_mgr->activeNVMeHostdevs);\n\n    /* Firstly, let's check if all devices are free */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        const virNVMeDevice *dev = virNVMeDeviceListGet(nvmeDevices, i);\n        const virPCIDeviceAddress *addr = NULL;\n        g_autofree char *addrStr = NULL;\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n\n        temp = virNVMeDeviceListLookup(hostdev_mgr->activeNVMeHostdevs, dev);\n\n        /* Not on the list means not used */\n        if (!temp)\n            continue;\n\n        virNVMeDeviceUsedByGet(temp, &actual_drvname, &actual_domname);\n        addr = virNVMeDeviceAddressGet(dev);\n        addrStr = virPCIDeviceAddressAsString(addr);\n\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"NVMe device %s already in use by driver %s domain %s\"),\n                       NULLSTR(addrStr), actual_drvname, actual_domname);\n        goto cleanup;\n    }\n\n    if (!(pciDevices = virNVMeDeviceListCreateDetachList(hostdev_mgr->activeNVMeHostdevs,\n                                                         nvmeDevices)))\n        goto cleanup;\n\n    /* Let's check if all PCI devices are NVMe disks. */\n    for (i = 0; i < virPCIDeviceListCount(pciDevices); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pciDevices, i);\n        g_autofree char *drvPath = NULL;\n        g_autofree char *drvName = NULL;\n        int stub = VIR_PCI_STUB_DRIVER_NONE;\n\n        if (virPCIDeviceGetDriverPathAndName(pci, &drvPath, &drvName) < 0)\n            goto cleanup;\n\n        if (drvName)\n            stub = virPCIStubDriverTypeFromString(drvName);\n\n        if (stub == VIR_PCI_STUB_DRIVER_VFIO ||\n            STREQ_NULLABLE(drvName, \"nvme\"))\n            continue;\n\n        VIR_WARN(\"Suspicious NVMe disk assignment. PCI device \"\n                 \"%s is not an NVMe disk, it has %s driver\",\n                 virPCIDeviceGetName(pci), NULLSTR(drvName));\n    }\n\n    /* This looks like a good opportunity to merge inactive NVMe devices onto\n     * the active list. This, however, means that if something goes wrong we\n     * have to perform a rollback before returning. */\n    for (i = 0; i < virNVMeDeviceListCount(nvmeDevices); i++) {\n        temp = virNVMeDeviceListGet(nvmeDevices, i);\n\n        if (virNVMeDeviceListAdd(hostdev_mgr->activeNVMeHostdevs, temp) < 0)\n            goto rollback;\n\n        lastGoodNVMeIdx = i;\n    }\n\n    if (virHostdevPreparePCIDevicesImpl(hostdev_mgr,\n                                        drv_name, dom_name, NULL,\n                                        pciDevices, NULL, 0, pciFlags) < 0)\n        goto rollback;\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(hostdev_mgr->activeNVMeHostdevs);\n    return ret;\n\n rollback:\n    while (lastGoodNVMeIdx >= 0) {\n        temp = virNVMeDeviceListGet(nvmeDevices, lastGoodNVMeIdx);\n\n        virNVMeDeviceListDel(hostdev_mgr->activeNVMeHostdevs, temp);\n\n        lastGoodNVMeIdx--;\n    }\n    goto cleanup;\n}"
  },
  {
    "function_name": "virHostdevGetNVMeDeviceList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2199-2226",
    "snippet": "static int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNVMeDeviceListAdd",
          "args": [
            "nvmeDevices",
            "dev"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "180-201",
          "snippet": "int\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nint\nvirNVMeDeviceListAdd(virNVMeDeviceListPtr list,\n                     const virNVMeDevice *dev)\n{\n    virNVMeDevicePtr tmp;\n\n    if ((tmp = virNVMeDeviceListLookup(list, dev))) {\n        g_autofree char *addrStr = virPCIDeviceAddressAsString(&tmp->address);\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NVMe device %s namespace %u is already on the list\"),\n                       NULLSTR(addrStr), tmp->namespace);\n        return -1;\n    }\n\n    if (!(tmp = virNVMeDeviceCopy(dev)) ||\n        VIR_APPEND_ELEMENT(list->devs, list->count, tmp) < 0) {\n        virNVMeDeviceFree(tmp);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceUsedBySet",
          "args": [
            "dev",
            "drv_name",
            "dom_name"
          ],
          "line": 2219
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceUsedBySet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "135-142",
          "snippet": "void\nvirNVMeDeviceUsedBySet(virNVMeDevicePtr dev,\n                       const char *drv,\n                       const char *dom)\n{\n    dev->drvname = g_strdup(drv);\n    dev->domname = g_strdup(dom);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvoid\nvirNVMeDeviceUsedBySet(virNVMeDevicePtr dev,\n                       const char *drv,\n                       const char *dom)\n{\n    dev->drvname = g_strdup(drv);\n    dev->domname = g_strdup(dom);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceNew",
          "args": [
            "&srcNVMe->pciAddr",
            "srcNVMe->namespace",
            "srcNVMe->managed"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "65-79",
          "snippet": "virNVMeDevicePtr\nvirNVMeDeviceNew(const virPCIDeviceAddress *address,\n                 unsigned long namespace,\n                 bool managed)\n{\n    virNVMeDevicePtr dev = NULL;\n\n    dev = g_new0(virNVMeDevice, 1);\n\n    virPCIDeviceAddressCopy(&dev->address, address);\n    dev->namespace = namespace;\n    dev->managed = managed;\n\n    return dev;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nvirNVMeDevicePtr\nvirNVMeDeviceNew(const virPCIDeviceAddress *address,\n                 unsigned long namespace,\n                 bool managed)\n{\n    virNVMeDevicePtr dev = NULL;\n\n    dev = g_new0(virNVMeDevice, 1);\n\n    virPCIDeviceAddressCopy(&dev->address, address);\n    dev->namespace = namespace;\n    dev->managed = managed;\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n"
          ],
          "line": 2207
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevGetNVMeDeviceList(virNVMeDeviceListPtr nvmeDevices,\n                            virStorageSourcePtr src,\n                            const char *drv_name,\n                            const char *dom_name)\n{\n    virStorageSourcePtr n;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        g_autoptr(virNVMeDevice) dev = NULL;\n        const virStorageSourceNVMeDef *srcNVMe = n->nvme;\n\n        if (n->type != VIR_STORAGE_TYPE_NVME)\n            continue;\n\n        if (!(dev = virNVMeDeviceNew(&srcNVMe->pciAddr,\n                                     srcNVMe->namespace,\n                                     srcNVMe->managed)))\n            return -1;\n\n        virNVMeDeviceUsedBySet(dev, drv_name, dom_name);\n\n        if (virNVMeDeviceListAdd(nvmeDevices, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevUpdateActiveDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2162-2196",
    "snippet": "int\nvirHostdevUpdateActiveDomainDevices(virHostdevManagerPtr mgr,\n                                    const char *driver,\n                                    virDomainDefPtr def,\n                                    unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevUpdateActivePCIDevices(mgr,\n                                             def->hostdevs,\n                                             def->nhostdevs,\n                                             driver, def->name) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevUpdateActiveUSBDevices(mgr,\n                                             def->hostdevs,\n                                             def->nhostdevs,\n                                             driver, def->name) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevUpdateActiveSCSIDevices(mgr,\n                                              def->hostdevs,\n                                              def->nhostdevs,\n                                              driver, def->name) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveSCSIDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "driver",
            "def->name"
          ],
          "line": 2188
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1218-1254",
          "snippet": "int\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveUSBDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "driver",
            "def->name"
          ],
          "line": 2180
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1145-1187",
          "snippet": "int\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevUpdateActivePCIDevices",
          "args": [
            "mgr",
            "def->hostdevs",
            "def->nhostdevs",
            "driver",
            "def->name"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActivePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1099-1143",
          "snippet": "int\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveDomainDevices(virHostdevManagerPtr mgr,\n                                    const char *driver,\n                                    virDomainDefPtr def,\n                                    unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevUpdateActivePCIDevices(mgr,\n                                             def->hostdevs,\n                                             def->nhostdevs,\n                                             driver, def->name) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevUpdateActiveUSBDevices(mgr,\n                                             def->hostdevs,\n                                             def->nhostdevs,\n                                             driver, def->name) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevUpdateActiveSCSIDevices(mgr,\n                                              def->hostdevs,\n                                              def->nhostdevs,\n                                              driver, def->name) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevReAttachDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2135-2160",
    "snippet": "void\nvirHostdevReAttachDomainDevices(virHostdevManagerPtr mgr,\n                                const char *driver,\n                                virDomainDefPtr def,\n                                unsigned int flags,\n                                const char *oldStateDir)\n{\n    if (!def->nhostdevs || !mgr)\n        return;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        virHostdevReAttachPCIDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs,\n                                     oldStateDir);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        virHostdevReAttachUSBDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        virHostdevReAttachSCSIDevices(mgr, driver, def->name,\n                                      def->hostdevs, def->nhostdevs);\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachSCSIDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1872-1899",
          "snippet": "void\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachUSBDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1772-1830",
          "snippet": "void\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachPCIDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs",
            "oldStateDir"
          ],
          "line": 2146
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1074-1096",
          "snippet": "void\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachDomainDevices(virHostdevManagerPtr mgr,\n                                const char *driver,\n                                virDomainDefPtr def,\n                                unsigned int flags,\n                                const char *oldStateDir)\n{\n    if (!def->nhostdevs || !mgr)\n        return;\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        virHostdevReAttachPCIDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs,\n                                     oldStateDir);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        virHostdevReAttachUSBDevices(mgr, driver, def->name,\n                                     def->hostdevs, def->nhostdevs);\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        virHostdevReAttachSCSIDevices(mgr, driver, def->name,\n                                      def->hostdevs, def->nhostdevs);\n    }\n}"
  },
  {
    "function_name": "virHostdevPrepareDomainDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2092-2130",
    "snippet": "int\nvirHostdevPrepareDomainDevices(virHostdevManagerPtr mgr,\n                               const char *driver,\n                               virDomainDefPtr def,\n                               unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (!mgr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no host device manager defined\"));\n        return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevPreparePCIDevices(mgr, driver,\n                                        def->name, def->uuid,\n                                        def->hostdevs,\n                                        def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevPrepareUSBDevices(mgr, driver, def->name,\n                                        def->hostdevs, def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevPrepareSCSIDevices(mgr, driver, def->name,\n                                         def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virHostdevManagerPtr manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPrepareSCSIDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareSCSIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1534-1629",
          "snippet": "int\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPrepareUSBDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->hostdevs",
            "def->nhostdevs",
            "flags"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1439-1505",
          "snippet": "int\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPreparePCIDevices",
          "args": [
            "mgr",
            "driver",
            "def->name",
            "def->uuid",
            "def->hostdevs",
            "def->nhostdevs",
            "flags"
          ],
          "line": 2108
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPreparePCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "942-961",
          "snippet": "int\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no host device manager defined\")"
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no host device manager defined\""
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virHostdevManagerPtr manager;\n\nint\nvirHostdevPrepareDomainDevices(virHostdevManagerPtr mgr,\n                               const char *driver,\n                               virDomainDefPtr def,\n                               unsigned int flags)\n{\n    if (!def->nhostdevs)\n        return 0;\n\n    if (!mgr) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"no host device manager defined\"));\n        return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_PCI) {\n        if (virHostdevPreparePCIDevices(mgr, driver,\n                                        def->name, def->uuid,\n                                        def->hostdevs,\n                                        def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_USB) {\n        if (virHostdevPrepareUSBDevices(mgr, driver, def->name,\n                                        def->hostdevs, def->nhostdevs,\n                                        flags) < 0)\n            return -1;\n    }\n\n    if (flags & VIR_HOSTDEV_SP_SCSI) {\n        if (virHostdevPrepareSCSIDevices(mgr, driver, def->name,\n                                         def->hostdevs, def->nhostdevs) < 0)\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevPCINodeDeviceReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2073-2090",
    "snippet": "int\nvirHostdevPCINodeDeviceReset(virHostdevManagerPtr mgr,\n                             virPCIDevicePtr pci)\n{\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n    if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                          mgr->inactivePCIHostdevs) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activePCIHostdevs"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReset",
          "args": [
            "pci",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "909-990",
          "snippet": "int\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2080
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPCINodeDeviceReset(virHostdevManagerPtr mgr,\n                             virPCIDevicePtr pci)\n{\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n    if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                          mgr->inactivePCIHostdevs) < 0)\n        goto out;\n\n    ret = 0;\n out:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevPCINodeDeviceReAttach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2043-2071",
    "snippet": "int\nvirHostdevPCINodeDeviceReAttach(virHostdevManagerPtr mgr,\n                                virPCIDevicePtr pci)\n{\n    struct virHostdevIsPCINodeDeviceUsedData data = {mgr, NULL, NULL, false};\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    if (virHostdevIsPCINodeDeviceUsed(virPCIDeviceGetAddress(pci), &data))\n        goto cleanup;\n\n    virPCIDeviceSetUnbindFromStub(pci, true);\n    virPCIDeviceSetRemoveSlot(pci, true);\n    virPCIDeviceSetReprobe(pci, true);\n\n    if (virPCIDeviceReattach(pci, mgr->activePCIHostdevs,\n                             mgr->inactivePCIHostdevs) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activePCIHostdevs"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReattach",
          "args": [
            "pci",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2060
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1232-1253",
          "snippet": "int\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetReprobe",
          "args": [
            "pci",
            "true"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetReprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1538-1542",
          "snippet": "void\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetRemoveSlot",
          "args": [
            "pci",
            "true"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetRemoveSlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1526-1530",
          "snippet": "void\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUnbindFromStub",
          "args": [
            "pci",
            "true"
          ],
          "line": 2056
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1514-1518",
          "snippet": "void\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINodeDeviceUsed",
          "args": [
            "virPCIDeviceGetAddress(pci)",
            "&data"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINodeDeviceUsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "79-111",
          "snippet": "static int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetAddress",
          "args": [
            "pci"
          ],
          "line": 2053
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1461-1465",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPCINodeDeviceReAttach(virHostdevManagerPtr mgr,\n                                virPCIDevicePtr pci)\n{\n    struct virHostdevIsPCINodeDeviceUsedData data = {mgr, NULL, NULL, false};\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    if (virHostdevIsPCINodeDeviceUsed(virPCIDeviceGetAddress(pci), &data))\n        goto cleanup;\n\n    virPCIDeviceSetUnbindFromStub(pci, true);\n    virPCIDeviceSetRemoveSlot(pci, true);\n    virPCIDeviceSetReprobe(pci, true);\n\n    if (virPCIDeviceReattach(pci, mgr->activePCIHostdevs,\n                             mgr->inactivePCIHostdevs) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevPCINodeDeviceDetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "2017-2041",
    "snippet": "int\nvirHostdevPCINodeDeviceDetach(virHostdevManagerPtr mgr,\n                              virPCIDevicePtr pci)\n{\n    struct virHostdevIsPCINodeDeviceUsedData data = {mgr, NULL, NULL, false};\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    if (virHostdevIsPCINodeDeviceUsed(virPCIDeviceGetAddress(pci), &data))\n        goto cleanup;\n\n    if (virPCIDeviceDetach(pci, mgr->activePCIHostdevs,\n                           mgr->inactivePCIHostdevs) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activePCIHostdevs"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceDetach",
          "args": [
            "pci",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceDetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1199-1226",
          "snippet": "int\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINodeDeviceUsed",
          "args": [
            "virPCIDeviceGetAddress(pci)",
            "&data"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINodeDeviceUsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "79-111",
          "snippet": "static int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetAddress",
          "args": [
            "pci"
          ],
          "line": 2027
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1461-1465",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 2025
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPCINodeDeviceDetach(virHostdevManagerPtr mgr,\n                              virPCIDevicePtr pci)\n{\n    struct virHostdevIsPCINodeDeviceUsedData data = {mgr, NULL, NULL, false};\n    int ret = -1;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    if (virHostdevIsPCINodeDeviceUsed(virPCIDeviceGetAddress(pci), &data))\n        goto cleanup;\n\n    if (virPCIDeviceDetach(pci, mgr->activePCIHostdevs,\n                           mgr->inactivePCIHostdevs) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    virObjectUnlock(mgr->activePCIHostdevs);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevReAttachMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1968-2015",
    "snippet": "void\nvirHostdevReAttachMediatedDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    const char *used_by_drvname = NULL;\n    const char *used_by_domname = NULL;\n    size_t i;\n\n    if (nhostdevs == 0)\n        return;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virMediatedDevice) mdev = NULL;\n        virMediatedDevicePtr tmp;\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr,\n                                          mdevsrc->model)))\n            continue;\n\n        /* Remove from the list only mdevs assigned to @drv_name/@dom_name */\n\n        tmp = virMediatedDeviceListFind(mgr->activeMediatedHostdevs, mdev);\n\n        /* skip inactive devices */\n        if (!tmp)\n            continue;\n\n        virMediatedDeviceGetUsedBy(tmp, &used_by_drvname, &used_by_domname);\n        if (STREQ_NULLABLE(drv_name, used_by_drvname) &&\n            STREQ_NULLABLE(dom_name, used_by_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeMediatedHostdevs\",\n                      mdevsrc->uuidstr, dom_name);\n            virMediatedDeviceListDel(mgr->activeMediatedHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeMediatedHostdevs"
          ],
          "line": 2014
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListDel",
          "args": [
            "mgr->activeMediatedHostdevs",
            "tmp"
          ],
          "line": 2011
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "367-372",
          "snippet": "void\nvirMediatedDeviceListDel(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr dev)\n{\n    virMediatedDeviceFree(virMediatedDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceListDel(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr dev)\n{\n    virMediatedDeviceFree(virMediatedDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing %s dom=%s from activeMediatedHostdevs\"",
            "mdevsrc->uuidstr",
            "dom_name"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "dom_name",
            "used_by_domname"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "drv_name",
            "used_by_drvname"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceGetUsedBy",
          "args": [
            "tmp",
            "&used_by_drvname",
            "&used_by_domname"
          ],
          "line": 2006
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "254-260",
          "snippet": "void\nvirMediatedDeviceGetUsedBy(virMediatedDevicePtr dev,\n                           const char **drvname, const char **domname)\n{\n    *drvname = dev->used_by_drvname;\n    *domname = dev->used_by_domname;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceGetUsedBy(virMediatedDevicePtr dev,\n                           const char **drvname, const char **domname)\n{\n    *drvname = dev->used_by_drvname;\n    *domname = dev->used_by_domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListFind",
          "args": [
            "mgr->activeMediatedHostdevs",
            "mdev"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "390-400",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceListFind(virMediatedDeviceListPtr list,\n                          virMediatedDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virMediatedDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceListFind(virMediatedDeviceListPtr list,\n                          virMediatedDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virMediatedDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceNew",
          "args": [
            "mdevsrc->uuidstr",
            "mdevsrc->model"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "170-178",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdev"
          ],
          "line": 1991
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeMediatedHostdevs"
          ],
          "line": 1982
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachMediatedDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    const char *used_by_drvname = NULL;\n    const char *used_by_domname = NULL;\n    size_t i;\n\n    if (nhostdevs == 0)\n        return;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virMediatedDevice) mdev = NULL;\n        virMediatedDevicePtr tmp;\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr,\n                                          mdevsrc->model)))\n            continue;\n\n        /* Remove from the list only mdevs assigned to @drv_name/@dom_name */\n\n        tmp = virMediatedDeviceListFind(mgr->activeMediatedHostdevs, mdev);\n\n        /* skip inactive devices */\n        if (!tmp)\n            continue;\n\n        virMediatedDeviceGetUsedBy(tmp, &used_by_drvname, &used_by_domname);\n        if (STREQ_NULLABLE(drv_name, used_by_drvname) &&\n            STREQ_NULLABLE(dom_name, used_by_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeMediatedHostdevs\",\n                      mdevsrc->uuidstr, dom_name);\n            virMediatedDeviceListDel(mgr->activeMediatedHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n}"
  },
  {
    "function_name": "virHostdevReAttachSCSIVHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1901-1959",
    "snippet": "void\nvirHostdevReAttachSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                   const char *drv_name,\n                                   const char *dom_name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n        virSCSIVHostDevicePtr tmp;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue; /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn))) {\n            VIR_WARN(\"Unable to reattach SCSI_host device %s on domain %s\",\n                     hostsrc->wwpn, NULLSTR(dom_name));\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        /* Only delete the devices which are marked as being used by @name,\n         * because qemuProcessStart could fail half way through. */\n\n        if (!(tmp = virSCSIVHostDeviceListFind(mgr->activeSCSIVHostHostdevs,\n                                               host))) {\n            VIR_WARN(\"Unable to find device %s \"\n                     \"in list of active SCSI_host devices\",\n                     hostsrc->wwpn);\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        virSCSIVHostDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeSCSIVHostHostdevs\",\n                      hostsrc->wwpn, dom_name);\n\n            virSCSIVHostDeviceListDel(mgr->activeSCSIVHostHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeSCSIVHostHostdevs"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListDel",
          "args": [
            "mgr->activeSCSIVHostHostdevs",
            "tmp"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "106-111",
          "snippet": "void\nvirSCSIVHostDeviceListDel(virSCSIVHostDeviceListPtr list,\n                          virSCSIVHostDevicePtr dev)\n{\n    virSCSIVHostDeviceFree(virSCSIVHostDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceListDel(virSCSIVHostDeviceListPtr list,\n                          virSCSIVHostDevicePtr dev)\n{\n    virSCSIVHostDeviceFree(virSCSIVHostDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing %s dom=%s from activeSCSIVHostHostdevs\"",
            "hostsrc->wwpn",
            "dom_name"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "dom_name",
            "usedby_domname"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "drv_name",
            "usedby_drvname"
          ],
          "line": 1950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceGetUsedBy",
          "args": [
            "tmp",
            "&usedby_drvname",
            "&usedby_domname"
          ],
          "line": 1948
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "215-222",
          "snippet": "void\nvirSCSIVHostDeviceGetUsedBy(virSCSIVHostDevicePtr dev,\n                            const char **drv_name,\n                            const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirSCSIVHostDeviceGetUsedBy(virSCSIVHostDevicePtr dev,\n                            const char **drv_name,\n                            const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to find device %s \"\n                     \"in list of active SCSI_host devices\"",
            "hostsrc->wwpn"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListFind",
          "args": [
            "mgr->activeSCSIVHostHostdevs",
            "host"
          ],
          "line": 1939
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "165-175",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceListFind(virSCSIVHostDeviceListPtr list,\n                           virSCSIVHostDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virSCSIVHostDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceListFind(virSCSIVHostDeviceListPtr list,\n                           virSCSIVHostDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virSCSIVHostDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to reattach SCSI_host device %s on domain %s\"",
            "hostsrc->wwpn",
            "NULLSTR(dom_name)"
          ],
          "line": 1930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dom_name"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeSCSIVHostHostdevs"
          ],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                   const char *drv_name,\n                                   const char *dom_name,\n                                   virDomainHostdevDefPtr *hostdevs,\n                                   int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n        virSCSIVHostDevicePtr tmp;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue; /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn))) {\n            VIR_WARN(\"Unable to reattach SCSI_host device %s on domain %s\",\n                     hostsrc->wwpn, NULLSTR(dom_name));\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        /* Only delete the devices which are marked as being used by @name,\n         * because qemuProcessStart could fail half way through. */\n\n        if (!(tmp = virSCSIVHostDeviceListFind(mgr->activeSCSIVHostHostdevs,\n                                               host))) {\n            VIR_WARN(\"Unable to find device %s \"\n                     \"in list of active SCSI_host devices\",\n                     hostsrc->wwpn);\n            virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n            return;\n        }\n\n        virSCSIVHostDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %s dom=%s from activeSCSIVHostHostdevs\",\n                      hostsrc->wwpn, dom_name);\n\n            virSCSIVHostDeviceListDel(mgr->activeSCSIVHostHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n}"
  },
  {
    "function_name": "virHostdevReAttachSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1872-1899",
    "snippet": "void\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReAttachSCSIHostDevices",
          "args": [
            "mgr",
            "hostdev",
            "scsisrc",
            "drv_name",
            "dom_name"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachSCSIHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1832-1870",
          "snippet": "static void\nvirHostdevReAttachSCSIHostDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr hostdev,\n                                  virDomainHostdevSubsysSCSIPtr scsisrc,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable))) {\n        VIR_WARN(\"Unable to reattach SCSI device %s:%u:%u:%llu on domain %s\",\n                 scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n                 scsihostsrc->unit, dom_name);\n        return;\n    }\n\n    /* Only delete the devices which are marked as being used by @name,\n     * because qemuProcessStart could fail half way through. */\n\n    if (!(tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        VIR_WARN(\"Unable to find device %s:%u:%u:%llu \"\n                 \"in list of active SCSI devices\",\n                 scsihostsrc->adapter, scsihostsrc->bus,\n                 scsihostsrc->target, scsihostsrc->unit);\n        return;\n    }\n\n    VIR_DEBUG(\"Removing %s:%u:%u:%llu dom=%s from activeSCSIHostdevs\",\n              scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n              scsihostsrc->unit, dom_name);\n\n    virSCSIDeviceListDel(mgr->activeSCSIHostdevs, tmp,\n                         drv_name, dom_name);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReAttachSCSIHostDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr hostdev,\n                                  virDomainHostdevSubsysSCSIPtr scsisrc,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable))) {\n        VIR_WARN(\"Unable to reattach SCSI device %s:%u:%u:%llu on domain %s\",\n                 scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n                 scsihostsrc->unit, dom_name);\n        return;\n    }\n\n    /* Only delete the devices which are marked as being used by @name,\n     * because qemuProcessStart could fail half way through. */\n\n    if (!(tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        VIR_WARN(\"Unable to find device %s:%u:%u:%llu \"\n                 \"in list of active SCSI devices\",\n                 scsihostsrc->adapter, scsihostsrc->bus,\n                 scsihostsrc->target, scsihostsrc->unit);\n        return;\n    }\n\n    VIR_DEBUG(\"Removing %s:%u:%u:%llu dom=%s from activeSCSIHostdevs\",\n              scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n              scsihostsrc->unit, dom_name);\n\n    virSCSIDeviceListDel(mgr->activeSCSIHostdevs, tmp,\n                         drv_name, dom_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsSCSIDevice",
          "args": [
            "hostdev"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsSCSIDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32282-32287",
          "snippet": "bool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1884
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachSCSIDevices(virHostdevManagerPtr mgr,\n                              const char *drv_name,\n                              const char *dom_name,\n                              virDomainHostdevDefPtr *hostdevs,\n                              int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI)\n            continue; /* Not supported for iSCSI */\n        else\n            virHostdevReAttachSCSIHostDevices(mgr, hostdev, scsisrc,\n                                              drv_name, dom_name);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n}"
  },
  {
    "function_name": "virHostdevReAttachSCSIHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1832-1870",
    "snippet": "static void\nvirHostdevReAttachSCSIHostDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr hostdev,\n                                  virDomainHostdevSubsysSCSIPtr scsisrc,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable))) {\n        VIR_WARN(\"Unable to reattach SCSI device %s:%u:%u:%llu on domain %s\",\n                 scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n                 scsihostsrc->unit, dom_name);\n        return;\n    }\n\n    /* Only delete the devices which are marked as being used by @name,\n     * because qemuProcessStart could fail half way through. */\n\n    if (!(tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        VIR_WARN(\"Unable to find device %s:%u:%u:%llu \"\n                 \"in list of active SCSI devices\",\n                 scsihostsrc->adapter, scsihostsrc->bus,\n                 scsihostsrc->target, scsihostsrc->unit);\n        return;\n    }\n\n    VIR_DEBUG(\"Removing %s:%u:%u:%llu dom=%s from activeSCSIHostdevs\",\n              scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n              scsihostsrc->unit, dom_name);\n\n    virSCSIDeviceListDel(mgr->activeSCSIHostdevs, tmp,\n                         drv_name, dom_name);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSCSIDeviceListDel",
          "args": [
            "mgr->activeSCSIHostdevs",
            "tmp",
            "drv_name",
            "dom_name"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "415-436",
          "snippet": "void\nvirSCSIDeviceListDel(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev,\n                     const char *drvname,\n                     const char *domname)\n{\n    size_t i;\n\n    for (i = 0; i < dev->n_used_by; i++) {\n        if (STREQ_NULLABLE(dev->used_by[i]->drvname, drvname) &&\n            STREQ_NULLABLE(dev->used_by[i]->domname, domname)) {\n            if (dev->n_used_by > 1) {\n                virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n                VIR_DELETE_ELEMENT(dev->used_by, i, dev->n_used_by);\n            } else {\n                g_autoptr(virSCSIDevice) tmp = NULL;\n                tmp = virSCSIDeviceListSteal(list, dev);\n            }\n            break;\n        }\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirSCSIDeviceListDel(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev,\n                     const char *drvname,\n                     const char *domname)\n{\n    size_t i;\n\n    for (i = 0; i < dev->n_used_by; i++) {\n        if (STREQ_NULLABLE(dev->used_by[i]->drvname, drvname) &&\n            STREQ_NULLABLE(dev->used_by[i]->domname, domname)) {\n            if (dev->n_used_by > 1) {\n                virSCSIDeviceUsedByInfoFree(dev->used_by[i]);\n                VIR_DELETE_ELEMENT(dev->used_by, i, dev->n_used_by);\n            } else {\n                g_autoptr(virSCSIDevice) tmp = NULL;\n                tmp = virSCSIDeviceListSteal(list, dev);\n            }\n            break;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing %s:%u:%u:%llu dom=%s from activeSCSIHostdevs\"",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dom_name"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to find device %s:%u:%u:%llu \"\n                 \"in list of active SCSI devices\"",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListFind",
          "args": [
            "mgr->activeSCSIHostdevs",
            "scsi"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "438-453",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to reattach SCSI device %s:%u:%u:%llu on domain %s\"",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "dom_name"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "hostdev->readonly",
            "hostdev->shareable"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReAttachSCSIHostDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr hostdev,\n                                  virDomainHostdevSubsysSCSIPtr scsisrc,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable))) {\n        VIR_WARN(\"Unable to reattach SCSI device %s:%u:%u:%llu on domain %s\",\n                 scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n                 scsihostsrc->unit, dom_name);\n        return;\n    }\n\n    /* Only delete the devices which are marked as being used by @name,\n     * because qemuProcessStart could fail half way through. */\n\n    if (!(tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        VIR_WARN(\"Unable to find device %s:%u:%u:%llu \"\n                 \"in list of active SCSI devices\",\n                 scsihostsrc->adapter, scsihostsrc->bus,\n                 scsihostsrc->target, scsihostsrc->unit);\n        return;\n    }\n\n    VIR_DEBUG(\"Removing %s:%u:%u:%llu dom=%s from activeSCSIHostdevs\",\n              scsihostsrc->adapter, scsihostsrc->bus, scsihostsrc->target,\n              scsihostsrc->unit, dom_name);\n\n    virSCSIDeviceListDel(mgr->activeSCSIHostdevs, tmp,\n                         drv_name, dom_name);\n}"
  },
  {
    "function_name": "virHostdevReAttachUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1772-1830",
    "snippet": "void\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1829
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListDel",
          "args": [
            "mgr->activeUSBHostdevs",
            "tmp"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "490-495",
          "snippet": "void\nvirUSBDeviceListDel(virUSBDeviceListPtr list,\n                    virUSBDevicePtr dev)\n{\n    virUSBDeviceFree(virUSBDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceListDel(virUSBDeviceListPtr list,\n                    virUSBDevicePtr dev)\n{\n    virUSBDeviceFree(virUSBDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing %03d.%03d dom=%s from activeUSBHostdevs\"",
            "usbsrc->bus",
            "usbsrc->device",
            "dom_name"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "dom_name",
            "usedby_domname"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "drv_name",
            "usedby_drvname"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetUsedBy",
          "args": [
            "tmp",
            "&usedby_drvname",
            "&usedby_domname"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "378-385",
          "snippet": "void\nvirUSBDeviceGetUsedBy(virUSBDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceGetUsedBy(virUSBDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\"",
            "usbsrc->bus",
            "usbsrc->device"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListFind",
          "args": [
            "mgr->activeUSBHostdevs",
            "usb"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "497-510",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListFind(virUSBDeviceListPtr list,\n                     virUSBDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev)\n            return list->devs[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListFind(virUSBDeviceListPtr list,\n                     virUSBDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev)\n            return list->devs[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to reattach USB device %03d.%03d on domain %s\"",
            "usbsrc->bus",
            "usbsrc->device",
            "NULLSTR(dom_name)"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "dom_name"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "NULL"
          ],
          "line": 1800
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachUSBDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i;\n\n    if (!nhostdevs)\n        return;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n        g_autoptr(virUSBDevice) usb = NULL;\n        virUSBDevicePtr tmp;\n        const char *usedby_drvname;\n        const char *usedby_domname;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n        if (hostdev->missing)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, NULLSTR(dom_name));\n            continue;\n        }\n\n        /* Delete only those USB devices which belongs\n         * to domain @name because qemuProcessStart() might\n         * have failed because USB device is already taken.\n         * Therefore we want to steal only those devices from\n         * the list which were taken by @name */\n\n        tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb);\n\n        if (!tmp) {\n            VIR_WARN(\"Unable to find device %03d.%03d \"\n                     \"in list of active USB devices\",\n                     usbsrc->bus, usbsrc->device);\n            continue;\n        }\n\n        virUSBDeviceGetUsedBy(tmp, &usedby_drvname, &usedby_domname);\n        if (STREQ_NULLABLE(drv_name, usedby_drvname) &&\n            STREQ_NULLABLE(dom_name, usedby_domname)) {\n            VIR_DEBUG(\"Removing %03d.%03d dom=%s from activeUSBHostdevs\",\n                      usbsrc->bus, usbsrc->device, dom_name);\n            virUSBDeviceListDel(mgr->activeUSBHostdevs, tmp);\n        }\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n}"
  },
  {
    "function_name": "virHostdevPrepareMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1716-1770",
    "snippet": "int\nvirHostdevPrepareMediatedDevices(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs)\n{\n    size_t i;\n    g_autoptr(virMediatedDeviceList) list = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where mediated device is assigned to multiple\n     * domains we maintain a driver list of currently assigned mediated devices.\n     * A device is appended to the driver list after a series of preparations.\n     */\n    if (!(list = virMediatedDeviceListNew()))\n        return -1;\n\n    /* Loop 1: Build a temporary list of ALL mediated devices. */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr src = &hostdev->source.subsys.u.mdev;\n        g_autoptr(virMediatedDevice) mdev = NULL;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(src->uuidstr, src->model)))\n            return -1;\n\n        if (virMediatedDeviceListAdd(list, &mdev) < 0)\n            return -1;\n        mdev = NULL;\n    }\n\n    /* Mark the devices in the list as used by @drv_name-@dom_name and copy the\n     * references to the driver list\n     */\n    if (virMediatedDeviceListMarkDevices(mgr->activeMediatedHostdevs,\n                                         list, drv_name, dom_name) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virMediatedDeviceListCount(list) > 0) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(list, 0);\n        virMediatedDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virMediatedDeviceListSteal",
          "args": [
            "list",
            "tmp"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "357-364",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceListSteal(virMediatedDeviceListPtr list,\n                           virMediatedDevicePtr dev)\n{\n    int idx = virMediatedDeviceListFindIndex(list, dev);\n\n    return virMediatedDeviceListStealIndex(list, idx);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceListSteal(virMediatedDeviceListPtr list,\n                           virMediatedDevicePtr dev)\n{\n    int idx = virMediatedDeviceListFindIndex(list, dev);\n\n    return virMediatedDeviceListStealIndex(list, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListGet",
          "args": [
            "list",
            "0"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "324-332",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceListGet(virMediatedDeviceListPtr list,\n                         ssize_t idx)\n{\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceListGet(virMediatedDeviceListPtr list,\n                         ssize_t idx)\n{\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListCount",
          "args": [
            "list"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "335-339",
          "snippet": "size_t\nvirMediatedDeviceListCount(virMediatedDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nsize_t\nvirMediatedDeviceListCount(virMediatedDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListMarkDevices",
          "args": [
            "mgr->activeMediatedHostdevs",
            "list",
            "drv_name",
            "dom_name"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListMarkDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "432-472",
          "snippet": "int\nvirMediatedDeviceListMarkDevices(virMediatedDeviceListPtr dst,\n                                 virMediatedDeviceListPtr src,\n                                 const char *drvname,\n                                 const char *domname)\n{\n    int ret = -1;\n    size_t count = virMediatedDeviceListCount(src);\n    size_t i, j;\n\n    virObjectLock(dst);\n    for (i = 0; i < count; i++) {\n        virMediatedDevicePtr mdev = virMediatedDeviceListGet(src, i);\n\n        if (virMediatedDeviceIsUsed(mdev, dst) ||\n            virMediatedDeviceSetUsedBy(mdev, drvname, domname) < 0)\n            goto cleanup;\n\n        /* Copy mdev references to the driver list:\n         * - caller is responsible for NOT freeing devices in @src on success\n         * - we're responsible for performing a rollback on failure\n         */\n        VIR_DEBUG(\"Add '%s' to list of active mediated devices used by '%s'\",\n                  mdev->path, domname);\n        if (virMediatedDeviceListAdd(dst, &mdev) < 0)\n            goto rollback;\n\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dst);\n    return ret;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(src, j);\n        virMediatedDeviceListSteal(dst, tmp);\n    }\n    goto cleanup;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceListMarkDevices(virMediatedDeviceListPtr dst,\n                                 virMediatedDeviceListPtr src,\n                                 const char *drvname,\n                                 const char *domname)\n{\n    int ret = -1;\n    size_t count = virMediatedDeviceListCount(src);\n    size_t i, j;\n\n    virObjectLock(dst);\n    for (i = 0; i < count; i++) {\n        virMediatedDevicePtr mdev = virMediatedDeviceListGet(src, i);\n\n        if (virMediatedDeviceIsUsed(mdev, dst) ||\n            virMediatedDeviceSetUsedBy(mdev, drvname, domname) < 0)\n            goto cleanup;\n\n        /* Copy mdev references to the driver list:\n         * - caller is responsible for NOT freeing devices in @src on success\n         * - we're responsible for performing a rollback on failure\n         */\n        VIR_DEBUG(\"Add '%s' to list of active mediated devices used by '%s'\",\n                  mdev->path, domname);\n        if (virMediatedDeviceListAdd(dst, &mdev) < 0)\n            goto rollback;\n\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(dst);\n    return ret;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(src, j);\n        virMediatedDeviceListSteal(dst, tmp);\n    }\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListAdd",
          "args": [
            "list",
            "&mdev"
          ],
          "line": 1748
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "311-321",
          "snippet": "int\nvirMediatedDeviceListAdd(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr *dev)\n{\n    if (virMediatedDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s is already in use\"), (*dev)->path);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceListAdd(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr *dev)\n{\n    if (virMediatedDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s is already in use\"), (*dev)->path);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceNew",
          "args": [
            "src->uuidstr",
            "src->model"
          ],
          "line": 1745
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "170-178",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdev"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListNew",
          "args": [],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "277-289",
          "snippet": "virMediatedDeviceListPtr\nvirMediatedDeviceListNew(void)\n{\n    virMediatedDeviceListPtr list;\n\n    if (virMediatedInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virMediatedDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virMediatedDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nstatic virClassPtr virMediatedDeviceListClass;\n\nvirMediatedDeviceListPtr\nvirMediatedDeviceListNew(void)\n{\n    virMediatedDeviceListPtr list;\n\n    if (virMediatedInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virMediatedDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareMediatedDevices(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs)\n{\n    size_t i;\n    g_autoptr(virMediatedDeviceList) list = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where mediated device is assigned to multiple\n     * domains we maintain a driver list of currently assigned mediated devices.\n     * A device is appended to the driver list after a series of preparations.\n     */\n    if (!(list = virMediatedDeviceListNew()))\n        return -1;\n\n    /* Loop 1: Build a temporary list of ALL mediated devices. */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr src = &hostdev->source.subsys.u.mdev;\n        g_autoptr(virMediatedDevice) mdev = NULL;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(src->uuidstr, src->model)))\n            return -1;\n\n        if (virMediatedDeviceListAdd(list, &mdev) < 0)\n            return -1;\n        mdev = NULL;\n    }\n\n    /* Mark the devices in the list as used by @drv_name-@dom_name and copy the\n     * references to the driver list\n     */\n    if (virMediatedDeviceListMarkDevices(mgr->activeMediatedHostdevs,\n                                         list, drv_name, dom_name) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virMediatedDeviceListCount(list) > 0) {\n        virMediatedDevicePtr tmp = virMediatedDeviceListGet(list, 0);\n        virMediatedDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevPrepareSCSIVHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1631-1713",
    "snippet": "int\nvirHostdevPrepareSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    g_autoptr(virSCSIVHostDeviceList) list = NULL;\n    virSCSIVHostDevicePtr tmp;\n    size_t i, j;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where scsi_host device is assigned to two domains\n     * we need to keep a list of currently assigned scsi_host devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIVHostDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue;  /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn)))\n            return -1;\n\n        if (virSCSIVHostDeviceSetUsedBy(host, drv_name, dom_name) < 0)\n            return -1;\n\n        if (virSCSIVHostDeviceListAdd(list, host) < 0)\n            return -1;\n        host = NULL;\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n\n    for (i = 0; i < virSCSIVHostDeviceListCount(list); i++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n\n        VIR_DEBUG(\"Adding %s to activeSCSIVHostHostdevs\",\n                  virSCSIVHostDeviceGetName(tmp));\n\n        if (virSCSIVHostDeviceListAdd(mgr->activeSCSIVHostHostdevs, tmp) < 0)\n            goto rollback;\n    }\n\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIVHostDeviceListCount(list) > 0) {\n        tmp = virSCSIVHostDeviceListGet(list, 0);\n        virSCSIVHostDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n        virSCSIVHostDeviceListSteal(mgr->activeSCSIVHostHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeSCSIVHostHostdevs"
          ],
          "line": 1711
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListSteal",
          "args": [
            "mgr->activeSCSIVHostHostdevs",
            "tmp"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "146-162",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceListSteal(virSCSIVHostDeviceListPtr list,\n                            virSCSIVHostDevicePtr dev)\n{\n    virSCSIVHostDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (STREQ_NULLABLE(list->devs[i]->name, dev->name)) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceListSteal(virSCSIVHostDeviceListPtr list,\n                            virSCSIVHostDevicePtr dev)\n{\n    virSCSIVHostDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (STREQ_NULLABLE(list->devs[i]->name, dev->name)) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListGet",
          "args": [
            "list",
            "i"
          ],
          "line": 1708
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "129-136",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceListGet(virSCSIVHostDeviceListPtr list, int idx)\n{\n    if (idx >= list->count || idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceListGet(virSCSIVHostDeviceListPtr list, int idx)\n{\n    if (idx >= list->count || idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListCount",
          "args": [
            "list"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "139-143",
          "snippet": "size_t\nvirSCSIVHostDeviceListCount(virSCSIVHostDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nsize_t\nvirSCSIVHostDeviceListCount(virSCSIVHostDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListAdd",
          "args": [
            "mgr->activeSCSIVHostHostdevs",
            "tmp"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "178-188",
          "snippet": "int\nvirSCSIVHostDeviceListAdd(virSCSIVHostDeviceListPtr list,\n                          virSCSIVHostDevicePtr dev)\n{\n    if (virSCSIVHostDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"), dev->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceListAdd(virSCSIVHostDeviceListPtr list,\n                          virSCSIVHostDevicePtr dev)\n{\n    if (virSCSIVHostDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"), dev->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding %s to activeSCSIVHostHostdevs\"",
            "virSCSIVHostDeviceGetName(tmp)"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceGetName",
          "args": [
            "tmp"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "234-238",
          "snippet": "const char *\nvirSCSIVHostDeviceGetName(virSCSIVHostDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirSCSIVHostDeviceGetName(virSCSIVHostDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeSCSIVHostHostdevs"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceSetUsedBy",
          "args": [
            "host",
            "drv_name",
            "dom_name"
          ],
          "line": 1669
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "201-212",
          "snippet": "int\nvirSCSIVHostDeviceSetUsedBy(virSCSIVHostDevicePtr dev,\n                            const char *drvname,\n                            const char *domname)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drvname);\n    dev->used_by_domname = g_strdup(domname);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirSCSIVHostDeviceSetUsedBy(virSCSIVHostDevicePtr dev,\n                            const char *drvname,\n                            const char *domname)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drvname);\n    dev->used_by_domname = g_strdup(domname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceNew",
          "args": [
            "hostsrc->wwpn"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "248-263",
          "snippet": "virSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\n#define SYSFS_VHOST_SCSI_DEVICES \"/sys/kernel/config/target/vhost/\"\n\nvirSCSIVHostDevicePtr\nvirSCSIVHostDeviceNew(const char *name)\n{\n    g_autoptr(virSCSIVHostDevice) dev = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->name = g_strdup(name);\n\n    dev->path = g_strdup_printf(\"%s/%s\", SYSFS_VHOST_SCSI_DEVICES, name);\n\n    VIR_DEBUG(\"%s: initialized\", dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListNew",
          "args": [],
          "line": 1650
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "191-198",
          "snippet": "virSCSIVHostDeviceListPtr\nvirSCSIVHostDeviceListNew(void)\n{\n    if (virSCSIVHostInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableNew(virSCSIVHostDeviceListClass);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSCSIVHostDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virSCSIVHostDeviceListClass;\n\nvirSCSIVHostDeviceListPtr\nvirSCSIVHostDeviceListNew(void)\n{\n    if (virSCSIVHostInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableNew(virSCSIVHostDeviceListClass);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareSCSIVHostDevices(virHostdevManagerPtr mgr,\n                                  const char *drv_name,\n                                  const char *dom_name,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs)\n{\n    g_autoptr(virSCSIVHostDeviceList) list = NULL;\n    virSCSIVHostDevicePtr tmp;\n    size_t i, j;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where scsi_host device is assigned to two domains\n     * we need to keep a list of currently assigned scsi_host devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIVHostDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIVHostPtr hostsrc = &hostdev->source.subsys.u.scsi_host;\n        g_autoptr(virSCSIVHostDevice) host = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n            hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI_HOST)\n            continue;\n\n        if (hostsrc->protocol != VIR_DOMAIN_HOSTDEV_SUBSYS_SCSI_HOST_PROTOCOL_TYPE_VHOST)\n            continue;  /* Not supported */\n\n        if (!(host = virSCSIVHostDeviceNew(hostsrc->wwpn)))\n            return -1;\n\n        if (virSCSIVHostDeviceSetUsedBy(host, drv_name, dom_name) < 0)\n            return -1;\n\n        if (virSCSIVHostDeviceListAdd(list, host) < 0)\n            return -1;\n        host = NULL;\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIVHostHostdevs);\n\n    for (i = 0; i < virSCSIVHostDeviceListCount(list); i++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n\n        VIR_DEBUG(\"Adding %s to activeSCSIVHostHostdevs\",\n                  virSCSIVHostDeviceGetName(tmp));\n\n        if (virSCSIVHostDeviceListAdd(mgr->activeSCSIVHostHostdevs, tmp) < 0)\n            goto rollback;\n    }\n\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIVHostDeviceListCount(list) > 0) {\n        tmp = virSCSIVHostDeviceListGet(list, 0);\n        virSCSIVHostDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n rollback:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIVHostDeviceListGet(list, i);\n        virSCSIVHostDeviceListSteal(mgr->activeSCSIVHostHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIVHostHostdevs);\n    return -1;\n}"
  },
  {
    "function_name": "virHostdevPrepareSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1534-1629",
    "snippet": "int\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListSteal",
          "args": [
            "mgr->activeSCSIHostdevs",
            "tmp"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "394-413",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceListSteal(virSCSIDeviceListPtr list,\n                       virSCSIDevicePtr dev)\n{\n    virSCSIDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirSCSIDevicePtr\nvirSCSIDeviceListSteal(virSCSIDeviceListPtr list,\n                       virSCSIDevicePtr dev)\n{\n    virSCSIDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListGet",
          "args": [
            "list",
            "i"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "379-386",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceListGet(virSCSIDeviceListPtr list, int idx)\n{\n    if (idx >= list->count || idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirSCSIDevicePtr\nvirSCSIDeviceListGet(virSCSIDeviceListPtr list, int idx)\n{\n    if (idx >= list->count || idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListCount",
          "args": [
            "list"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "388-392",
          "snippet": "size_t\nvirSCSIDeviceListCount(virSCSIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nsize_t\nvirSCSIDeviceListCount(virSCSIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListAdd",
          "args": [
            "mgr->activeSCSIHostdevs",
            "scsi"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "365-377",
          "snippet": "int\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding %s to activeSCSIHostdevs\"",
            "virSCSIDeviceGetName(scsi)"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetName",
          "args": [
            "scsi"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "283-287",
          "snippet": "const char *\nvirSCSIDeviceGetName(virSCSIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nconst char *\nvirSCSIDeviceGetName(virSCSIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceSetUsedBy",
          "args": [
            "scsi",
            "drv_name",
            "dom_name"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "259-275",
          "snippet": "int\nvirSCSIDeviceSetUsedBy(virSCSIDevicePtr dev,\n                       const char *drvname,\n                       const char *domname)\n{\n    g_autoptr(virUsedByInfo) copy = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return -1;\n    copy->drvname = g_strdup(drvname);\n    copy->domname = g_strdup(domname);\n\n    if (VIR_APPEND_ELEMENT(dev->used_by, dev->n_used_by, copy) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceSetUsedBy(virSCSIDevicePtr dev,\n                       const char *drvname,\n                       const char *domname)\n{\n    g_autoptr(virUsedByInfo) copy = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return -1;\n    copy->drvname = g_strdup(drvname);\n    copy->domname = g_strdup(domname);\n\n    if (VIR_APPEND_ELEMENT(dev->used_by, dev->n_used_by, copy) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\")",
            "virSCSIDeviceGetName(tmp)",
            "tmp_shareable ? \"shareable\" : \"non-shareable\""
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\""
          ],
          "line": 1589
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceGetShareable",
          "args": [
            "tmp"
          ],
          "line": 1585
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceGetShareable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "325-329",
          "snippet": "bool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nbool\nvirSCSIDeviceGetShareable(virSCSIDevicePtr dev)\n{\n    return dev->shareable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListFind",
          "args": [
            "mgr->activeSCSIHostdevs",
            "scsi"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "438-453",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPrepareSCSIHostDevices",
          "args": [
            "hostdev",
            "scsisrc",
            "list"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPrepareSCSIHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1507-1532",
          "snippet": "static int\nvirHostdevPrepareSCSIHostDevices(virDomainHostdevDefPtr hostdev,\n                                 virDomainHostdevSubsysSCSIPtr scsisrc,\n                                 virSCSIDeviceListPtr list)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n\n    if (hostdev->managed) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"SCSI host device doesn't support managed mode\"));\n        return -1;\n    }\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if (virSCSIDeviceListAdd(list, scsi) < 0)\n        return -1;\n    scsi = NULL;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPrepareSCSIHostDevices(virDomainHostdevDefPtr hostdev,\n                                 virDomainHostdevSubsysSCSIPtr scsisrc,\n                                 virSCSIDeviceListPtr list)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n\n    if (hostdev->managed) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"SCSI host device doesn't support managed mode\"));\n        return -1;\n    }\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if (virSCSIDeviceListAdd(list, scsi) < 0)\n        return -1;\n    scsi = NULL;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsSCSIDevice",
          "args": [
            "hostdev"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsSCSIDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32282-32287",
          "snippet": "bool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListNew",
          "args": [],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "339-351",
          "snippet": "virSCSIDeviceListPtr\nvirSCSIDeviceListNew(void)\n{\n    virSCSIDeviceListPtr list;\n\n    if (virSCSIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virSCSIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSCSIDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virClassPtr virSCSIDeviceListClass;\n\nvirSCSIDeviceListPtr\nvirSCSIDeviceListNew(void)\n{\n    virSCSIDeviceListPtr list;\n\n    if (virSCSIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virSCSIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareSCSIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs)\n{\n    size_t i, j;\n    int count;\n    g_autoptr(virSCSIDeviceList) list = NULL;\n    virSCSIDevicePtr tmp;\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where SCSI device is assigned to two domains\n     * we need to keep a list of currently assigned SCSI devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virSCSIDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysSCSIPtr scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevPrepareSCSIHostDevices(hostdev, scsisrc, list) < 0)\n                return -1;\n        }\n    }\n\n    /* Loop 2: Mark devices in temporary list as used by @name\n     * and add them to driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    virObjectLock(mgr->activeSCSIHostdevs);\n    count = virSCSIDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virSCSIDevicePtr scsi = virSCSIDeviceListGet(list, i);\n        if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs,\n                                         scsi))) {\n            bool scsi_shareable = virSCSIDeviceGetShareable(scsi);\n            bool tmp_shareable = virSCSIDeviceGetShareable(tmp);\n\n            if (!(scsi_shareable && tmp_shareable)) {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"SCSI device %s is already in use by \"\n                                 \"other domain(s) as '%s'\"),\n                               virSCSIDeviceGetName(tmp),\n                               tmp_shareable ? \"shareable\" : \"non-shareable\");\n                goto error;\n            }\n\n            if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n                goto error;\n        } else {\n            if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0)\n                goto error;\n\n            VIR_DEBUG(\"Adding %s to activeSCSIHostdevs\", virSCSIDeviceGetName(scsi));\n\n            if (virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n                goto error;\n        }\n    }\n\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n\n    /* Loop 3: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * when freeing temporary list.\n     */\n    while (virSCSIDeviceListCount(list) > 0) {\n        tmp = virSCSIDeviceListGet(list, 0);\n        virSCSIDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virSCSIDeviceListGet(list, i);\n        virSCSIDeviceListSteal(mgr->activeSCSIHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return -1;\n}"
  },
  {
    "function_name": "virHostdevPrepareSCSIHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1507-1532",
    "snippet": "static int\nvirHostdevPrepareSCSIHostDevices(virDomainHostdevDefPtr hostdev,\n                                 virDomainHostdevSubsysSCSIPtr scsisrc,\n                                 virSCSIDeviceListPtr list)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n\n    if (hostdev->managed) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"SCSI host device doesn't support managed mode\"));\n        return -1;\n    }\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if (virSCSIDeviceListAdd(list, scsi) < 0)\n        return -1;\n    scsi = NULL;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSCSIDeviceListAdd",
          "args": [
            "list",
            "scsi"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "365-377",
          "snippet": "int\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "hostdev->readonly",
            "hostdev->shareable"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"SCSI host device doesn't support managed mode\")"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SCSI host device doesn't support managed mode\""
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPrepareSCSIHostDevices(virDomainHostdevDefPtr hostdev,\n                                 virDomainHostdevSubsysSCSIPtr scsisrc,\n                                 virSCSIDeviceListPtr list)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n\n    if (hostdev->managed) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"SCSI host device doesn't support managed mode\"));\n        return -1;\n    }\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if (virSCSIDeviceListAdd(list, scsi) < 0)\n        return -1;\n    scsi = NULL;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevPrepareUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1439-1505",
    "snippet": "int\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUSBDeviceListSteal",
          "args": [
            "list",
            "tmp"
          ],
          "line": 1501
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "472-488",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListGet",
          "args": [
            "list",
            "0"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "455-464",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListCount",
          "args": [
            "list"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "466-470",
          "snippet": "size_t\nvirUSBDeviceListCount(virUSBDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nsize_t\nvirUSBDeviceListCount(virUSBDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevMarkUSBDevices",
          "args": [
            "mgr",
            "drv_name",
            "dom_name",
            "list"
          ],
          "line": 1492
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevMarkUSBDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1297-1353",
          "snippet": "static int\nvirHostdevMarkUSBDevices(virHostdevManagerPtr mgr,\n                         const char *drv_name,\n                         const char *dom_name,\n                         virUSBDeviceListPtr list)\n{\n    size_t i, j;\n    unsigned int count;\n    virUSBDevicePtr tmp;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    count = virUSBDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virUSBDevicePtr usb = virUSBDeviceListGet(list, i);\n        if ((tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb))) {\n            const char *other_drvname;\n            const char *other_domname;\n\n            virUSBDeviceGetUsedBy(tmp, &other_drvname, &other_domname);\n            if (other_drvname && other_domname)\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is in use by \"\n                                 \"driver %s, domain %s\"),\n                               virUSBDeviceGetName(tmp),\n                               other_drvname, other_domname);\n            else\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is already in use\"),\n                               virUSBDeviceGetName(tmp));\n            goto error;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n        VIR_DEBUG(\"Adding %03d.%03d dom=%s to activeUSBHostdevs\",\n                  virUSBDeviceGetBus(usb), virUSBDeviceGetDevno(usb),\n                  dom_name);\n        /*\n         * The caller is responsible to steal these usb devices\n         * from the virUSBDeviceList that passed in on success,\n         * perform rollback on failure.\n         */\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto error;\n    }\n\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virUSBDeviceListGet(list, i);\n        virUSBDeviceListSteal(mgr->activeUSBHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return -1;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevMarkUSBDevices(virHostdevManagerPtr mgr,\n                         const char *drv_name,\n                         const char *dom_name,\n                         virUSBDeviceListPtr list)\n{\n    size_t i, j;\n    unsigned int count;\n    virUSBDevicePtr tmp;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    count = virUSBDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virUSBDevicePtr usb = virUSBDeviceListGet(list, i);\n        if ((tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb))) {\n            const char *other_drvname;\n            const char *other_domname;\n\n            virUSBDeviceGetUsedBy(tmp, &other_drvname, &other_domname);\n            if (other_drvname && other_domname)\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is in use by \"\n                                 \"driver %s, domain %s\"),\n                               virUSBDeviceGetName(tmp),\n                               other_drvname, other_domname);\n            else\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is already in use\"),\n                               virUSBDeviceGetName(tmp));\n            goto error;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n        VIR_DEBUG(\"Adding %03d.%03d dom=%s to activeUSBHostdevs\",\n                  virUSBDeviceGetBus(usb), virUSBDeviceGetDevno(usb),\n                  dom_name);\n        /*\n         * The caller is responsible to steal these usb devices\n         * from the virUSBDeviceList that passed in on success,\n         * perform rollback on failure.\n         */\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto error;\n    }\n\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virUSBDeviceListGet(list, i);\n        virUSBDeviceListSteal(mgr->activeUSBHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListAdd",
          "args": [
            "list",
            "&usb"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "442-453",
          "snippet": "int\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevFindUSBDevice",
          "args": [
            "hostdev",
            "required",
            "&usb"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevFindUSBDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1356-1437",
          "snippet": "int\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListNew",
          "args": [],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "416-428",
          "snippet": "virUSBDeviceListPtr\nvirUSBDeviceListNew(void)\n{\n    virUSBDeviceListPtr list;\n\n    if (virUSBInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virUSBDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virUSBDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virClassPtr virUSBDeviceListClass;\n\nvirUSBDeviceListPtr\nvirUSBDeviceListNew(void)\n{\n    virUSBDeviceListPtr list;\n\n    if (virUSBInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virUSBDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPrepareUSBDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    size_t i;\n    g_autoptr(virUSBDeviceList) list = NULL;\n    virUSBDevicePtr tmp;\n    bool coldBoot = !!(flags & VIR_HOSTDEV_COLD_BOOT);\n\n    if (!nhostdevs)\n        return 0;\n\n    /* To prevent situation where USB device is assigned to two domains\n     * we need to keep a list of currently assigned USB devices.\n     * This is done in several loops which cannot be joined into one big\n     * loop. See virHostdevPreparePCIDevices()\n     */\n    if (!(list = virUSBDeviceListNew()))\n        return -1;\n\n    /* Loop 1: build temporary list\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        bool required = true;\n        g_autoptr(virUSBDevice) usb = NULL;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_OPTIONAL ||\n            (hostdev->startupPolicy == VIR_DOMAIN_STARTUP_POLICY_REQUISITE &&\n             !coldBoot))\n            required = false;\n\n        if (virHostdevFindUSBDevice(hostdev, required, &usb) < 0)\n            return -1;\n\n        if (usb && virUSBDeviceListAdd(list, &usb) < 0)\n            return -1;\n        usb = NULL;\n    }\n\n    /* Mark devices in temporary list as used by @dom_name\n     * and add them do driver list. However, if something goes\n     * wrong, perform rollback.\n     */\n    if (virHostdevMarkUSBDevices(mgr, drv_name, dom_name, list) < 0)\n        return -1;\n\n    /* Loop 2: Temporary list was successfully merged with\n     * driver list, so steal all items to avoid freeing them\n     * in cleanup label.\n     */\n    while (virUSBDeviceListCount(list) > 0) {\n        tmp = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, tmp);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevFindUSBDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1356-1437",
    "snippet": "int\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virUSBDeviceFindByBus",
          "args": [
            "bus",
            "device",
            "NULL",
            "mandatory",
            "usb"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFindByBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "228-265",
          "snippet": "int\nvirUSBDeviceFindByBus(unsigned int bus,\n                      unsigned int devno,\n                      const char *vroot,\n                      bool mandatory,\n                      virUSBDevicePtr *usb)\n{\n    virUSBDeviceListPtr list;\n\n    if (!(list = virUSBDeviceSearch(0, 0, bus, devno,\n                                    vroot,\n                                    USB_DEVICE_FIND_BY_BUS)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device bus:%u device:%u\",\n                      bus, devno);\n            if (usb)\n                *usb = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device bus:%u device:%u\"),\n                       bus, devno);\n        return -1;\n    }\n\n    if (usb) {\n        *usb = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, *usb);\n    }\n    virObjectUnref(list);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceFindByBus(unsigned int bus,\n                      unsigned int devno,\n                      const char *vroot,\n                      bool mandatory,\n                      virUSBDevicePtr *usb)\n{\n    virUSBDeviceListPtr list;\n\n    if (!(list = virUSBDeviceSearch(0, 0, bus, devno,\n                                    vroot,\n                                    USB_DEVICE_FIND_BY_BUS)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device bus:%u device:%u\",\n                      bus, devno);\n            if (usb)\n                *usb = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device bus:%u device:%u\"),\n                       bus, devno);\n        return -1;\n    }\n\n    if (usb) {\n        *usb = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, *usb);\n    }\n    virObjectUnref(list);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\"",
            "vendor",
            "product",
            "usbsrc->bus",
            "usbsrc->device",
            "bus",
            "device"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetDevno",
          "args": [
            "*usb"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetDevno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "403-406",
          "snippet": "unsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetBus",
          "args": [
            "*usb"
          ],
          "line": 1417
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "397-400",
          "snippet": "unsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListSteal",
          "args": [
            "devs",
            "*usb"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "472-488",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListGet",
          "args": [
            "devs",
            "0"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "455-464",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\")",
            "vendor",
            "product"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\""
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\")",
            "vendor",
            "product",
            "bus",
            "device"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFindByVendor",
          "args": [
            "vendor",
            "product",
            "NULL",
            "mandatory",
            "&devs"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFindByVendor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "189-226",
          "snippet": "int\nvirUSBDeviceFindByVendor(unsigned int vendor,\n                         unsigned int product,\n                         const char *vroot,\n                         bool mandatory,\n                         virUSBDeviceListPtr *devices)\n{\n    virUSBDeviceListPtr list;\n    int count;\n\n    if (!(list = virUSBDeviceSearch(vendor, product, 0, 0,\n                                    vroot,\n                                    USB_DEVICE_FIND_BY_VENDOR)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device %04x:%04x\",\n                      vendor, product);\n            if (devices)\n                *devices = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device %04x:%04x\"), vendor, product);\n        return -1;\n    }\n\n    count = list->count;\n    if (devices)\n        *devices = list;\n    else\n        virObjectUnref(list);\n\n    return count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceFindByVendor(unsigned int vendor,\n                         unsigned int product,\n                         const char *vroot,\n                         bool mandatory,\n                         virUSBDeviceListPtr *devices)\n{\n    virUSBDeviceListPtr list;\n    int count;\n\n    if (!(list = virUSBDeviceSearch(vendor, product, 0, 0,\n                                    vroot,\n                                    USB_DEVICE_FIND_BY_VENDOR)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device %04x:%04x\",\n                      vendor, product);\n            if (devices)\n                *devices = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device %04x:%04x\"), vendor, product);\n        return -1;\n    }\n\n    count = list->count;\n    if (devices)\n        *devices = list;\n    else\n        virObjectUnref(list);\n\n    return count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\"",
            "vendor",
            "product",
            "bus",
            "device"
          ],
          "line": 1381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceFind",
          "args": [
            "vendor",
            "product",
            "bus",
            "device",
            "NULL",
            "autoAddress ? false : mandatory",
            "usb"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "267-306",
          "snippet": "int\nvirUSBDeviceFind(unsigned int vendor,\n                 unsigned int product,\n                 unsigned int bus,\n                 unsigned int devno,\n                 const char *vroot,\n                 bool mandatory,\n                 virUSBDevicePtr *usb)\n{\n    virUSBDeviceListPtr list;\n\n    unsigned int flags = USB_DEVICE_FIND_BY_VENDOR|USB_DEVICE_FIND_BY_BUS;\n    if (!(list = virUSBDeviceSearch(vendor, product, bus, devno,\n                                    vroot, flags)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device %04x:%04x bus:%u device:%u\",\n                      vendor, product, bus, devno);\n            if (usb)\n                *usb = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device %04x:%04x bus:%u device:%u\"),\n                       vendor, product, bus, devno);\n        return -1;\n    }\n\n    if (usb) {\n        *usb = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, *usb);\n    }\n    virObjectUnref(list);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceFind(unsigned int vendor,\n                 unsigned int product,\n                 unsigned int bus,\n                 unsigned int devno,\n                 const char *vroot,\n                 bool mandatory,\n                 virUSBDevicePtr *usb)\n{\n    virUSBDeviceListPtr list;\n\n    unsigned int flags = USB_DEVICE_FIND_BY_VENDOR|USB_DEVICE_FIND_BY_BUS;\n    if (!(list = virUSBDeviceSearch(vendor, product, bus, devno,\n                                    vroot, flags)))\n        return -1;\n\n    if (list->count == 0) {\n        virObjectUnref(list);\n        if (!mandatory) {\n            VIR_DEBUG(\"Did not find USB device %04x:%04x bus:%u device:%u\",\n                      vendor, product, bus, devno);\n            if (usb)\n                *usb = NULL;\n            return 0;\n        }\n\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Did not find USB device %04x:%04x bus:%u device:%u\"),\n                       vendor, product, bus, devno);\n        return -1;\n    }\n\n    if (usb) {\n        *usb = virUSBDeviceListGet(list, 0);\n        virUSBDeviceListSteal(list, *usb);\n    }\n    virObjectUnref(list);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevFindUSBDevice(virDomainHostdevDefPtr hostdev,\n                        bool mandatory,\n                        virUSBDevicePtr *usb)\n{\n    virDomainHostdevSubsysUSBPtr usbsrc = &hostdev->source.subsys.u.usb;\n    unsigned vendor = usbsrc->vendor;\n    unsigned product = usbsrc->product;\n    unsigned bus = usbsrc->bus;\n    unsigned device = usbsrc->device;\n    bool autoAddress = usbsrc->autoAddress;\n    int rc;\n\n    *usb = NULL;\n\n    if (vendor && bus) {\n        rc = virUSBDeviceFind(vendor, product, bus, device,\n                              NULL,\n                              autoAddress ? false : mandatory,\n                              usb);\n        if (rc < 0) {\n            return -1;\n        } else if (!autoAddress) {\n            goto out;\n        } else {\n            VIR_INFO(\"USB device %x:%x could not be found at previous\"\n                     \" address (bus:%u device:%u)\",\n                     vendor, product, bus, device);\n        }\n    }\n\n    /* When vendor is specified, its USB address is either unspecified or the\n     * device could not be found at the USB device where it had been\n     * automatically found before.\n     */\n    if (vendor) {\n        g_autoptr(virUSBDeviceList) devs = NULL;\n\n        rc = virUSBDeviceFindByVendor(vendor, product, NULL, mandatory, &devs);\n        if (rc < 0) {\n            return -1;\n        } else if (rc == 0) {\n            goto out;\n        } else if (rc > 1) {\n            if (autoAddress) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x were found,\"\n                                 \" but none of them is at bus:%u device:%u\"),\n                               vendor, product, bus, device);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"Multiple USB devices for %x:%x, \"\n                                 \"use <address> to specify one\"),\n                               vendor, product);\n            }\n            return -1;\n        }\n\n        *usb = virUSBDeviceListGet(devs, 0);\n        virUSBDeviceListSteal(devs, *usb);\n\n        usbsrc->bus = virUSBDeviceGetBus(*usb);\n        usbsrc->device = virUSBDeviceGetDevno(*usb);\n        usbsrc->autoAddress = true;\n\n        if (autoAddress) {\n            VIR_INFO(\"USB device %x:%x found at bus:%u device:%u (moved\"\n                     \" from bus:%u device:%u)\",\n                     vendor, product,\n                     usbsrc->bus, usbsrc->device,\n                     bus, device);\n        }\n    } else if (!vendor && bus) {\n        if (virUSBDeviceFindByBus(bus, device, NULL, mandatory, usb) < 0)\n            return -1;\n    }\n\n out:\n    if (!*usb)\n        hostdev->missing = true;\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevMarkUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1297-1353",
    "snippet": "static int\nvirHostdevMarkUSBDevices(virHostdevManagerPtr mgr,\n                         const char *drv_name,\n                         const char *dom_name,\n                         virUSBDeviceListPtr list)\n{\n    size_t i, j;\n    unsigned int count;\n    virUSBDevicePtr tmp;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    count = virUSBDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virUSBDevicePtr usb = virUSBDeviceListGet(list, i);\n        if ((tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb))) {\n            const char *other_drvname;\n            const char *other_domname;\n\n            virUSBDeviceGetUsedBy(tmp, &other_drvname, &other_domname);\n            if (other_drvname && other_domname)\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is in use by \"\n                                 \"driver %s, domain %s\"),\n                               virUSBDeviceGetName(tmp),\n                               other_drvname, other_domname);\n            else\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is already in use\"),\n                               virUSBDeviceGetName(tmp));\n            goto error;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n        VIR_DEBUG(\"Adding %03d.%03d dom=%s to activeUSBHostdevs\",\n                  virUSBDeviceGetBus(usb), virUSBDeviceGetDevno(usb),\n                  dom_name);\n        /*\n         * The caller is responsible to steal these usb devices\n         * from the virUSBDeviceList that passed in on success,\n         * perform rollback on failure.\n         */\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto error;\n    }\n\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virUSBDeviceListGet(list, i);\n        virUSBDeviceListSteal(mgr->activeUSBHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return -1;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListSteal",
          "args": [
            "mgr->activeUSBHostdevs",
            "tmp"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "472-488",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListSteal(virUSBDeviceListPtr list,\n                      virUSBDevicePtr dev)\n{\n    virUSBDevicePtr ret = NULL;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev) {\n            ret = list->devs[i];\n            VIR_DELETE_ELEMENT(list->devs, i, list->count);\n            break;\n        }\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListGet",
          "args": [
            "list",
            "i"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "455-464",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListGet(virUSBDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count ||\n        idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListAdd",
          "args": [
            "mgr->activeUSBHostdevs",
            "&usb"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "442-453",
          "snippet": "int\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding %03d.%03d dom=%s to activeUSBHostdevs\"",
            "virUSBDeviceGetBus(usb)",
            "virUSBDeviceGetDevno(usb)",
            "dom_name"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetDevno",
          "args": [
            "usb"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetDevno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "403-406",
          "snippet": "unsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetDevno(virUSBDevicePtr dev)\n{\n    return dev->dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetBus",
          "args": [
            "usb"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "397-400",
          "snippet": "unsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nunsigned int virUSBDeviceGetBus(virUSBDevicePtr dev)\n{\n    return dev->bus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceSetUsedBy",
          "args": [
            "usb",
            "drv_name",
            "dom_name"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "365-376",
          "snippet": "int\nvirUSBDeviceSetUsedBy(virUSBDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceSetUsedBy(virUSBDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"USB device %s is already in use\")",
            "virUSBDeviceGetName(tmp)"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetName",
          "args": [
            "tmp"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "387-390",
          "snippet": "const char *virUSBDeviceGetName(virUSBDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nconst char *virUSBDeviceGetName(virUSBDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"USB device %s is already in use\""
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"USB device %s is in use by \"\n                                 \"driver %s, domain %s\")",
            "virUSBDeviceGetName(tmp)",
            "other_drvname",
            "other_domname"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceGetUsedBy",
          "args": [
            "tmp",
            "&other_drvname",
            "&other_domname"
          ],
          "line": 1316
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "378-385",
          "snippet": "void\nvirUSBDeviceGetUsedBy(virUSBDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvoid\nvirUSBDeviceGetUsedBy(virUSBDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListFind",
          "args": [
            "mgr->activeUSBHostdevs",
            "usb"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "497-510",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceListFind(virUSBDeviceListPtr list,\n                     virUSBDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev)\n            return list->devs[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceListFind(virUSBDeviceListPtr list,\n                     virUSBDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->bus == dev->bus &&\n            list->devs[i]->dev == dev->dev)\n            return list->devs[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListCount",
          "args": [
            "list"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "466-470",
          "snippet": "size_t\nvirUSBDeviceListCount(virUSBDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nsize_t\nvirUSBDeviceListCount(virUSBDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1307
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevMarkUSBDevices(virHostdevManagerPtr mgr,\n                         const char *drv_name,\n                         const char *dom_name,\n                         virUSBDeviceListPtr list)\n{\n    size_t i, j;\n    unsigned int count;\n    virUSBDevicePtr tmp;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    count = virUSBDeviceListCount(list);\n\n    for (i = 0; i < count; i++) {\n        virUSBDevicePtr usb = virUSBDeviceListGet(list, i);\n        if ((tmp = virUSBDeviceListFind(mgr->activeUSBHostdevs, usb))) {\n            const char *other_drvname;\n            const char *other_domname;\n\n            virUSBDeviceGetUsedBy(tmp, &other_drvname, &other_domname);\n            if (other_drvname && other_domname)\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is in use by \"\n                                 \"driver %s, domain %s\"),\n                               virUSBDeviceGetName(tmp),\n                               other_drvname, other_domname);\n            else\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"USB device %s is already in use\"),\n                               virUSBDeviceGetName(tmp));\n            goto error;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n        VIR_DEBUG(\"Adding %03d.%03d dom=%s to activeUSBHostdevs\",\n                  virUSBDeviceGetBus(usb), virUSBDeviceGetDevno(usb),\n                  dom_name);\n        /*\n         * The caller is responsible to steal these usb devices\n         * from the virUSBDeviceList that passed in on success,\n         * perform rollback on failure.\n         */\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto error;\n    }\n\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return 0;\n\n error:\n    for (j = 0; j < i; j++) {\n        tmp = virUSBDeviceListGet(list, i);\n        virUSBDeviceListSteal(mgr->activeUSBHostdevs, tmp);\n    }\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return -1;\n}"
  },
  {
    "function_name": "virHostdevUpdateActiveMediatedDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1257-1294",
    "snippet": "int\nvirHostdevUpdateActiveMediatedDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr *hostdevs,\n                                      int nhostdevs,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    int ret = -1;\n    size_t i;\n    g_autoptr(virMediatedDevice) mdev = NULL;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr, mdevsrc->model)))\n            goto cleanup;\n\n        virMediatedDeviceSetUsedBy(mdev, drv_name, dom_name);\n\n        if (virMediatedDeviceListAdd(mgr->activeMediatedHostdevs, &mdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeMediatedHostdevs"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListAdd",
          "args": [
            "mgr->activeMediatedHostdevs",
            "&mdev"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "311-321",
          "snippet": "int\nvirMediatedDeviceListAdd(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr *dev)\n{\n    if (virMediatedDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s is already in use\"), (*dev)->path);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceListAdd(virMediatedDeviceListPtr list,\n                         virMediatedDevicePtr *dev)\n{\n    if (virMediatedDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s is already in use\"), (*dev)->path);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceSetUsedBy",
          "args": [
            "mdev",
            "drv_name",
            "dom_name"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "263-274",
          "snippet": "int\nvirMediatedDeviceSetUsedBy(virMediatedDevicePtr dev,\n                           const char *drvname,\n                           const char *domname)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drvname);\n    dev->used_by_domname = g_strdup(domname);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceSetUsedBy(virMediatedDevicePtr dev,\n                           const char *drvname,\n                           const char *domname)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drvname);\n    dev->used_by_domname = g_strdup(domname);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceNew",
          "args": [
            "mdevsrc->uuidstr",
            "mdevsrc->model"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "170-178",
          "snippet": "virMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvirMediatedDevicePtr\nvirMediatedDeviceNew(const char *uuidstr G_GNUC_UNUSED,\n                     virMediatedDeviceModelType model G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"mediated devices are not supported on non-linux \"\n                     \"platforms\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsMdevDevice",
          "args": [
            "hostdev"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsMdevDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32296-32301",
          "snippet": "bool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsMdevDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeMediatedHostdevs"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveMediatedDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr *hostdevs,\n                                      int nhostdevs,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    int ret = -1;\n    size_t i;\n    g_autoptr(virMediatedDevice) mdev = NULL;\n\n    if (nhostdevs == 0)\n        return 0;\n\n    virObjectLock(mgr->activeMediatedHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysMediatedDevPtr mdevsrc;\n\n        mdevsrc = &hostdev->source.subsys.u.mdev;\n\n        if (!virHostdevIsMdevDevice(hostdev))\n            continue;\n\n        if (!(mdev = virMediatedDeviceNew(mdevsrc->uuidstr, mdevsrc->model)))\n            goto cleanup;\n\n        virMediatedDeviceSetUsedBy(mdev, drv_name, dom_name);\n\n        if (virMediatedDeviceListAdd(mgr->activeMediatedHostdevs, &mdev) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeMediatedHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevUpdateActiveSCSIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1218-1254",
    "snippet": "int\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevUpdateActiveSCSIHostDevices",
          "args": [
            "mgr",
            "hostdev",
            "scsisrc",
            "drv_name",
            "dom_name"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevUpdateActiveSCSIHostDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "1189-1216",
          "snippet": "static int\nvirHostdevUpdateActiveSCSIHostDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr hostdev,\n                                      virDomainHostdevSubsysSCSIPtr scsisrc,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp = NULL;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n            return -1;\n    } else {\n        if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0 ||\n            virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n            return -1;\n        scsi = NULL;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevUpdateActiveSCSIHostDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr hostdev,\n                                      virDomainHostdevSubsysSCSIPtr scsisrc,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp = NULL;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n            return -1;\n    } else {\n        if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0 ||\n            virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n            return -1;\n        scsi = NULL;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsSCSIDevice",
          "args": [
            "hostdev"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsSCSIDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "32282-32287",
          "snippet": "bool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nbool\nvirHostdevIsSCSIDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_SCSI;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeSCSIHostdevs"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveSCSIDevices(virHostdevManagerPtr mgr,\n                                  virDomainHostdevDefPtr *hostdevs,\n                                  int nhostdevs,\n                                  const char *drv_name,\n                                  const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeSCSIHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysSCSIPtr scsisrc;\n        hostdev = hostdevs[i];\n        scsisrc = &hostdev->source.subsys.u.scsi;\n\n        if (!virHostdevIsSCSIDevice(hostdev))\n            continue;\n\n        if (scsisrc->protocol == VIR_DOMAIN_HOSTDEV_SCSI_PROTOCOL_TYPE_ISCSI) {\n            continue;  /* Not supported for iSCSI */\n        } else {\n            if (virHostdevUpdateActiveSCSIHostDevices(mgr, hostdev, scsisrc,\n                                                      drv_name, dom_name) < 0)\n                goto cleanup;\n        }\n    }\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr->activeSCSIHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevUpdateActiveSCSIHostDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1189-1216",
    "snippet": "static int\nvirHostdevUpdateActiveSCSIHostDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr hostdev,\n                                      virDomainHostdevSubsysSCSIPtr scsisrc,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp = NULL;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n            return -1;\n    } else {\n        if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0 ||\n            virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n            return -1;\n        scsi = NULL;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSCSIDeviceListAdd",
          "args": [
            "mgr->activeSCSIHostdevs",
            "scsi"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "365-377",
          "snippet": "int\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceListAdd(virSCSIDeviceListPtr list,\n                     virSCSIDevicePtr dev)\n{\n    if (virSCSIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s already exists\"),\n                       dev->name);\n        return -1;\n    }\n\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceSetUsedBy",
          "args": [
            "scsi",
            "drv_name",
            "dom_name"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "259-275",
          "snippet": "int\nvirSCSIDeviceSetUsedBy(virSCSIDevicePtr dev,\n                       const char *drvname,\n                       const char *domname)\n{\n    g_autoptr(virUsedByInfo) copy = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return -1;\n    copy->drvname = g_strdup(drvname);\n    copy->domname = g_strdup(domname);\n\n    if (VIR_APPEND_ELEMENT(dev->used_by, dev->n_used_by, copy) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirSCSIDeviceSetUsedBy(virSCSIDevicePtr dev,\n                       const char *drvname,\n                       const char *domname)\n{\n    g_autoptr(virUsedByInfo) copy = NULL;\n\n    if (VIR_ALLOC(copy) < 0)\n        return -1;\n    copy->drvname = g_strdup(drvname);\n    copy->domname = g_strdup(domname);\n\n    if (VIR_APPEND_ELEMENT(dev->used_by, dev->n_used_by, copy) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListFind",
          "args": [
            "mgr->activeSCSIHostdevs",
            "scsi"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "438-453",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirSCSIDevicePtr\nvirSCSIDeviceListFind(virSCSIDeviceListPtr list,\n                      virSCSIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        if (list->devs[i]->adapter == dev->adapter &&\n            list->devs[i]->bus == dev->bus &&\n            list->devs[i]->target == dev->target &&\n            list->devs[i]->unit == dev->unit)\n            return list->devs[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceNew",
          "args": [
            "NULL",
            "scsihostsrc->adapter",
            "scsihostsrc->bus",
            "scsihostsrc->target",
            "scsihostsrc->unit",
            "hostdev->readonly",
            "hostdev->shareable"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "172-231",
          "snippet": "virSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\n#define SYSFS_SCSI_DEVICES \"/sys/bus/scsi/devices\"\n\nvirSCSIDevicePtr\nvirSCSIDeviceNew(const char *sysfs_prefix,\n                 const char *adapter,\n                 unsigned int bus,\n                 unsigned int target,\n                 unsigned long long unit,\n                 bool readonly,\n                 bool shareable)\n{\n    g_autoptr(virSCSIDevice) dev = NULL;\n    g_autofree char *sg = NULL;\n    g_autofree char *vendor_path = NULL;\n    g_autofree char *model_path = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *model = NULL;\n    const char *prefix = sysfs_prefix ? sysfs_prefix : SYSFS_SCSI_DEVICES;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus = bus;\n    dev->target = target;\n    dev->unit = unit;\n    dev->readonly = readonly;\n    dev->shareable = shareable;\n\n    if (!(sg = virSCSIDeviceGetSgName(prefix, adapter, bus, target, unit)))\n        return NULL;\n\n    if (virSCSIDeviceGetAdapterId(adapter, &dev->adapter) < 0)\n        return NULL;\n\n    dev->name = g_strdup_printf(\"%d:%u:%u:%llu\", dev->adapter,\n                                dev->bus, dev->target, dev->unit);\n    dev->sg_path = g_strdup_printf(\"%s/%s\",\n                                   sysfs_prefix ? sysfs_prefix : \"/dev\", sg);\n\n    if (!virFileExists(dev->sg_path)) {\n        virReportSystemError(errno,\n                             _(\"SCSI device '%s': could not access %s\"),\n                             dev->name, dev->sg_path);\n        return NULL;\n    }\n\n    vendor_path = g_strdup_printf(\"%s/%s/vendor\", prefix, dev->name);\n    model_path = g_strdup_printf(\"%s/%s/model\", prefix, dev->name);\n\n    if (virFileReadAll(vendor_path, 1024, &vendor) < 0)\n        return NULL;\n\n    if (virFileReadAll(model_path, 1024, &model) < 0)\n        return NULL;\n\n    virTrimSpaces(vendor, NULL);\n    virTrimSpaces(model, NULL);\n\n    dev->id = g_strdup_printf(\"%s:%s\", vendor, model);\n\n    return g_steal_pointer(&dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevUpdateActiveSCSIHostDevices(virHostdevManagerPtr mgr,\n                                      virDomainHostdevDefPtr hostdev,\n                                      virDomainHostdevSubsysSCSIPtr scsisrc,\n                                      const char *drv_name,\n                                      const char *dom_name)\n{\n    virDomainHostdevSubsysSCSIHostPtr scsihostsrc = &scsisrc->u.host;\n    g_autoptr(virSCSIDevice) scsi = NULL;\n    virSCSIDevicePtr tmp = NULL;\n\n    if (!(scsi = virSCSIDeviceNew(NULL,\n                                  scsihostsrc->adapter, scsihostsrc->bus,\n                                  scsihostsrc->target, scsihostsrc->unit,\n                                  hostdev->readonly, hostdev->shareable)))\n        return -1;\n\n    if ((tmp = virSCSIDeviceListFind(mgr->activeSCSIHostdevs, scsi))) {\n        if (virSCSIDeviceSetUsedBy(tmp, drv_name, dom_name) < 0)\n            return -1;\n    } else {\n        if (virSCSIDeviceSetUsedBy(scsi, drv_name, dom_name) < 0 ||\n            virSCSIDeviceListAdd(mgr->activeSCSIHostdevs, scsi) < 0)\n            return -1;\n        scsi = NULL;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevUpdateActiveUSBDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1145-1187",
    "snippet": "int\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListAdd",
          "args": [
            "mgr->activeUSBHostdevs",
            "&usb"
          ],
          "line": 1179
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "442-453",
          "snippet": "int\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceListAdd(virUSBDeviceListPtr list,\n                    virUSBDevicePtr *dev)\n{\n    if (virUSBDeviceListFind(list, *dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"),\n                       (*dev)->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, *dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceSetUsedBy",
          "args": [
            "usb",
            "drv_name",
            "dom_name"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "365-376",
          "snippet": "int\nvirUSBDeviceSetUsedBy(virUSBDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nint\nvirUSBDeviceSetUsedBy(virUSBDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to reattach USB device %03d.%03d on domain %s\"",
            "usbsrc->bus",
            "usbsrc->device",
            "dom_name"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUSBDeviceNew",
          "args": [
            "usbsrc->bus",
            "usbsrc->device",
            "NULL"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "308-351",
          "snippet": "virUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nvirUSBDevicePtr\nvirUSBDeviceNew(unsigned int bus,\n                unsigned int devno,\n                const char *vroot)\n{\n    virUSBDevicePtr dev;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->bus     = bus;\n    dev->dev     = devno;\n\n    if (g_snprintf(dev->name, sizeof(dev->name), \"%.3d:%.3d\",\n                   dev->bus, dev->dev) >= sizeof(dev->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->name buffer overflow: %.3d:%.3d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    if (vroot) {\n        dev->path = g_strdup_printf(\"%s/%03d/%03d\",\n                                    vroot, dev->bus, dev->dev);\n    } else {\n        dev->path = g_strdup_printf(USB_DEVFS \"%03d/%03d\",\n                                    dev->bus, dev->dev);\n    }\n\n    /* XXX fixme. this should be product/vendor */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%d %d\", dev->bus,\n                   dev->dev) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %d %d\"),\n                       dev->bus, dev->dev);\n        virUSBDeviceFree(dev);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return dev;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->activeUSBHostdevs"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActiveUSBDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    virDomainHostdevDefPtr hostdev = NULL;\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activeUSBHostdevs);\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevSubsysUSBPtr usbsrc;\n        g_autoptr(virUSBDevice) usb = NULL;\n        hostdev = hostdevs[i];\n        usbsrc = &hostdev->source.subsys.u.usb;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB)\n            continue;\n\n        if (!(usb = virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL))) {\n            VIR_WARN(\"Unable to reattach USB device %03d.%03d on domain %s\",\n                     usbsrc->bus, usbsrc->device, dom_name);\n            continue;\n        }\n\n        virUSBDeviceSetUsedBy(usb, drv_name, dom_name);\n\n        if (virUSBDeviceListAdd(mgr->activeUSBHostdevs, &usb) < 0)\n            goto cleanup;\n        usb = NULL;\n    }\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activeUSBHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevUpdateActivePCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1099-1143",
    "snippet": "int\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "mgr->activePCIHostdevs",
            "actual"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetReprobe",
          "args": [
            "actual",
            "hostdev->origstates.states.pci.reprobe"
          ],
          "line": 1131
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetReprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1538-1542",
          "snippet": "void\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetRemoveSlot",
          "args": [
            "actual",
            "hostdev->origstates.states.pci.remove_slot"
          ],
          "line": 1130
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetRemoveSlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1526-1530",
          "snippet": "void\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUnbindFromStub",
          "args": [
            "actual",
            "hostdev->origstates.states.pci.unbind_from_stub"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1514-1518",
          "snippet": "void\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUsedBy",
          "args": [
            "actual",
            "drv_name",
            "dom_name"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1544-1555",
          "snippet": "int\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetPCIHostDevice",
          "args": [
            "hostdev",
            "&actual"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetPCIHostDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "261-286",
          "snippet": "static virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevUpdateActivePCIDevices(virHostdevManagerPtr mgr,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *drv_name,\n                                 const char *dom_name)\n{\n    size_t i;\n    int ret = -1;\n\n    if (!nhostdevs)\n        return 0;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    for (i = 0; i < nhostdevs; i++) {\n        const virDomainHostdevDef *hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) actual = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &actual) < 0)\n            goto cleanup;\n\n        if (!actual)\n            continue;\n\n        if (virPCIDeviceSetUsedBy(actual, drv_name, dom_name) < 0)\n            goto cleanup;\n\n        /* Setup the original states for the PCI device */\n        virPCIDeviceSetUnbindFromStub(actual, hostdev->origstates.states.pci.unbind_from_stub);\n        virPCIDeviceSetRemoveSlot(actual, hostdev->origstates.states.pci.remove_slot);\n        virPCIDeviceSetReprobe(actual, hostdev->origstates.states.pci.reprobe);\n\n        if (virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto cleanup;\n        actual = NULL;\n    }\n\n    ret = 0;\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevReAttachPCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "1074-1096",
    "snippet": "void\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevReAttachPCIDevicesImpl",
          "args": [
            "mgr",
            "drv_name",
            "dom_name",
            "pcidevs",
            "hostdevs",
            "nhostdevs",
            "oldStateDir"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReAttachPCIDevicesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "964-1068",
          "snippet": "static void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to allocate PCI device list: %s\")",
            "virGetLastErrorMessage()"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to allocate PCI device list: %s\""
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetPCIHostDeviceList",
          "args": [
            "hostdevs",
            "nhostdevs"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetPCIHostDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "261-286",
          "snippet": "static virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid\nvirHostdevReAttachPCIDevices(virHostdevManagerPtr mgr,\n                             const char *drv_name,\n                             const char *dom_name,\n                             virDomainHostdevDefPtr *hostdevs,\n                             int nhostdevs,\n                             const char *oldStateDir)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs))) {\n        VIR_ERROR(_(\"Failed to allocate PCI device list: %s\"),\n                  virGetLastErrorMessage());\n        virResetLastError();\n        return;\n    }\n\n    virHostdevReAttachPCIDevicesImpl(mgr, drv_name, dom_name, pcidevs,\n                                     hostdevs, nhostdevs, oldStateDir);\n}"
  },
  {
    "function_name": "virHostdevReAttachPCIDevicesImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "964-1068",
    "snippet": "static void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReattachAllPCIDevices",
          "args": [
            "mgr",
            "pcidevs"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReattachAllPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "645-674",
          "snippet": "static void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevResetAllPCIDevices",
          "args": [
            "mgr",
            "pcidevs"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevResetAllPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "620-643",
          "snippet": "static int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevRestoreNetConfig",
          "args": [
            "hostdev",
            "mgr->stateDir",
            "oldStateDir"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevRestoreNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "501-618",
          "snippet": "static int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Restoring network configuration of PCI device %s\"",
            "virPCIDeviceGetName(actual)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "actual"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFindByIDs",
          "args": [
            "mgr->inactivePCIHostdevs",
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFindByIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1687-1705",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINetDevice",
          "args": [
            "hostdev"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "353-359",
          "snippet": "static bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to add PCI device %s to the inactive list\")",
            "virGetLastErrorMessage()"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to add PCI device %s to the inactive list\""
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "mgr->inactivePCIHostdevs",
            "actual"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding PCI device %s to inactive list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListSteal",
          "args": [
            "mgr->activePCIHostdevs",
            "pci"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1656-1661",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing PCI device %s from active list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pcidevs",
            "i"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pcidevs"
          ],
          "line": 1012
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListDel",
          "args": [
            "pcidevs",
            "pci"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1663-1668",
          "snippet": "void\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "dom_name",
            "actual_domname"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "drv_name",
            "actual_drvname"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetUsedBy",
          "args": [
            "actual",
            "&actual_drvname",
            "&actual_domname"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1557-1564",
          "snippet": "void\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "mgr->activePCIHostdevs",
            "pci"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReAttachPCIDevicesImpl(virHostdevManagerPtr mgr,\n                                 const char *drv_name,\n                                 const char *dom_name,\n                                 virPCIDeviceListPtr pcidevs,\n                                 virDomainHostdevDefPtr *hostdevs,\n                                 int nhostdevs,\n                                 const char *oldStateDir)\n{\n    size_t i;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Reattaching devices to the host involves several steps; each\n     * of them is described at length below */\n\n    /* Step 1: Filter out all devices that are either not active or not\n     *         used by the current domain and driver */\n    i = 0;\n    while (i < virPCIDeviceListCount(pcidevs)) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual = NULL;\n\n        /* We need to look up the actual device, which is the one containing\n         * information such as by which domain and driver it is used. As a\n         * side effect, by looking it up we can also tell whether it was\n         * really active in the first place */\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n        if (actual) {\n            const char *actual_drvname;\n            const char *actual_domname;\n            virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n            if (STRNEQ_NULLABLE(drv_name, actual_drvname) ||\n                STRNEQ_NULLABLE(dom_name, actual_domname)) {\n\n                virPCIDeviceListDel(pcidevs, pci);\n                continue;\n            }\n        } else {\n            virPCIDeviceListDel(pcidevs, pci);\n            continue;\n        }\n\n        i++;\n    }\n\n    /* Step 2: Move devices from the active list to the inactive list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual ||\n            virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0) {\n\n            VIR_ERROR(_(\"Failed to add PCI device %s to the inactive list\"),\n                      virGetLastErrorMessage());\n            virResetLastError();\n        }\n    }\n\n    /* At this point, any device that had been used by the guest has been\n     * moved to the inactive list */\n\n    /* Step 3: restore original network config of hostdevs that used\n     * <interface type='hostdev'>\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n\n        if (virHostdevIsPCINetDevice(hostdev)) {\n            virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n            virPCIDevicePtr actual;\n\n            actual = virPCIDeviceListFindByIDs(mgr->inactivePCIHostdevs,\n                                               pcisrc->addr.domain,\n                                               pcisrc->addr.bus,\n                                               pcisrc->addr.slot,\n                                               pcisrc->addr.function);\n\n            if (actual) {\n                VIR_DEBUG(\"Restoring network configuration of PCI device %s\",\n                          virPCIDeviceGetName(actual));\n                virHostdevRestoreNetConfig(hostdev, mgr->stateDir,\n                                           oldStateDir);\n            }\n        }\n    }\n\n    /* Step 4: perform a PCI Reset on all devices */\n    virHostdevResetAllPCIDevices(mgr, pcidevs);\n\n    /* Step 5: Reattach managed devices to their host drivers; unmanaged\n     *         devices don't need to be processed further */\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n}"
  },
  {
    "function_name": "virHostdevPreparePCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "942-961",
    "snippet": "int\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevPreparePCIDevicesImpl",
          "args": [
            "mgr",
            "drv_name",
            "dom_name",
            "uuid",
            "pcidevs",
            "hostdevs",
            "nhostdevs",
            "flags"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPreparePCIDevicesImpl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "677-939",
          "snippet": "static int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetPCIHostDeviceList",
          "args": [
            "hostdevs",
            "nhostdevs"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetPCIHostDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "261-286",
          "snippet": "static virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirHostdevPreparePCIDevices(virHostdevManagerPtr mgr,\n                            const char *drv_name,\n                            const char *dom_name,\n                            const unsigned char *uuid,\n                            virDomainHostdevDefPtr *hostdevs,\n                            int nhostdevs,\n                            unsigned int flags)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n\n    if (!nhostdevs)\n        return 0;\n\n    if (!(pcidevs = virHostdevGetPCIHostDeviceList(hostdevs, nhostdevs)))\n        return -1;\n\n    return virHostdevPreparePCIDevicesImpl(mgr, drv_name, dom_name, uuid,\n                                           pcidevs, hostdevs, nhostdevs, flags);\n}"
  },
  {
    "function_name": "virHostdevPreparePCIDevicesImpl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "677-939",
    "snippet": "static int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevReattachAllPCIDevices",
          "args": [
            "mgr",
            "pcidevs"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevReattachAllPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "645-674",
          "snippet": "static void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevRestoreNetConfig",
          "args": [
            "hostdevs[i]",
            "mgr->stateDir",
            "NULL"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevRestoreNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "501-618",
          "snippet": "static int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to add PCI device %s to the inactive list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "pci"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "mgr->inactivePCIHostdevs",
            "actual"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding PCI device %s to inactive list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListSteal",
          "args": [
            "mgr->activePCIHostdevs",
            "pci"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1656-1661",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing PCI device %s from active list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pcidevs",
            "i"
          ],
          "line": 910
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pcidevs"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetReprobe",
          "args": [
            "actual"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetReprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1532-1536",
          "snippet": "bool\nvirPCIDeviceGetReprobe(virPCIDevicePtr dev)\n{\n    return dev->reprobe;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetReprobe(virPCIDevicePtr dev)\n{\n    return dev->reprobe;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetRemoveSlot",
          "args": [
            "actual"
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetRemoveSlot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1520-1524",
          "snippet": "bool\nvirPCIDeviceGetRemoveSlot(virPCIDevicePtr dev)\n{\n    return dev->remove_slot;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetRemoveSlot(virPCIDevicePtr dev)\n{\n    return dev->remove_slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetUnbindFromStub",
          "args": [
            "actual"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1508-1512",
          "snippet": "bool\nvirPCIDeviceGetUnbindFromStub(virPCIDevicePtr dev)\n{\n    return dev->unbind_from_stub;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetUnbindFromStub(virPCIDevicePtr dev)\n{\n    return dev->unbind_from_stub;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Saving network configuration of PCI device %s\"",
            "virPCIDeviceGetName(actual)"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFindByIDs",
          "args": [
            "mgr->activePCIHostdevs",
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFindByIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1687-1705",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetUsedBy",
          "args": [
            "actual",
            "drv_name",
            "dom_name"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1544-1555",
          "snippet": "int\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Setting driver and domain information for PCI device %s\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "mgr->activePCIHostdevs",
            "pci"
          ],
          "line": 860
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding PCI device %s to active list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing PCI device %s from inactive list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostdevSetNetConfig",
          "args": [
            "hostdevs[i]",
            "uuid"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevSetNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "454-491",
          "snippet": "static int\nvirHostdevSetNetConfig(virDomainHostdevDefPtr hostdev,\n                       const unsigned char *uuid)\n{\n    g_autofree char *linkdev = NULL;\n    const virNetDevVlan *vlan;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = true;\n\n    if (!virHostdevIsPCINetDevice(hostdev))\n        return 0;\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    vlan = virDomainNetGetActualVlan(hostdev->parentnet);\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        if (vlan) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\"),\n                           virNetDevVPortTypeToString(virtPort->virtPortType));\n            return -1;\n        }\n        if (virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                               &hostdev->parentnet->mac,\n                                               uuid, port_profile_associate) < 0)\n            return -1;\n    } else {\n        if (virNetDevSetNetConfig(linkdev, vf, &hostdev->parentnet->mac,\n                                  vlan, NULL, true) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevSetNetConfig(virDomainHostdevDefPtr hostdev,\n                       const unsigned char *uuid)\n{\n    g_autofree char *linkdev = NULL;\n    const virNetDevVlan *vlan;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = true;\n\n    if (!virHostdevIsPCINetDevice(hostdev))\n        return 0;\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    vlan = virDomainNetGetActualVlan(hostdev->parentnet);\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        if (vlan) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\"),\n                           virNetDevVPortTypeToString(virtPort->virtPortType));\n            return -1;\n        }\n        if (virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                               &hostdev->parentnet->mac,\n                                               uuid, port_profile_associate) < 0)\n            return -1;\n    } else {\n        if (virNetDevSetNetConfig(linkdev, vf, &hostdev->parentnet->mac,\n                                  vlan, NULL, true) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevResetAllPCIDevices",
          "args": [
            "mgr",
            "pcidevs"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevResetAllPCIDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "620-643",
          "snippet": "static int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\")",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\""
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding PCI device %s to inactive list\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetStubDriver",
          "args": [
            "pci",
            "stub"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetStubDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1496-1500",
          "snippet": "void\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIStubDriverTypeFromString",
          "args": [
            "driverName"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetDriverPathAndName",
          "args": [
            "pci",
            "&driverPath",
            "&driverName"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetDriverPathAndName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "236-276",
          "snippet": "int\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Not detaching unmanaged PCI device %s\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceDetach",
          "args": [
            "pci",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceDetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1199-1226",
          "snippet": "int\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Detaching managed PCI device %s\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetManaged",
          "args": [
            "pci"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetManaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1490-1494",
          "snippet": "bool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevSaveNetConfig",
          "args": [
            "hostdevs[i]",
            "mgr->stateDir"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevSaveNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "415-440",
          "snippet": "static int\nvirHostdevSaveNetConfig(virDomainHostdevDefPtr hostdev,\n                        const char *stateDir)\n{\n    g_autofree char *linkdev = NULL;\n    int vf = -1;\n\n    if (!virHostdevIsPCINetDevice(hostdev) ||\n        virDomainNetGetActualVirtPortProfile(hostdev->parentnet))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    if (virNetDevSaveNetConfig(linkdev, vf, stateDir, true) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevSaveNetConfig(virDomainHostdevDefPtr hostdev,\n                        const char *stateDir)\n{\n    g_autofree char *linkdev = NULL;\n    int vf = -1;\n\n    if (!virHostdevIsPCINetDevice(hostdev) ||\n        virDomainNetGetActualVirtPortProfile(hostdev->parentnet))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    if (virNetDevSaveNetConfig(linkdev, vf, stateDir, true) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressIOMMUGroupIterate",
          "args": [
            "devAddr",
            "virHostdevIsPCINodeDeviceUsed",
            "&data"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressIOMMUGroupIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1770-1811",
          "snippet": "int\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINodeDeviceUsed",
          "args": [
            "devAddr",
            "&data"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINodeDeviceUsed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "79-111",
          "snippet": "static int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetAddress",
          "args": [
            "pci"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetAddress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1461-1465",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"PCI device %s is not assignable\")",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceIsAssignable",
          "args": [
            "pci",
            "strict_acs_check"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIsAssignable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2095-2123",
          "snippet": "int virPCIDeviceIsAssignable(virPCIDevicePtr dev,\n                             int strict_acs_check)\n{\n    int ret;\n\n    /* XXX This could be a great place to actually check that a non-managed\n     * device isn't in use, e.g. by checking that device is either un-bound\n     * or bound to a stub driver.\n     */\n\n    ret = virPCIDeviceIsBehindSwitchLackingACS(dev);\n    if (ret < 0)\n        return 0;\n\n    if (ret) {\n        if (!strict_acs_check) {\n            VIR_DEBUG(\"%s %s: strict ACS check disabled; device assignment allowed\",\n                      dev->id, dev->name);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\"),\n                           dev->name);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceIsAssignable(virPCIDevicePtr dev,\n                             int strict_acs_check)\n{\n    int ret;\n\n    /* XXX This could be a great place to actually check that a non-managed\n     * device isn't in use, e.g. by checking that device is either un-bound\n     * or bound to a stub driver.\n     */\n\n    ret = virPCIDeviceIsBehindSwitchLackingACS(dev);\n    if (ret < 0)\n        return 0;\n\n    if (ret) {\n        if (!strict_acs_check) {\n            VIR_DEBUG(\"%s %s: strict ACS check disabled; device assignment allowed\",\n                      dev->id, dev->name);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\"),\n                           dev->name);\n            return 0;\n        }\n    }\n\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\")"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIGetHeaderType",
          "args": [
            "pci",
            "&hdrType"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetHeaderType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2812-2837",
          "snippet": "int virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_HEADER_TYPE_MASK   0x7f",
            "#define PCI_HEADER_TYPE         0x0e    /* Header type */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_HEADER_TYPE_MASK   0x7f\n#define PCI_HEADER_TYPE         0x0e    /* Header type */\n\nint virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetStubDriver",
          "args": [
            "pci"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetStubDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1502-1506",
          "snippet": "virPCIStubDriver\nvirPCIDeviceGetStubDriver(virPCIDevicePtr dev)\n{\n    return dev->stubDriver;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIStubDriver\nvirPCIDeviceGetStubDriver(virPCIDevicePtr dev)\n{\n    return dev->stubDriver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr->inactivePCIHostdevs"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPreparePCIDevicesImpl(virHostdevManagerPtr mgr,\n                                const char *drv_name,\n                                const char *dom_name,\n                                const unsigned char *uuid,\n                                virPCIDeviceListPtr pcidevs,\n                                virDomainHostdevDefPtr *hostdevs,\n                                int nhostdevs,\n                                unsigned int flags)\n{\n    int last_processed_hostdev_vf = -1;\n    size_t i;\n    int ret = -1;\n    virPCIDeviceAddressPtr devAddr = NULL;\n\n    virObjectLock(mgr->activePCIHostdevs);\n    virObjectLock(mgr->inactivePCIHostdevs);\n\n    /* Detaching devices from the host involves several steps; each\n     * of them is described at length below.\n     *\n     * All devices must be detached before we reset any of them,\n     * because in some cases you have to reset the whole PCI, which\n     * impacts all devices on it. Also, all devices must be reset\n     * before being marked as active */\n\n    /* Step 1: Perform some initial checks on the devices */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        bool strict_acs_check = !!(flags & VIR_HOSTDEV_STRICT_ACS_CHECK);\n        bool usesVFIO = (virPCIDeviceGetStubDriver(pci) == VIR_PCI_STUB_DRIVER_VFIO);\n        struct virHostdevIsPCINodeDeviceUsedData data = {mgr, drv_name, dom_name, false};\n        int hdrType = -1;\n\n        if (virPCIGetHeaderType(pci, &hdrType) < 0)\n            goto cleanup;\n\n        if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Non-endpoint PCI devices cannot be assigned \"\n                             \"to guests\"));\n            goto cleanup;\n        }\n\n        if (!usesVFIO && !virPCIDeviceIsAssignable(pci, strict_acs_check)) {\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is not assignable\"),\n                           virPCIDeviceGetName(pci));\n            goto cleanup;\n        }\n\n        /* The device is in use by other active domain if\n         * the dev is in list activePCIHostdevs. */\n        devAddr = virPCIDeviceGetAddress(pci);\n        if (virHostdevIsPCINodeDeviceUsed(devAddr, &data))\n            goto cleanup;\n\n        /* VFIO devices belonging to same IOMMU group can't be\n         * shared across guests. Check if that's the case. */\n        if (usesVFIO) {\n            data.usesVFIO = true;\n            if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                                     virHostdevIsPCINodeDeviceUsed,\n                                                     &data) < 0)\n                goto cleanup;\n        }\n    }\n\n    /* Step 1.5: For non-802.11Qbh SRIOV network devices, save the\n     * current device config\n     */\n    for (i = 0; i < nhostdevs; i++) {\n        if (virHostdevSaveNetConfig(hostdevs[i], mgr->stateDir) < 0)\n            goto cleanup;\n    }\n\n    /* Step 2: detach managed devices and make sure unmanaged devices\n     *         have already been taken care of */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        if (virPCIDeviceGetManaged(pci)) {\n\n            /* We can't look up the actual device because it has not been\n             * created yet: virPCIDeviceDetach() will insert a copy of 'pci'\n             * into the list of inactive devices, and that copy will be the\n             * actual device going forward */\n            VIR_DEBUG(\"Detaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceDetach(pci,\n                                   mgr->activePCIHostdevs,\n                                   mgr->inactivePCIHostdevs) < 0)\n                goto reattachdevs;\n        } else {\n            g_autofree char *driverPath = NULL;\n            g_autofree char *driverName = NULL;\n            int stub;\n\n            /* Unmanaged devices should already have been marked as\n             * inactive: if that's the case, we can simply move on */\n            if (virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)) {\n                VIR_DEBUG(\"Not detaching unmanaged PCI device %s\",\n                          virPCIDeviceGetName(pci));\n                continue;\n            }\n\n            /* If that's not the case, though, it might be because the\n             * daemon has been restarted, causing us to lose track of the\n             * device. Try and recover by marking the device as inactive\n             * if it happens to be bound to a known stub driver.\n             *\n             * FIXME Get rid of this once a proper way to keep track of\n             *       information about active / inactive device across\n             *       daemon restarts has been implemented */\n\n            if (virPCIDeviceGetDriverPathAndName(pci,\n                                                 &driverPath, &driverName) < 0)\n                goto reattachdevs;\n\n            stub = virPCIStubDriverTypeFromString(driverName);\n\n            if (stub > VIR_PCI_STUB_DRIVER_NONE &&\n                stub < VIR_PCI_STUB_DRIVER_LAST) {\n\n                /* The device is bound to a known stub driver: store this\n                 * information and add a copy to the inactive list */\n                virPCIDeviceSetStubDriver(pci, stub);\n\n                VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                          virPCIDeviceGetName(pci));\n                if (virPCIDeviceListAddCopy(mgr->inactivePCIHostdevs, pci) < 0)\n                    goto reattachdevs;\n            } else {\n                virReportError(VIR_ERR_OPERATION_INVALID,\n                               _(\"Unmanaged PCI device %s must be manually \"\n                                 \"detached from the host\"),\n                               virPCIDeviceGetName(pci));\n                goto reattachdevs;\n            }\n        }\n    }\n\n    /* At this point, all devices are attached to the stub driver and have\n     * been marked as inactive */\n\n    /* Step 3: Now that all the PCI hostdevs have been detached, we\n     * can safely reset them */\n    if (virHostdevResetAllPCIDevices(mgr, pcidevs) < 0)\n        goto reattachdevs;\n\n    /* Step 4: For SRIOV network devices, Now that we have detached the\n     * the network device, set the new netdev config */\n    for (i = 0; i < nhostdevs; i++) {\n\n        if (virHostdevSetNetConfig(hostdevs[i], uuid) < 0)\n            goto resetvfnetconfig;\n\n        last_processed_hostdev_vf = i;\n    }\n\n    /* Step 5: Move devices from the inactive list to the active list */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\",\n                  virPCIDeviceGetName(pci));\n        actual = virPCIDeviceListSteal(mgr->inactivePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Adding PCI device %s to active list\",\n                  virPCIDeviceGetName(pci));\n        if (!actual || virPCIDeviceListAdd(mgr->activePCIHostdevs, actual) < 0)\n            goto inactivedevs;\n    }\n\n    /* Step 6: Set driver and domain information */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci, actual;\n\n        /* We need to look up the actual device and set the information\n         * there because 'pci' only contain address information and will\n         * be released at the end of the function */\n        pci = virPCIDeviceListGet(pcidevs, i);\n        actual = virPCIDeviceListFind(mgr->activePCIHostdevs, pci);\n\n        VIR_DEBUG(\"Setting driver and domain information for PCI device %s\",\n                  virPCIDeviceGetName(pci));\n        if (actual)\n            virPCIDeviceSetUsedBy(actual, drv_name, dom_name);\n    }\n\n    /* Step 7: Now set the original states for hostdev def */\n    for (i = 0; i < nhostdevs; i++) {\n        virPCIDevicePtr actual;\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        virDomainHostdevSubsysPCIPtr pcisrc = &hostdev->source.subsys.u.pci;\n\n        if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS)\n            continue;\n        if (hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n            continue;\n\n        /* We need to look up the actual device because it's the one\n         * that contains the information we care about (unbind_from_stub,\n         * remove_slot, reprobe) */\n        actual = virPCIDeviceListFindByIDs(mgr->activePCIHostdevs,\n                                           pcisrc->addr.domain,\n                                           pcisrc->addr.bus,\n                                           pcisrc->addr.slot,\n                                           pcisrc->addr.function);\n\n        /* Appropriate values for the unbind_from_stub, remove_slot\n         * and reprobe properties of the device were set earlier\n         * by virPCIDeviceDetach() */\n        if (actual) {\n            VIR_DEBUG(\"Saving network configuration of PCI device %s\",\n                      virPCIDeviceGetName(actual));\n            hostdev->origstates.states.pci.unbind_from_stub =\n                virPCIDeviceGetUnbindFromStub(actual);\n            hostdev->origstates.states.pci.remove_slot =\n                virPCIDeviceGetRemoveSlot(actual);\n            hostdev->origstates.states.pci.reprobe =\n                virPCIDeviceGetReprobe(actual);\n        }\n    }\n\n    ret = 0;\n    goto cleanup;\n\n inactivedevs:\n    /* Move devices back to the inactive list so that they can be\n     * processed properly below (reattachdevs label) */\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        VIR_DEBUG(\"Removing PCI device %s from active list\",\n                  virPCIDeviceGetName(pci));\n        if (!(actual = virPCIDeviceListSteal(mgr->activePCIHostdevs, pci)))\n            continue;\n\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\",\n                  virPCIDeviceGetName(pci));\n        if (virPCIDeviceListAdd(mgr->inactivePCIHostdevs, actual) < 0)\n            VIR_WARN(\"Failed to add PCI device %s to the inactive list\",\n                     virPCIDeviceGetName(pci));\n    }\n\n resetvfnetconfig:\n    if (last_processed_hostdev_vf >= 0) {\n        for (i = 0; i <= last_processed_hostdev_vf; i++)\n            virHostdevRestoreNetConfig(hostdevs[i], mgr->stateDir, NULL);\n    }\n\n reattachdevs:\n    virHostdevReattachAllPCIDevices(mgr, pcidevs);\n\n cleanup:\n    virObjectUnlock(mgr->activePCIHostdevs);\n    virObjectUnlock(mgr->inactivePCIHostdevs);\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevReattachAllPCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "645-674",
    "snippet": "static void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Not reattaching unmanaged PCI device %s\"",
            "virPCIDeviceGetName(actual)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "actual"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to re-attach PCI device: %s\")",
            "virGetLastErrorMessage()"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to re-attach PCI device: %s\""
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReattach",
          "args": [
            "actual",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReattach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1232-1253",
          "snippet": "int\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reattaching managed PCI device %s\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetManaged",
          "args": [
            "actual"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetManaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1490-1494",
          "snippet": "bool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "mgr->inactivePCIHostdevs",
            "pci"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pcidevs",
            "i"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pcidevs"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void\nvirHostdevReattachAllPCIDevices(virHostdevManagerPtr mgr,\n                                virPCIDeviceListPtr pcidevs)\n{\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n        virPCIDevicePtr actual;\n\n        /* We need to look up the actual device because that's what\n         * virPCIDeviceReattach() expects as its argument */\n        if (!(actual = virPCIDeviceListFind(mgr->inactivePCIHostdevs, pci)))\n            continue;\n\n        if (virPCIDeviceGetManaged(actual)) {\n            VIR_DEBUG(\"Reattaching managed PCI device %s\",\n                      virPCIDeviceGetName(pci));\n            if (virPCIDeviceReattach(actual,\n                                     mgr->activePCIHostdevs,\n                                     mgr->inactivePCIHostdevs) < 0) {\n                VIR_ERROR(_(\"Failed to re-attach PCI device: %s\"),\n                          virGetLastErrorMessage());\n            }\n        } else {\n            VIR_DEBUG(\"Not reattaching unmanaged PCI device %s\",\n                      virPCIDeviceGetName(actual));\n        }\n    }\n}"
  },
  {
    "function_name": "virHostdevResetAllPCIDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "620-643",
    "snippet": "static int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to reset PCI device: %s\")",
            "virGetLastErrorMessage()"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetLastErrorMessage",
          "args": [],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to reset PCI device: %s\""
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReset",
          "args": [
            "pci",
            "mgr->activePCIHostdevs",
            "mgr->inactivePCIHostdevs"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "909-990",
          "snippet": "int\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Resetting PCI device %s\"",
            "virPCIDeviceGetName(pci)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "pci"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListGet",
          "args": [
            "pcidevs",
            "i"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListGet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1624-1634",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListCount",
          "args": [
            "pcidevs"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListCount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1636-1640",
          "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevResetAllPCIDevices(virHostdevManagerPtr mgr,\n                             virPCIDeviceListPtr pcidevs)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < virPCIDeviceListCount(pcidevs); i++) {\n        virPCIDevicePtr pci = virPCIDeviceListGet(pcidevs, i);\n\n        /* We can avoid looking up the actual device here, because performing\n         * a PCI reset on a device doesn't require any information other than\n         * the address, which 'pci' already contains */\n        VIR_DEBUG(\"Resetting PCI device %s\", virPCIDeviceGetName(pci));\n        if (virPCIDeviceReset(pci, mgr->activePCIHostdevs,\n                              mgr->inactivePCIHostdevs) < 0) {\n            VIR_ERROR(_(\"Failed to reset PCI device: %s\"),\n                      virGetLastErrorMessage());\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevRestoreNetConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "501-618",
    "snippet": "static int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevSetNetConfig",
          "args": [
            "linkdev",
            "vf",
            "adminMAC",
            "vlan",
            "MAC",
            "true"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2384-2395",
          "snippet": "int\nvirNetDevSetNetConfig(const char *linkdev G_GNUC_UNUSED,\n                      int vf G_GNUC_UNUSED,\n                      const virMacAddr *adminMAC G_GNUC_UNUSED,\n                      const virNetDevVlan *vlan G_GNUC_UNUSED,\n                      const virMacAddr *MAC G_GNUC_UNUSED,\n                      bool setVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set net device config on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetNetConfig(const char *linkdev G_GNUC_UNUSED,\n                      int vf G_GNUC_UNUSED,\n                      const virMacAddr *adminMAC G_GNUC_UNUSED,\n                      const virNetDevVlan *vlan G_GNUC_UNUSED,\n                      const virMacAddr *MAC G_GNUC_UNUSED,\n                      bool setVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set net device config on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "adminMAC"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevReadNetConfig",
          "args": [
            "linkdev",
            "vf",
            "stateDir",
            "&adminMAC",
            "&vlan",
            "&MAC"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevReadNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2370-2381",
          "snippet": "int\nvirNetDevReadNetConfig(const char *linkdev G_GNUC_UNUSED,\n                       int vf G_GNUC_UNUSED,\n                       const char *stateDir G_GNUC_UNUSED,\n                       virMacAddrPtr *adminMAC G_GNUC_UNUSED,\n                       virNetDevVlanPtr *vlan G_GNUC_UNUSED,\n                       virMacAddrPtr *MAC G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to read net device config on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevReadNetConfig(const char *linkdev G_GNUC_UNUSED,\n                       int vf G_GNUC_UNUSED,\n                       const char *stateDir G_GNUC_UNUSED,\n                       virMacAddrPtr *adminMAC G_GNUC_UNUSED,\n                       virNetDevVlanPtr *vlan G_GNUC_UNUSED,\n                       virMacAddrPtr *MAC G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to read net device config on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevNetDevice",
          "args": [
            "hostdev",
            "1",
            "&linkdev",
            "&vf"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevNetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "315-350",
          "snippet": "static int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "linkdev"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHostdevNetConfigVirtPortProfile",
          "args": [
            "linkdev",
            "vf",
            "virtPort",
            "&hostdev->parentnet->mac",
            "NULL",
            "port_profile_associate"
          ],
          "line": 533
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevNetConfigVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "362-399",
          "snippet": "static int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "hostdev->parentnet"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\")"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\""
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsVirtualFunction",
          "args": [
            "hostdev"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "303-312",
          "snippet": "static int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINetDevice",
          "args": [
            "hostdev"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "353-359",
          "snippet": "static bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevRestoreNetConfig(virDomainHostdevDefPtr hostdev,\n                           const char *stateDir,\n                           const char *oldStateDir)\n{\n    g_autofree char *linkdev = NULL;\n    g_autofree virMacAddrPtr MAC = NULL;\n    g_autofree virMacAddrPtr adminMAC = NULL;\n    g_autoptr(virNetDevVlan) vlan = NULL;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = false;\n\n\n    /* This is only needed for PCI devices that have been defined\n     * using <interface type='hostdev'>. For all others, it is a NOP.\n     */\n    if (!virHostdevIsPCINetDevice(hostdev))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, 0, &linkdev, &vf) < 0)\n        return -1;\n\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        return virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                                  &hostdev->parentnet->mac,\n                                                  NULL,\n                                                  port_profile_associate);\n    } else {\n        /* we need to try 3 different places for the config file:\n         * 1) ${stateDir}/${PF}_vf${vf}\n         *    This is almost always where the saved config is\n         *\n         * 2) ${oldStateDir/${PF}_vf${vf}\n         *    saved config is only here if this machine was running a\n         *    (by now *very*) old version of libvirt that saved the\n         *    file in a different directory\n         *\n         * 3) ${stateDir}${PF[1]}_vf${VF}\n         *    PF[1] means \"the netdev for port 2 of the PF device\", and\n         *    is only valid when the PF is a Mellanox dual port NIC with\n         *    a VF that was created in \"single port\" mode.\n         *\n         *  NB: if virNetDevReadNetConfig() returns < 0, then it found\n         *  the file, but there was a problem, so we should\n         *  immediately return an error to our caller. If it returns\n         *  0, but all of the interesting stuff is NULL, that means\n         *  the file wasn't found, so we can/should check other\n         *  locations for it.\n         */\n\n        /* 1) standard location */\n        if (virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 2) \"old\" (pre-1.2.3 circa 2014) location - whenever we get\n        *  to the point that nobody will ever upgrade directly from\n        *  1.2.3 (or older) directly to current libvirt, we can\n        *  eliminate this clause\n        **/\n        if (!(adminMAC || vlan || MAC) && oldStateDir &&\n            virNetDevReadNetConfig(linkdev, vf, oldStateDir,\n                                   &adminMAC, &vlan, &MAC) < 0) {\n            return -1;\n        }\n\n        /* 3) try using the PF's \"port 2\" netdev as the name of the\n         * config file\n         */\n        if (!(adminMAC || vlan || MAC)) {\n            VIR_FREE(linkdev);\n\n            if (virHostdevNetDevice(hostdev, 1, &linkdev, &vf) < 0 ||\n                virNetDevReadNetConfig(linkdev, vf, stateDir,\n                                       &adminMAC, &vlan, &MAC) < 0) {\n                return -1;\n            }\n        }\n\n        /* if a MAC was stored for the VF, we should now restore\n         * that as the adminMAC. We have to do it this way because\n         * the VF is still not bound to the host's net driver, so\n         * we can't directly set its MAC (and even after it is\n         * re-bound to the host net driver, it will still have its\n         * \"administratively set\" flag on, and that prohibits the\n         * VF's net driver from directly setting the MAC\n         * anyway). But it we set the desired VF MAC as the \"admin\n         * MAC\" *now*, then when the VF is re-bound to the host\n         * net driver (which will happen soon after returning from\n         * this function), that adminMAC will be set (by the PF)\n         * as the VF's new initial MAC.\n         *\n         * If no MAC was stored for the VF, that means it wasn't\n         * bound to a net driver before we used it anyway, so the\n         * adminMAC is all we have, and we can just restore it\n         * directly.\n         */\n        if (MAC) {\n            VIR_FREE(adminMAC);\n            adminMAC = MAC;\n            MAC = NULL;\n        }\n\n        ignore_value(virNetDevSetNetConfig(linkdev, vf,\n                                           adminMAC, vlan, MAC, true));\n        return 0;\n    }\n}"
  },
  {
    "function_name": "virHostdevSetNetConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "454-491",
    "snippet": "static int\nvirHostdevSetNetConfig(virDomainHostdevDefPtr hostdev,\n                       const unsigned char *uuid)\n{\n    g_autofree char *linkdev = NULL;\n    const virNetDevVlan *vlan;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = true;\n\n    if (!virHostdevIsPCINetDevice(hostdev))\n        return 0;\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    vlan = virDomainNetGetActualVlan(hostdev->parentnet);\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        if (vlan) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\"),\n                           virNetDevVPortTypeToString(virtPort->virtPortType));\n            return -1;\n        }\n        if (virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                               &hostdev->parentnet->mac,\n                                               uuid, port_profile_associate) < 0)\n            return -1;\n    } else {\n        if (virNetDevSetNetConfig(linkdev, vf, &hostdev->parentnet->mac,\n                                  vlan, NULL, true) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevSetNetConfig",
          "args": [
            "linkdev",
            "vf",
            "&hostdev->parentnet->mac",
            "vlan",
            "NULL",
            "true"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2384-2395",
          "snippet": "int\nvirNetDevSetNetConfig(const char *linkdev G_GNUC_UNUSED,\n                      int vf G_GNUC_UNUSED,\n                      const virMacAddr *adminMAC G_GNUC_UNUSED,\n                      const virNetDevVlan *vlan G_GNUC_UNUSED,\n                      const virMacAddr *MAC G_GNUC_UNUSED,\n                      bool setVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set net device config on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetNetConfig(const char *linkdev G_GNUC_UNUSED,\n                      int vf G_GNUC_UNUSED,\n                      const virMacAddr *adminMAC G_GNUC_UNUSED,\n                      const virNetDevVlan *vlan G_GNUC_UNUSED,\n                      const virMacAddr *MAC G_GNUC_UNUSED,\n                      bool setVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to set net device config on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevNetConfigVirtPortProfile",
          "args": [
            "linkdev",
            "vf",
            "virtPort",
            "&hostdev->parentnet->mac",
            "uuid",
            "port_profile_associate"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevNetConfigVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "362-399",
          "snippet": "static int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\")",
            "virNetDevVPortTypeToString(virtPort->virtPortType)"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "virtPort->virtPortType"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\""
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "hostdev->parentnet"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVlan",
          "args": [
            "hostdev->parentnet"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30269-30284",
          "snippet": "const virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVlan *\nvirDomainNetGetActualVlan(const virDomainNetDef *iface)\n{\n    const virNetDevVlan *vlan = &iface->vlan;\n\n    /* if there is an ActualNetDef, *always* return\n     * its vlan rather than the NetDef's vlan.\n     */\n    if (iface->type == VIR_DOMAIN_NET_TYPE_NETWORK &&\n        iface->data.network.actual)\n        vlan = &iface->data.network.actual->vlan;\n\n    if (vlan->nTags > 0)\n        return vlan;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevNetDevice",
          "args": [
            "hostdev",
            "-1",
            "&linkdev",
            "&vf"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevNetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "315-350",
          "snippet": "static int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINetDevice",
          "args": [
            "hostdev"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "353-359",
          "snippet": "static bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevSetNetConfig(virDomainHostdevDefPtr hostdev,\n                       const unsigned char *uuid)\n{\n    g_autofree char *linkdev = NULL;\n    const virNetDevVlan *vlan;\n    const virNetDevVPortProfile *virtPort;\n    int vf = -1;\n    bool port_profile_associate = true;\n\n    if (!virHostdevIsPCINetDevice(hostdev))\n        return 0;\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    vlan = virDomainNetGetActualVlan(hostdev->parentnet);\n    virtPort = virDomainNetGetActualVirtPortProfile(hostdev->parentnet);\n    if (virtPort) {\n        if (vlan) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"direct setting of the vlan tag is not allowed \"\n                             \"for hostdev devices using %s mode\"),\n                           virNetDevVPortTypeToString(virtPort->virtPortType));\n            return -1;\n        }\n        if (virHostdevNetConfigVirtPortProfile(linkdev, vf, virtPort,\n                                               &hostdev->parentnet->mac,\n                                               uuid, port_profile_associate) < 0)\n            return -1;\n    } else {\n        if (virNetDevSetNetConfig(linkdev, vf, &hostdev->parentnet->mac,\n                                  vlan, NULL, true) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevSaveNetConfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "415-440",
    "snippet": "static int\nvirHostdevSaveNetConfig(virDomainHostdevDefPtr hostdev,\n                        const char *stateDir)\n{\n    g_autofree char *linkdev = NULL;\n    int vf = -1;\n\n    if (!virHostdevIsPCINetDevice(hostdev) ||\n        virDomainNetGetActualVirtPortProfile(hostdev->parentnet))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    if (virNetDevSaveNetConfig(linkdev, vf, stateDir, true) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevSaveNetConfig",
          "args": [
            "linkdev",
            "vf",
            "stateDir",
            "true"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSaveNetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "2358-2367",
          "snippet": "int\nvirNetDevSaveNetConfig(const char *linkdev G_GNUC_UNUSED,\n                       int vf G_GNUC_UNUSED,\n                       const char *stateDir G_GNUC_UNUSED,\n                       bool saveVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to save net device config on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSaveNetConfig(const char *linkdev G_GNUC_UNUSED,\n                       int vf G_GNUC_UNUSED,\n                       const char *stateDir G_GNUC_UNUSED,\n                       bool saveVlan G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to save net device config on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevNetDevice",
          "args": [
            "hostdev",
            "-1",
            "&linkdev",
            "&vf"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevNetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "315-350",
          "snippet": "static int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\")"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\""
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsVirtualFunction",
          "args": [
            "hostdev"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "303-312",
          "snippet": "static int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainNetGetActualVirtPortProfile",
          "args": [
            "hostdev->parentnet"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainNetGetActualVirtPortProfile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30224-30255",
          "snippet": "const virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst virNetDevVPortProfile *\nvirDomainNetGetActualVirtPortProfile(const virDomainNetDef *iface)\n{\n    switch (iface->type) {\n    case VIR_DOMAIN_NET_TYPE_DIRECT:\n    case VIR_DOMAIN_NET_TYPE_BRIDGE:\n    case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n        return iface->virtPortProfile;\n    case VIR_DOMAIN_NET_TYPE_NETWORK:\n        if (!iface->data.network.actual)\n            return NULL;\n        switch (iface->data.network.actual->type) {\n        case VIR_DOMAIN_NET_TYPE_DIRECT:\n        case VIR_DOMAIN_NET_TYPE_BRIDGE:\n        case VIR_DOMAIN_NET_TYPE_HOSTDEV:\n            return iface->data.network.actual->virtPortProfile;\n        default:\n            return NULL;\n        }\n    case VIR_DOMAIN_NET_TYPE_USER:\n    case VIR_DOMAIN_NET_TYPE_ETHERNET:\n    case VIR_DOMAIN_NET_TYPE_VHOSTUSER:\n    case VIR_DOMAIN_NET_TYPE_SERVER:\n    case VIR_DOMAIN_NET_TYPE_CLIENT:\n    case VIR_DOMAIN_NET_TYPE_MCAST:\n    case VIR_DOMAIN_NET_TYPE_INTERNAL:\n    case VIR_DOMAIN_NET_TYPE_UDP:\n    case VIR_DOMAIN_NET_TYPE_LAST:\n    default:\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevIsPCINetDevice",
          "args": [
            "hostdev"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevIsPCINetDevice",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "353-359",
          "snippet": "static bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevSaveNetConfig(virDomainHostdevDefPtr hostdev,\n                        const char *stateDir)\n{\n    g_autofree char *linkdev = NULL;\n    int vf = -1;\n\n    if (!virHostdevIsPCINetDevice(hostdev) ||\n        virDomainNetGetActualVirtPortProfile(hostdev->parentnet))\n       return 0;\n\n    if (virHostdevIsVirtualFunction(hostdev) != 1) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"Interface type hostdev is currently supported on\"\n                         \" SR-IOV Virtual Functions only\"));\n        return -1;\n    }\n\n    if (virHostdevNetDevice(hostdev, -1, &linkdev, &vf) < 0)\n        return -1;\n\n    if (virNetDevSaveNetConfig(linkdev, vf, stateDir, true) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevNetConfigVirtPortProfile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "362-399",
    "snippet": "static int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevVPortProfileDisassociate",
          "args": [
            "NULL",
            "virtPort",
            "macaddr",
            "linkdev",
            "vf",
            "VIR_NETDEV_VPORT_PROFILE_OP_DESTROY"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileDisassociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1365-1375",
          "snippet": "int virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileAssociate",
          "args": [
            "NULL",
            "virtPort",
            "macaddr",
            "linkdev",
            "vf",
            "uuid",
            "VIR_NETDEV_VPORT_PROFILE_OP_CREATE",
            "false"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileAssociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1351-1363",
          "snippet": "int virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\")",
            "virNetDevVPortTypeToString(virtPort->virtPortType)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "virtPort->virtPortType"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\""
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetConfigVirtPortProfile(const char *linkdev, int vf,\n                                   const virNetDevVPortProfile *virtPort,\n                                   const virMacAddr *macaddr,\n                                   const unsigned char *uuid,\n                                   bool associate)\n{\n    int ret = -1;\n\n    if (!virtPort)\n        return ret;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"virtualport type %s is \"\n                         \"currently not supported on interfaces of type \"\n                         \"hostdev\"),\n                       virNetDevVPortTypeToString(virtPort->virtPortType));\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (associate)\n            ret = virNetDevVPortProfileAssociate(NULL, virtPort, macaddr,\n                                                 linkdev, vf, uuid,\n                                                 VIR_NETDEV_VPORT_PROFILE_OP_CREATE, false);\n        else\n            ret = virNetDevVPortProfileDisassociate(NULL, virtPort,\n                                                    macaddr, linkdev, vf,\n                                                    VIR_NETDEV_VPORT_PROFILE_OP_DESTROY);\n        break;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virHostdevIsPCINetDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "353-359",
    "snippet": "static bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic bool\nvirHostdevIsPCINetDevice(const virDomainHostdevDef *hostdev)\n{\n    return hostdev->mode == VIR_DOMAIN_HOSTDEV_MODE_SUBSYS &&\n        hostdev->source.subsys.type == VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI &&\n        hostdev->parentnet != NULL;\n}"
  },
  {
    "function_name": "virHostdevNetDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "315-350",
    "snippet": "static int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"The device at %s has no network device name\")",
            "sysfs_path"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The device at %s has no network device name\""
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetNetName",
          "args": [
            "sysfs_path",
            "0",
            "NULL",
            "linkdev"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetNetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2697-2705",
          "snippet": "int\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetVirtualFunctionInfo",
          "args": [
            "sysfs_path",
            "pfNetDevIdx",
            "linkdev",
            "vf"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetVirtualFunctionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2707-2715",
          "snippet": "int\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path G_GNUC_UNUSED,\n                             int pfNetDevIdx G_GNUC_UNUSED,\n                             char **pfname G_GNUC_UNUSED,\n                             int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path G_GNUC_UNUSED,\n                             int pfNetDevIdx G_GNUC_UNUSED,\n                             char **pfname G_GNUC_UNUSED,\n                             int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIIsVirtualFunction",
          "args": [
            "sysfs_path"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2664-2669",
          "snippet": "int\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPCISysfsPath",
          "args": [
            "hostdev",
            "&sysfs_path"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPCISysfsPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "288-300",
          "snippet": "static int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevNetDevice(virDomainHostdevDefPtr hostdev,\n                    int pfNetDevIdx,\n                    char **linkdev,\n                    int *vf)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    if (virPCIIsVirtualFunction(sysfs_path) == 1) {\n        if (virPCIGetVirtualFunctionInfo(sysfs_path, pfNetDevIdx,\n                                         linkdev, vf) < 0)\n            return -1;\n    } else {\n        /* In practice this should never happen, since we currently\n         * only support assigning SRIOV VFs via <interface\n         * type='hostdev'>, and it is only those devices that should\n         * end up calling this function.\n         */\n        if (virPCIGetNetName(sysfs_path, 0, NULL, linkdev) < 0)\n            return -1;\n\n        if (!(*linkdev)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"The device at %s has no network device name\"),\n                           sysfs_path);\n            return -1;\n        }\n\n        *vf = -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevIsVirtualFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "303-312",
    "snippet": "static int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIIsVirtualFunction",
          "args": [
            "sysfs_path"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2664-2669",
          "snippet": "int\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevPCISysfsPath",
          "args": [
            "hostdev",
            "&sysfs_path"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevPCISysfsPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "288-300",
          "snippet": "static int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevIsVirtualFunction(virDomainHostdevDefPtr hostdev)\n{\n    g_autofree char *sysfs_path = NULL;\n\n    if (virHostdevPCISysfsPath(hostdev, &sysfs_path) < 0)\n        return -1;\n\n    return virPCIIsVirtualFunction(sysfs_path);\n}"
  },
  {
    "function_name": "virHostdevPCISysfsPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "288-300",
    "snippet": "static int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetSysfsFile",
          "args": [
            "&config_address",
            "sysfs_path"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetSysfsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2689-2695",
          "snippet": "int\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevPCISysfsPath(virDomainHostdevDefPtr hostdev,\n                       char **sysfs_path)\n{\n    virPCIDeviceAddress config_address;\n\n    config_address.domain = hostdev->source.subsys.u.pci.addr.domain;\n    config_address.bus = hostdev->source.subsys.u.pci.addr.bus;\n    config_address.slot = hostdev->source.subsys.u.pci.addr.slot;\n    config_address.function = hostdev->source.subsys.u.pci.addr.function;\n\n    return virPCIDeviceAddressGetSysfsFile(&config_address, sysfs_path);\n}"
  },
  {
    "function_name": "virHostdevGetPCIHostDeviceList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "261-286",
    "snippet": "static virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&pcidevs"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "pcidevs",
            "pci"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevGetPCIHostDevice",
          "args": [
            "hostdev",
            "&pci"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevGetPCIHostDeviceList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "261-286",
          "snippet": "static virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListNew",
          "args": [],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1566-1578",
          "snippet": "virPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virPCIDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virClassPtr virPCIDeviceListClass;\n\nvirPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virPCIDeviceListPtr\nvirHostdevGetPCIHostDeviceList(virDomainHostdevDefPtr *hostdevs, int nhostdevs)\n{\n    g_autoptr(virPCIDeviceList) pcidevs = NULL;\n    size_t i;\n\n    if (!(pcidevs = virPCIDeviceListNew()))\n        return NULL;\n\n    for (i = 0; i < nhostdevs; i++) {\n        virDomainHostdevDefPtr hostdev = hostdevs[i];\n        g_autoptr(virPCIDevice) pci = NULL;\n\n        if (virHostdevGetPCIHostDevice(hostdev, &pci) < 0)\n            return NULL;\n\n        if (!pci)\n            continue;\n\n        if (virPCIDeviceListAdd(pcidevs, pci) < 0)\n            return NULL;\n        pci = NULL;\n    }\n\n    return g_steal_pointer(&pcidevs);\n}"
  },
  {
    "function_name": "virHostdevGetPCIHostDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "225-259",
    "snippet": "static int\nvirHostdevGetPCIHostDevice(const virDomainHostdevDef *hostdev,\n                           virPCIDevicePtr *pci)\n{\n    g_autoptr(virPCIDevice) actual = NULL;\n    const virDomainHostdevSubsysPCI *pcisrc = &hostdev->source.subsys.u.pci;\n\n    *pci = NULL;\n\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n        hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n        return 0;\n\n    actual = virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                             pcisrc->addr.slot, pcisrc->addr.function);\n\n    if (!actual)\n        return -1;\n\n    virPCIDeviceSetManaged(actual, hostdev->managed);\n\n    if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n        virPCIDeviceSetStubDriver(actual, VIR_PCI_STUB_DRIVER_VFIO);\n    } else if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN) {\n        virPCIDeviceSetStubDriver(actual, VIR_PCI_STUB_DRIVER_XEN);\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"pci backend driver '%s' is not supported\"),\n                       virDomainHostdevSubsysPCIBackendTypeToString(pcisrc->backend));\n        return -1;\n    }\n\n    *pci = g_steal_pointer(&actual);\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&actual"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"pci backend driver '%s' is not supported\")",
            "virDomainHostdevSubsysPCIBackendTypeToString(pcisrc->backend)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainHostdevSubsysPCIBackendTypeToString",
          "args": [
            "pcisrc->backend"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"pci backend driver '%s' is not supported\""
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetStubDriver",
          "args": [
            "actual",
            "VIR_PCI_STUB_DRIVER_XEN"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetStubDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1496-1500",
          "snippet": "void\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceSetManaged",
          "args": [
            "actual",
            "hostdev->managed"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceSetManaged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1485-1488",
          "snippet": "void virPCIDeviceSetManaged(virPCIDevicePtr dev, bool managed)\n{\n    dev->managed = managed;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid virPCIDeviceSetManaged(virPCIDevicePtr dev, bool managed)\n{\n    dev->managed = managed;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "pcisrc->addr.domain",
            "pcisrc->addr.bus",
            "pcisrc->addr.slot",
            "pcisrc->addr.function"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int\nvirHostdevGetPCIHostDevice(const virDomainHostdevDef *hostdev,\n                           virPCIDevicePtr *pci)\n{\n    g_autoptr(virPCIDevice) actual = NULL;\n    const virDomainHostdevSubsysPCI *pcisrc = &hostdev->source.subsys.u.pci;\n\n    *pci = NULL;\n\n    if (hostdev->mode != VIR_DOMAIN_HOSTDEV_MODE_SUBSYS ||\n        hostdev->source.subsys.type != VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI)\n        return 0;\n\n    actual = virPCIDeviceNew(pcisrc->addr.domain, pcisrc->addr.bus,\n                             pcisrc->addr.slot, pcisrc->addr.function);\n\n    if (!actual)\n        return -1;\n\n    virPCIDeviceSetManaged(actual, hostdev->managed);\n\n    if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO) {\n        virPCIDeviceSetStubDriver(actual, VIR_PCI_STUB_DRIVER_VFIO);\n    } else if (pcisrc->backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN) {\n        virPCIDeviceSetStubDriver(actual, VIR_PCI_STUB_DRIVER_XEN);\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"pci backend driver '%s' is not supported\"),\n                       virDomainHostdevSubsysPCIBackendTypeToString(pcisrc->backend));\n        return -1;\n    }\n\n    *pci = g_steal_pointer(&actual);\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevManagerGetDefault",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "203-210",
    "snippet": "virHostdevManagerPtr\nvirHostdevManagerGetDefault(void)\n{\n    if (virHostdevManagerInitialize() < 0)\n        return NULL;\n\n    return virObjectRef(manager);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virHostdevManagerPtr manager;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "manager"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHostdevManagerInitialize",
          "args": [],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virHostdevManagerPtr manager;\n\nvirHostdevManagerPtr\nvirHostdevManagerGetDefault(void)\n{\n    if (virHostdevManagerInitialize() < 0)\n        return NULL;\n\n    return virObjectRef(manager);\n}"
  },
  {
    "function_name": "virHostdevManagerNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "141-201",
    "snippet": "static virHostdevManagerPtr\nvirHostdevManagerNew(void)\n{\n    g_autoptr(virHostdevManager) hostdevMgr = NULL;\n    bool privileged = geteuid() == 0;\n\n    if (!(hostdevMgr = virObjectNew(virHostdevManagerClass)))\n        return NULL;\n\n    if (!(hostdevMgr->activePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeUSBHostdevs = virUSBDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->inactivePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIHostdevs = virSCSIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIVHostHostdevs = virSCSIVHostDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeMediatedHostdevs = virMediatedDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeNVMeHostdevs = virNVMeDeviceListNew()))\n        return NULL;\n\n    if (privileged) {\n        hostdevMgr->stateDir = g_strdup(HOSTDEV_STATE_DIR);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        hostdevMgr->stateDir = g_strdup_printf(\"%s/hostdevmgr\", rundir);\n\n        old_umask = umask(077);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            umask(old_umask);\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n        umask(old_umask);\n    }\n\n    return g_steal_pointer(&hostdevMgr);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define HOSTDEV_STATE_DIR RUNSTATEDIR \"/libvirt/hostdevmgr\""
    ],
    "globals_used": [
      "static virClassPtr virHostdevManagerClass;",
      "static virHostdevManagerPtr virHostdevManagerNew(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&hostdevMgr"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to create state dir '%s'\")",
            "hostdevMgr->stateDir"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to create state dir '%s'\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileMakePath",
          "args": [
            "hostdevMgr->stateDir"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "virFileMakePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3076-3080",
          "snippet": "int\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileMakePath(const char *path)\n{\n    return virFileMakePathWithMode(path, 0777);\n}"
        }
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "077"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Failed to create state dir '%s'\")",
            "hostdevMgr->stateDir"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNVMeDeviceListNew",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virNVMeDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnvme.c",
          "lines": "145-157",
          "snippet": "virNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virpci.h\"",
            "#include \"virobject.h\"",
            "#include \"virnvme.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNVMeDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virpci.h\"\n#include \"virobject.h\"\n#include \"virnvme.h\"\n#include <config.h>\n\nstatic virClassPtr virNVMeDeviceListClass;\n\nvirNVMeDeviceListPtr\nvirNVMeDeviceListNew(void)\n{\n    virNVMeDeviceListPtr list;\n\n    if (virNVMeInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virNVMeDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceListNew",
          "args": [],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "277-289",
          "snippet": "virMediatedDeviceListPtr\nvirMediatedDeviceListNew(void)\n{\n    virMediatedDeviceListPtr list;\n\n    if (virMediatedInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virMediatedDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virMediatedDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nstatic virClassPtr virMediatedDeviceListClass;\n\nvirMediatedDeviceListPtr\nvirMediatedDeviceListNew(void)\n{\n    virMediatedDeviceListPtr list;\n\n    if (virMediatedInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virMediatedDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIVHostDeviceListNew",
          "args": [],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIVHostDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsivhost.c",
          "lines": "191-198",
          "snippet": "virSCSIVHostDeviceListPtr\nvirSCSIVHostDeviceListNew(void)\n{\n    if (virSCSIVHostInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableNew(virSCSIVHostDeviceListClass);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virscsivhost.h\"",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSCSIVHostDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virscsivhost.h\"\n#include <fcntl.h>\n#include <config.h>\n\nstatic virClassPtr virSCSIVHostDeviceListClass;\n\nvirSCSIVHostDeviceListPtr\nvirSCSIVHostDeviceListNew(void)\n{\n    if (virSCSIVHostInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableNew(virSCSIVHostDeviceListClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSCSIDeviceListNew",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "virSCSIDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virscsi.c",
          "lines": "339-351",
          "snippet": "virSCSIDeviceListPtr\nvirSCSIDeviceListNew(void)\n{\n    virSCSIDeviceListPtr list;\n\n    if (virSCSIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virSCSIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsi.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSCSIDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virscsi.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virClassPtr virSCSIDeviceListClass;\n\nvirSCSIDeviceListPtr\nvirSCSIDeviceListNew(void)\n{\n    virSCSIDeviceListPtr list;\n\n    if (virSCSIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virSCSIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListNew",
          "args": [],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1566-1578",
          "snippet": "virPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virPCIDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virClassPtr virPCIDeviceListClass;\n\nvirPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUSBDeviceListNew",
          "args": [],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "virUSBDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virusb.c",
          "lines": "416-428",
          "snippet": "virUSBDeviceListPtr\nvirUSBDeviceListNew(void)\n{\n    virUSBDeviceListPtr list;\n\n    if (virUSBInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virUSBDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virusb.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virUSBDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virusb.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include <config.h>\n\nstatic virClassPtr virUSBDeviceListClass;\n\nvirUSBDeviceListPtr\nvirUSBDeviceListNew(void)\n{\n    virUSBDeviceListPtr list;\n\n    if (virUSBInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virUSBDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "virHostdevManagerClass"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "geteuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.h",
          "lines": "68-69",
          "snippet": "static inline int geteuid(void)\n{ return 0; }",
          "includes": [
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include \"internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/types.h>\n#include <unistd.h>\n#include \"internal.h\"\n\nstatic inline int geteuid(void)\n{ return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define HOSTDEV_STATE_DIR RUNSTATEDIR \"/libvirt/hostdevmgr\"\n\nstatic virClassPtr virHostdevManagerClass;\nstatic virHostdevManagerPtr virHostdevManagerNew(void);\n\nstatic virHostdevManagerPtr\nvirHostdevManagerNew(void)\n{\n    g_autoptr(virHostdevManager) hostdevMgr = NULL;\n    bool privileged = geteuid() == 0;\n\n    if (!(hostdevMgr = virObjectNew(virHostdevManagerClass)))\n        return NULL;\n\n    if (!(hostdevMgr->activePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeUSBHostdevs = virUSBDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->inactivePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIHostdevs = virSCSIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIVHostHostdevs = virSCSIVHostDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeMediatedHostdevs = virMediatedDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeNVMeHostdevs = virNVMeDeviceListNew()))\n        return NULL;\n\n    if (privileged) {\n        hostdevMgr->stateDir = g_strdup(HOSTDEV_STATE_DIR);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        hostdevMgr->stateDir = g_strdup_printf(\"%s/hostdevmgr\", rundir);\n\n        old_umask = umask(077);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            umask(old_umask);\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n        umask(old_umask);\n    }\n\n    return g_steal_pointer(&hostdevMgr);\n}"
  },
  {
    "function_name": "virHostdevManagerDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "126-139",
    "snippet": "static void\nvirHostdevManagerDispose(void *obj)\n{\n    virHostdevManagerPtr hostdevMgr = obj;\n\n    virObjectUnref(hostdevMgr->activePCIHostdevs);\n    virObjectUnref(hostdevMgr->inactivePCIHostdevs);\n    virObjectUnref(hostdevMgr->activeUSBHostdevs);\n    virObjectUnref(hostdevMgr->activeSCSIHostdevs);\n    virObjectUnref(hostdevMgr->activeSCSIVHostHostdevs);\n    virObjectUnref(hostdevMgr->activeMediatedHostdevs);\n    virObjectUnref(hostdevMgr->activeNVMeHostdevs);\n    VIR_FREE(hostdevMgr->stateDir);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virHostdevManagerDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "hostdevMgr->stateDir"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "hostdevMgr->activeNVMeHostdevs"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic void virHostdevManagerDispose(void *obj);\n\nstatic void\nvirHostdevManagerDispose(void *obj)\n{\n    virHostdevManagerPtr hostdevMgr = obj;\n\n    virObjectUnref(hostdevMgr->activePCIHostdevs);\n    virObjectUnref(hostdevMgr->inactivePCIHostdevs);\n    virObjectUnref(hostdevMgr->activeUSBHostdevs);\n    virObjectUnref(hostdevMgr->activeSCSIHostdevs);\n    virObjectUnref(hostdevMgr->activeSCSIVHostHostdevs);\n    virObjectUnref(hostdevMgr->activeMediatedHostdevs);\n    virObjectUnref(hostdevMgr->activeNVMeHostdevs);\n    VIR_FREE(hostdevMgr->stateDir);\n}"
  },
  {
    "function_name": "virHostdevManagerOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "113-122",
    "snippet": "static int virHostdevManagerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virHostdevManager, virClassForObject()))\n        return -1;\n\n    if (!(manager = virHostdevManagerNew()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virHostdevManagerPtr manager;",
      "static virHostdevManagerPtr virHostdevManagerNew(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virHostdevManagerNew",
          "args": [],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "virHostdevManagerNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
          "lines": "141-201",
          "snippet": "static virHostdevManagerPtr\nvirHostdevManagerNew(void)\n{\n    g_autoptr(virHostdevManager) hostdevMgr = NULL;\n    bool privileged = geteuid() == 0;\n\n    if (!(hostdevMgr = virObjectNew(virHostdevManagerClass)))\n        return NULL;\n\n    if (!(hostdevMgr->activePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeUSBHostdevs = virUSBDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->inactivePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIHostdevs = virSCSIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIVHostHostdevs = virSCSIVHostDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeMediatedHostdevs = virMediatedDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeNVMeHostdevs = virNVMeDeviceListNew()))\n        return NULL;\n\n    if (privileged) {\n        hostdevMgr->stateDir = g_strdup(HOSTDEV_STATE_DIR);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        hostdevMgr->stateDir = g_strdup_printf(\"%s/hostdevmgr\", rundir);\n\n        old_umask = umask(077);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            umask(old_umask);\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n        umask(old_umask);\n    }\n\n    return g_steal_pointer(&hostdevMgr);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhostdev.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define HOSTDEV_STATE_DIR RUNSTATEDIR \"/libvirt/hostdevmgr\""
          ],
          "globals_used": [
            "static virClassPtr virHostdevManagerClass;",
            "static virHostdevManagerPtr virHostdevManagerNew(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define HOSTDEV_STATE_DIR RUNSTATEDIR \"/libvirt/hostdevmgr\"\n\nstatic virClassPtr virHostdevManagerClass;\nstatic virHostdevManagerPtr virHostdevManagerNew(void);\n\nstatic virHostdevManagerPtr\nvirHostdevManagerNew(void)\n{\n    g_autoptr(virHostdevManager) hostdevMgr = NULL;\n    bool privileged = geteuid() == 0;\n\n    if (!(hostdevMgr = virObjectNew(virHostdevManagerClass)))\n        return NULL;\n\n    if (!(hostdevMgr->activePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeUSBHostdevs = virUSBDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->inactivePCIHostdevs = virPCIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIHostdevs = virSCSIDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeSCSIVHostHostdevs = virSCSIVHostDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeMediatedHostdevs = virMediatedDeviceListNew()))\n        return NULL;\n\n    if (!(hostdevMgr->activeNVMeHostdevs = virNVMeDeviceListNew()))\n        return NULL;\n\n    if (privileged) {\n        hostdevMgr->stateDir = g_strdup(HOSTDEV_STATE_DIR);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n    } else {\n        g_autofree char *rundir = NULL;\n        mode_t old_umask;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        hostdevMgr->stateDir = g_strdup_printf(\"%s/hostdevmgr\", rundir);\n\n        old_umask = umask(077);\n\n        if (virFileMakePath(hostdevMgr->stateDir) < 0) {\n            umask(old_umask);\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Failed to create state dir '%s'\"),\n                           hostdevMgr->stateDir);\n            return NULL;\n        }\n        umask(old_umask);\n    }\n\n    return g_steal_pointer(&hostdevMgr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virHostdevManager",
            "virClassForObject()"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic virHostdevManagerPtr manager;\nstatic virHostdevManagerPtr virHostdevManagerNew(void);\n\nstatic int virHostdevManagerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virHostdevManager, virClassForObject()))\n        return -1;\n\n    if (!(manager = virHostdevManagerNew()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virHostdevIsPCINodeDeviceUsed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/hypervisor/virhostdev.c",
    "lines": "79-111",
    "snippet": "static int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"virnetdev.h\"",
      "#include \"virutil.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virhostdev.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <fcntl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"PCI device %s is in use\")",
            "virPCIDeviceGetName(actual)"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetName",
          "args": [
            "actual"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1467-1471",
          "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"PCI device %s is in use\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\")",
            "virPCIDeviceGetName(actual)",
            "actual_drvname",
            "actual_domname"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "actual_domname",
            "helperData->domainName"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "actual_drvname",
            "helperData->driverName"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetUsedBy",
          "args": [
            "actual",
            "&actual_drvname",
            "&actual_domname"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetUsedBy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1557-1564",
          "snippet": "void\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFindByIDs",
          "args": [
            "helperData->mgr->activePCIHostdevs",
            "devAddr->domain",
            "devAddr->bus",
            "devAddr->slot",
            "devAddr->function"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFindByIDs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1687-1705",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"virnetdev.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virhostdev.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include <config.h>\n\nstatic int virHostdevIsPCINodeDeviceUsed(virPCIDeviceAddressPtr devAddr, void *opaque)\n{\n    virPCIDevicePtr actual;\n    struct virHostdevIsPCINodeDeviceUsedData *helperData = opaque;\n\n    actual = virPCIDeviceListFindByIDs(helperData->mgr->activePCIHostdevs,\n                                       devAddr->domain, devAddr->bus,\n                                       devAddr->slot, devAddr->function);\n    if (actual) {\n        const char *actual_drvname = NULL;\n        const char *actual_domname = NULL;\n        virPCIDeviceGetUsedBy(actual, &actual_drvname, &actual_domname);\n\n        if (helperData->usesVFIO &&\n            STREQ_NULLABLE(actual_drvname, helperData->driverName) &&\n            STREQ_NULLABLE(actual_domname, helperData->domainName))\n            goto iommu_owner;\n\n        if (actual_drvname && actual_domname)\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use by \"\n                             \"driver %s, domain %s\"),\n                           virPCIDeviceGetName(actual),\n                           actual_drvname, actual_domname);\n        else\n            virReportError(VIR_ERR_OPERATION_INVALID,\n                           _(\"PCI device %s is in use\"),\n                           virPCIDeviceGetName(actual));\n        return -1;\n    }\n iommu_owner:\n    return 0;\n}"
  }
]