[
  {
    "function_name": "virSocketAddrFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1317-1321",
    "snippet": "void\nvirSocketAddrFree(virSocketAddrPtr addr)\n{\n    VIR_FREE(addr);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "addr"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid\nvirSocketAddrFree(virSocketAddrPtr addr)\n{\n    VIR_FREE(addr);\n}"
  },
  {
    "function_name": "virSocketAddrPTRDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1264-1315",
    "snippet": "int\nvirSocketAddrPTRDomain(const virSocketAddr *addr,\n                       unsigned int prefix,\n                       char **ptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) {\n        virSocketAddrIPv4 ip;\n\n        if (prefix == 0 || prefix >= 32 || prefix % 8 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv4Addr(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 8; i > 0; i--)\n            virBufferAsprintf(&buf, \"%u.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV4_ARPA);\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6)) {\n        virSocketAddrIPv6Nibbles ip;\n\n        if (prefix == 0 || prefix >= 128 || prefix % 4 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv6Nibbles(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 4; i > 0; i--)\n            virBufferAsprintf(&buf, \"%x.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV6_ARPA);\n    } else {\n        goto unsupported;\n    }\n\n    if (!(*ptr = virBufferContentAndReset(&buf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n\n unsupported:\n    ret = -2;\n    goto cleanup;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buf"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buf"
          ],
          "line": 1303
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "VIR_SOCKET_ADDR_IPV6_ARPA"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buf",
            "\"%x.\"",
            "ip[i - 1]"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv6Nibbles",
          "args": [
            "addr",
            "&ip"
          ],
          "line": 1292
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv6Nibbles",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "76-91",
          "snippet": "static int\nvirSocketAddrGetIPv6Nibbles(const virSocketAddr *addr,\n                            virSocketAddrIPv6NibblesPtr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 16; i++) {\n        (*tab)[2 * i] = addr->data.inet6.sin6_addr.s6_addr[i] >> 4;\n        (*tab)[2 * i + 1] = addr->data.inet6.sin6_addr.s6_addr[i] & 0xF;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Nibbles(const virSocketAddr *addr,\n                            virSocketAddrIPv6NibblesPtr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 16; i++) {\n        (*tab)[2 * i] = addr->data.inet6.sin6_addr.s6_addr[i] >> 4;\n        (*tab)[2 * i + 1] = addr->data.inet6.sin6_addr.s6_addr[i] & 0xF;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "AF_INET6"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buf",
            "VIR_SOCKET_ADDR_IPV4_ARPA"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv4Addr",
          "args": [
            "addr",
            "&ip"
          ],
          "line": 1279
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv4Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "40-58",
          "snippet": "static int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "addr",
            "AF_INET"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPTRDomain(const virSocketAddr *addr,\n                       unsigned int prefix,\n                       char **ptr)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    size_t i;\n    int ret = -1;\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET)) {\n        virSocketAddrIPv4 ip;\n\n        if (prefix == 0 || prefix >= 32 || prefix % 8 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv4Addr(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 8; i > 0; i--)\n            virBufferAsprintf(&buf, \"%u.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV4_ARPA);\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(addr, AF_INET6)) {\n        virSocketAddrIPv6Nibbles ip;\n\n        if (prefix == 0 || prefix >= 128 || prefix % 4 != 0)\n            goto unsupported;\n\n        if (virSocketAddrGetIPv6Nibbles(addr, &ip) < 0)\n            goto cleanup;\n\n        for (i = prefix / 4; i > 0; i--)\n            virBufferAsprintf(&buf, \"%x.\", ip[i - 1]);\n\n        virBufferAddLit(&buf, VIR_SOCKET_ADDR_IPV6_ARPA);\n    } else {\n        goto unsupported;\n    }\n\n    if (!(*ptr = virBufferContentAndReset(&buf)))\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virBufferFreeAndReset(&buf);\n    return ret;\n\n unsupported:\n    ret = -2;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virSocketAddrIsNumericLocalhost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1232-1250",
    "snippet": "bool\nvirSocketAddrIsNumericLocalhost(const char *addr)\n{\n    virSocketAddr res;\n    struct in_addr tmp = { .s_addr = htonl(INADDR_LOOPBACK) };\n\n    if (virSocketAddrParse(&res, addr, AF_UNSPEC) < 0)\n        return false;\n\n    switch (res.data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&res.data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(res.data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_LOOPBACK(&res.data.inet6.sin6_addr);\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_LOOPBACK",
          "args": [
            "&res.data.inet6.sin6_addr"
          ],
          "line": 1246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&res.data.inet4.sin_addr.s_addr",
            "&tmp.s_addr",
            "sizeof(res.data.inet4.sin_addr.s_addr)"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "&res",
            "addr",
            "AF_UNSPEC"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "INADDR_LOOPBACK"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsNumericLocalhost(const char *addr)\n{\n    virSocketAddr res;\n    struct in_addr tmp = { .s_addr = htonl(INADDR_LOOPBACK) };\n\n    if (virSocketAddrParse(&res, addr, AF_UNSPEC) < 0)\n        return false;\n\n    switch (res.data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&res.data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(res.data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_LOOPBACK(&res.data.inet6.sin6_addr);\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "virSocketAddrNumericFamily",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1209-1221",
    "snippet": "int\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseInternal",
          "args": [
            "&res",
            "address",
            "AF_UNSPEC",
            "AI_NUMERICHOST",
            "false"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "93-122",
          "snippet": "static int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrNumericFamily(const char *address)\n{\n    struct addrinfo *res;\n    unsigned short family;\n\n    if (virSocketAddrParseInternal(&res, address, AF_UNSPEC, AI_NUMERICHOST, false) < 0)\n        return -1;\n\n    family = res->ai_addr->sa_family;\n    freeaddrinfo(res);\n    return family;\n}"
  },
  {
    "function_name": "virSocketAddrGetIPPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1152-1198",
    "snippet": "int\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrIsWildcard",
          "args": [
            "address"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrIsWildcard",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "419-431",
          "snippet": "bool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "address",
            "AF_INET6"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "address->data.inet4.sin_addr.s_addr"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "address",
            "AF_INET"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetNumNetmaskBits",
          "args": [
            "netmask"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetNumNetmaskBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1009-1084",
          "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_VALID",
          "args": [
            "netmask"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetIPPrefix(const virSocketAddr *address,\n                         const virSocketAddr *netmask,\n                         int prefix)\n{\n    if (prefix > 0) {\n        return prefix;\n    } else if (netmask && VIR_SOCKET_ADDR_VALID(netmask)) {\n        return virSocketAddrGetNumNetmaskBits(netmask);\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET)) {\n        /* Return the natural prefix for the network's ip address.\n         * On Linux we could use the IN_CLASSx() macros, but those\n         * aren't guaranteed on all platforms, so we just deal with\n         * the bits ourselves.\n         */\n        unsigned char octet\n            = ntohl(address->data.inet4.sin_addr.s_addr) >> 24;\n\n        /* If address is 0.0.0.0, we surely want to have 0 prefix for\n         * the default route. */\n        if (address->data.inet4.sin_addr.s_addr == 0)\n            return 0;\n\n        if ((octet & 0x80) == 0) {\n            /* Class A network */\n            return 8;\n        } else if ((octet & 0xC0) == 0x80) {\n            /* Class B network */\n            return 16;\n        } else if ((octet & 0xE0) == 0xC0) {\n            /* Class C network */\n            return 24;\n        }\n        return -1;\n    } else if (address && VIR_SOCKET_ADDR_IS_FAMILY(address, AF_INET6)) {\n        if (virSocketAddrIsWildcard(address))\n            return 0;\n        return 64;\n    }\n\n    /* When none of the three (address/netmask/prefix) is given, 0 is\n     * returned rather than error, because this is a valid\n     * expectation, e.g. for the address/prefix used for a default\n     * route (the destination of a default route is 0.0.0.0/0).\n     */\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrPrefixToNetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1098-1141",
    "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "ip"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
  },
  {
    "function_name": "virSocketAddrGetNumNetmaskBits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "1009-1084",
    "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv6Addr",
          "args": [
            "netmask",
            "&tm"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv6Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "60-74",
          "snippet": "static int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv4Addr",
          "args": [
            "netmask",
            "&tm"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv4Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "40-58",
          "snippet": "static int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virSocketAddrGetRange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "825-997",
    "snippet": "int\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\")",
            "startStr",
            "endStr"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\""
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"range %s - %s start larger than end\")",
            "startStr",
            "endStr"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"range %s - %s is too large (> 65535)\")",
            "startStr",
            "endStr"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\")",
            "startStr",
            "endStr"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv6Addr",
          "args": [
            "end",
            "&t2"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv6Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "60-74",
          "snippet": "static int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "start",
            "AF_INET6"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"range %s - %s is reversed \")",
            "startStr",
            "endStr"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"range %s - %s is too large (> 65535)\")",
            "startStr",
            "endStr"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\")",
            "startStr",
            "endStr"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv4Addr",
          "args": [
            "end",
            "&t2"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv4Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "40-58",
          "snippet": "static int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "start",
            "AF_INET"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\")",
            "startStr",
            "endStr",
            "netStr",
            "prefix"
          ],
          "line": 917
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrEqual",
          "args": [
            "end",
            "&broadcast"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "359-378",
          "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\")",
            "netStr",
            "prefix"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrMask",
          "args": [
            "network",
            "&netmask",
            "&netaddr"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrMaskByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "679-693",
          "snippet": "int\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrBroadcast",
          "args": [
            "network",
            "&netmask",
            "&broadcast"
          ],
          "line": 892
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrBroadcastByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "738-750",
          "snippet": "int\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_IS_FAMILY",
          "args": [
            "start",
            "AF_INET"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrCheckNetmask",
          "args": [
            "end",
            "network",
            "&netmask"
          ],
          "line": 881
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrCheckNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "764-808",
          "snippet": "int virSocketAddrCheckNetmask(virSocketAddrPtr addr1, virSocketAddrPtr addr2,\n                              virSocketAddrPtr netmask)\n{\n    size_t i;\n\n    if ((addr1 == NULL) || (addr2 == NULL) || (netmask == NULL))\n        return -1;\n    if ((addr1->data.stor.ss_family != addr2->data.stor.ss_family) ||\n        (addr1->data.stor.ss_family != netmask->data.stor.ss_family))\n        return -1;\n\n    if (virSocketAddrIsNetmask(netmask) != 0)\n        return -1;\n\n    if (addr1->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv4Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv4Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv4Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 4; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else if (addr1->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv6Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv6Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv6Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 8; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else {\n        return -1;\n    }\n    return 1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrCheckNetmask(virSocketAddrPtr addr1, virSocketAddrPtr addr2,\n                              virSocketAddrPtr netmask)\n{\n    size_t i;\n\n    if ((addr1 == NULL) || (addr2 == NULL) || (netmask == NULL))\n        return -1;\n    if ((addr1->data.stor.ss_family != addr2->data.stor.ss_family) ||\n        (addr1->data.stor.ss_family != netmask->data.stor.ss_family))\n        return -1;\n\n    if (virSocketAddrIsNetmask(netmask) != 0)\n        return -1;\n\n    if (addr1->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv4Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv4Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv4Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 4; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else if (addr1->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv6Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv6Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv6Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 8; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else {\n        return -1;\n    }\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "prefix",
            "&netmask",
            "VIR_SOCKET_ADDR_FAMILY(network)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "network"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\")",
            "startStr",
            "endStr",
            "netStr"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "network"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "start"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSocketAddrFormat",
          "args": [
            "network"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "441-445",
          "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"mismatch of address family in range %s - %s\")",
            "startStr",
            "endStr"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "end"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "start"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"NULL argument - %p %p\")",
            "start",
            "end"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetRange(virSocketAddrPtr start, virSocketAddrPtr end,\n                      virSocketAddrPtr network, int prefix)\n{\n    int ret = 0;\n    size_t i;\n    virSocketAddr netmask;\n    g_autofree char *startStr = NULL;\n    g_autofree char *endStr = NULL;\n    g_autofree char *netStr = NULL;\n\n    if (start == NULL || end == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"NULL argument - %p %p\"), start, end);\n        return -1;\n    }\n\n    startStr = virSocketAddrFormat(start);\n    endStr = virSocketAddrFormat(end);\n    if (!startStr || !endStr)\n        return -1; /*error already reported */\n\n    if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(end)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"mismatch of address family in range %s - %s\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    if (network) {\n        /* some checks can only be done if we have details of the\n         * network the range should be within\n         */\n        if (!(netStr = virSocketAddrFormat(network)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_FAMILY(start) != VIR_SOCKET_ADDR_FAMILY(network)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"mismatch of address family in \"\n                             \"range %s - %s for network %s\"),\n                           startStr, endStr, netStr);\n            return -1;\n        }\n\n        if (prefix < 0 ||\n            virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                         VIR_SOCKET_ADDR_FAMILY(network)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"bad prefix %d for network %s when \"\n                             \" checking range %s - %s\"),\n                           prefix, netStr, startStr, endStr);\n            return -1;\n        }\n\n        /* both start and end of range need to be within network */\n        if (virSocketAddrCheckNetmask(start, network, &netmask) <= 0 ||\n            virSocketAddrCheckNetmask(end, network, &netmask) <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is not entirely within \"\n                             \"network %s/%d\"),\n                           startStr, endStr, netStr, prefix);\n            return -1;\n        }\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n            virSocketAddr netaddr, broadcast;\n\n            if (virSocketAddrBroadcast(network, &netmask, &broadcast) < 0 ||\n                virSocketAddrMask(network, &netmask, &netaddr) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"failed to construct broadcast or network \"\n                                 \"address for network %s/%d\"),\n                               netStr, prefix);\n                return -1;\n            }\n\n            /* Don't allow the start of the range to be the network\n             * address (usually \"...0\") or the end of the range to be the\n             * broadcast address (usually \"...255\"). (the opposite also\n             * isn't allowed, but checking for that is implicit in all the\n             * other combined checks) (IPv6 doesn't have broadcast and\n             * network addresses, so this check is only done for IPv4)\n             */\n            if (virSocketAddrEqual(start, &netaddr)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"start of range %s - %s in network %s/%d \"\n                                 \"is the network address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n\n            if (virSocketAddrEqual(end, &broadcast)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"end of range %s - %s in network %s/%d \"\n                                 \"is the broadcast address\"),\n                               startStr, endStr, netStr, prefix);\n                return -1;\n            }\n        }\n    }\n\n    if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET)) {\n        virSocketAddrIPv4 t1, t2;\n\n        if (virSocketAddrGetIPv4Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv4Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv4 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes\n         * are the same\n         */\n        for (i = 0; i < 2; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = (t2[2] - t1[2]) * 256 + (t2[3] - t1[3]);\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s is reversed \"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else if (VIR_SOCKET_ADDR_IS_FAMILY(start, AF_INET6)) {\n        virSocketAddrIPv6 t1, t2;\n\n        if (virSocketAddrGetIPv6Addr(start, &t1) < 0 ||\n            virSocketAddrGetIPv6Addr(end, &t2) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"failed to get IPv6 address \"\n                             \"for start or end of range %s - %s\"),\n                           startStr, endStr);\n            return -1;\n        }\n\n        /* legacy check that everything except the last two bytes are\n         * the same\n         */\n        for (i = 0; i < 7; i++) {\n            if (t1[i] != t2[i]) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"range %s - %s is too large (> 65535)\"),\n                               startStr, endStr);\n                return -1;\n            }\n        }\n        ret = t2[7] - t1[7];\n        if (ret < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"range %s - %s start larger than end\"),\n                           startStr, endStr);\n            return -1;\n        }\n        ret++;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unsupported address family \"\n                         \"for range %s - %s, must be ipv4 or ipv6\"),\n                       startStr, endStr);\n        return -1;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSocketAddrCheckNetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "764-808",
    "snippet": "int virSocketAddrCheckNetmask(virSocketAddrPtr addr1, virSocketAddrPtr addr2,\n                              virSocketAddrPtr netmask)\n{\n    size_t i;\n\n    if ((addr1 == NULL) || (addr2 == NULL) || (netmask == NULL))\n        return -1;\n    if ((addr1->data.stor.ss_family != addr2->data.stor.ss_family) ||\n        (addr1->data.stor.ss_family != netmask->data.stor.ss_family))\n        return -1;\n\n    if (virSocketAddrIsNetmask(netmask) != 0)\n        return -1;\n\n    if (addr1->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv4Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv4Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv4Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 4; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else if (addr1->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv6Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv6Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv6Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 8; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else {\n        return -1;\n    }\n    return 1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv6Addr",
          "args": [
            "netmask",
            "&tm"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv6Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "60-74",
          "snippet": "static int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrGetIPv4Addr",
          "args": [
            "netmask",
            "&tm"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetIPv4Addr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "40-58",
          "snippet": "static int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrIsNetmask",
          "args": [
            "netmask"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrIsNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "613-619",
          "snippet": "int virSocketAddrIsNetmask(virSocketAddrPtr netmask)\n{\n    int n = virSocketAddrGetNumNetmaskBits(netmask);\n    if (n < 0)\n        return -1;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrIsNetmask(virSocketAddrPtr netmask)\n{\n    int n = virSocketAddrGetNumNetmaskBits(netmask);\n    if (n < 0)\n        return -1;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrCheckNetmask(virSocketAddrPtr addr1, virSocketAddrPtr addr2,\n                              virSocketAddrPtr netmask)\n{\n    size_t i;\n\n    if ((addr1 == NULL) || (addr2 == NULL) || (netmask == NULL))\n        return -1;\n    if ((addr1->data.stor.ss_family != addr2->data.stor.ss_family) ||\n        (addr1->data.stor.ss_family != netmask->data.stor.ss_family))\n        return -1;\n\n    if (virSocketAddrIsNetmask(netmask) != 0)\n        return -1;\n\n    if (addr1->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv4Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv4Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv4Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 4; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else if (addr1->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 t1, t2, tm;\n\n        if ((virSocketAddrGetIPv6Addr(addr1, &t1) < 0) ||\n            (virSocketAddrGetIPv6Addr(addr2, &t2) < 0) ||\n            (virSocketAddrGetIPv6Addr(netmask, &tm) < 0))\n            return -1;\n\n        for (i = 0; i < 8; i++) {\n            if ((t1[i] & tm[i]) != (t2[i] & tm[i]))\n                return 0;\n        }\n\n    } else {\n        return -1;\n    }\n    return 1;\n}"
  },
  {
    "function_name": "virSocketAddrBroadcastByPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "738-750",
    "snippet": "int\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrBroadcast",
          "args": [
            "addr",
            "&netmask",
            "broadcast"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrBroadcastByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "738-750",
          "snippet": "int\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "prefix",
            "&netmask",
            "addr->data.stor.ss_family"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrBroadcastByPrefix(const virSocketAddr *addr,\n                               unsigned int prefix,\n                               virSocketAddrPtr broadcast)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0)\n        return -1;\n\n    return virSocketAddrBroadcast(addr, &netmask, broadcast);\n}"
  },
  {
    "function_name": "virSocketAddrBroadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "706-725",
    "snippet": "int\nvirSocketAddrBroadcast(const virSocketAddr *addr,\n                       const virSocketAddr *netmask,\n                       virSocketAddrPtr broadcast)\n{\n    memset(broadcast, 0, sizeof(*broadcast));\n\n    if ((addr->data.stor.ss_family != AF_INET) ||\n        (netmask->data.stor.ss_family != AF_INET)) {\n        broadcast->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    broadcast->data.stor.ss_family = AF_INET;\n    broadcast->len = addr->len;\n    broadcast->data.inet4.sin_addr.s_addr\n        = (addr->data.inet4.sin_addr.s_addr\n           | ~netmask->data.inet4.sin_addr.s_addr);\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "broadcast",
            "0",
            "sizeof(*broadcast)"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrBroadcast(const virSocketAddr *addr,\n                       const virSocketAddr *netmask,\n                       virSocketAddrPtr broadcast)\n{\n    memset(broadcast, 0, sizeof(*broadcast));\n\n    if ((addr->data.stor.ss_family != AF_INET) ||\n        (netmask->data.stor.ss_family != AF_INET)) {\n        broadcast->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    broadcast->data.stor.ss_family = AF_INET;\n    broadcast->len = addr->len;\n    broadcast->data.inet4.sin_addr.s_addr\n        = (addr->data.inet4.sin_addr.s_addr\n           | ~netmask->data.inet4.sin_addr.s_addr);\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrMaskByPrefix",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "679-693",
    "snippet": "int\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrMask",
          "args": [
            "addr",
            "&netmask",
            "network"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrMaskByPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "679-693",
          "snippet": "int\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrPrefixToNetmask",
          "args": [
            "prefix",
            "&netmask",
            "addr->data.stor.ss_family"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrPrefixToNetmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1098-1141",
          "snippet": "int\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrPrefixToNetmask(unsigned int prefix,\n                             virSocketAddrPtr netmask,\n                             int family)\n{\n    netmask->data.stor.ss_family = AF_UNSPEC; /* assume failure */\n\n    if (family == AF_INET) {\n        int ip;\n\n        if (prefix > 32)\n            return -1;\n\n        ip = prefix ? ~((1 << (32 - prefix)) - 1) : 0;\n        netmask->data.inet4.sin_addr.s_addr = htonl(ip);\n        netmask->data.stor.ss_family = AF_INET;\n        netmask->len = sizeof(struct sockaddr_in);\n\n    } else if (family == AF_INET6) {\n        size_t i = 0;\n\n        if (prefix > 128)\n            return -1;\n\n        while (prefix >= 8) {\n            /* do as much as possible an entire byte at a time */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0xff;\n            prefix -= 8;\n        }\n        if (prefix > 0) {\n            /* final partial byte */\n            netmask->data.inet6.sin6_addr.s6_addr[i++]\n                = ~((1 << (8 - prefix)) -1);\n        }\n        while (i < 16) {\n            /* zerofill remainder in case it wasn't initialized */\n            netmask->data.inet6.sin6_addr.s6_addr[i++] = 0;\n        }\n        netmask->data.stor.ss_family = AF_INET6;\n        netmask->len = sizeof(struct sockaddr_in6);\n    }\n\n    return 0;\n }"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrMaskByPrefix(const virSocketAddr *addr,\n                          unsigned int prefix,\n                          virSocketAddrPtr network)\n{\n    virSocketAddr netmask;\n\n    if (virSocketAddrPrefixToNetmask(prefix, &netmask,\n                                     addr->data.stor.ss_family) < 0) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    return virSocketAddrMask(addr, &netmask, network);\n}"
  },
  {
    "function_name": "virSocketAddrMask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "632-666",
    "snippet": "int\nvirSocketAddrMask(const virSocketAddr *addr,\n                  const virSocketAddr *netmask,\n                  virSocketAddrPtr network)\n{\n    memset(network, 0, sizeof(*network));\n    if (addr->data.stor.ss_family != netmask->data.stor.ss_family) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        network->data.inet4.sin_addr.s_addr\n            = (addr->data.inet4.sin_addr.s_addr\n               & netmask->data.inet4.sin_addr.s_addr);\n        network->data.inet4.sin_port = 0;\n        network->data.stor.ss_family = AF_INET;\n        network->len = addr->len;\n        return 0;\n    }\n    if (addr->data.stor.ss_family == AF_INET6) {\n        size_t i;\n        for (i = 0; i < 16; i++) {\n            network->data.inet6.sin6_addr.s6_addr[i]\n                = (addr->data.inet6.sin6_addr.s6_addr[i]\n                   & netmask->data.inet6.sin6_addr.s6_addr[i]);\n        }\n        network->data.inet6.sin6_port = 0;\n        network->data.stor.ss_family = AF_INET6;\n        network->len = addr->len;\n        return 0;\n    }\n    network->data.stor.ss_family = AF_UNSPEC;\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "network",
            "0",
            "sizeof(*network)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrMask(const virSocketAddr *addr,\n                  const virSocketAddr *netmask,\n                  virSocketAddrPtr network)\n{\n    memset(network, 0, sizeof(*network));\n    if (addr->data.stor.ss_family != netmask->data.stor.ss_family) {\n        network->data.stor.ss_family = AF_UNSPEC;\n        return -1;\n    }\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        network->data.inet4.sin_addr.s_addr\n            = (addr->data.inet4.sin_addr.s_addr\n               & netmask->data.inet4.sin_addr.s_addr);\n        network->data.inet4.sin_port = 0;\n        network->data.stor.ss_family = AF_INET;\n        network->len = addr->len;\n        return 0;\n    }\n    if (addr->data.stor.ss_family == AF_INET6) {\n        size_t i;\n        for (i = 0; i < 16; i++) {\n            network->data.inet6.sin6_addr.s6_addr[i]\n                = (addr->data.inet6.sin6_addr.s6_addr[i]\n                   & netmask->data.inet6.sin6_addr.s6_addr[i]);\n        }\n        network->data.inet6.sin6_port = 0;\n        network->data.stor.ss_family = AF_INET6;\n        network->len = addr->len;\n        return 0;\n    }\n    network->data.stor.ss_family = AF_UNSPEC;\n    return -1;\n}"
  },
  {
    "function_name": "virSocketAddrIsNetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "613-619",
    "snippet": "int virSocketAddrIsNetmask(virSocketAddrPtr netmask)\n{\n    int n = virSocketAddrGetNumNetmaskBits(netmask);\n    if (n < 0)\n        return -1;\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrGetNumNetmaskBits",
          "args": [
            "netmask"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrGetNumNetmaskBits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "1009-1084",
          "snippet": "int virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrGetNumNetmaskBits(const virSocketAddr *netmask)\n{\n    size_t i, j;\n    int c = 0;\n\n    if (netmask->data.stor.ss_family == AF_INET) {\n        virSocketAddrIPv4 tm;\n        uint8_t bit;\n\n        if (virSocketAddrGetIPv4Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 4; i++)\n            if (tm[i] == 0xff)\n                c += 8;\n            else\n                break;\n\n        if (c == 8 * 4)\n            return c;\n\n        j = i << 3;\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (8 * 4)) {\n            bit = 1 << (7 - (j & 7));\n            if ((tm[j >> 3] & bit))\n                return -1;\n            j++;\n        }\n\n        return c;\n    } else if (netmask->data.stor.ss_family == AF_INET6) {\n        virSocketAddrIPv6 tm;\n        uint16_t bit;\n\n        if (virSocketAddrGetIPv6Addr(netmask, &tm) < 0)\n            return -1;\n\n        for (i = 0; i < 8; i++)\n            if (tm[i] == 0xffff)\n                c += 16;\n            else\n                break;\n\n        if (c == 16 * 8)\n            return c;\n\n        j = i << 4;\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4] & bit))\n                c++;\n            else\n                break;\n            j++;\n        }\n\n        while (j < (16 * 8)) {\n            bit = 1 << (15 - (j & 0xf));\n            if ((tm[j >> 4]) & bit)\n                return -1;\n            j++;\n        }\n\n        return c;\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrIsNetmask(virSocketAddrPtr netmask)\n{\n    int n = virSocketAddrGetNumNetmaskBits(netmask);\n    if (n < 0)\n        return -1;\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrGetPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "577-602",
    "snippet": "char *\nvirSocketAddrGetPath(virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n#ifndef WIN32\n    char *path = NULL;\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"No socket address provided\"));\n        return NULL;\n    }\n\n    if (addr->data.sa.sa_family != AF_UNIX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"UNIX socket address is required\"));\n        return NULL;\n    }\n\n    path = g_strndup(addr->data.un.sun_path, sizeof(addr->data.un.sun_path));\n\n    return path;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"UNIX sockets not supported on this platform\"));\n    return NULL;\n#endif\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_SUPPORT",
            "\"%s\"",
            "_(\"UNIX sockets not supported on this platform\")"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"UNIX sockets not supported on this platform\""
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strndup",
          "args": [
            "addr->data.un.sun_path",
            "sizeof(addr->data.un.sun_path)"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"UNIX socket address is required\")"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"No socket address provided\")"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrGetPath(virSocketAddrPtr addr G_GNUC_UNUSED)\n{\n#ifndef WIN32\n    char *path = NULL;\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"No socket address provided\"));\n        return NULL;\n    }\n\n    if (addr->data.sa.sa_family != AF_UNIX) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"UNIX socket address is required\"));\n        return NULL;\n    }\n\n    path = g_strndup(addr->data.un.sun_path, sizeof(addr->data.un.sun_path));\n\n    return path;\n#else\n    virReportError(VIR_ERR_NO_SUPPORT, \"%s\",\n                   _(\"UNIX sockets not supported on this platform\"));\n    return NULL;\n#endif\n}"
  },
  {
    "function_name": "virSocketAddrGetPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "552-565",
    "snippet": "int\nvirSocketAddrGetPort(virSocketAddrPtr addr)\n{\n    if (addr == NULL)\n        return -1;\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        return ntohs(addr->data.inet4.sin_port);\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        return ntohs(addr->data.inet6.sin6_port);\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr->data.inet6.sin6_port"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "addr->data.inet4.sin_port"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrGetPort(virSocketAddrPtr addr)\n{\n    if (addr == NULL)\n        return -1;\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        return ntohs(addr->data.inet4.sin_port);\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        return ntohs(addr->data.inet6.sin6_port);\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virSocketAddrSetPort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "526-543",
    "snippet": "int\nvirSocketAddrSetPort(virSocketAddrPtr addr, int port)\n{\n    if (addr == NULL)\n        return -1;\n\n    port = htons(port);\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        addr->data.inet4.sin_port = port;\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        addr->data.inet6.sin6_port = port;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrSetPort(virSocketAddrPtr addr, int port)\n{\n    if (addr == NULL)\n        return -1;\n\n    port = htons(port);\n\n    if (addr->data.stor.ss_family == AF_INET) {\n        addr->data.inet4.sin_port = port;\n    } else if (addr->data.stor.ss_family == AF_INET6) {\n        addr->data.inet6.sin6_port = port;\n    } else {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrFormatFull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "460-514",
    "snippet": "char *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "host"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_SOCKET_ADDR_FAMILY",
          "args": [
            "addr"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Cannot convert socket address to string: %s\")",
            "gai_strerror(err)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getnameinfo",
          "args": [
            "&addr->data.sa",
            "addr->len",
            "host",
            "sizeof(host)",
            "port",
            "sizeof(port)",
            "NI_NUMERICHOST | NI_NUMERICSERV"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Missing address\")"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}"
  },
  {
    "function_name": "virSocketAddrFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "441-445",
    "snippet": "char *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrFormatFull",
          "args": [
            "addr",
            "false",
            "NULL"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrFormatFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "460-514",
          "snippet": "char *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormatFull(const virSocketAddr *addr,\n                        bool withService,\n                        const char *separator)\n{\n    char host[NI_MAXHOST], port[NI_MAXSERV];\n    char *addrstr;\n    int err;\n\n    if (addr == NULL) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return NULL;\n    }\n\n    /* Short-circuit since getnameinfo doesn't work\n     * nicely for UNIX sockets */\n    if (addr->data.sa.sa_family == AF_UNIX) {\n        if (withService) {\n            addrstr = g_strdup_printf(VIR_LOOPBACK_IPV4_ADDR \"%s0\",\n                                      separator ? separator : \":\");\n        } else {\n            addrstr = g_strdup(VIR_LOOPBACK_IPV4_ADDR);\n        }\n        return addrstr;\n    }\n\n    if ((err = getnameinfo(&addr->data.sa,\n                           addr->len,\n                           host, sizeof(host),\n                           port, sizeof(port),\n                           NI_NUMERICHOST | NI_NUMERICSERV)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot convert socket address to string: %s\"),\n                       gai_strerror(err));\n        return NULL;\n    }\n\n    if (withService) {\n        g_autofree char *ipv6_host = NULL;\n        /* sasl_new_client demands the socket address to be in an odd format:\n         * a.b.c.d;port or e:f:g:h:i:j:k:l;port, so use square brackets for\n         * IPv6 only if no separator is passed to the function\n         */\n        if (!separator && VIR_SOCKET_ADDR_FAMILY(addr) == AF_INET6)\n            ipv6_host = g_strdup_printf(\"[%s]\", host);\n\n        addrstr = g_strdup_printf(\"%s%s%s\",\n                                  ipv6_host ? ipv6_host : host,\n                                  separator ? separator : \":\", port);\n    } else {\n        addrstr = g_strdup(host);\n    }\n\n    return addrstr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nchar *\nvirSocketAddrFormat(const virSocketAddr *addr)\n{\n    return virSocketAddrFormatFull(addr, false, NULL);\n}"
  },
  {
    "function_name": "virSocketAddrIsWildcard",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "419-431",
    "snippet": "bool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "IN6_IS_ADDR_UNSPECIFIED",
          "args": [
            "&addr->data.inet6.sin6_addr"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&addr->data.inet4.sin_addr.s_addr",
            "&tmp.s_addr",
            "sizeof(addr->data.inet4.sin_addr.s_addr)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsWildcard(const virSocketAddr *addr)\n{\n    struct in_addr tmp = { .s_addr = INADDR_ANY };\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n        return memcmp(&addr->data.inet4.sin_addr.s_addr, &tmp.s_addr,\n                      sizeof(addr->data.inet4.sin_addr.s_addr)) == 0;\n    case AF_INET6:\n        return IN6_IS_ADDR_UNSPECIFIED(&addr->data.inet6.sin6_addr);\n    }\n    return false;\n}"
  },
  {
    "function_name": "virSocketAddrIsPrivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "392-411",
    "snippet": "bool\nvirSocketAddrIsPrivate(const virSocketAddr *addr)\n{\n    unsigned long val;\n\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n       val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n       return ((val & 0xFFFF0000) == ((192UL << 24) + (168 << 16)) ||\n               (val & 0xFFF00000) == ((172UL << 24) + (16  << 16)) ||\n               (val & 0xFF000000) == ((10UL  << 24)));\n\n    case AF_INET6:\n        return ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFE) == 0xFC ||\n                ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFF) == 0xFE &&\n                 (addr->data.inet6.sin6_addr.s6_addr[1] & 0xC0) == 0xC0));\n    }\n    return false;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "addr->data.inet4.sin_addr.s_addr"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrIsPrivate(const virSocketAddr *addr)\n{\n    unsigned long val;\n\n    switch (addr->data.stor.ss_family) {\n    case AF_INET:\n       val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n       return ((val & 0xFFFF0000) == ((192UL << 24) + (168 << 16)) ||\n               (val & 0xFFF00000) == ((172UL << 24) + (16  << 16)) ||\n               (val & 0xFF000000) == ((10UL  << 24)));\n\n    case AF_INET6:\n        return ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFE) == 0xFC ||\n                ((addr->data.inet6.sin6_addr.s6_addr[0] & 0xFF) == 0xFE &&\n                 (addr->data.inet6.sin6_addr.s6_addr[1] & 0xC0) == 0xC0));\n    }\n    return false;\n}"
  },
  {
    "function_name": "virSocketAddrEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "359-378",
    "snippet": "bool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&s1->data.inet6.sin6_addr.s6_addr",
            "&s2->data.inet6.sin6_addr.s6_addr",
            "sizeof(s1->data.inet6.sin6_addr.s6_addr)"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&s1->data.inet4.sin_addr.s_addr",
            "&s2->data.inet4.sin_addr.s_addr",
            "sizeof(s1->data.inet4.sin_addr.s_addr)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nbool\nvirSocketAddrEqual(const virSocketAddr *s1, const virSocketAddr *s2)\n{\n    if (s1->data.stor.ss_family != s2->data.stor.ss_family)\n        return false;\n\n    switch (s1->data.stor.ss_family) {\n    case AF_INET:\n        return (memcmp(&s1->data.inet4.sin_addr.s_addr,\n                       &s2->data.inet4.sin_addr.s_addr,\n                       sizeof(s1->data.inet4.sin_addr.s_addr)) == 0 &&\n                s1->data.inet4.sin_port == s2->data.inet4.sin_port);\n    case AF_INET6:\n        return (memcmp(&s1->data.inet6.sin6_addr.s6_addr,\n                       &s2->data.inet6.sin6_addr.s6_addr,\n                       sizeof(s1->data.inet6.sin6_addr.s6_addr)) == 0 &&\n                s1->data.inet6.sin6_port == s2->data.inet6.sin6_port);\n    }\n    return false;\n}"
  },
  {
    "function_name": "virSocketAddrSetIPv6Addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "340-349",
    "snippet": "void virSocketAddrSetIPv6Addr(virSocketAddrPtr addr, uint32_t val[4])\n{\n    size_t i = 0;\n    uint32_t host_val[4];\n\n    for (i = 0; i < 4; i++)\n        host_val[i] = htonl(val[i]);\n\n    virSocketAddrSetIPv6AddrNetOrder(addr, host_val);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrSetIPv6AddrNetOrder",
          "args": [
            "addr",
            "host_val"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrSetIPv6AddrNetOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "325-330",
          "snippet": "void virSocketAddrSetIPv6AddrNetOrder(virSocketAddrPtr addr, uint32_t val[4])\n{\n    addr->data.stor.ss_family = AF_INET6;\n    memcpy(addr->data.inet6.sin6_addr.s6_addr, val, 4 * sizeof(*val));\n    addr->len = sizeof(struct sockaddr_in6);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid virSocketAddrSetIPv6AddrNetOrder(virSocketAddrPtr addr, uint32_t val[4])\n{\n    addr->data.stor.ss_family = AF_INET6;\n    memcpy(addr->data.inet6.sin6_addr.s6_addr, val, 4 * sizeof(*val));\n    addr->len = sizeof(struct sockaddr_in6);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "val[i]"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid virSocketAddrSetIPv6Addr(virSocketAddrPtr addr, uint32_t val[4])\n{\n    size_t i = 0;\n    uint32_t host_val[4];\n\n    for (i = 0; i < 4; i++)\n        host_val[i] = htonl(val[i]);\n\n    virSocketAddrSetIPv6AddrNetOrder(addr, host_val);\n}"
  },
  {
    "function_name": "virSocketAddrSetIPv6AddrNetOrder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "325-330",
    "snippet": "void virSocketAddrSetIPv6AddrNetOrder(virSocketAddrPtr addr, uint32_t val[4])\n{\n    addr->data.stor.ss_family = AF_INET6;\n    memcpy(addr->data.inet6.sin6_addr.s6_addr, val, 4 * sizeof(*val));\n    addr->len = sizeof(struct sockaddr_in6);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "addr->data.inet6.sin6_addr.s6_addr",
            "val",
            "4 * sizeof(*val)"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid virSocketAddrSetIPv6AddrNetOrder(virSocketAddrPtr addr, uint32_t val[4])\n{\n    addr->data.stor.ss_family = AF_INET6;\n    memcpy(addr->data.inet6.sin6_addr.s6_addr, val, 4 * sizeof(*val));\n    addr->len = sizeof(struct sockaddr_in6);\n}"
  },
  {
    "function_name": "virSocketAddrSetIPv4Addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "311-315",
    "snippet": "void\nvirSocketAddrSetIPv4Addr(virSocketAddrPtr addr, uint32_t val)\n{\n    virSocketAddrSetIPv4AddrNetOrder(addr, htonl(val));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrSetIPv4AddrNetOrder",
          "args": [
            "addr",
            "htonl(val)"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrSetIPv4AddrNetOrder",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "295-301",
          "snippet": "void\nvirSocketAddrSetIPv4AddrNetOrder(virSocketAddrPtr addr, uint32_t val)\n{\n    addr->data.stor.ss_family = AF_INET;\n    addr->data.inet4.sin_addr.s_addr = val;\n    addr->len = sizeof(struct sockaddr_in);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid\nvirSocketAddrSetIPv4AddrNetOrder(virSocketAddrPtr addr, uint32_t val)\n{\n    addr->data.stor.ss_family = AF_INET;\n    addr->data.inet4.sin_addr.s_addr = val;\n    addr->len = sizeof(struct sockaddr_in);\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "val"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid\nvirSocketAddrSetIPv4Addr(virSocketAddrPtr addr, uint32_t val)\n{\n    virSocketAddrSetIPv4AddrNetOrder(addr, htonl(val));\n}"
  },
  {
    "function_name": "virSocketAddrSetIPv4AddrNetOrder",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "295-301",
    "snippet": "void\nvirSocketAddrSetIPv4AddrNetOrder(virSocketAddrPtr addr, uint32_t val)\n{\n    addr->data.stor.ss_family = AF_INET;\n    addr->data.inet4.sin_addr.s_addr = val;\n    addr->len = sizeof(struct sockaddr_in);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nvoid\nvirSocketAddrSetIPv4AddrNetOrder(virSocketAddrPtr addr, uint32_t val)\n{\n    addr->data.stor.ss_family = AF_INET;\n    addr->data.inet4.sin_addr.s_addr = val;\n    addr->len = sizeof(struct sockaddr_in);\n}"
  },
  {
    "function_name": "virSocketAddrResolveService",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "245-285",
    "snippet": "int virSocketAddrResolveService(const char *service)\n{\n    struct addrinfo *res, *tmp;\n    struct addrinfo hints;\n    int err;\n    int port = -1;\n\n    memset(&hints, 0, sizeof(hints));\n\n    if ((err = getaddrinfo(NULL, service, &hints, &res)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot parse socket service '%s': %s\"),\n                       service, gai_strerror(err));\n        return -1;\n    }\n\n    tmp = res;\n    while (tmp) {\n        if (tmp->ai_family == AF_INET) {\n            struct sockaddr_in in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin_port);\n            goto cleanup;\n        } else if (tmp->ai_family == AF_INET6) {\n            struct sockaddr_in6 in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin6_port);\n            goto cleanup;\n        }\n        tmp++;\n    }\n\n    virReportError(VIR_ERR_SYSTEM_ERROR,\n                   _(\"No matches for socket service '%s': %s\"),\n                   service, gai_strerror(err));\n\n cleanup:\n    freeaddrinfo(res);\n\n    return port;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"No matches for socket service '%s': %s\")",
            "service",
            "gai_strerror(err)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No matches for socket service '%s': %s\""
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "in.sin6_port"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&in",
            "tmp->ai_addr",
            "sizeof(in)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "in.sin_port"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&in",
            "tmp->ai_addr",
            "sizeof(in)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Cannot parse socket service '%s': %s\")",
            "service",
            "gai_strerror(err)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "NULL",
            "service",
            "&hints",
            "&res"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrResolveService(const char *service)\n{\n    struct addrinfo *res, *tmp;\n    struct addrinfo hints;\n    int err;\n    int port = -1;\n\n    memset(&hints, 0, sizeof(hints));\n\n    if ((err = getaddrinfo(NULL, service, &hints, &res)) != 0) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"Cannot parse socket service '%s': %s\"),\n                       service, gai_strerror(err));\n        return -1;\n    }\n\n    tmp = res;\n    while (tmp) {\n        if (tmp->ai_family == AF_INET) {\n            struct sockaddr_in in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin_port);\n            goto cleanup;\n        } else if (tmp->ai_family == AF_INET6) {\n            struct sockaddr_in6 in;\n            memcpy(&in, tmp->ai_addr, sizeof(in));\n            port = ntohs(in.sin6_port);\n            goto cleanup;\n        }\n        tmp++;\n    }\n\n    virReportError(VIR_ERR_SYSTEM_ERROR,\n                   _(\"No matches for socket service '%s': %s\"),\n                   service, gai_strerror(err));\n\n cleanup:\n    freeaddrinfo(res);\n\n    return port;\n}"
  },
  {
    "function_name": "virSocketAddrParseIPv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "230-234",
    "snippet": "int\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "addr",
            "val",
            "AF_INET6"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv6(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET6);\n}"
  },
  {
    "function_name": "virSocketAddrParseIPv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "215-219",
    "snippet": "int\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSocketAddrParse",
          "args": [
            "addr",
            "val",
            "AF_INET"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "135-158",
          "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint\nvirSocketAddrParseIPv4(virSocketAddrPtr addr, const char *val)\n{\n    return virSocketAddrParse(addr, val, AF_INET);\n}"
  },
  {
    "function_name": "virSocketAddrParseAny",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "176-204",
    "snippet": "int virSocketAddrParseAny(virSocketAddrPtr addr,\n                          const char *val,\n                          int family,\n                          bool reportError)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, 0, reportError) < 0)\n        return -1;\n\n    if (res == NULL) {\n        if (reportError) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"No socket addresses found for '%s'\"),\n                           val);\n        }\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr->data.stor",
            "res->ai_addr",
            "len"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"No socket addresses found for '%s'\")",
            "val"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No socket addresses found for '%s'\""
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseInternal",
          "args": [
            "&res",
            "val",
            "family",
            "0",
            "reportError"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "93-122",
          "snippet": "static int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParseAny(virSocketAddrPtr addr,\n                          const char *val,\n                          int family,\n                          bool reportError)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, 0, reportError) < 0)\n        return -1;\n\n    if (res == NULL) {\n        if (reportError) {\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"No socket addresses found for '%s'\"),\n                           val);\n        }\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
  },
  {
    "function_name": "virSocketAddrParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "135-158",
    "snippet": "int virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "freeaddrinfo",
          "args": [
            "res"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&addr->data.stor",
            "res->ai_addr",
            "len"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"No socket addresses found for '%s'\")",
            "val"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No socket addresses found for '%s'\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSocketAddrParseInternal",
          "args": [
            "&res",
            "val",
            "family",
            "AI_NUMERICHOST",
            "true"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virSocketAddrParseInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
          "lines": "93-122",
          "snippet": "static int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"virsocketaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nint virSocketAddrParse(virSocketAddrPtr addr, const char *val, int family)\n{\n    int len;\n    struct addrinfo *res;\n\n    if (virSocketAddrParseInternal(&res, val, family, AI_NUMERICHOST, true) < 0)\n        return -1;\n\n    if (res == NULL) {\n        virReportError(VIR_ERR_SYSTEM_ERROR,\n                       _(\"No socket addresses found for '%s'\"),\n                       val);\n        return -1;\n    }\n\n    len = res->ai_addrlen;\n    if (addr != NULL) {\n        memcpy(&addr->data.stor, res->ai_addr, len);\n        addr->len = res->ai_addrlen;\n    }\n\n    freeaddrinfo(res);\n    return len;\n}"
  },
  {
    "function_name": "virSocketAddrParseInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "93-122",
    "snippet": "static int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_SYSTEM_ERROR",
            "_(\"Cannot parse socket address '%s': %s\")",
            "val",
            "gai_strerror(err)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gai_strerror",
          "args": [
            "err"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot parse socket address '%s': %s\""
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getaddrinfo",
          "args": [
            "val",
            "NULL",
            "&hints",
            "res"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hints",
            "0",
            "sizeof(hints)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Missing address\")"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrParseInternal(struct addrinfo **res,\n                           const char *val,\n                           int family,\n                           int ai_flags,\n                           bool reportError)\n{\n    struct addrinfo hints;\n    int err;\n\n    if (val == NULL) {\n        if (reportError)\n            virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Missing address\"));\n        return -1;\n    }\n\n    memset(&hints, 0, sizeof(hints));\n    hints.ai_family = family;\n    hints.ai_flags = ai_flags;\n    if ((err = getaddrinfo(val, NULL, &hints, res)) != 0) {\n        if (reportError)\n            virReportError(VIR_ERR_SYSTEM_ERROR,\n                           _(\"Cannot parse socket address '%s': %s\"),\n                           val, gai_strerror(err));\n\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrGetIPv6Nibbles",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "76-91",
    "snippet": "static int\nvirSocketAddrGetIPv6Nibbles(const virSocketAddr *addr,\n                            virSocketAddrIPv6NibblesPtr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 16; i++) {\n        (*tab)[2 * i] = addr->data.inet6.sin6_addr.s6_addr[i] >> 4;\n        (*tab)[2 * i + 1] = addr->data.inet6.sin6_addr.s6_addr[i] & 0xF;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Nibbles(const virSocketAddr *addr,\n                            virSocketAddrIPv6NibblesPtr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 16; i++) {\n        (*tab)[2 * i] = addr->data.inet6.sin6_addr.s6_addr[i] >> 4;\n        (*tab)[2 * i + 1] = addr->data.inet6.sin6_addr.s6_addr[i] & 0xF;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrGetIPv6Addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "60-74",
    "snippet": "static int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv6Addr(const virSocketAddr *addr, virSocketAddrIPv6Ptr tab)\n{\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET6)\n        return -1;\n\n    for (i = 0; i < 8; i++) {\n        (*tab)[i] = ((addr->data.inet6.sin6_addr.s6_addr[2 * i] << 8) |\n                     addr->data.inet6.sin6_addr.s6_addr[2 * i + 1]);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSocketAddrGetIPv4Addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virsocketaddr.c",
    "lines": "40-58",
    "snippet": "static int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virbuffer.h\"",
      "#include \"virstring.h\"",
      "#include \"virerror.h\"",
      "#include \"virsocketaddr.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "addr->data.inet4.sin_addr.s_addr"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"virsocketaddr.h\"\n#include <config.h>\n\nstatic int\nvirSocketAddrGetIPv4Addr(const virSocketAddr *addr,\n                         virSocketAddrIPv4Ptr tab)\n{\n    unsigned long val;\n    size_t i;\n\n    if (!addr || !tab || addr->data.stor.ss_family != AF_INET)\n        return -1;\n\n    val = ntohl(addr->data.inet4.sin_addr.s_addr);\n\n    for (i = 0; i < 4; i++) {\n        (*tab)[3 - i] = val & 0xFF;\n        val >>= 8;\n    }\n\n    return 0;\n}"
  }
]