[
  {
    "function_name": "esxRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "5164-5169",
    "snippet": "int\nesxRegister(void)\n{\n    return virRegisterConnectDriver(&esxConnectDriver,\n                                    false);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virConnectDriver esxConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"vpx\", \"esx\", \"gsx\", NULL },\n    .hypervisorDriver = &esxHypervisorDriver,\n    .interfaceDriver = &esxInterfaceDriver,\n    .networkDriver = &esxNetworkDriver,\n    .storageDriver = &esxStorageDriver,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRegisterConnectDriver",
          "args": [
            "&esxConnectDriver",
            "false"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "virRegisterConnectDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libvirt.c",
          "lines": "515-550",
          "snippet": "int\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}",
          "includes": [
            "#include \"access/viraccessmanager.h\"",
            "# include \"bhyve/bhyve_driver.h\"",
            "# include \"hyperv/hyperv_driver.h\"",
            "# include \"esx/esx_driver.h\"",
            "# include \"vmware/vmware_driver.h\"",
            "# include \"openvz/openvz_driver.h\"",
            "# include \"remote/remote_driver.h\"",
            "# include \"test/test_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"viruri.h\"",
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"virevent.h\"",
            "#include \"vircommand.h\"",
            "#include \"rpc/virnettlscontext.h\"",
            "#include \"virconf.h\"",
            "#include \"configmake.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruuid.h\"",
            "#include \"driver.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <curl/curl.h>",
            "#include <libxml/xpath.h>",
            "#include <libxml/parser.h>",
            "#include <gio/gnetworking.h>",
            "#include <time.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define MAX_DRIVERS 21"
          ],
          "globals_used": [
            "static virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];",
            "static int virConnectDriverTabCount;",
            "static virNetworkDriverPtr virSharedNetworkDriver;",
            "static virInterfaceDriverPtr virSharedInterfaceDriver;",
            "static virStorageDriverPtr virSharedStorageDriver;",
            "static virNodeDeviceDriverPtr virSharedNodeDeviceDriver;",
            "static virSecretDriverPtr virSharedSecretDriver;",
            "static virNWFilterDriverPtr virSharedNWFilterDriver;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"access/viraccessmanager.h\"\n# include \"bhyve/bhyve_driver.h\"\n# include \"hyperv/hyperv_driver.h\"\n# include \"esx/esx_driver.h\"\n# include \"vmware/vmware_driver.h\"\n# include \"openvz/openvz_driver.h\"\n# include \"remote/remote_driver.h\"\n# include \"test/test_driver.h\"\n#include \"virtypedparam.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"viruri.h\"\n#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"virevent.h\"\n#include \"vircommand.h\"\n#include \"rpc/virnettlscontext.h\"\n#include \"virconf.h\"\n#include \"configmake.h\"\n#include \"viralloc.h\"\n#include \"viruuid.h\"\n#include \"driver.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <curl/curl.h>\n#include <libxml/xpath.h>\n#include <libxml/parser.h>\n#include <gio/gnetworking.h>\n#include <time.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define MAX_DRIVERS 21\n\nstatic virConnectDriverPtr virConnectDriverTab[MAX_DRIVERS];\nstatic int virConnectDriverTabCount;\nstatic virNetworkDriverPtr virSharedNetworkDriver;\nstatic virInterfaceDriverPtr virSharedInterfaceDriver;\nstatic virStorageDriverPtr virSharedStorageDriver;\nstatic virNodeDeviceDriverPtr virSharedNodeDeviceDriver;\nstatic virSecretDriverPtr virSharedSecretDriver;\nstatic virNWFilterDriverPtr virSharedNWFilterDriver;\n\nint\nvirRegisterConnectDriver(virConnectDriverPtr driver,\n                         bool setSharedDrivers)\n{\n    VIR_DEBUG(\"driver=%p name=%s\", driver,\n              driver ? NULLSTR(driver->hypervisorDriver->name) : \"(null)\");\n\n    virCheckNonNullArgReturn(driver, -1);\n    if (virConnectDriverTabCount >= MAX_DRIVERS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Too many drivers, cannot register %s\"),\n                       driver->hypervisorDriver->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"registering %s as driver %d\",\n           driver->hypervisorDriver->name, virConnectDriverTabCount);\n\n    if (setSharedDrivers) {\n        if (driver->interfaceDriver == NULL)\n            driver->interfaceDriver = virSharedInterfaceDriver;\n        if (driver->networkDriver == NULL)\n            driver->networkDriver = virSharedNetworkDriver;\n        if (driver->nodeDeviceDriver == NULL)\n            driver->nodeDeviceDriver = virSharedNodeDeviceDriver;\n        if (driver->nwfilterDriver == NULL)\n            driver->nwfilterDriver = virSharedNWFilterDriver;\n        if (driver->secretDriver == NULL)\n            driver->secretDriver = virSharedSecretDriver;\n        if (driver->storageDriver == NULL)\n            driver->storageDriver = virSharedStorageDriver;\n    }\n\n    virConnectDriverTab[virConnectDriverTabCount] = driver;\n    return virConnectDriverTabCount++;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virConnectDriver esxConnectDriver = {\n    .remoteOnly = true,\n    .uriSchemes = (const char *[]){ \"vpx\", \"esx\", \"gsx\", NULL },\n    .hypervisorDriver = &esxHypervisorDriver,\n    .interfaceDriver = &esxInterfaceDriver,\n    .networkDriver = &esxNetworkDriver,\n    .storageDriver = &esxStorageDriver,\n};\n\nint\nesxRegister(void)\n{\n    return virRegisterConnectDriver(&esxConnectDriver,\n                                    false);\n}"
  },
  {
    "function_name": "esxDomainHasManagedSaveImage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "5035-5069",
    "snippet": "static int\nesxDomainHasManagedSaveImage(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (esxVI_FindByUuid(priv->primary, priv->primary->datacenter->_reference,\n                         uuid_string, esxVI_Boolean_True,\n                         esxVI_Boolean_Undefined,\n                         &managedObjectReference) < 0) {\n        return -1;\n    }\n\n    if (!managedObjectReference) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with UUID '%s'\"),\n                       uuid_string);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&managedObjectReference"
          ],
          "line": 5067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"Could not find domain with UUID '%s'\")",
            "uuid_string"
          ],
          "line": 5058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find domain with UUID '%s'\""
          ],
          "line": 5059
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_FindByUuid",
          "args": [
            "priv->primary",
            "priv->primary->datacenter->_reference",
            "uuid_string",
            "esxVI_Boolean_True",
            "esxVI_Boolean_Undefined",
            "&managedObjectReference"
          ],
          "line": 5050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "domain->uuid",
            "uuid_string"
          ],
          "line": 5048
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 5043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainHasManagedSaveImage(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    virUUIDFormat(domain->uuid, uuid_string);\n\n    if (esxVI_FindByUuid(priv->primary, priv->primary->datacenter->_reference,\n                         uuid_string, esxVI_Boolean_True,\n                         esxVI_Boolean_Undefined,\n                         &managedObjectReference) < 0) {\n        return -1;\n    }\n\n    if (!managedObjectReference) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with UUID '%s'\"),\n                       uuid_string);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n    return result;\n}"
  },
  {
    "function_name": "esxConnectListAllDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4797-5032",
    "snippet": "static int\nesxConnectListAllDomains(virConnectPtr conn,\n                         virDomainPtr **domains,\n                         unsigned int flags)\n{\n    int ret = -1;\n    esxPrivate *priv = conn->privateData;\n    bool needIdentity;\n    bool needPowerState;\n    virDomainPtr dom;\n    virDomainPtr *doms = NULL;\n    size_t ndoms = 0;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_AutoStartDefaults *autoStartDefaults = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    char *name = NULL;\n    int id;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int count = 0;\n    bool autostart;\n    int state;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* check for flags that would produce empty output lists:\n     * - persistence: all esx machines are persistent\n     * - managed save: esx doesn't support managed save\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE))) {\n        if (domains &&\n            VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* check system default autostart value */\n    if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART)) {\n        if (esxVI_LookupAutoStartDefaults(priv->primary,\n                                          &autoStartDefaults) < 0) {\n            goto cleanup;\n        }\n\n        if (autoStartDefaults->enabled == esxVI_Boolean_True) {\n            if (esxVI_LookupAutoStartPowerInfoList(priv->primary,\n                                                   &powerInfoList) < 0) {\n                goto cleanup;\n            }\n        }\n    }\n\n    needIdentity = MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT) ||\n                   domains;\n\n    if (needIdentity) {\n        /* Request required data for esxVI_GetVirtualMachineIdentity */\n        if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                               \"configStatus\\0\"\n                                               \"name\\0\"\n                                               \"config.uuid\\0\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    needPowerState = MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) ||\n                     MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE) ||\n                     domains;\n\n    if (needPowerState) {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"runtime.powerState\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"snapshot.rootSnapshotList\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0)\n        goto cleanup;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, 1) < 0)\n            goto cleanup;\n        ndoms = 1;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (needIdentity) {\n            VIR_FREE(name);\n\n            if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id,\n                                                &name, uuid) < 0) {\n                goto cleanup;\n            }\n        }\n\n        if (needPowerState) {\n            if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                                  &powerState) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* filter by active state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) &&\n            !((MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) &&\n               powerState != esxVI_VirtualMachinePowerState_PoweredOff) ||\n              (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE) &&\n               powerState == esxVI_VirtualMachinePowerState_PoweredOff)))\n            continue;\n\n        /* filter by snapshot existence */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n\n            esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n            for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n                dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n                    if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                        (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n                   rootSnapshotTreeList) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT) &&\n                   !rootSnapshotTreeList)))\n                continue;\n        }\n\n        /* filter by autostart */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART)) {\n            autostart = false;\n\n            if (autoStartDefaults->enabled == esxVI_Boolean_True) {\n                for (powerInfo = powerInfoList; powerInfo;\n                     powerInfo = powerInfo->_next) {\n                    if (STREQ(powerInfo->key->value, virtualMachine->obj->value)) {\n                        if (STRCASEEQ(powerInfo->startAction, \"powerOn\"))\n                            autostart = true;\n\n                        break;\n                    }\n                }\n            }\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n                   autostart) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART) &&\n                   !autostart)))\n                continue;\n        }\n\n        /* filter by domain state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE)) {\n            state = esxVI_VirtualMachinePowerState_ConvertToLibvirt(powerState);\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n                   state == VIR_DOMAIN_RUNNING) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n                   state == VIR_DOMAIN_PAUSED) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n                   state == VIR_DOMAIN_SHUTOFF) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n                   (state != VIR_DOMAIN_RUNNING &&\n                    state != VIR_DOMAIN_PAUSED &&\n                    state != VIR_DOMAIN_SHUTOFF))))\n                continue;\n        }\n\n        /* just count the machines */\n        if (!doms) {\n            count++;\n            continue;\n        }\n\n        if (VIR_RESIZE_N(doms, ndoms, count, 2) < 0)\n            goto cleanup;\n\n        /* Only running/suspended virtual machines have an ID != -1 */\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n            id = -1;\n\n        if (!(dom = virGetDomain(conn, name, uuid, id)))\n            goto cleanup;\n\n        doms[count++] = dom;\n    }\n\n    if (doms)\n        *domains = doms;\n    doms = NULL;\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (id = 0; id < count; id++)\n            virObjectUnref(doms[id]);\n\n        VIR_FREE(doms);\n    }\n\n    VIR_FREE(name);\n    esxVI_AutoStartDefaults_Free(&autoStartDefaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return ret;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 5029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 5028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 5027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_Free",
          "args": [
            "&powerInfoList"
          ],
          "line": 5026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartDefaults_Free",
          "args": [
            "&autoStartDefaults"
          ],
          "line": 5025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 5024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "doms"
          ],
          "line": 5021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "doms[id]"
          ],
          "line": 5019
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "name",
            "uuid",
            "id"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_RESIZE_N",
          "args": [
            "doms",
            "ndoms",
            "count",
            "2"
          ],
          "line": 4998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_OTHER"
          ],
          "line": 4985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_SHUTOFF"
          ],
          "line": 4983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PAUSED"
          ],
          "line": 4981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_RUNNING"
          ],
          "line": 4979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_ConvertToLibvirt",
          "args": [
            "powerState"
          ],
          "line": 4977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE"
          ],
          "line": 4976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART"
          ],
          "line": 4970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_AUTOSTART"
          ],
          "line": 4968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "powerInfo->startAction",
            "\"powerOn\""
          ],
          "line": 4960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "powerInfo->key->value",
            "virtualMachine->obj->value"
          ],
          "line": 4959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART"
          ],
          "line": 4953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT"
          ],
          "line": 4947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT"
          ],
          "line": 4945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&rootSnapshotTreeList"
          ],
          "line": 4936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"snapshot.rootSnapshotList\""
          ],
          "line": 4935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_INACTIVE"
          ],
          "line": 4924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_ACTIVE"
          ],
          "line": 4922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE"
          ],
          "line": 4921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 4914
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id",
            "&name",
            "uuid"
          ],
          "line": 4907
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 4905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "doms",
            "1"
          ],
          "line": 4897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&virtualMachineList"
          ],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"snapshot.rootSnapshotList\""
          ],
          "line": 4886
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT"
          ],
          "line": 4885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE"
          ],
          "line": 4875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE"
          ],
          "line": 4874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"configStatus\\0\"\n                                               \"name\\0\"\n                                               \"config.uuid\\0\""
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT"
          ],
          "line": 4861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartPowerInfoList",
          "args": [
            "priv->primary",
            "&powerInfoList"
          ],
          "line": 4854
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartPowerInfoList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3804-3848",
          "snippet": "int\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartDefaults",
          "args": [
            "priv->primary",
            "&autoStartDefaults"
          ],
          "line": 4848
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartDefaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3750-3800",
          "snippet": "int\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART"
          ],
          "line": 4847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4843
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*domains",
            "1"
          ],
          "line": 4836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE"
          ],
          "line": 4834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE"
          ],
          "line": 4833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_PERSISTENT"
          ],
          "line": 4832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MATCH",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_TRANSIENT"
          ],
          "line": 4831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL",
            "-1"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxConnectListAllDomains(virConnectPtr conn,\n                         virDomainPtr **domains,\n                         unsigned int flags)\n{\n    int ret = -1;\n    esxPrivate *priv = conn->privateData;\n    bool needIdentity;\n    bool needPowerState;\n    virDomainPtr dom;\n    virDomainPtr *doms = NULL;\n    size_t ndoms = 0;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_AutoStartDefaults *autoStartDefaults = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    char *name = NULL;\n    int id;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    int count = 0;\n    bool autostart;\n    int state;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_CONNECT_LIST_DOMAINS_FILTERS_ALL, -1);\n\n    /* check for flags that would produce empty output lists:\n     * - persistence: all esx machines are persistent\n     * - managed save: esx doesn't support managed save\n     */\n    if ((MATCH(VIR_CONNECT_LIST_DOMAINS_TRANSIENT) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_PERSISTENT)) ||\n        (MATCH(VIR_CONNECT_LIST_DOMAINS_MANAGEDSAVE) &&\n         !MATCH(VIR_CONNECT_LIST_DOMAINS_NO_MANAGEDSAVE))) {\n        if (domains &&\n            VIR_ALLOC_N(*domains, 1) < 0)\n            goto cleanup;\n\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* check system default autostart value */\n    if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART)) {\n        if (esxVI_LookupAutoStartDefaults(priv->primary,\n                                          &autoStartDefaults) < 0) {\n            goto cleanup;\n        }\n\n        if (autoStartDefaults->enabled == esxVI_Boolean_True) {\n            if (esxVI_LookupAutoStartPowerInfoList(priv->primary,\n                                                   &powerInfoList) < 0) {\n                goto cleanup;\n            }\n        }\n    }\n\n    needIdentity = MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT) ||\n                   domains;\n\n    if (needIdentity) {\n        /* Request required data for esxVI_GetVirtualMachineIdentity */\n        if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                               \"configStatus\\0\"\n                                               \"name\\0\"\n                                               \"config.uuid\\0\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    needPowerState = MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) ||\n                     MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE) ||\n                     domains;\n\n    if (needPowerState) {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"runtime.powerState\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"snapshot.rootSnapshotList\") < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0)\n        goto cleanup;\n\n    if (domains) {\n        if (VIR_ALLOC_N(doms, 1) < 0)\n            goto cleanup;\n        ndoms = 1;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (needIdentity) {\n            VIR_FREE(name);\n\n            if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id,\n                                                &name, uuid) < 0) {\n                goto cleanup;\n            }\n        }\n\n        if (needPowerState) {\n            if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                                  &powerState) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* filter by active state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_ACTIVE) &&\n            !((MATCH(VIR_CONNECT_LIST_DOMAINS_ACTIVE) &&\n               powerState != esxVI_VirtualMachinePowerState_PoweredOff) ||\n              (MATCH(VIR_CONNECT_LIST_DOMAINS_INACTIVE) &&\n               powerState == esxVI_VirtualMachinePowerState_PoweredOff)))\n            continue;\n\n        /* filter by snapshot existence */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_SNAPSHOT)) {\n\n            esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n            for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n                dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n                    if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                        (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_HAS_SNAPSHOT) &&\n                   rootSnapshotTreeList) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_SNAPSHOT) &&\n                   !rootSnapshotTreeList)))\n                continue;\n        }\n\n        /* filter by autostart */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_AUTOSTART)) {\n            autostart = false;\n\n            if (autoStartDefaults->enabled == esxVI_Boolean_True) {\n                for (powerInfo = powerInfoList; powerInfo;\n                     powerInfo = powerInfo->_next) {\n                    if (STREQ(powerInfo->key->value, virtualMachine->obj->value)) {\n                        if (STRCASEEQ(powerInfo->startAction, \"powerOn\"))\n                            autostart = true;\n\n                        break;\n                    }\n                }\n            }\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_AUTOSTART) &&\n                   autostart) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_NO_AUTOSTART) &&\n                   !autostart)))\n                continue;\n        }\n\n        /* filter by domain state */\n        if (MATCH(VIR_CONNECT_LIST_DOMAINS_FILTERS_STATE)) {\n            state = esxVI_VirtualMachinePowerState_ConvertToLibvirt(powerState);\n\n            if (!((MATCH(VIR_CONNECT_LIST_DOMAINS_RUNNING) &&\n                   state == VIR_DOMAIN_RUNNING) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_PAUSED) &&\n                   state == VIR_DOMAIN_PAUSED) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_SHUTOFF) &&\n                   state == VIR_DOMAIN_SHUTOFF) ||\n                  (MATCH(VIR_CONNECT_LIST_DOMAINS_OTHER) &&\n                   (state != VIR_DOMAIN_RUNNING &&\n                    state != VIR_DOMAIN_PAUSED &&\n                    state != VIR_DOMAIN_SHUTOFF))))\n                continue;\n        }\n\n        /* just count the machines */\n        if (!doms) {\n            count++;\n            continue;\n        }\n\n        if (VIR_RESIZE_N(doms, ndoms, count, 2) < 0)\n            goto cleanup;\n\n        /* Only running/suspended virtual machines have an ID != -1 */\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n            id = -1;\n\n        if (!(dom = virGetDomain(conn, name, uuid, id)))\n            goto cleanup;\n\n        doms[count++] = dom;\n    }\n\n    if (doms)\n        *domains = doms;\n    doms = NULL;\n    ret = count;\n\n cleanup:\n    if (doms) {\n        for (id = 0; id < count; id++)\n            virObjectUnref(doms[id]);\n\n        VIR_FREE(doms);\n    }\n\n    VIR_FREE(name);\n    esxVI_AutoStartDefaults_Free(&autoStartDefaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return ret;\n}"
  },
  {
    "function_name": "esxDomainGetMemoryParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4749-4794",
    "snippet": "static int\nesxDomainGetMemoryParameters(virDomainPtr domain, virTypedParameterPtr params,\n                             int *nparams, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_Long *reservation = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (*nparams == 0) {\n        *nparams = 1; /* min_guarantee */\n        return 0;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.memoryAllocation.reservation\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetLong(virtualMachine, \"config.memoryAllocation.reservation\",\n                      &reservation, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Scale from megabytes to kilobytes */\n    if (virTypedParameterAssign(params, VIR_DOMAIN_MEMORY_MIN_GUARANTEE,\n                                VIR_TYPED_PARAM_ULLONG,\n                                reservation->value * 1024) < 0)\n        goto cleanup;\n\n    *nparams = 1;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_Long_Free(&reservation);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_Long_Free",
          "args": [
            "&reservation"
          ],
          "line": 4791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 4790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 4789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParameterAssign",
          "args": [
            "params",
            "VIR_DOMAIN_MEMORY_MIN_GUARANTEE",
            "VIR_TYPED_PARAM_ULLONG",
            "reservation->value * 1024"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParameterAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "276-294",
          "snippet": "int\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetLong",
          "args": [
            "virtualMachine",
            "\"config.memoryAllocation.reservation\"",
            "&reservation",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4774
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2294-2319",
          "snippet": "int\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4771
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.memoryAllocation.reservation\""
          ],
          "line": 4769
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4766
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4759
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetMemoryParameters(virDomainPtr domain, virTypedParameterPtr params,\n                             int *nparams, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_Long *reservation = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (*nparams == 0) {\n        *nparams = 1; /* min_guarantee */\n        return 0;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList\n          (&propertyNameList, \"config.memoryAllocation.reservation\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetLong(virtualMachine, \"config.memoryAllocation.reservation\",\n                      &reservation, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Scale from megabytes to kilobytes */\n    if (virTypedParameterAssign(params, VIR_DOMAIN_MEMORY_MIN_GUARANTEE,\n                                VIR_TYPED_PARAM_ULLONG,\n                                reservation->value * 1024) < 0)\n        goto cleanup;\n\n    *nparams = 1;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_Long_Free(&reservation);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSetMemoryParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4679-4745",
    "snippet": "static int\nesxDomainSetMemoryParameters(virDomainPtr domain, virTypedParameterPtr params,\n                             int nparams, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_MEMORY_MIN_GUARANTEE,\n                               VIR_TYPED_PARAM_ULLONG,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_MEMORY_MIN_GUARANTEE)) {\n            if (esxVI_Long_Alloc(&spec->memoryAllocation->reservation) < 0)\n                goto cleanup;\n\n            spec->memoryAllocation->reservation->value =\n              VIR_DIV_UP(params[i].value.ul, 1024); /* Scale from kilobytes to megabytes */\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change memory parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 4742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 4741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Free",
          "args": [
            "&spec"
          ],
          "line": 4740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 4739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not change memory parameters: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 4730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not change memory parameters: %s\""
          ],
          "line": 4731
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 4722
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "spec",
            "&task"
          ],
          "line": 4720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "params[i].value.ul",
            "1024"
          ],
          "line": 4716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&spec->memoryAllocation->reservation"
          ],
          "line": 4712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].field",
            "VIR_DOMAIN_MEMORY_MIN_GUARANTEE"
          ],
          "line": 4711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ResourceAllocationInfo_Alloc",
          "args": [
            "&spec->memoryAllocation"
          ],
          "line": 4706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Alloc",
          "args": [
            "&spec"
          ],
          "line": 4705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 4702
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsValidate",
          "args": [
            "params",
            "nparams",
            "VIR_DOMAIN_MEMORY_MIN_GUARANTEE",
            "VIR_TYPED_PARAM_ULLONG",
            "NULL"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "58-142",
          "snippet": "int\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetMemoryParameters(virDomainPtr domain, virTypedParameterPtr params,\n                             int nparams, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_MEMORY_MIN_GUARANTEE,\n                               VIR_TYPED_PARAM_ULLONG,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_MEMORY_MIN_GUARANTEE)) {\n            if (esxVI_Long_Alloc(&spec->memoryAllocation->reservation) < 0)\n                goto cleanup;\n\n            spec->memoryAllocation->reservation->value =\n              VIR_DIV_UP(params[i].value.ul, 1024); /* Scale from kilobytes to megabytes */\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change memory parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSnapshotDelete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4615-4675",
    "snippet": "static int\nesxDomainSnapshotDelete(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_Boolean removeChildren = esxVI_Boolean_False;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN)\n        removeChildren = esxVI_Boolean_True;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require any libvirt metadata, making this\n     * flag trivial once we know we have a valid snapshot.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_RemoveSnapshot_Task(priv->primary, snapshotTree->snapshot,\n                                  removeChildren, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, snapshot->domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not delete snapshot '%s': %s\"), snapshot->name,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 4672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 4671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not delete snapshot '%s': %s\")",
            "snapshot->name",
            "taskInfoErrorMessage"
          ],
          "line": 4661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not delete snapshot '%s': %s\""
          ],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "snapshot->domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 4653
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_RemoveSnapshot_Task",
          "args": [
            "priv->primary",
            "snapshotTree->snapshot",
            "removeChildren",
            "&task"
          ],
          "line": 4651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4638
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4636
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4630
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY",
            "-1"
          ],
          "line": 4627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotDelete(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_Boolean removeChildren = esxVI_Boolean_False;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN |\n                  VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_CHILDREN)\n        removeChildren = esxVI_Boolean_True;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require any libvirt metadata, making this\n     * flag trivial once we know we have a valid snapshot.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_DELETE_METADATA_ONLY) {\n        result = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_RemoveSnapshot_Task(priv->primary, snapshotTree->snapshot,\n                                  removeChildren, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, snapshot->domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not delete snapshot '%s': %s\"), snapshot->name,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainRevertToSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4563-4611",
    "snippet": "static int\nesxDomainRevertToSnapshot(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_RevertToSnapshot_Task(priv->primary, snapshotTree->snapshot, NULL,\n                                    esxVI_Boolean_Undefined, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, snapshot->domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not revert to snapshot '%s': %s\"), snapshot->name,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 4608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 4607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not revert to snapshot '%s': %s\")",
            "snapshot->name",
            "taskInfoErrorMessage"
          ],
          "line": 4597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not revert to snapshot '%s': %s\""
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "snapshot->domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 4589
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_RevertToSnapshot_Task",
          "args": [
            "priv->primary",
            "snapshotTree->snapshot",
            "NULL",
            "esxVI_Boolean_Undefined",
            "&task"
          ],
          "line": 4587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4581
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4576
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainRevertToSnapshot(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_RevertToSnapshot_Task(priv->primary, snapshotTree->snapshot, NULL,\n                                    esxVI_Boolean_Undefined, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, snapshot->domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not revert to snapshot '%s': %s\"), snapshot->name,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSnapshotHasMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4533-4560",
    "snippet": "static int\nesxDomainSnapshotHasMetadata(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check that snapshot exists.  If so, there is no metadata.  */\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    return ret;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4549
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4547
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4543
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotHasMetadata(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check that snapshot exists.  If so, there is no metadata.  */\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    return ret;\n}"
  },
  {
    "function_name": "esxDomainSnapshotIsCurrent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4495-4530",
    "snippet": "static int\nesxDomainSnapshotIsCurrent(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check that snapshot exists.  */\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, snapshot->domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    ret = STREQ(snapshot->name, currentSnapshotTree->name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    return ret;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&currentSnapshotTree"
          ],
          "line": 4527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "snapshot->name",
            "currentSnapshotTree->name"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupCurrentSnapshotTree",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&currentSnapshotTree",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4518
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupCurrentSnapshotTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3305-3381",
          "snippet": "int\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4510
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4506
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotIsCurrent(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    int ret = -1;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check that snapshot exists.  */\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, snapshot->domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    ret = STREQ(snapshot->name, currentSnapshotTree->name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    return ret;\n}"
  },
  {
    "function_name": "esxDomainSnapshotCurrent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4469-4492",
    "snippet": "static virDomainSnapshotPtr\nesxDomainSnapshotCurrent(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, currentSnapshotTree->name);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n\n    return snapshot;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&currentSnapshotTree"
          ],
          "line": 4489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "domain",
            "currentSnapshotTree->name"
          ],
          "line": 4487
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupCurrentSnapshotTree",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&currentSnapshotTree",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4481
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupCurrentSnapshotTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3305-3381",
          "snippet": "int\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4478
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainSnapshotPtr\nesxDomainSnapshotCurrent(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        return NULL;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, currentSnapshotTree->name);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n\n    return snapshot;\n}"
  },
  {
    "function_name": "esxDomainSnapshotGetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4430-4465",
    "snippet": "static virDomainSnapshotPtr\nesxDomainSnapshotGetParent(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTreeParent = NULL;\n    virDomainSnapshotPtr parent = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, &snapshotTreeParent,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!snapshotTreeParent) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"snapshot '%s' does not have a parent\"),\n                       snapshotTree->name);\n        goto cleanup;\n    }\n\n    parent = virGetDomainSnapshot(snapshot->domain, snapshotTreeParent->name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n\n    return parent;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "snapshot->domain",
            "snapshotTreeParent->name"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN_SNAPSHOT",
            "_(\"snapshot '%s' does not have a parent\")",
            "snapshotTree->name"
          ],
          "line": 4453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"snapshot '%s' does not have a parent\""
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "&snapshotTreeParent",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4446
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4441
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 4439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainSnapshotPtr\nesxDomainSnapshotGetParent(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTreeParent = NULL;\n    virDomainSnapshotPtr parent = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, &snapshotTreeParent,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!snapshotTreeParent) {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"snapshot '%s' does not have a parent\"),\n                       snapshotTree->name);\n        goto cleanup;\n    }\n\n    parent = virGetDomainSnapshot(snapshot->domain, snapshotTreeParent->name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n\n    return parent;\n}"
  },
  {
    "function_name": "esxDomainHasCurrentSnapshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4403-4426",
    "snippet": "static int\nesxDomainHasCurrentSnapshot(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_OptionalItem) < 0) {\n        return -1;\n    }\n\n    if (currentSnapshotTree) {\n        esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n        return 1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&currentSnapshotTree"
          ],
          "line": 4421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupCurrentSnapshotTree",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&currentSnapshotTree",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 4414
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupCurrentSnapshotTree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3305-3381",
          "snippet": "int\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupCurrentSnapshotTree\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **currentSnapshotTree,\n   esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedObjectReference *currentSnapshot = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(currentSnapshotTree);\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"snapshot.currentSnapshot\\0\"\n                                           \"snapshot.rootSnapshotList\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.currentSnapshot\")) {\n            if (esxVI_ManagedObjectReference_CastFromAnyType\n                  (dynamicProperty->val, &currentSnapshot) < 0) {\n                goto cleanup;\n            }\n        } else if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, &rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSnapshot) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT, \"%s\",\n                           _(\"Domain has no current snapshot\"));\n            goto cleanup;\n        }\n    }\n\n    if (!rootSnapshotTreeList) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup root snapshot list\"));\n        goto cleanup;\n    }\n\n    if (esxVI_GetSnapshotTreeBySnapshot(rootSnapshotTreeList, currentSnapshot,\n                                        &snapshotTree) < 0 ||\n        esxVI_VirtualMachineSnapshotTree_DeepCopy(currentSnapshotTree,\n                                                  snapshotTree) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_ManagedObjectReference_Free(&currentSnapshot);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4411
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 4409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainHasCurrentSnapshot(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *currentSnapshotTree = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupCurrentSnapshotTree(priv->primary, domain->uuid,\n                                        &currentSnapshotTree,\n                                        esxVI_Occurrence_OptionalItem) < 0) {\n        return -1;\n    }\n\n    if (currentSnapshotTree) {\n        esxVI_VirtualMachineSnapshotTree_Free(&currentSnapshotTree);\n        return 1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxDomainSnapshotLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4371-4399",
    "snippet": "static virDomainSnapshotPtr\nesxDomainSnapshotLookupByName(virDomainPtr domain, const char *name,\n                              unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, name, &snapshotTree,\n                                    NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return snapshot;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "domain",
            "name"
          ],
          "line": 4393
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotTreeList",
            "name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4387
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&rootSnapshotTreeList"
          ],
          "line": 4385
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4382
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 4380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainSnapshotPtr\nesxDomainSnapshotLookupByName(virDomainPtr domain, const char *name,\n                              unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, name, &snapshotTree,\n                                    NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, name);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return snapshot;\n}"
  },
  {
    "function_name": "esxDomainSnapshotListChildrenNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4316-4367",
    "snippet": "static int\nesxDomainSnapshotListChildrenNames(virDomainSnapshotPtr snapshot,\n                                   char **names, int nameslen,\n                                   unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS) != 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (!names || nameslen < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (nameslen == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        result = 0;\n        goto cleanup;\n    }\n\n    result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                        names, nameslen, recurse, leaves);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeNames",
          "args": [
            "snapshotTree->childSnapshotList",
            "names",
            "nameslen",
            "recurse",
            "leaves"
          ],
          "line": 4360
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2573-2615",
          "snippet": "int\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotTreeList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4348
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotTreeList"
          ],
          "line": 4346
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 4336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 4336
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES",
            "-1"
          ],
          "line": 4328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotListChildrenNames(virDomainSnapshotPtr snapshot,\n                                   char **names, int nameslen,\n                                   unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS) != 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (!names || nameslen < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (nameslen == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        result = 0;\n        goto cleanup;\n    }\n\n    result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                        names, nameslen, recurse, leaves);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSnapshotNumChildren",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4271-4312",
    "snippet": "static int\nesxDomainSnapshotNumChildren(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int count = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS) != 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        count = 0;\n        goto cleanup;\n    }\n\n    count = esxVI_GetNumberOfSnapshotTrees(snapshotTree->childSnapshotList,\n                                           recurse, leaves);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return count;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetNumberOfSnapshotTrees",
          "args": [
            "snapshotTree->childSnapshotList",
            "recurse",
            "leaves"
          ],
          "line": 4305
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetNumberOfSnapshotTrees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2551-2569",
          "snippet": "int\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotTreeList",
            "snapshot->name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4293
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotTreeList"
          ],
          "line": 4291
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4288
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES",
            "-1"
          ],
          "line": 4281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotNumChildren(virDomainSnapshotPtr snapshot, unsigned int flags)\n{\n    int count = -1;\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_DESCENDANTS) != 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotTreeList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotTreeList, snapshot->name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA) {\n        count = 0;\n        goto cleanup;\n    }\n\n    count = esxVI_GetNumberOfSnapshotTrees(snapshotTree->childSnapshotList,\n                                           recurse, leaves);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxDomainSnapshotListNames",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4228-4267",
    "snippet": "static int\nesxDomainSnapshotListNames(virDomainPtr domain, char **names, int nameslen,\n                           unsigned int flags)\n{\n    int result;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) == 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (!names || nameslen < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (nameslen == 0 || (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA))\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0) {\n        return -1;\n    }\n\n    result = esxVI_GetSnapshotTreeNames(rootSnapshotTreeList, names, nameslen,\n                                        recurse, leaves);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeNames",
          "args": [
            "rootSnapshotTreeList",
            "names",
            "nameslen",
            "recurse",
            "leaves"
          ],
          "line": 4261
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeNames",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2573-2615",
          "snippet": "int\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeNames(esxVI_VirtualMachineSnapshotTree *snapshotTreeList,\n                           char **names, int nameslen, bool recurse,\n                           bool leaves)\n{\n    int count = 0;\n    int result;\n    size_t i;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList;\n         snapshotTree && count < nameslen;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList)) {\n            names[count] = g_strdup(snapshotTree->name);\n\n            count++;\n        }\n\n        if (count >= nameslen)\n            break;\n\n        if (recurse) {\n            result = esxVI_GetSnapshotTreeNames(snapshotTree->childSnapshotList,\n                                                names + count,\n                                                nameslen - count,\n                                                true, leaves);\n\n            if (result < 0)\n                goto failure;\n\n            count += result;\n        }\n    }\n\n    return count;\n\n failure:\n    for (i = 0; i < count; ++i)\n        VIR_FREE(names[i]);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&rootSnapshotTreeList"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4253
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Invalid argument\")"
          ],
          "line": 4246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid argument\""
          ],
          "line": 4246
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES",
            "-1"
          ],
          "line": 4238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotListNames(virDomainPtr domain, char **names, int nameslen,\n                           unsigned int flags)\n{\n    int result;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) == 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (!names || nameslen < 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    if (nameslen == 0 || (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA))\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0) {\n        return -1;\n    }\n\n    result = esxVI_GetSnapshotTreeNames(rootSnapshotTreeList, names, nameslen,\n                                        recurse, leaves);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSnapshotNum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4190-4224",
    "snippet": "static int\nesxDomainSnapshotNum(virDomainPtr domain, unsigned int flags)\n{\n    int count;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) == 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA)\n        return 0;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0) {\n        return -1;\n    }\n\n    count = esxVI_GetNumberOfSnapshotTrees(rootSnapshotTreeList, recurse,\n                                           leaves);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return count;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotTreeList"
          ],
          "line": 4221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetNumberOfSnapshotTrees",
          "args": [
            "rootSnapshotTreeList",
            "recurse",
            "leaves"
          ],
          "line": 4218
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetNumberOfSnapshotTrees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2551-2569",
          "snippet": "int\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetNumberOfSnapshotTrees\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, bool recurse,\n   bool leaves)\n{\n    int count = 0;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree;\n\n    for (snapshotTree = snapshotTreeList; snapshotTree;\n         snapshotTree = snapshotTree->_next) {\n        if (!(leaves && snapshotTree->childSnapshotList))\n            count++;\n        if (recurse)\n            count += esxVI_GetNumberOfSnapshotTrees\n                (snapshotTree->childSnapshotList, true, leaves);\n    }\n\n    return count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&rootSnapshotTreeList"
          ],
          "line": 4213
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4206
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES",
            "-1"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSnapshotNum(virDomainPtr domain, unsigned int flags)\n{\n    int count;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotTreeList = NULL;\n    bool recurse;\n    bool leaves;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_LIST_ROOTS |\n                  VIR_DOMAIN_SNAPSHOT_LIST_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_LIST_LEAVES, -1);\n\n    recurse = (flags & VIR_DOMAIN_SNAPSHOT_LIST_ROOTS) == 0;\n    leaves = (flags & VIR_DOMAIN_SNAPSHOT_LIST_LEAVES) != 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* ESX snapshots do not require libvirt to maintain any metadata.  */\n    if (flags & VIR_DOMAIN_SNAPSHOT_LIST_METADATA)\n        return 0;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotTreeList) < 0) {\n        return -1;\n    }\n\n    count = esxVI_GetNumberOfSnapshotTrees(rootSnapshotTreeList, recurse,\n                                           leaves);\n\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotTreeList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxDomainSnapshotGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4138-4186",
    "snippet": "static char *\nesxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                            unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTreeParent = NULL;\n    virDomainSnapshotDef def;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, &snapshotTreeParent,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    def.parent.name = snapshot->name;\n    def.parent.description = snapshotTree->description;\n    def.parent.parent_name = snapshotTreeParent ? snapshotTreeParent->name : NULL;\n\n    if (esxVI_DateTime_ConvertToCalendarTime(snapshotTree->createTime,\n                                             &def.parent.creationTime) < 0) {\n        goto cleanup;\n    }\n\n    def.state = esxVI_VirtualMachinePowerState_ConvertToLibvirt\n                  (snapshotTree->state);\n\n    virUUIDFormat(snapshot->domain->uuid, uuid_string);\n\n    xml = virDomainSnapshotDefFormat(uuid_string, &def, priv->xmlopt,\n                                     0);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n\n    return xml;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefFormat",
          "args": [
            "uuid_string",
            "&def",
            "priv->xmlopt",
            "0"
          ],
          "line": 4179
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "926-942",
          "snippet": "char *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nchar *\nvirDomainSnapshotDefFormat(const char *uuidstr,\n                           virDomainSnapshotDefPtr def,\n                           virDomainXMLOptionPtr xmlopt,\n                           unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_FORMAT_SECURE |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_INTERNAL |\n                  VIR_DOMAIN_SNAPSHOT_FORMAT_CURRENT, NULL);\n    if (virDomainSnapshotDefFormatInternal(&buf, uuidstr, def,\n                                           xmlopt, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "snapshot->domain->uuid",
            "uuid_string"
          ],
          "line": 4177
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_ConvertToLibvirt",
          "args": [
            "snapshotTree->state"
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DateTime_ConvertToCalendarTime",
          "args": [
            "snapshotTree->createTime",
            "&def.parent.creationTime"
          ],
          "line": 4169
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_DateTime_ConvertToCalendarTime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1472-1554",
          "snippet": "int\nesxVI_DateTime_ConvertToCalendarTime(esxVI_DateTime *dateTime,\n                                     long long *secondsSinceEpoch)\n{\n    char *tmp;\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = NULL;\n    int year, mon, mday, hour, min, sec, milliseconds;\n\n    if (!dateTime || !secondsSinceEpoch) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    /*\n     * expected format: [-]CCYY-MM-DDTHH:MM:SS[.ssssss][((+|-)HH:MM|Z)]\n     * typical example: 2010-04-05T12:13:55.316789+02:00\n     *\n     * see http://www.w3.org/TR/xmlschema-2/#dateTime\n     *\n     * map negative years to 0, since the base for time_t is the year 1970.\n     */\n    if (dateTime->value[0] == '-') {\n        *secondsSinceEpoch = 0;\n        return 0;\n    }\n\n    if (/* year */\n        virStrToLong_i(dateTime->value, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != 'T' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"xsd:dateTime value '%s' has unexpected format\"),\n                       dateTime->value);\n        return -1;\n    }\n\n    if (*tmp != '\\0') {\n        /* skip .ssssss part if present */\n        if (*tmp == '.' &&\n            virStrToLong_i(tmp + 1, &tmp, 10, &milliseconds) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"xsd:dateTime value '%s' has unexpected format\"),\n                           dateTime->value);\n            return -1;\n        }\n\n        /* parse timezone offset if present. if missing assume UTC */\n        if (*tmp == '+' || *tmp == '-') {\n            tz = g_time_zone_new(tmp);\n        } else if (STREQ(tmp, \"Z\")) {\n            tz = g_time_zone_new_utc();\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"xsd:dateTime value '%s' has unexpected format\"),\n                           dateTime->value);\n            return -1;\n        }\n    } else {\n        tz = g_time_zone_new_utc();\n    }\n\n    /*\n     * xsd:dateTime represents local time relative to the optional timezone\n     * given as offset. pretend the local time is in UTC and use timegm in\n     * order to avoid interference with the timezone to this computer.\n     * apply timezone correction afterwards, because it's simpler than\n     * handling all the possible over- and underflows when trying to apply\n     * it to the tm struct.\n     */\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    *secondsSinceEpoch = (long long)g_date_time_to_unix(then);\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_DateTime_ConvertToCalendarTime(esxVI_DateTime *dateTime,\n                                     long long *secondsSinceEpoch)\n{\n    char *tmp;\n    g_autoptr(GDateTime) then = NULL;\n    g_autoptr(GTimeZone) tz = NULL;\n    int year, mon, mday, hour, min, sec, milliseconds;\n\n    if (!dateTime || !secondsSinceEpoch) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    /*\n     * expected format: [-]CCYY-MM-DDTHH:MM:SS[.ssssss][((+|-)HH:MM|Z)]\n     * typical example: 2010-04-05T12:13:55.316789+02:00\n     *\n     * see http://www.w3.org/TR/xmlschema-2/#dateTime\n     *\n     * map negative years to 0, since the base for time_t is the year 1970.\n     */\n    if (dateTime->value[0] == '-') {\n        *secondsSinceEpoch = 0;\n        return 0;\n    }\n\n    if (/* year */\n        virStrToLong_i(dateTime->value, &tmp, 10, &year) < 0 || *tmp != '-' ||\n        /* month */\n        virStrToLong_i(tmp+1, &tmp, 10, &mon) < 0 || *tmp != '-' ||\n        /* day */\n        virStrToLong_i(tmp+1, &tmp, 10, &mday) < 0 || *tmp != 'T' ||\n        /* hour */\n        virStrToLong_i(tmp+1, &tmp, 10, &hour) < 0 || *tmp != ':' ||\n        /* minute */\n        virStrToLong_i(tmp+1, &tmp, 10, &min) < 0 || *tmp != ':' ||\n        /* second */\n        virStrToLong_i(tmp+1, &tmp, 10, &sec) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"xsd:dateTime value '%s' has unexpected format\"),\n                       dateTime->value);\n        return -1;\n    }\n\n    if (*tmp != '\\0') {\n        /* skip .ssssss part if present */\n        if (*tmp == '.' &&\n            virStrToLong_i(tmp + 1, &tmp, 10, &milliseconds) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"xsd:dateTime value '%s' has unexpected format\"),\n                           dateTime->value);\n            return -1;\n        }\n\n        /* parse timezone offset if present. if missing assume UTC */\n        if (*tmp == '+' || *tmp == '-') {\n            tz = g_time_zone_new(tmp);\n        } else if (STREQ(tmp, \"Z\")) {\n            tz = g_time_zone_new_utc();\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"xsd:dateTime value '%s' has unexpected format\"),\n                           dateTime->value);\n            return -1;\n        }\n    } else {\n        tz = g_time_zone_new_utc();\n    }\n\n    /*\n     * xsd:dateTime represents local time relative to the optional timezone\n     * given as offset. pretend the local time is in UTC and use timegm in\n     * order to avoid interference with the timezone to this computer.\n     * apply timezone correction afterwards, because it's simpler than\n     * handling all the possible over- and underflows when trying to apply\n     * it to the tm struct.\n     */\n    then = g_date_time_new(tz, year, mon, mday, hour, min, sec);\n    *secondsSinceEpoch = (long long)g_date_time_to_unix(then);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "snapshot->name",
            "&snapshotTree",
            "&snapshotTreeParent",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4159
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "snapshot->domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4154
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&def",
            "0",
            "sizeof(def)"
          ],
          "line": 4152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 4150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic char *\nesxDomainSnapshotGetXMLDesc(virDomainSnapshotPtr snapshot,\n                            unsigned int flags)\n{\n    esxPrivate *priv = snapshot->domain->conn->privateData;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTreeParent = NULL;\n    virDomainSnapshotDef def;\n    char uuid_string[VIR_UUID_STRING_BUFLEN] = \"\";\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&def, 0, sizeof(def));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_LookupRootSnapshotTreeList(priv->primary, snapshot->domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, snapshot->name,\n                                    &snapshotTree, &snapshotTreeParent,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    def.parent.name = snapshot->name;\n    def.parent.description = snapshotTree->description;\n    def.parent.parent_name = snapshotTreeParent ? snapshotTreeParent->name : NULL;\n\n    if (esxVI_DateTime_ConvertToCalendarTime(snapshotTree->createTime,\n                                             &def.parent.creationTime) < 0) {\n        goto cleanup;\n    }\n\n    def.state = esxVI_VirtualMachinePowerState_ConvertToLibvirt\n                  (snapshotTree->state);\n\n    virUUIDFormat(snapshot->domain->uuid, uuid_string);\n\n    xml = virDomainSnapshotDefFormat(uuid_string, &def, priv->xmlopt,\n                                     0);\n\n cleanup:\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxDomainSnapshotCreateXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4048-4134",
    "snippet": "static virDomainSnapshotPtr\nesxDomainSnapshotCreateXML(virDomainPtr domain, const char *xmlDesc,\n                           unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n    bool diskOnly = (flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) != 0;\n    bool quiesce = (flags & VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE) != 0;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n    unsigned int parse_flags = 0;\n\n    /* ESX supports disk-only and quiesced snapshots; libvirt tracks no\n     * snapshot metadata so supporting that flag is trivial.  */\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE)\n        parse_flags = VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    def = virDomainSnapshotDefParseString(xmlDesc,\n                                          priv->xmlopt, NULL, NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (def->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"disk snapshots not supported yet\"));\n        return NULL;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, def->parent.name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (snapshotTree) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Snapshot '%s' already exists\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (esxVI_CreateSnapshot_Task(priv->primary, virtualMachine->obj,\n                                  def->parent.name, def->parent.description,\n                                  diskOnly ? esxVI_Boolean_False : esxVI_Boolean_True,\n                                  quiesce ? esxVI_Boolean_True : esxVI_Boolean_False,\n                                  &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not create snapshot: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, def->parent.name);\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return snapshot;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 4131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 4130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineSnapshotTree_Free",
          "args": [
            "&rootSnapshotList"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 4128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomainSnapshot",
          "args": [
            "domain",
            "def->parent.name"
          ],
          "line": 4125
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomainSnapshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "1023-1045",
          "snippet": "virDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainSnapshotClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainSnapshotClass;\n\nvirDomainSnapshotPtr\nvirGetDomainSnapshot(virDomainPtr domain, const char *name)\n{\n    virDomainSnapshotPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckDomainGoto(domain, error);\n    virCheckNonNullArgGoto(name, error);\n\n    if (!(ret = virObjectNew(virDomainSnapshotClass)))\n        goto error;\n    ret->name = g_strdup(name);\n\n    ret->domain = virObjectRef(domain);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not create snapshot: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not create snapshot: %s\""
          ],
          "line": 4120
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 4112
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CreateSnapshot_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "def->parent.name",
            "def->parent.description",
            "diskOnly ? esxVI_Boolean_False : esxVI_Boolean_True",
            "quiesce ? esxVI_Boolean_True : esxVI_Boolean_False",
            "&task"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "_(\"Snapshot '%s' already exists\")",
            "def->parent.name"
          ],
          "line": 4102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetSnapshotTreeByName",
          "args": [
            "rootSnapshotList",
            "def->parent.name",
            "&snapshotTree",
            "NULL",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 4095
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetSnapshotTreeByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2619-2661",
          "snippet": "int\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetSnapshotTreeByName\n  (esxVI_VirtualMachineSnapshotTree *snapshotTreeList, const char *name,\n   esxVI_VirtualMachineSnapshotTree **snapshotTree,\n   esxVI_VirtualMachineSnapshotTree **snapshotTreeParent,\n   esxVI_Occurrence occurrence)\n{\n    esxVI_VirtualMachineSnapshotTree *candidate;\n\n    if (!snapshotTree || *snapshotTree ||\n        (snapshotTreeParent && *snapshotTreeParent)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (candidate = snapshotTreeList; candidate;\n         candidate = candidate->_next) {\n        if (STREQ(candidate->name, name)) {\n            *snapshotTree = candidate;\n            if (snapshotTreeParent)\n                *snapshotTreeParent = NULL;\n            return 1;\n        }\n\n        if (esxVI_GetSnapshotTreeByName(candidate->childSnapshotList, name,\n                                        snapshotTree, snapshotTreeParent,\n                                        occurrence) > 0) {\n            if (snapshotTreeParent && !(*snapshotTreeParent))\n                *snapshotTreeParent = candidate;\n\n            return 1;\n        }\n    }\n\n    if (occurrence == esxVI_Occurrence_OptionalItem) {\n        return 0;\n    } else {\n        virReportError(VIR_ERR_NO_DOMAIN_SNAPSHOT,\n                       _(\"Could not find snapshot with name '%s'\"), name);\n\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupRootSnapshotTreeList",
          "args": [
            "priv->primary",
            "domain->uuid",
            "&rootSnapshotList"
          ],
          "line": 4093
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupRootSnapshotTreeList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3257-3301",
          "snippet": "int\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupRootSnapshotTreeList\n  (esxVI_Context *ctx, const unsigned char *virtualMachineUuid,\n   esxVI_VirtualMachineSnapshotTree **rootSnapshotTreeList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(rootSnapshotTreeList);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"snapshot.rootSnapshotList\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, virtualMachineUuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"snapshot.rootSnapshotList\")) {\n            if (esxVI_VirtualMachineSnapshotTree_CastListFromAnyType\n                  (dynamicProperty->val, rootSnapshotTreeList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxVI_VirtualMachineSnapshotTree_Free(rootSnapshotTreeList);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 4090
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"disk snapshots not supported yet\")"
          ],
          "line": 4085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainSnapshotDefParseString",
          "args": [
            "xmlDesc",
            "priv->xmlopt",
            "NULL",
            "NULL",
            "parse_flags"
          ],
          "line": 4078
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainSnapshotDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/snapshot_conf.c",
          "lines": "452-473",
          "snippet": "virDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"snapshot_conf_priv.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virbitmap.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"snapshot_conf_priv.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virstoragefile.h\"\n#include \"snapshot_conf.h\"\n#include \"secret_conf.h\"\n#include \"nwfilter_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"virbitmap.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainSnapshotDefPtr\nvirDomainSnapshotDefParseString(const char *xmlStr,\n                                virDomainXMLOptionPtr xmlopt,\n                                void *parseOpaque,\n                                bool *current,\n                                unsigned int flags)\n{\n    virDomainSnapshotDefPtr ret = NULL;\n    xmlDocPtr xml;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_snapshot)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainSnapshotDefParseNode(xml, xmlDocGetRootElement(xml),\n                                            xmlopt, parseOpaque,\n                                            current, flags);\n        xmlFreeDoc(xml);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4075
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE",
            "NULL"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainSnapshotPtr\nesxDomainSnapshotCreateXML(virDomainPtr domain, const char *xmlDesc,\n                           unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineSnapshotTree *rootSnapshotList = NULL;\n    esxVI_VirtualMachineSnapshotTree *snapshotTree = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainSnapshotPtr snapshot = NULL;\n    bool diskOnly = (flags & VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY) != 0;\n    bool quiesce = (flags & VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE) != 0;\n    g_autoptr(virDomainSnapshotDef) def = NULL;\n    unsigned int parse_flags = 0;\n\n    /* ESX supports disk-only and quiesced snapshots; libvirt tracks no\n     * snapshot metadata so supporting that flag is trivial.  */\n    virCheckFlags(VIR_DOMAIN_SNAPSHOT_CREATE_DISK_ONLY |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_QUIESCE |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_NO_METADATA |\n                  VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_SNAPSHOT_CREATE_VALIDATE)\n        parse_flags = VIR_DOMAIN_SNAPSHOT_PARSE_VALIDATE;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    def = virDomainSnapshotDefParseString(xmlDesc,\n                                          priv->xmlopt, NULL, NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (def->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"disk snapshots not supported yet\"));\n        return NULL;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_LookupRootSnapshotTreeList(priv->primary, domain->uuid,\n                                         &rootSnapshotList) < 0 ||\n        esxVI_GetSnapshotTreeByName(rootSnapshotList, def->parent.name,\n                                    &snapshotTree, NULL,\n                                    esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (snapshotTree) {\n        virReportError(VIR_ERR_OPERATION_INVALID,\n                       _(\"Snapshot '%s' already exists\"), def->parent.name);\n        goto cleanup;\n    }\n\n    if (esxVI_CreateSnapshot_Task(priv->primary, virtualMachine->obj,\n                                  def->parent.name, def->parent.description,\n                                  diskOnly ? esxVI_Boolean_False : esxVI_Boolean_True,\n                                  quiesce ? esxVI_Boolean_True : esxVI_Boolean_False,\n                                  &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not create snapshot: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    snapshot = virGetDomainSnapshot(domain, def->parent.name);\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineSnapshotTree_Free(&rootSnapshotList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return snapshot;\n}"
  },
  {
    "function_name": "esxDomainIsUpdated",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "4021-4044",
    "snippet": "static int\nesxDomainIsUpdated(virDomainPtr domain G_GNUC_UNUSED)\n{\n    /* ESX domains never have a persistent state that differs from\n     * current state.  However, we do want to check for existence.  */\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 4041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4033
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainIsUpdated(virDomainPtr domain G_GNUC_UNUSED)\n{\n    /* ESX domains never have a persistent state that differs from\n     * current state.  However, we do want to check for existence.  */\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainIsPersistent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3994-4017",
    "snippet": "static int\nesxDomainIsPersistent(virDomainPtr domain)\n{\n    /* ESX has no concept of transient domains, so all of them are\n     * persistent.  However, we do want to check for existence. */\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n    result = 1;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 4014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 4006
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainIsPersistent(virDomainPtr domain)\n{\n    /* ESX has no concept of transient domains, so all of them are\n     * persistent.  However, we do want to check for existence. */\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n    result = 1;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainIsActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3958-3990",
    "snippet": "static int\nesxDomainIsActive(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        result = 1;\n    } else {\n        result = 0;\n    }\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 3975
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 3970
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainIsActive(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        result = 1;\n    } else {\n        result = 0;\n    }\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectIsAlive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3941-3954",
    "snippet": "static int\nesxConnectIsAlive(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    /* XXX we should be able to do something better than this but this is\n     * simple, safe, and good enough for now. In worst case, the function will\n     * return true even though the connection is not alive.\n     */\n    if (priv->primary)\n        return 1;\n    else\n        return 0;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectIsAlive(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    /* XXX we should be able to do something better than this but this is\n     * simple, safe, and good enough for now. In worst case, the function will\n     * return true even though the connection is not alive.\n     */\n    if (priv->primary)\n        return 1;\n    else\n        return 0;\n}"
  },
  {
    "function_name": "esxConnectIsSecure",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3931-3937",
    "snippet": "static int\nesxConnectIsSecure(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return STRCASEEQ(priv->parsedUri->transport, \"https\");\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 3936
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectIsSecure(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return STRCASEEQ(priv->parsedUri->transport, \"https\");\n}"
  },
  {
    "function_name": "esxConnectIsEncrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3921-3927",
    "snippet": "static int\nesxConnectIsEncrypted(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return STRCASEEQ(priv->parsedUri->transport, \"https\");\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectIsEncrypted(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return STRCASEEQ(priv->parsedUri->transport, \"https\");\n}"
  },
  {
    "function_name": "esxNodeGetFreeMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3880-3917",
    "snippet": "static unsigned long long\nesxNodeGetFreeMemory(virConnectPtr conn)\n{\n    unsigned long long result = 0;\n    unsigned long long usageBytes = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Int *memoryUsage = NULL;\n    esxVI_Long *memorySize = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return 0;\n\n    /* Get memory usage of host system */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.quickStats.overallMemoryUsage\\0\"\n                                           \"hardware.memorySize\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetInt(hostSystem, \"summary.quickStats.overallMemoryUsage\",\n                      &memoryUsage, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetLong(hostSystem, \"hardware.memorySize\", &memorySize,\n                      esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    usageBytes = (unsigned long long)(memoryUsage->value) * 1048576;\n    result = memorySize->value - usageBytes;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_Int_Free(&memoryUsage);\n    esxVI_Long_Free(&memorySize);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_Long_Free",
          "args": [
            "&memorySize"
          ],
          "line": 3914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Free",
          "args": [
            "&memoryUsage"
          ],
          "line": 3913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 3912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetLong",
          "args": [
            "hostSystem",
            "\"hardware.memorySize\"",
            "&memorySize",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3902
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetLong",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2294-2319",
          "snippet": "int\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetLong(esxVI_ObjectContent *objectContent, const char *propertyName,\n              esxVI_Long **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Long_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetInt",
          "args": [
            "hostSystem",
            "\"summary.quickStats.overallMemoryUsage\"",
            "&memoryUsage",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3900
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetInt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2265-2290",
          "snippet": "int\nesxVI_GetInt(esxVI_ObjectContent *objectContent, const char *propertyName,\n             esxVI_Int **value, esxVI_Occurrence occurence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Int_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetInt(esxVI_ObjectContent *objectContent, const char *propertyName,\n             esxVI_Int **value, esxVI_Occurrence occurence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_Int_CastFromAnyType(dynamicProperty->val, value) < 0)\n                return -1;\n\n            break;\n        }\n    }\n\n    if (!(*value) && occurence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 3898
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"summary.quickStats.overallMemoryUsage\\0\"\n                                           \"hardware.memorySize\\0\""
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3891
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic unsigned long long\nesxNodeGetFreeMemory(virConnectPtr conn)\n{\n    unsigned long long result = 0;\n    unsigned long long usageBytes = 0;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Int *memoryUsage = NULL;\n    esxVI_Long *memorySize = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return 0;\n\n    /* Get memory usage of host system */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"summary.quickStats.overallMemoryUsage\\0\"\n                                           \"hardware.memorySize\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetInt(hostSystem, \"summary.quickStats.overallMemoryUsage\",\n                      &memoryUsage, esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetLong(hostSystem, \"hardware.memorySize\", &memorySize,\n                      esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    usageBytes = (unsigned long long)(memoryUsage->value) * 1048576;\n    result = memorySize->value - usageBytes;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_Int_Free(&memoryUsage);\n    esxVI_Long_Free(&memorySize);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainMigrateFinish",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3866-3876",
    "snippet": "static virDomainPtr\nesxDomainMigrateFinish(virConnectPtr dconn, const char *dname,\n                       const char *cookie G_GNUC_UNUSED,\n                       int cookielen G_GNUC_UNUSED,\n                       const char *uri G_GNUC_UNUSED,\n                       unsigned long flags)\n{\n    virCheckFlags(ESX_MIGRATION_FLAGS, NULL);\n\n    return esxDomainLookupByName(dconn, dname);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainLookupByName",
          "args": [
            "dconn",
            "dname"
          ],
          "line": 3875
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainLookupByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "1507-1547",
          "snippet": "static virDomainPtr\nesxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByName(priv->primary, name, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, uuid) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return domain;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByName(priv->primary, name, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, uuid) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "ESX_MIGRATION_FLAGS",
            "NULL"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)\n\nstatic virDomainPtr\nesxDomainMigrateFinish(virConnectPtr dconn, const char *dname,\n                       const char *cookie G_GNUC_UNUSED,\n                       int cookielen G_GNUC_UNUSED,\n                       const char *uri G_GNUC_UNUSED,\n                       unsigned long flags)\n{\n    virCheckFlags(ESX_MIGRATION_FLAGS, NULL);\n\n    return esxDomainLookupByName(dconn, dname);\n}"
  },
  {
    "function_name": "esxDomainMigratePerform",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3723-3862",
    "snippet": "static int\nesxDomainMigratePerform(virDomainPtr domain,\n                        const char *cookie G_GNUC_UNUSED,\n                        int cookielen G_GNUC_UNUSED,\n                        const char *uri,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth G_GNUC_UNUSED)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    virURIPtr parsedUri = NULL;\n    char *saveptr;\n    char *path_resourcePool;\n    char *path_hostSystem;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_ManagedObjectReference resourcePool;\n    esxVI_ManagedObjectReference hostSystem;\n    esxVI_Event *eventList = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(ESX_MIGRATION_FLAGS, -1);\n\n    if (!priv->vCenter) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration not possible without a vCenter\"));\n        return -1;\n    }\n\n    if (dname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Renaming domains on migration not supported\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->vCenter) < 0)\n        return -1;\n\n    /* Parse migration URI */\n    if (!(parsedUri = virURIParse(uri)))\n        return -1;\n\n    if (!parsedUri->scheme || STRCASENEQ(parsedUri->scheme, \"vpxmigr\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Only vpxmigr:// migration URIs are supported\"));\n        goto cleanup;\n    }\n\n    if (STRCASENEQ(priv->vCenter->ipAddress, parsedUri->server)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration source and destination have to refer to \"\n                         \"the same vCenter\"));\n        goto cleanup;\n    }\n\n    path_resourcePool = strtok_r(parsedUri->path, \"/\", &saveptr);\n    path_hostSystem = strtok_r(NULL, \"\", &saveptr);\n\n    if (!path_resourcePool || !path_hostSystem) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration URI has to specify resource pool and host system\"));\n        goto cleanup;\n    }\n\n    resourcePool._next = NULL;\n    resourcePool._type = esxVI_Type_ManagedObjectReference;\n    resourcePool.type = (char *)\"ResourcePool\";\n    resourcePool.value = path_resourcePool;\n\n    hostSystem._next = NULL;\n    hostSystem._type = esxVI_Type_ManagedObjectReference;\n    hostSystem.type = (char *)\"HostSystem\";\n    hostSystem.value = path_hostSystem;\n\n    /* Lookup VirtualMachine */\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->vCenter, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0) {\n        goto cleanup;\n    }\n\n    /* Validate the purposed migration */\n    if (esxVI_ValidateMigration(priv->vCenter, virtualMachine->obj,\n                                esxVI_VirtualMachinePowerState_Undefined, NULL,\n                                &resourcePool, &hostSystem, &eventList) < 0) {\n        goto cleanup;\n    }\n\n    if (eventList) {\n        /*\n         * FIXME: Need to report the complete list of events. Limit reporting\n         *        to the first event for now.\n         */\n        if (eventList->fullFormattedMessage) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not migrate domain, validation reported a \"\n                             \"problem: %s\"), eventList->fullFormattedMessage);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not migrate domain, validation reported a \"\n                             \"problem\"));\n        }\n\n        goto cleanup;\n    }\n\n    /* Perform the purposed migration */\n    if (esxVI_MigrateVM_Task(priv->vCenter, virtualMachine->obj,\n                             &resourcePool, &hostSystem,\n                             esxVI_VirtualMachineMovePriority_DefaultPriority,\n                             esxVI_VirtualMachinePowerState_Undefined,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->vCenter, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not migrate domain, migration task finished with \"\n                         \"an error: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virURIFree(parsedUri);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_Event_Free(&eventList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)"
    ],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 3858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Event_Free",
          "args": [
            "&eventList"
          ],
          "line": 3857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIFree",
          "args": [
            "parsedUri"
          ],
          "line": 3855
        },
        "resolved": true,
        "details": {
          "function_name": "virURIFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "277-298",
          "snippet": "void virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvoid virURIFree(virURIPtr uri)\n{\n    size_t i;\n\n    if (!uri)\n        return;\n\n    VIR_FREE(uri->scheme);\n    VIR_FREE(uri->server);\n    VIR_FREE(uri->user);\n    VIR_FREE(uri->path);\n    VIR_FREE(uri->query);\n    VIR_FREE(uri->fragment);\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        VIR_FREE(uri->params[i].name);\n        VIR_FREE(uri->params[i].value);\n    }\n    VIR_FREE(uri->params);\n\n    VIR_FREE(uri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not migrate domain, migration task finished with \"\n                         \"an error: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 3845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not migrate domain, migration task finished with \"\n                         \"an error: %s\""
          ],
          "line": 3846
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->vCenter",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 3837
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_MigrateVM_Task",
          "args": [
            "priv->vCenter",
            "virtualMachine->obj",
            "&resourcePool",
            "&hostSystem",
            "esxVI_VirtualMachineMovePriority_DefaultPriority",
            "esxVI_VirtualMachinePowerState_Undefined",
            "&task"
          ],
          "line": 3832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Could not migrate domain, validation reported a \"\n                             \"problem\")"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not migrate domain, validation reported a \"\n                             \"problem: %s\")",
            "eventList->fullFormattedMessage"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ValidateMigration",
          "args": [
            "priv->vCenter",
            "virtualMachine->obj",
            "esxVI_VirtualMachinePowerState_Undefined",
            "NULL",
            "&resourcePool",
            "&hostSystem",
            "&eventList"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->vCenter",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 3800
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Migration URI has to specify resource pool and host system\")"
          ],
          "line": 3784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"\"",
            "&saveptr"
          ],
          "line": 3781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "parsedUri->path",
            "\"/\"",
            "&saveptr"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Migration source and destination have to refer to \"\n                         \"the same vCenter\")"
          ],
          "line": 3774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "priv->vCenter->ipAddress",
            "parsedUri->server"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Only vpxmigr:// migration URIs are supported\")"
          ],
          "line": 3768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "parsedUri->scheme",
            "\"vpxmigr\""
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virURIParse",
          "args": [
            "uri"
          ],
          "line": 3764
        },
        "resolved": true,
        "details": {
          "function_name": "virURIParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruri.c",
          "lines": "143-194",
          "snippet": "virURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"viruri.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"viruri.h\"\n#include <config.h>\n\nvirURIPtr\nvirURIParse(const char *uri)\n{\n    xmlURIPtr xmluri;\n    virURIPtr ret = NULL;\n\n    xmluri = xmlParseURI(uri);\n\n    if (!xmluri) {\n        /* libxml2 does not tell us what failed. Grr :-( */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to parse URI %s\"), uri);\n        return NULL;\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto error;\n\n    ret->scheme = g_strdup(xmluri->scheme);\n    ret->server = g_strdup(xmluri->server);\n    /* xmluri->port value is not defined if server was\n     * not given. Modern versions libxml2 fill port\n     * differently to old versions in this case, so\n     * don't rely on it. eg libxml2 git commit:\n     *   beb7281055dbf0ed4d041022a67c6c5cfd126f25\n     */\n    if (!ret->server || STREQ(ret->server, \"\"))\n        ret->port = 0;\n    else\n        ret->port = xmluri->port;\n    ret->path = g_strdup(xmluri->path);\n    ret->query = g_strdup(xmluri->query_raw);\n    ret->fragment = g_strdup(xmluri->fragment);\n    ret->user = g_strdup(xmluri->user);\n\n    /* Strip square bracket from an IPv6 address.\n     * The function modifies the string in-place. Even after such\n     * modification, it is OK to free the URI with xmlFreeURI. */\n    virStringStripIPv6Brackets(ret->server);\n\n    if (virURIParseParams(ret) < 0)\n        goto error;\n\n    xmlFreeURI(xmluri);\n\n    return ret;\n\n error:\n    xmlFreeURI(xmluri);\n    virURIFree(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->vCenter"
          ],
          "line": 3760
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Renaming domains on migration not supported\")"
          ],
          "line": 3755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Migration not possible without a vCenter\")"
          ],
          "line": 3749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "ESX_MIGRATION_FLAGS",
            "-1"
          ],
          "line": 3746
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainMigratePerform(virDomainPtr domain,\n                        const char *cookie G_GNUC_UNUSED,\n                        int cookielen G_GNUC_UNUSED,\n                        const char *uri,\n                        unsigned long flags,\n                        const char *dname,\n                        unsigned long bandwidth G_GNUC_UNUSED)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    virURIPtr parsedUri = NULL;\n    char *saveptr;\n    char *path_resourcePool;\n    char *path_hostSystem;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_ManagedObjectReference resourcePool;\n    esxVI_ManagedObjectReference hostSystem;\n    esxVI_Event *eventList = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(ESX_MIGRATION_FLAGS, -1);\n\n    if (!priv->vCenter) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration not possible without a vCenter\"));\n        return -1;\n    }\n\n    if (dname) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Renaming domains on migration not supported\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->vCenter) < 0)\n        return -1;\n\n    /* Parse migration URI */\n    if (!(parsedUri = virURIParse(uri)))\n        return -1;\n\n    if (!parsedUri->scheme || STRCASENEQ(parsedUri->scheme, \"vpxmigr\")) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Only vpxmigr:// migration URIs are supported\"));\n        goto cleanup;\n    }\n\n    if (STRCASENEQ(priv->vCenter->ipAddress, parsedUri->server)) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration source and destination have to refer to \"\n                         \"the same vCenter\"));\n        goto cleanup;\n    }\n\n    path_resourcePool = strtok_r(parsedUri->path, \"/\", &saveptr);\n    path_hostSystem = strtok_r(NULL, \"\", &saveptr);\n\n    if (!path_resourcePool || !path_hostSystem) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Migration URI has to specify resource pool and host system\"));\n        goto cleanup;\n    }\n\n    resourcePool._next = NULL;\n    resourcePool._type = esxVI_Type_ManagedObjectReference;\n    resourcePool.type = (char *)\"ResourcePool\";\n    resourcePool.value = path_resourcePool;\n\n    hostSystem._next = NULL;\n    hostSystem._type = esxVI_Type_ManagedObjectReference;\n    hostSystem.type = (char *)\"HostSystem\";\n    hostSystem.value = path_hostSystem;\n\n    /* Lookup VirtualMachine */\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->vCenter, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0) {\n        goto cleanup;\n    }\n\n    /* Validate the purposed migration */\n    if (esxVI_ValidateMigration(priv->vCenter, virtualMachine->obj,\n                                esxVI_VirtualMachinePowerState_Undefined, NULL,\n                                &resourcePool, &hostSystem, &eventList) < 0) {\n        goto cleanup;\n    }\n\n    if (eventList) {\n        /*\n         * FIXME: Need to report the complete list of events. Limit reporting\n         *        to the first event for now.\n         */\n        if (eventList->fullFormattedMessage) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not migrate domain, validation reported a \"\n                             \"problem: %s\"), eventList->fullFormattedMessage);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not migrate domain, validation reported a \"\n                             \"problem\"));\n        }\n\n        goto cleanup;\n    }\n\n    /* Perform the purposed migration */\n    if (esxVI_MigrateVM_Task(priv->vCenter, virtualMachine->obj,\n                             &resourcePool, &hostSystem,\n                             esxVI_VirtualMachineMovePriority_DefaultPriority,\n                             esxVI_VirtualMachinePowerState_Undefined,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->vCenter, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not migrate domain, migration task finished with \"\n                         \"an error: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virURIFree(parsedUri);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_Event_Free(&eventList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainMigratePrepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3698-3719",
    "snippet": "static int\nesxDomainMigratePrepare(virConnectPtr dconn,\n                        char **cookie G_GNUC_UNUSED,\n                        int *cookielen G_GNUC_UNUSED,\n                        const char *uri_in G_GNUC_UNUSED,\n                        char **uri_out,\n                        unsigned long flags,\n                        const char *dname G_GNUC_UNUSED,\n                        unsigned long resource G_GNUC_UNUSED)\n{\n    esxPrivate *priv = dconn->privateData;\n\n    virCheckFlags(ESX_MIGRATION_FLAGS, -1);\n\n    if (!uri_in) {\n        *uri_out = g_strdup_printf(\"vpxmigr://%s/%s/%s\", priv->vCenter->ipAddress,\n                                   priv->vCenter->computeResource->resourcePool->value,\n                                   priv->vCenter->hostSystem->_reference->value);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"vpxmigr://%s/%s/%s\"",
            "priv->vCenter->ipAddress",
            "priv->vCenter->computeResource->resourcePool->value",
            "priv->vCenter->hostSystem->_reference->value"
          ],
          "line": 3713
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "ESX_MIGRATION_FLAGS",
            "-1"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define ESX_MIGRATION_FLAGS \\\n    (VIR_MIGRATE_PERSIST_DEST | \\\n     VIR_MIGRATE_UNDEFINE_SOURCE | \\\n     VIR_MIGRATE_LIVE | \\\n     VIR_MIGRATE_PAUSED)\n\nstatic int\nesxDomainMigratePrepare(virConnectPtr dconn,\n                        char **cookie G_GNUC_UNUSED,\n                        int *cookielen G_GNUC_UNUSED,\n                        const char *uri_in G_GNUC_UNUSED,\n                        char **uri_out,\n                        unsigned long flags,\n                        const char *dname G_GNUC_UNUSED,\n                        unsigned long resource G_GNUC_UNUSED)\n{\n    esxPrivate *priv = dconn->privateData;\n\n    virCheckFlags(ESX_MIGRATION_FLAGS, -1);\n\n    if (!uri_in) {\n        *uri_out = g_strdup_printf(\"vpxmigr://%s/%s/%s\", priv->vCenter->ipAddress,\n                                   priv->vCenter->computeResource->resourcePool->value,\n                                   priv->vCenter->hostSystem->_reference->value);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "esxDomainSetSchedulerParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3684-3689",
    "snippet": "static int\nesxDomainSetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int nparams)\n{\n    return esxDomainSetSchedulerParametersFlags(domain, params, nparams, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainSetSchedulerParametersFlags",
          "args": [
            "domain",
            "params",
            "nparams",
            "0"
          ],
          "line": 3688
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainSetSchedulerParametersFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "3551-3682",
          "snippet": "static int\nesxDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_SCHEDULER_RESERVATION,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_LIMIT,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_SHARES,\n                               VIR_TYPED_PARAM_INT,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->cpuAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_RESERVATION)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->reservation) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < 0) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set reservation to %lld MHz, expecting \"\n                                 \"positive value\"), params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->reservation->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_LIMIT)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->limit) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < -1) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set limit to %lld MHz, expecting \"\n                                 \"positive value or -1 (unlimited)\"),\n                               params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->limit->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_SHARES)) {\n            if (esxVI_SharesInfo_Alloc(&sharesInfo) < 0 ||\n                esxVI_Int_Alloc(&sharesInfo->shares) < 0) {\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->shares = sharesInfo;\n            sharesInfo = NULL;\n\n            if (params[i].value.i >= 0) {\n                spec->cpuAllocation->shares->level = esxVI_SharesLevel_Custom;\n                spec->cpuAllocation->shares->shares->value = params[i].value.i;\n            } else {\n                switch (params[i].value.i) {\n                  case -1:\n                    spec->cpuAllocation->shares->level = esxVI_SharesLevel_Low;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -2:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_Normal;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -3:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_High;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  default:\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Could not set shares to %d, expecting positive \"\n                                     \"value or -1 (low), -2 (normal) or -3 (high)\"),\n                                   params[i].value.i);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change scheduler parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_SharesInfo_Free(&sharesInfo);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_SCHEDULER_RESERVATION,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_LIMIT,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_SHARES,\n                               VIR_TYPED_PARAM_INT,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->cpuAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_RESERVATION)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->reservation) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < 0) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set reservation to %lld MHz, expecting \"\n                                 \"positive value\"), params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->reservation->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_LIMIT)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->limit) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < -1) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set limit to %lld MHz, expecting \"\n                                 \"positive value or -1 (unlimited)\"),\n                               params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->limit->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_SHARES)) {\n            if (esxVI_SharesInfo_Alloc(&sharesInfo) < 0 ||\n                esxVI_Int_Alloc(&sharesInfo->shares) < 0) {\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->shares = sharesInfo;\n            sharesInfo = NULL;\n\n            if (params[i].value.i >= 0) {\n                spec->cpuAllocation->shares->level = esxVI_SharesLevel_Custom;\n                spec->cpuAllocation->shares->shares->value = params[i].value.i;\n            } else {\n                switch (params[i].value.i) {\n                  case -1:\n                    spec->cpuAllocation->shares->level = esxVI_SharesLevel_Low;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -2:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_Normal;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -3:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_High;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  default:\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Could not set shares to %d, expecting positive \"\n                                     \"value or -1 (low), -2 (normal) or -3 (high)\"),\n                                   params[i].value.i);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change scheduler parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_SharesInfo_Free(&sharesInfo);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int nparams)\n{\n    return esxDomainSetSchedulerParametersFlags(domain, params, nparams, 0);\n}"
  },
  {
    "function_name": "esxDomainSetSchedulerParametersFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3551-3682",
    "snippet": "static int\nesxDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_SCHEDULER_RESERVATION,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_LIMIT,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_SHARES,\n                               VIR_TYPED_PARAM_INT,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->cpuAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_RESERVATION)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->reservation) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < 0) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set reservation to %lld MHz, expecting \"\n                                 \"positive value\"), params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->reservation->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_LIMIT)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->limit) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < -1) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set limit to %lld MHz, expecting \"\n                                 \"positive value or -1 (unlimited)\"),\n                               params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->limit->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_SHARES)) {\n            if (esxVI_SharesInfo_Alloc(&sharesInfo) < 0 ||\n                esxVI_Int_Alloc(&sharesInfo->shares) < 0) {\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->shares = sharesInfo;\n            sharesInfo = NULL;\n\n            if (params[i].value.i >= 0) {\n                spec->cpuAllocation->shares->level = esxVI_SharesLevel_Custom;\n                spec->cpuAllocation->shares->shares->value = params[i].value.i;\n            } else {\n                switch (params[i].value.i) {\n                  case -1:\n                    spec->cpuAllocation->shares->level = esxVI_SharesLevel_Low;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -2:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_Normal;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -3:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_High;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  default:\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Could not set shares to %d, expecting positive \"\n                                     \"value or -1 (low), -2 (normal) or -3 (high)\"),\n                                   params[i].value.i);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change scheduler parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_SharesInfo_Free(&sharesInfo);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 3679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Free",
          "args": [
            "&spec"
          ],
          "line": 3677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharesInfo_Free",
          "args": [
            "&sharesInfo"
          ],
          "line": 3675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not change scheduler parameters: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 3666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not change scheduler parameters: %s\""
          ],
          "line": 3667
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 3658
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "spec",
            "&task"
          ],
          "line": 3656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not set shares to %d, expecting positive \"\n                                     \"value or -1 (low), -2 (normal) or -3 (high)\")",
            "params[i].value.i"
          ],
          "line": 3646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&sharesInfo->shares"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharesInfo_Alloc",
          "args": [
            "&sharesInfo"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].field",
            "VIR_DOMAIN_SCHEDULER_SHARES"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not set limit to %lld MHz, expecting \"\n                                 \"positive value or -1 (unlimited)\")",
            "params[i].value.l"
          ],
          "line": 3606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&spec->cpuAllocation->limit"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].field",
            "VIR_DOMAIN_SCHEDULER_LIMIT"
          ],
          "line": 3601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Could not set reservation to %lld MHz, expecting \"\n                                 \"positive value\")",
            "params[i].value.l"
          ],
          "line": 3594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&spec->cpuAllocation->reservation"
          ],
          "line": 3590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "params[i].field",
            "VIR_DOMAIN_SCHEDULER_RESERVATION"
          ],
          "line": 3589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ResourceAllocationInfo_Alloc",
          "args": [
            "&spec->cpuAllocation"
          ],
          "line": 3584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Alloc",
          "args": [
            "&spec"
          ],
          "line": 3583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTypedParamsValidate",
          "args": [
            "params",
            "nparams",
            "VIR_DOMAIN_SCHEDULER_RESERVATION",
            "VIR_TYPED_PARAM_LLONG",
            "VIR_DOMAIN_SCHEDULER_LIMIT",
            "VIR_TYPED_PARAM_LLONG",
            "VIR_DOMAIN_SCHEDULER_SHARES",
            "VIR_TYPED_PARAM_INT",
            "NULL"
          ],
          "line": 3567
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParamsValidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "58-142",
          "snippet": "int\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParamsValidate(virTypedParameterPtr params, int nparams, ...)\n{\n    va_list ap;\n    int ret = -1;\n    size_t i, j;\n    const char *name, *last_name = NULL;\n    int type;\n    size_t nkeys = 0, nkeysalloc = 0;\n    virTypedParameterPtr sorted = NULL, keys = NULL;\n\n    va_start(ap, nparams);\n\n    if (VIR_ALLOC_N(sorted, nparams) < 0)\n        goto cleanup;\n\n    /* Here we intentionally don't copy values */\n    memcpy(sorted, params, sizeof(*params) * nparams);\n    qsort(sorted, nparams, sizeof(*sorted), virTypedParamsSortName);\n\n    name = va_arg(ap, const char *);\n    while (name) {\n        type = va_arg(ap, int);\n        if (VIR_RESIZE_N(keys, nkeysalloc, nkeys, 1) < 0)\n            goto cleanup;\n\n        if (virStrcpyStatic(keys[nkeys].field, name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Field name '%s' too long\"), name);\n            goto cleanup;\n        }\n\n        keys[nkeys].type = type & ~VIR_TYPED_PARAM_MULTIPLE;\n        /* Value is not used anyway */\n        keys[nkeys].value.i = type & VIR_TYPED_PARAM_MULTIPLE;\n\n        nkeys++;\n        name = va_arg(ap, const char *);\n    }\n\n    qsort(keys, nkeys, sizeof(*keys), virTypedParamsSortName);\n\n    for (i = 0, j = 0; i < nparams && j < nkeys;) {\n        if (STRNEQ(sorted[i].field, keys[j].field)) {\n            j++;\n        } else {\n            if (STREQ_NULLABLE(last_name, sorted[i].field) &&\n                !(keys[j].value.i & VIR_TYPED_PARAM_MULTIPLE)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"parameter '%s' occurs multiple times\"),\n                               sorted[i].field);\n                goto cleanup;\n            }\n            if (sorted[i].type != keys[j].type) {\n                const char *badtype;\n\n                badtype = virTypedParameterTypeToString(sorted[i].type);\n                if (!badtype)\n                    badtype = virTypedParameterTypeToString(0);\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"invalid type '%s' for parameter '%s', \"\n                                 \"expected '%s'\"),\n                               badtype, sorted[i].field,\n                               virTypedParameterTypeToString(keys[j].type));\n                goto cleanup;\n            }\n            last_name = sorted[i].field;\n            i++;\n        }\n    }\n\n    if (j == nkeys && i != nparams) {\n        virReportError(VIR_ERR_ARGUMENT_UNSUPPORTED,\n                       _(\"parameter '%s' not supported\"),\n                       sorted[i].field);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    va_end(ap);\n    VIR_FREE(sorted);\n    VIR_FREE(keys);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    size_t i;\n\n    virCheckFlags(0, -1);\n    if (virTypedParamsValidate(params, nparams,\n                               VIR_DOMAIN_SCHEDULER_RESERVATION,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_LIMIT,\n                               VIR_TYPED_PARAM_LLONG,\n                               VIR_DOMAIN_SCHEDULER_SHARES,\n                               VIR_TYPED_PARAM_INT,\n                               NULL) < 0)\n        return -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->cpuAllocation) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < nparams; ++i) {\n        if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_RESERVATION)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->reservation) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < 0) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set reservation to %lld MHz, expecting \"\n                                 \"positive value\"), params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->reservation->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_LIMIT)) {\n            if (esxVI_Long_Alloc(&spec->cpuAllocation->limit) < 0)\n                goto cleanup;\n\n            if (params[i].value.l < -1) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Could not set limit to %lld MHz, expecting \"\n                                 \"positive value or -1 (unlimited)\"),\n                               params[i].value.l);\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->limit->value = params[i].value.l;\n        } else if (STREQ(params[i].field, VIR_DOMAIN_SCHEDULER_SHARES)) {\n            if (esxVI_SharesInfo_Alloc(&sharesInfo) < 0 ||\n                esxVI_Int_Alloc(&sharesInfo->shares) < 0) {\n                goto cleanup;\n            }\n\n            spec->cpuAllocation->shares = sharesInfo;\n            sharesInfo = NULL;\n\n            if (params[i].value.i >= 0) {\n                spec->cpuAllocation->shares->level = esxVI_SharesLevel_Custom;\n                spec->cpuAllocation->shares->shares->value = params[i].value.i;\n            } else {\n                switch (params[i].value.i) {\n                  case -1:\n                    spec->cpuAllocation->shares->level = esxVI_SharesLevel_Low;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -2:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_Normal;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  case -3:\n                    spec->cpuAllocation->shares->level =\n                      esxVI_SharesLevel_High;\n                    spec->cpuAllocation->shares->shares->value = -1;\n                    break;\n\n                  default:\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Could not set shares to %d, expecting positive \"\n                                     \"value or -1 (low), -2 (normal) or -3 (high)\"),\n                                   params[i].value.i);\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not change scheduler parameters: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_SharesInfo_Free(&sharesInfo);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainGetSchedulerParameters",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3543-3548",
    "snippet": "static int\nesxDomainGetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int *nparams)\n{\n    return esxDomainGetSchedulerParametersFlags(domain, params, nparams, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainGetSchedulerParametersFlags",
          "args": [
            "domain",
            "params",
            "nparams",
            "0"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainGetSchedulerParametersFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "3429-3541",
          "snippet": "static int\nesxDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    unsigned int mask = 0;\n    size_t i = 0;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.cpuAllocation.reservation\\0\"\n                                           \"config.cpuAllocation.limit\\0\"\n                                           \"config.cpuAllocation.shares\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet;\n         dynamicProperty && mask != 7 && i < 3 && i < *nparams;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.cpuAllocation.reservation\") &&\n            ! (mask & (1 << 0))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_RESERVATION,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 0;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.limit\") &&\n                   ! (mask & (1 << 1))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_LIMIT,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 1;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.shares\") &&\n                   ! (mask & (1 << 2))) {\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_SHARES,\n                                        VIR_TYPED_PARAM_INT, 0) < 0)\n                goto cleanup;\n            if (esxVI_SharesInfo_CastFromAnyType(dynamicProperty->val,\n                                                 &sharesInfo) < 0) {\n                goto cleanup;\n            }\n\n            switch (sharesInfo->level) {\n              case esxVI_SharesLevel_Custom:\n                params[i].value.i = sharesInfo->shares->value;\n                break;\n\n              case esxVI_SharesLevel_Low:\n                params[i].value.i = -1;\n                break;\n\n              case esxVI_SharesLevel_Normal:\n                params[i].value.i = -2;\n                break;\n\n              case esxVI_SharesLevel_High:\n                params[i].value.i = -3;\n                break;\n\n              case esxVI_SharesLevel_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_SharesLevel, sharesInfo->level);\n                esxVI_SharesInfo_Free(&sharesInfo);\n                goto cleanup;\n            }\n\n            esxVI_SharesInfo_Free(&sharesInfo);\n\n            mask |= 1 << 2;\n            ++i;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    *nparams = i;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    unsigned int mask = 0;\n    size_t i = 0;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.cpuAllocation.reservation\\0\"\n                                           \"config.cpuAllocation.limit\\0\"\n                                           \"config.cpuAllocation.shares\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet;\n         dynamicProperty && mask != 7 && i < 3 && i < *nparams;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.cpuAllocation.reservation\") &&\n            ! (mask & (1 << 0))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_RESERVATION,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 0;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.limit\") &&\n                   ! (mask & (1 << 1))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_LIMIT,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 1;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.shares\") &&\n                   ! (mask & (1 << 2))) {\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_SHARES,\n                                        VIR_TYPED_PARAM_INT, 0) < 0)\n                goto cleanup;\n            if (esxVI_SharesInfo_CastFromAnyType(dynamicProperty->val,\n                                                 &sharesInfo) < 0) {\n                goto cleanup;\n            }\n\n            switch (sharesInfo->level) {\n              case esxVI_SharesLevel_Custom:\n                params[i].value.i = sharesInfo->shares->value;\n                break;\n\n              case esxVI_SharesLevel_Low:\n                params[i].value.i = -1;\n                break;\n\n              case esxVI_SharesLevel_Normal:\n                params[i].value.i = -2;\n                break;\n\n              case esxVI_SharesLevel_High:\n                params[i].value.i = -3;\n                break;\n\n              case esxVI_SharesLevel_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_SharesLevel, sharesInfo->level);\n                esxVI_SharesInfo_Free(&sharesInfo);\n                goto cleanup;\n            }\n\n            esxVI_SharesInfo_Free(&sharesInfo);\n\n            mask |= 1 << 2;\n            ++i;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    *nparams = i;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetSchedulerParameters(virDomainPtr domain,\n                                virTypedParameterPtr params, int *nparams)\n{\n    return esxDomainGetSchedulerParametersFlags(domain, params, nparams, 0);\n}"
  },
  {
    "function_name": "esxDomainGetSchedulerParametersFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3429-3541",
    "snippet": "static int\nesxDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    unsigned int mask = 0;\n    size_t i = 0;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.cpuAllocation.reservation\\0\"\n                                           \"config.cpuAllocation.limit\\0\"\n                                           \"config.cpuAllocation.shares\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet;\n         dynamicProperty && mask != 7 && i < 3 && i < *nparams;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.cpuAllocation.reservation\") &&\n            ! (mask & (1 << 0))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_RESERVATION,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 0;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.limit\") &&\n                   ! (mask & (1 << 1))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_LIMIT,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 1;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.shares\") &&\n                   ! (mask & (1 << 2))) {\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_SHARES,\n                                        VIR_TYPED_PARAM_INT, 0) < 0)\n                goto cleanup;\n            if (esxVI_SharesInfo_CastFromAnyType(dynamicProperty->val,\n                                                 &sharesInfo) < 0) {\n                goto cleanup;\n            }\n\n            switch (sharesInfo->level) {\n              case esxVI_SharesLevel_Custom:\n                params[i].value.i = sharesInfo->shares->value;\n                break;\n\n              case esxVI_SharesLevel_Low:\n                params[i].value.i = -1;\n                break;\n\n              case esxVI_SharesLevel_Normal:\n                params[i].value.i = -2;\n                break;\n\n              case esxVI_SharesLevel_High:\n                params[i].value.i = -3;\n                break;\n\n              case esxVI_SharesLevel_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_SharesLevel, sharesInfo->level);\n                esxVI_SharesInfo_Free(&sharesInfo);\n                goto cleanup;\n            }\n\n            esxVI_SharesInfo_Free(&sharesInfo);\n\n            mask |= 1 << 2;\n            ++i;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    *nparams = i;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharesInfo_Free",
          "args": [
            "&sharesInfo"
          ],
          "line": 3524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharesInfo_Free",
          "args": [
            "&sharesInfo"
          ],
          "line": 3520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "esxVI_SharesLevel",
            "sharesInfo->level"
          ],
          "line": 3519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_SharesInfo_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&sharesInfo"
          ],
          "line": 3495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTypedParameterAssign",
          "args": [
            "&params[i]",
            "VIR_DOMAIN_SCHEDULER_SHARES",
            "VIR_TYPED_PARAM_INT",
            "0"
          ],
          "line": 3491
        },
        "resolved": true,
        "details": {
          "function_name": "virTypedParameterAssign",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtypedparam.c",
          "lines": "276-294",
          "snippet": "int\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include <stdarg.h>",
            "#include \"virtypedparam.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include <stdarg.h>\n#include \"virtypedparam.h\"\n#include <config.h>\n\nint\nvirTypedParameterAssign(virTypedParameterPtr param, const char *name,\n                        int type, ...)\n{\n    va_list ap;\n    int ret = -1;\n\n    if (virStrcpyStatic(param->field, name) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Field name '%s' too long\"),\n                       name);\n        return -1;\n    }\n\n    va_start(ap, type);\n    ret = virTypedParameterAssignValueVArgs(param, type, ap, false);\n    va_end(ap);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.cpuAllocation.shares\""
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Long"
          ],
          "line": 3477
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.cpuAllocation.limit\""
          ],
          "line": 3474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.cpuAllocation.reservation\""
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3452
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"config.cpuAllocation.reservation\\0\"\n                                           \"config.cpuAllocation.limit\\0\"\n                                           \"config.cpuAllocation.shares\\0\""
          ],
          "line": 3448
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3445
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetSchedulerParametersFlags(virDomainPtr domain,\n                                     virTypedParameterPtr params, int *nparams,\n                                     unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_SharesInfo *sharesInfo = NULL;\n    unsigned int mask = 0;\n    size_t i = 0;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.cpuAllocation.reservation\\0\"\n                                           \"config.cpuAllocation.limit\\0\"\n                                           \"config.cpuAllocation.shares\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet;\n         dynamicProperty && mask != 7 && i < 3 && i < *nparams;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.cpuAllocation.reservation\") &&\n            ! (mask & (1 << 0))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_RESERVATION,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 0;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.limit\") &&\n                   ! (mask & (1 << 1))) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_LIMIT,\n                                        VIR_TYPED_PARAM_LLONG,\n                                        dynamicProperty->val->int64) < 0)\n                goto cleanup;\n            mask |= 1 << 1;\n            ++i;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.cpuAllocation.shares\") &&\n                   ! (mask & (1 << 2))) {\n            if (virTypedParameterAssign(&params[i],\n                                        VIR_DOMAIN_SCHEDULER_SHARES,\n                                        VIR_TYPED_PARAM_INT, 0) < 0)\n                goto cleanup;\n            if (esxVI_SharesInfo_CastFromAnyType(dynamicProperty->val,\n                                                 &sharesInfo) < 0) {\n                goto cleanup;\n            }\n\n            switch (sharesInfo->level) {\n              case esxVI_SharesLevel_Custom:\n                params[i].value.i = sharesInfo->shares->value;\n                break;\n\n              case esxVI_SharesLevel_Low:\n                params[i].value.i = -1;\n                break;\n\n              case esxVI_SharesLevel_Normal:\n                params[i].value.i = -2;\n                break;\n\n              case esxVI_SharesLevel_High:\n                params[i].value.i = -3;\n                break;\n\n              case esxVI_SharesLevel_Undefined:\n              default:\n                virReportEnumRangeError(esxVI_SharesLevel, sharesInfo->level);\n                esxVI_SharesInfo_Free(&sharesInfo);\n                goto cleanup;\n            }\n\n            esxVI_SharesInfo_Free(&sharesInfo);\n\n            mask |= 1 << 2;\n            ++i;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    *nparams = i;\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainGetSchedulerType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3414-3425",
    "snippet": "static char *\nesxDomainGetSchedulerType(virDomainPtr domain G_GNUC_UNUSED, int *nparams)\n{\n    char *type;\n\n    type = g_strdup(\"allocation\");\n\n    if (nparams)\n        *nparams = 3; /* reservation, limit, shares */\n\n    return type;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"allocation\""
          ],
          "line": 3419
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic char *\nesxDomainGetSchedulerType(virDomainPtr domain G_GNUC_UNUSED, int *nparams)\n{\n    char *type;\n\n    type = g_strdup(\"allocation\");\n\n    if (nparams)\n        *nparams = 3; /* reservation, limit, shares */\n\n    return type;\n}"
  },
  {
    "function_name": "esxDomainSetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3278-3380",
    "snippet": "static int\nesxDomainSetAutostart(virDomainPtr domain, int autostart)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_HostAutoStartManagerConfig *spec = NULL;\n    esxVI_AutoStartDefaults *defaults = NULL;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_AutoStartPowerInfo *newPowerInfo = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_HostAutoStartManagerConfig_Alloc(&spec) < 0) {\n        goto cleanup;\n    }\n\n    if (autostart) {\n        /*\n         * There is a general autostart option that affects the autostart\n         * behavior of all domains. If it's disabled then no domain does\n         * autostart. If it's enabled then the autostart behavior depends on\n         * the per-domain autostart config.\n         */\n        if (esxVI_LookupAutoStartDefaults(priv->primary, &defaults) < 0)\n            goto cleanup;\n\n        if (defaults->enabled != esxVI_Boolean_True) {\n            /*\n             * Autostart is disabled in general. Check if no other domain is\n             * in the list of autostarted domains, so it's safe to enable the\n             * general autostart option without affecting the autostart\n             * behavior of other domains.\n             */\n            if (esxVI_LookupAutoStartPowerInfoList(priv->primary,\n                                                   &powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (powerInfo = powerInfoList; powerInfo;\n                 powerInfo = powerInfo->_next) {\n                if (STRNEQ(powerInfo->key->value, virtualMachine->obj->value)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"Cannot enable general autostart option \"\n                                     \"without affecting other domains\"));\n                    goto cleanup;\n                }\n            }\n\n            /* Enable autostart in general */\n            if (esxVI_AutoStartDefaults_Alloc(&spec->defaults) < 0)\n                goto cleanup;\n\n            spec->defaults->enabled = esxVI_Boolean_True;\n        }\n    }\n\n    if (esxVI_AutoStartPowerInfo_Alloc(&newPowerInfo) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->startOrder) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->startDelay) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->stopDelay) < 0 ||\n        esxVI_AutoStartPowerInfo_AppendToList(&spec->powerInfo,\n                                              newPowerInfo) < 0) {\n        esxVI_AutoStartPowerInfo_Free(&newPowerInfo);\n        goto cleanup;\n    }\n\n    newPowerInfo->key = virtualMachine->obj;\n    newPowerInfo->startOrder->value = -1; /* no specific start order */\n    newPowerInfo->startDelay->value = -1; /* use system default */\n    newPowerInfo->waitForHeartbeat = esxVI_AutoStartWaitHeartbeatSetting_SystemDefault;\n    newPowerInfo->startAction = autostart ? (char *)\"powerOn\" : (char *)\"none\";\n    newPowerInfo->stopDelay->value = -1; /* use system default */\n    newPowerInfo->stopAction = (char *)\"none\";\n\n    if (esxVI_ReconfigureAutostart\n          (priv->primary,\n           priv->primary->hostSystem->configManager->autoStartManager,\n           spec) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (newPowerInfo) {\n        newPowerInfo->key = NULL;\n        newPowerInfo->startAction = NULL;\n        newPowerInfo->stopAction = NULL;\n    }\n\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_HostAutoStartManagerConfig_Free(&spec);\n    esxVI_AutoStartDefaults_Free(&defaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_Free",
          "args": [
            "&powerInfoList"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartDefaults_Free",
          "args": [
            "&defaults"
          ],
          "line": 3376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_HostAutoStartManagerConfig_Free",
          "args": [
            "&spec"
          ],
          "line": 3375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigureAutostart",
          "args": [
            "priv->primary",
            "priv->primary->hostSystem->configManager->autoStartManager",
            "spec"
          ],
          "line": 3358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_Free",
          "args": [
            "&newPowerInfo"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_AppendToList",
          "args": [
            "&spec->powerInfo",
            "newPowerInfo"
          ],
          "line": 3344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&newPowerInfo->stopDelay"
          ],
          "line": 3343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&newPowerInfo->startDelay"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&newPowerInfo->startOrder"
          ],
          "line": 3341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_Alloc",
          "args": [
            "&newPowerInfo"
          ],
          "line": 3340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartDefaults_Alloc",
          "args": [
            "&spec->defaults"
          ],
          "line": 3333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Cannot enable general autostart option \"\n                                     \"without affecting other domains\")"
          ],
          "line": 3325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cannot enable general autostart option \"\n                                     \"without affecting other domains\""
          ],
          "line": 3326
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "powerInfo->key->value",
            "virtualMachine->obj->value"
          ],
          "line": 3324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartPowerInfoList",
          "args": [
            "priv->primary",
            "&powerInfoList"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartPowerInfoList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3804-3848",
          "snippet": "int\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartDefaults",
          "args": [
            "priv->primary",
            "&defaults"
          ],
          "line": 3307
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartDefaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3750-3800",
          "snippet": "int\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostAutoStartManagerConfig_Alloc",
          "args": [
            "&spec"
          ],
          "line": 3296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3293
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3290
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetAutostart(virDomainPtr domain, int autostart)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_HostAutoStartManagerConfig *spec = NULL;\n    esxVI_AutoStartDefaults *defaults = NULL;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_AutoStartPowerInfo *newPowerInfo = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_HostAutoStartManagerConfig_Alloc(&spec) < 0) {\n        goto cleanup;\n    }\n\n    if (autostart) {\n        /*\n         * There is a general autostart option that affects the autostart\n         * behavior of all domains. If it's disabled then no domain does\n         * autostart. If it's enabled then the autostart behavior depends on\n         * the per-domain autostart config.\n         */\n        if (esxVI_LookupAutoStartDefaults(priv->primary, &defaults) < 0)\n            goto cleanup;\n\n        if (defaults->enabled != esxVI_Boolean_True) {\n            /*\n             * Autostart is disabled in general. Check if no other domain is\n             * in the list of autostarted domains, so it's safe to enable the\n             * general autostart option without affecting the autostart\n             * behavior of other domains.\n             */\n            if (esxVI_LookupAutoStartPowerInfoList(priv->primary,\n                                                   &powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (powerInfo = powerInfoList; powerInfo;\n                 powerInfo = powerInfo->_next) {\n                if (STRNEQ(powerInfo->key->value, virtualMachine->obj->value)) {\n                    virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                                   _(\"Cannot enable general autostart option \"\n                                     \"without affecting other domains\"));\n                    goto cleanup;\n                }\n            }\n\n            /* Enable autostart in general */\n            if (esxVI_AutoStartDefaults_Alloc(&spec->defaults) < 0)\n                goto cleanup;\n\n            spec->defaults->enabled = esxVI_Boolean_True;\n        }\n    }\n\n    if (esxVI_AutoStartPowerInfo_Alloc(&newPowerInfo) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->startOrder) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->startDelay) < 0 ||\n        esxVI_Int_Alloc(&newPowerInfo->stopDelay) < 0 ||\n        esxVI_AutoStartPowerInfo_AppendToList(&spec->powerInfo,\n                                              newPowerInfo) < 0) {\n        esxVI_AutoStartPowerInfo_Free(&newPowerInfo);\n        goto cleanup;\n    }\n\n    newPowerInfo->key = virtualMachine->obj;\n    newPowerInfo->startOrder->value = -1; /* no specific start order */\n    newPowerInfo->startDelay->value = -1; /* use system default */\n    newPowerInfo->waitForHeartbeat = esxVI_AutoStartWaitHeartbeatSetting_SystemDefault;\n    newPowerInfo->startAction = autostart ? (char *)\"powerOn\" : (char *)\"none\";\n    newPowerInfo->stopDelay->value = -1; /* use system default */\n    newPowerInfo->stopAction = (char *)\"none\";\n\n    if (esxVI_ReconfigureAutostart\n          (priv->primary,\n           priv->primary->hostSystem->configManager->autoStartManager,\n           spec) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (newPowerInfo) {\n        newPowerInfo->key = NULL;\n        newPowerInfo->startAction = NULL;\n        newPowerInfo->stopAction = NULL;\n    }\n\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_HostAutoStartManagerConfig_Free(&spec);\n    esxVI_AutoStartDefaults_Free(&defaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainGetAutostart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3213-3274",
    "snippet": "static int\nesxDomainGetAutostart(virDomainPtr domain, int *autostart)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_AutoStartDefaults *defaults = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    *autostart = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check general autostart config */\n    if (esxVI_LookupAutoStartDefaults(priv->primary, &defaults) < 0)\n        goto cleanup;\n\n    if (defaults->enabled != esxVI_Boolean_True) {\n        /* Autostart is disabled in general, exit early here */\n        result = 0;\n        goto cleanup;\n    }\n\n    /* Check specific autostart config */\n    if (esxVI_LookupAutoStartPowerInfoList(priv->primary, &powerInfoList) < 0)\n        goto cleanup;\n\n    if (!powerInfoList) {\n        /* powerInfo list is empty, exit early here */\n        result = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (powerInfo = powerInfoList; powerInfo;\n         powerInfo = powerInfo->_next) {\n        if (STREQ(powerInfo->key->value, virtualMachine->obj->value)) {\n            if (STRCASEEQ(powerInfo->startAction, \"powerOn\"))\n                *autostart = 1;\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_AutoStartDefaults_Free(&defaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartPowerInfo_Free",
          "args": [
            "&powerInfoList"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AutoStartDefaults_Free",
          "args": [
            "&defaults"
          ],
          "line": 3269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "powerInfo->startAction",
            "\"powerOn\""
          ],
          "line": 3258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "powerInfo->key->value",
            "virtualMachine->obj->value"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3249
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartPowerInfoList",
          "args": [
            "priv->primary",
            "&powerInfoList"
          ],
          "line": 3240
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartPowerInfoList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3804-3848",
          "snippet": "int\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartPowerInfoList(esxVI_Context *ctx,\n                                   esxVI_AutoStartPowerInfo **powerInfoList)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(powerInfoList);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.powerInfo\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.powerInfo\")) {\n            if (esxVI_AutoStartPowerInfo_CastListFromAnyType\n                  (dynamicProperty->val, powerInfoList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupAutoStartDefaults",
          "args": [
            "priv->primary",
            "&defaults"
          ],
          "line": 3230
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupAutoStartDefaults",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3750-3800",
          "snippet": "int\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupAutoStartDefaults(esxVI_Context *ctx,\n                              esxVI_AutoStartDefaults **defaults)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostAutoStartManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(defaults);\n\n    /*\n     * Lookup HostAutoStartManagerConfig from the HostAutoStartManager because\n     * for some reason this is much faster than looking up the same info from\n     * the HostSystem config.\n     */\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.defaults\") < 0 ||\n        esxVI_LookupObjectContentByType\n          (ctx, ctx->hostSystem->configManager->autoStartManager,\n           \"HostAutoStartManager\", propertyNameList,\n           &hostAutoStartManager, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostAutoStartManager->propSet;\n         dynamicProperty; dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.defaults\")) {\n            if (esxVI_AutoStartDefaults_CastFromAnyType(dynamicProperty->val,\n                                                        defaults) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        }\n    }\n\n    if (!(*defaults)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve the AutoStartDefaults object\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostAutoStartManager);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 3226
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetAutostart(virDomainPtr domain, int *autostart)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_AutoStartDefaults *defaults = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_AutoStartPowerInfo *powerInfo = NULL;\n    esxVI_AutoStartPowerInfo *powerInfoList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n\n    *autostart = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    /* Check general autostart config */\n    if (esxVI_LookupAutoStartDefaults(priv->primary, &defaults) < 0)\n        goto cleanup;\n\n    if (defaults->enabled != esxVI_Boolean_True) {\n        /* Autostart is disabled in general, exit early here */\n        result = 0;\n        goto cleanup;\n    }\n\n    /* Check specific autostart config */\n    if (esxVI_LookupAutoStartPowerInfoList(priv->primary, &powerInfoList) < 0)\n        goto cleanup;\n\n    if (!powerInfoList) {\n        /* powerInfo list is empty, exit early here */\n        result = 0;\n        goto cleanup;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         NULL, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (powerInfo = powerInfoList; powerInfo;\n         powerInfo = powerInfo->_next) {\n        if (STREQ(powerInfo->key->value, virtualMachine->obj->value)) {\n            if (STRCASEEQ(powerInfo->startAction, \"powerOn\"))\n                *autostart = 1;\n\n            break;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_AutoStartDefaults_Free(&defaults);\n    esxVI_AutoStartPowerInfo_Free(&powerInfoList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainUndefine",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3207-3211",
    "snippet": "static int\nesxDomainUndefine(virDomainPtr domain)\n{\n    return esxDomainUndefineFlags(domain, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainUndefineFlags",
          "args": [
            "domain",
            "0"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainUndefineFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "3153-3204",
          "snippet": "static int\nesxDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * ESX, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, domain->uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended &&\n        powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not suspended or powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_UnregisterVM(ctx, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * ESX, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, domain->uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended &&\n        powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not suspended or powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_UnregisterVM(ctx, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainUndefine(virDomainPtr domain)\n{\n    return esxDomainUndefineFlags(domain, 0);\n}"
  },
  {
    "function_name": "esxDomainUndefineFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3153-3204",
    "snippet": "static int\nesxDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * ESX, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, domain->uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended &&\n        powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not suspended or powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_UnregisterVM(ctx, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_UnregisterVM",
          "args": [
            "ctx",
            "virtualMachine->obj"
          ],
          "line": 3194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not suspended or powered off\")"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not suspended or powered off\""
          ],
          "line": 3190
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 3183
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "ctx",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 3180
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 3178
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "ctx"
          ],
          "line": 3175
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA",
            "-1"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainUndefineFlags(virDomainPtr domain,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    /* No managed save, so we explicitly reject\n     * VIR_DOMAIN_UNDEFINE_MANAGED_SAVE.  No snapshot metadata for\n     * ESX, so we can trivially ignore that flag.  */\n    virCheckFlags(VIR_DOMAIN_UNDEFINE_SNAPSHOTS_METADATA, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, domain->uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended &&\n        powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not suspended or powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_UnregisterVM(ctx, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainDefineXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "3147-3151",
    "snippet": "static virDomainPtr\nesxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return esxDomainDefineXMLFlags(conn, xml, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainDefineXMLFlags",
          "args": [
            "conn",
            "xml",
            "0"
          ],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainDefineXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "2924-3145",
          "snippet": "static virDomainPtr\nesxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n    size_t i;\n    virDomainDiskDefPtr disk = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *escapedName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *datastoreRelatedPath = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_ManagedObjectReference *resourcePool = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainPtr domain = NULL;\n    const char *src;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse domain XML */\n    def = virDomainDefParseString(xml, priv->xmlopt,\n                                  NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* Check if an existing domain should be edited */\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, def->uuid, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!virtualMachine &&\n        esxVI_LookupVirtualMachineByName(priv->primary, def->name, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain already exists, editing existing domains is not \"\n                         \"supported yet\"));\n        goto cleanup;\n    }\n\n    /* Build VMX from domain XML */\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    if (!vmx)\n        goto cleanup;\n\n    /*\n     * Build VMX datastore URL. Use the source of the first file-based harddisk\n     * to deduce the datastore and path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach to deduce the\n     * datastore isn't perfect but should work in the majority of cases.\n     */\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = def->disks[i];\n            break;\n        }\n    }\n\n    if (!disk) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(src, &datastoreName, &directoryName,\n                                   NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(src, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk to \"\n                         \"be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      conn->uri->server, conn->uri->port);\n\n    if (directoryName) {\n        virBufferURIEncodeString(&buffer, directoryName);\n        virBufferAddChar(&buffer, '/');\n    }\n\n    escapedName = esxUtil_EscapeDatastoreItem(def->name);\n\n    if (!escapedName)\n        goto cleanup;\n\n    virBufferURIEncodeString(&buffer, escapedName);\n    virBufferAddLit(&buffer, \".vmx?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    /* Check, if VMX file already exists */\n    /* FIXME */\n\n    /* Upload VMX file */\n    VIR_DEBUG(\"Uploading .vmx config, url='%s' vmx='%s'\", url, vmx);\n\n    if (esxVI_CURL_Upload(priv->primary->curl, url, vmx) < 0)\n        goto cleanup;\n\n    /* Register the domain */\n    if (directoryName) {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s/%s.vmx\", datastoreName,\n                                               directoryName, escapedName);\n    } else {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s.vmx\", datastoreName,\n                                               escapedName);\n    }\n\n    if (esxVI_RegisterVM_Task(priv->primary, priv->primary->datacenter->vmFolder,\n                              datastoreRelatedPath, NULL, esxVI_Boolean_False,\n                              priv->primary->computeResource->resourcePool,\n                              priv->primary->hostSystem->_reference,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, def->uuid,\n                                    esxVI_Occurrence_OptionalItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not define domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain = virGetDomain(conn, def->name, def->uuid, -1);\n\n    /* FIXME: Add proper rollback in case of an error */\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    virDomainDefFree(def);\n    VIR_FREE(vmx);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(escapedName);\n    VIR_FREE(url);\n    VIR_FREE(datastoreRelatedPath);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_ManagedObjectReference_Free(&resourcePool);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return domain;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n    size_t i;\n    virDomainDiskDefPtr disk = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *escapedName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *datastoreRelatedPath = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_ManagedObjectReference *resourcePool = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainPtr domain = NULL;\n    const char *src;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse domain XML */\n    def = virDomainDefParseString(xml, priv->xmlopt,\n                                  NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* Check if an existing domain should be edited */\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, def->uuid, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!virtualMachine &&\n        esxVI_LookupVirtualMachineByName(priv->primary, def->name, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain already exists, editing existing domains is not \"\n                         \"supported yet\"));\n        goto cleanup;\n    }\n\n    /* Build VMX from domain XML */\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    if (!vmx)\n        goto cleanup;\n\n    /*\n     * Build VMX datastore URL. Use the source of the first file-based harddisk\n     * to deduce the datastore and path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach to deduce the\n     * datastore isn't perfect but should work in the majority of cases.\n     */\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = def->disks[i];\n            break;\n        }\n    }\n\n    if (!disk) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(src, &datastoreName, &directoryName,\n                                   NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(src, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk to \"\n                         \"be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      conn->uri->server, conn->uri->port);\n\n    if (directoryName) {\n        virBufferURIEncodeString(&buffer, directoryName);\n        virBufferAddChar(&buffer, '/');\n    }\n\n    escapedName = esxUtil_EscapeDatastoreItem(def->name);\n\n    if (!escapedName)\n        goto cleanup;\n\n    virBufferURIEncodeString(&buffer, escapedName);\n    virBufferAddLit(&buffer, \".vmx?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    /* Check, if VMX file already exists */\n    /* FIXME */\n\n    /* Upload VMX file */\n    VIR_DEBUG(\"Uploading .vmx config, url='%s' vmx='%s'\", url, vmx);\n\n    if (esxVI_CURL_Upload(priv->primary->curl, url, vmx) < 0)\n        goto cleanup;\n\n    /* Register the domain */\n    if (directoryName) {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s/%s.vmx\", datastoreName,\n                                               directoryName, escapedName);\n    } else {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s.vmx\", datastoreName,\n                                               escapedName);\n    }\n\n    if (esxVI_RegisterVM_Task(priv->primary, priv->primary->datacenter->vmFolder,\n                              datastoreRelatedPath, NULL, esxVI_Boolean_False,\n                              priv->primary->computeResource->resourcePool,\n                              priv->primary->hostSystem->_reference,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, def->uuid,\n                                    esxVI_Occurrence_OptionalItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not define domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain = virGetDomain(conn, def->name, def->uuid, -1);\n\n    /* FIXME: Add proper rollback in case of an error */\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    virDomainDefFree(def);\n    VIR_FREE(vmx);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(escapedName);\n    VIR_FREE(url);\n    VIR_FREE(datastoreRelatedPath);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_ManagedObjectReference_Free(&resourcePool);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return domain;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainPtr\nesxDomainDefineXML(virConnectPtr conn, const char *xml)\n{\n    return esxDomainDefineXMLFlags(conn, xml, 0);\n}"
  },
  {
    "function_name": "esxDomainDefineXMLFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2924-3145",
    "snippet": "static virDomainPtr\nesxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n    size_t i;\n    virDomainDiskDefPtr disk = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *escapedName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *datastoreRelatedPath = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_ManagedObjectReference *resourcePool = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainPtr domain = NULL;\n    const char *src;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse domain XML */\n    def = virDomainDefParseString(xml, priv->xmlopt,\n                                  NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* Check if an existing domain should be edited */\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, def->uuid, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!virtualMachine &&\n        esxVI_LookupVirtualMachineByName(priv->primary, def->name, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain already exists, editing existing domains is not \"\n                         \"supported yet\"));\n        goto cleanup;\n    }\n\n    /* Build VMX from domain XML */\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    if (!vmx)\n        goto cleanup;\n\n    /*\n     * Build VMX datastore URL. Use the source of the first file-based harddisk\n     * to deduce the datastore and path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach to deduce the\n     * datastore isn't perfect but should work in the majority of cases.\n     */\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = def->disks[i];\n            break;\n        }\n    }\n\n    if (!disk) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(src, &datastoreName, &directoryName,\n                                   NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(src, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk to \"\n                         \"be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      conn->uri->server, conn->uri->port);\n\n    if (directoryName) {\n        virBufferURIEncodeString(&buffer, directoryName);\n        virBufferAddChar(&buffer, '/');\n    }\n\n    escapedName = esxUtil_EscapeDatastoreItem(def->name);\n\n    if (!escapedName)\n        goto cleanup;\n\n    virBufferURIEncodeString(&buffer, escapedName);\n    virBufferAddLit(&buffer, \".vmx?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    /* Check, if VMX file already exists */\n    /* FIXME */\n\n    /* Upload VMX file */\n    VIR_DEBUG(\"Uploading .vmx config, url='%s' vmx='%s'\", url, vmx);\n\n    if (esxVI_CURL_Upload(priv->primary->curl, url, vmx) < 0)\n        goto cleanup;\n\n    /* Register the domain */\n    if (directoryName) {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s/%s.vmx\", datastoreName,\n                                               directoryName, escapedName);\n    } else {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s.vmx\", datastoreName,\n                                               escapedName);\n    }\n\n    if (esxVI_RegisterVM_Task(priv->primary, priv->primary->datacenter->vmFolder,\n                              datastoreRelatedPath, NULL, esxVI_Boolean_False,\n                              priv->primary->computeResource->resourcePool,\n                              priv->primary->hostSystem->_reference,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, def->uuid,\n                                    esxVI_Occurrence_OptionalItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not define domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain = virGetDomain(conn, def->name, def->uuid, -1);\n\n    /* FIXME: Add proper rollback in case of an error */\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    virDomainDefFree(def);\n    VIR_FREE(vmx);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(escapedName);\n    VIR_FREE(url);\n    VIR_FREE(datastoreRelatedPath);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_ManagedObjectReference_Free(&resourcePool);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return domain;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 3141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&resourcePool"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 3137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreRelatedPath"
          ],
          "line": 3136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "url"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "escapedName"
          ],
          "line": 3134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreName"
          ],
          "line": 3132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmx"
          ],
          "line": 3131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 3130
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "def->name",
            "def->uuid",
            "-1"
          ],
          "line": 3122
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not define domain: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 3117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not define domain: %s\""
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "def->uuid",
            "esxVI_Occurrence_OptionalItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 3109
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_RegisterVM_Task",
          "args": [
            "priv->primary",
            "priv->primary->datacenter->vmFolder",
            "datastoreRelatedPath",
            "NULL",
            "esxVI_Boolean_False",
            "priv->primary->computeResource->resourcePool",
            "priv->primary->hostSystem->_reference",
            "&task"
          ],
          "line": 3104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s.vmx\"",
            "datastoreName",
            "escapedName"
          ],
          "line": 3100
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Upload",
          "args": [
            "priv->primary->curl",
            "url",
            "vmx"
          ],
          "line": 3092
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Upload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "432-464",
          "snippet": "int\nesxVI_CURL_Upload(esxVI_CURL *curl, const char *url, const char *content)\n{\n    int responseCode = 0;\n\n    if (!content) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(curl->handle, CURLOPT_READDATA, &content);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_INFILESIZE, strlen(content));\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        return -1;\n    } else if (responseCode != 200 && responseCode != 201) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for upload to '%s'\"),\n                       responseCode, url);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_CURL_Upload(esxVI_CURL *curl, const char *url, const char *content)\n{\n    int responseCode = 0;\n\n    if (!content) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, NULL);\n    curl_easy_setopt(curl->handle, CURLOPT_READDATA, &content);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 1);\n    curl_easy_setopt(curl->handle, CURLOPT_INFILESIZE, strlen(content));\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        return -1;\n    } else if (responseCode != 200 && responseCode != 201) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for upload to '%s'\"),\n                       responseCode, url);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Uploading .vmx config, url='%s' vmx='%s'\"",
            "url",
            "vmx"
          ],
          "line": 3090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 3084
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferURIEncodeString",
          "args": [
            "&buffer",
            "datastoreName"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferURIEncodeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "534-544",
          "snippet": "void\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"&dsName=\""
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\".vmx?dcPath=\""
          ],
          "line": 3079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_EscapeDatastoreItem",
          "args": [
            "def->name"
          ],
          "line": 3073
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_EscapeDatastoreItem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "429-452",
          "snippet": "char *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nesxUtil_EscapeDatastoreItem(const char *string)\n{\n    char *replaced;\n    char *escaped1;\n    char *escaped2 = NULL;\n\n    replaced = g_strdup(string);\n\n    esxUtil_ReplaceSpecialWindowsPathChars(replaced);\n\n    escaped1 = virVMXEscapeHexPercent(replaced);\n\n    if (!escaped1)\n        goto cleanup;\n\n    escaped2 = esxUtil_EscapeBase64(escaped1);\n\n cleanup:\n    VIR_FREE(replaced);\n    VIR_FREE(escaped1);\n\n    return escaped2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buffer",
            "'/'"
          ],
          "line": 3070
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buffer",
            "\"%s://%s:%d/folder/\"",
            "priv->parsedUri->transport",
            "conn->uri->server",
            "conn->uri->port"
          ],
          "line": 3065
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting source '%s' of first file-based harddisk to \"\n                         \"be a VMDK image\")",
            "src"
          ],
          "line": 3059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStringHasCaseSuffix",
          "args": [
            "src",
            "\".vmdk\""
          ],
          "line": 3058
        },
        "resolved": true,
        "details": {
          "function_name": "virStringHasCaseSuffix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "1110-1121",
          "snippet": "bool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nbool\nvirStringHasCaseSuffix(const char *str,\n                       const char *suffix)\n{\n    int len = strlen(str);\n    int suffixlen = strlen(suffix);\n\n    if (len < suffixlen)\n        return false;\n\n    return STRCASEEQ(str + len - suffixlen, suffix);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "src",
            "&datastoreName",
            "&directoryName",
            "NULL"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"First file-based harddisk has no source, cannot deduce \"\n                         \"datastore and path for VMX file\")"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\")"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def->disks[i]"
          ],
          "line": 3032
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain XML doesn't contain any disks, cannot deduce \"\n                         \"datastore and path for VMX file\")"
          ],
          "line": 3024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virVMXFormatConfig",
          "args": [
            "&ctx",
            "priv->xmlopt",
            "def",
            "virtualHW_version"
          ],
          "line": 3011
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3052-3453",
          "snippet": "char *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ProductVersionToDefaultVirtualHWVersion",
          "args": [
            "priv->primary->productLine",
            "priv->primary->productVersion"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductVersionToDefaultVirtualHWVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4472-4544",
          "snippet": "int\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Domain already exists, editing existing domains is not \"\n                         \"supported yet\")"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByName",
          "args": [
            "priv->primary",
            "def->name",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2775-2829",
          "snippet": "int\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "def->uuid",
            "NULL",
            "&virtualMachine",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLCheckIllegalChars",
          "args": [
            "\"name\"",
            "def->name",
            "\"\\n\""
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLCheckIllegalChars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "490-502",
          "snippet": "int\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLCheckIllegalChars(const char *nodeName,\n                        const char *str,\n                        const char *illegal)\n{\n    char *c;\n    if ((c = strpbrk(str, illegal))) {\n        virReportError(VIR_ERR_XML_DETAIL,\n                       _(\"invalid char in %s: %c\"), nodeName, *c);\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "xml",
            "priv->xmlopt",
            "NULL",
            "parse_flags"
          ],
          "line": 2963
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2959
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 2957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_DEFINE_VALIDATE",
            "NULL"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainDefineXMLFlags(virConnectPtr conn, const char *xml, unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n    size_t i;\n    virDomainDiskDefPtr disk = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *escapedName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *datastoreRelatedPath = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_ManagedObjectReference *resourcePool = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    virDomainPtr domain = NULL;\n    const char *src;\n    unsigned int parse_flags = VIR_DOMAIN_DEF_PARSE_INACTIVE;\n\n    virCheckFlags(VIR_DOMAIN_DEFINE_VALIDATE, NULL);\n\n    if (flags & VIR_DOMAIN_DEFINE_VALIDATE)\n        parse_flags |= VIR_DOMAIN_DEF_PARSE_VALIDATE_SCHEMA;\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    /* Parse domain XML */\n    def = virDomainDefParseString(xml, priv->xmlopt,\n                                  NULL, parse_flags);\n\n    if (!def)\n        return NULL;\n\n    if (virXMLCheckIllegalChars(\"name\", def->name, \"\\n\") < 0)\n        goto cleanup;\n\n    /* Check if an existing domain should be edited */\n    if (esxVI_LookupVirtualMachineByUuid(priv->primary, def->uuid, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!virtualMachine &&\n        esxVI_LookupVirtualMachineByName(priv->primary, def->name, NULL,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualMachine) {\n        /* FIXME */\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain already exists, editing existing domains is not \"\n                         \"supported yet\"));\n        goto cleanup;\n    }\n\n    /* Build VMX from domain XML */\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    if (!vmx)\n        goto cleanup;\n\n    /*\n     * Build VMX datastore URL. Use the source of the first file-based harddisk\n     * to deduce the datastore and path for the VMX file. Don't just use the\n     * first disk, because it may be CDROM disk and ISO images are normally not\n     * located in the virtual machine's directory. This approach to deduce the\n     * datastore isn't perfect but should work in the majority of cases.\n     */\n    if (def->ndisks < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any disks, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        if (def->disks[i]->device == VIR_DOMAIN_DISK_DEVICE_DISK &&\n            virDomainDiskGetType(def->disks[i]) == VIR_STORAGE_TYPE_FILE) {\n            disk = def->disks[i];\n            break;\n        }\n    }\n\n    if (!disk) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Domain XML doesn't contain any file-based harddisks, \"\n                         \"cannot deduce datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    src = virDomainDiskGetSource(disk);\n    if (!src) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"First file-based harddisk has no source, cannot deduce \"\n                         \"datastore and path for VMX file\"));\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(src, &datastoreName, &directoryName,\n                                   NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (!virStringHasCaseSuffix(src, \".vmdk\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting source '%s' of first file-based harddisk to \"\n                         \"be a VMDK image\"), src);\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      conn->uri->server, conn->uri->port);\n\n    if (directoryName) {\n        virBufferURIEncodeString(&buffer, directoryName);\n        virBufferAddChar(&buffer, '/');\n    }\n\n    escapedName = esxUtil_EscapeDatastoreItem(def->name);\n\n    if (!escapedName)\n        goto cleanup;\n\n    virBufferURIEncodeString(&buffer, escapedName);\n    virBufferAddLit(&buffer, \".vmx?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    /* Check, if VMX file already exists */\n    /* FIXME */\n\n    /* Upload VMX file */\n    VIR_DEBUG(\"Uploading .vmx config, url='%s' vmx='%s'\", url, vmx);\n\n    if (esxVI_CURL_Upload(priv->primary->curl, url, vmx) < 0)\n        goto cleanup;\n\n    /* Register the domain */\n    if (directoryName) {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s/%s.vmx\", datastoreName,\n                                               directoryName, escapedName);\n    } else {\n        datastoreRelatedPath = g_strdup_printf(\"[%s] %s.vmx\", datastoreName,\n                                               escapedName);\n    }\n\n    if (esxVI_RegisterVM_Task(priv->primary, priv->primary->datacenter->vmFolder,\n                              datastoreRelatedPath, NULL, esxVI_Boolean_False,\n                              priv->primary->computeResource->resourcePool,\n                              priv->primary->hostSystem->_reference,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, def->uuid,\n                                    esxVI_Occurrence_OptionalItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not define domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain = virGetDomain(conn, def->name, def->uuid, -1);\n\n    /* FIXME: Add proper rollback in case of an error */\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    virDomainDefFree(def);\n    VIR_FREE(vmx);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(escapedName);\n    VIR_FREE(url);\n    VIR_FREE(datastoreRelatedPath);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_ManagedObjectReference_Free(&resourcePool);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return domain;\n}"
  },
  {
    "function_name": "esxDomainCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2916-2920",
    "snippet": "static int\nesxDomainCreate(virDomainPtr domain)\n{\n    return esxDomainCreateWithFlags(domain, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainCreateWithFlags",
          "args": [
            "domain",
            "0"
          ],
          "line": 2919
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainCreateWithFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "2853-2912",
          "snippet": "static int\nesxDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not start domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = id;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not start domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = id;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainCreate(virDomainPtr domain)\n{\n    return esxDomainCreateWithFlags(domain, 0);\n}"
  },
  {
    "function_name": "esxDomainCreateWithFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2853-2912",
    "snippet": "static int\nesxDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not start domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = id;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 2909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not start domain: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not start domain: %s\""
          ],
          "line": 2897
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PowerOnVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "NULL",
            "&task"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered off\")"
          ],
          "line": 2882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id",
            "NULL",
            "NULL"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 2873
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2868
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainCreateWithFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not start domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = id;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectNumOfDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2839-2849",
    "snippet": "static int\nesxConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return esxVI_LookupNumberOfDomainsByPowerState\n             (priv->primary, esxVI_VirtualMachinePowerState_PoweredOn, true);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupNumberOfDomainsByPowerState",
          "args": [
            "priv->primary",
            "esxVI_VirtualMachinePowerState_PoweredOn",
            "true"
          ],
          "line": 2847
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupNumberOfDomainsByPowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2389-2437",
          "snippet": "int\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2844
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfDefinedDomains(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return esxVI_LookupNumberOfDomainsByPowerState\n             (priv->primary, esxVI_VirtualMachinePowerState_PoweredOn, true);\n}"
  },
  {
    "function_name": "esxConnectListDefinedDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2772-2835",
    "snippet": "static int\nesxConnectListDefinedDomains(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOn)\n            continue;\n\n        names[count] = NULL;\n\n        if (esxVI_GetVirtualMachineIdentity(virtualMachine, NULL, &names[count],\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        ++count;\n\n        if (count >= maxnames)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return count;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 2832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "names[i]"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "NULL",
            "&names[count]",
            "NULL"
          ],
          "line": 2810
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&virtualMachineList"
          ],
          "line": 2793
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"name\\0\"\n                                           \"runtime.powerState\\0\""
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2787
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListDefinedDomains(virConnectPtr conn, char **const names, int maxnames)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int count = 0;\n    size_t i;\n\n    if (maxnames == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOn)\n            continue;\n\n        names[count] = NULL;\n\n        if (esxVI_GetVirtualMachineIdentity(virtualMachine, NULL, &names[count],\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        ++count;\n\n        if (count >= maxnames)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        for (i = 0; i < count; ++i)\n            VIR_FREE(names[i]);\n\n        count = -1;\n    }\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return count;\n}"
  },
  {
    "function_name": "esxConnectDomainXMLToNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2719-2768",
    "snippet": "static char *\nesxConnectDomainXMLToNative(virConnectPtr conn, const char *nativeFormat,\n                            const char *domainXml,\n                            unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        return NULL;\n\n    def = virDomainDefParseString(domainXml, priv->xmlopt,\n                                  NULL, VIR_DOMAIN_DEF_PARSE_INACTIVE);\n\n    if (!def)\n        return NULL;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    virDomainDefFree(def);\n\n    return vmx;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXFormatConfig",
          "args": [
            "&ctx",
            "priv->xmlopt",
            "def",
            "virtualHW_version"
          ],
          "line": 2763
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXFormatConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "3052-3453",
          "snippet": "char *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirVMXFormatConfig(virVMXContext *ctx, virDomainXMLOptionPtr xmlopt, virDomainDefPtr def,\n                   int virtualHW_version)\n{\n    char *vmx = NULL;\n    size_t i;\n    int sched_cpu_affinity_length;\n    unsigned char zero[VIR_UUID_BUFLEN];\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *preliminaryDisplayName = NULL;\n    char *displayName = NULL;\n    char *annotation = NULL;\n    unsigned long long max_balloon;\n    bool scsi_present[4] = { false, false, false, false };\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    bool floppy_present[2] = { false, false };\n    unsigned int maxvcpus;\n    bool hasSCSI = false;\n\n    if (ctx->formatFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no formatFileName function set\"));\n        return NULL;\n    }\n\n    memset(zero, 0, VIR_UUID_BUFLEN);\n\n    if (def->virtType != VIR_DOMAIN_VIRT_VMWARE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting virt type to be '%s' but found '%s'\"),\n                       virDomainVirtTypeToString(VIR_DOMAIN_VIRT_VMWARE),\n                       virDomainVirtTypeToString(def->virtType));\n        return NULL;\n    }\n\n    /* vmx:.encoding */\n    virBufferAddLit(&buffer, \".encoding = \\\"UTF-8\\\"\\n\");\n\n    /* vmx:config.version */\n    virBufferAddLit(&buffer, \"config.version = \\\"8\\\"\\n\");\n\n    /* vmx:virtualHW.version */\n    virBufferAsprintf(&buffer, \"virtualHW.version = \\\"%d\\\"\\n\",\n                      virtualHW_version);\n\n    /* def:os.arch -> vmx:guestOS */\n    if (def->os.arch == VIR_ARCH_I686) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other\\\"\\n\");\n    } else if (def->os.arch == VIR_ARCH_X86_64) {\n        virBufferAddLit(&buffer, \"guestOS = \\\"other-64\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting domain XML attribute 'arch' of entry 'os/type' \"\n                         \"to be 'i686' or 'x86_64' but found '%s'\"),\n                       virArchToString(def->os.arch));\n        goto cleanup;\n    }\n\n    /* def:os.smbios_mode -> vmx:smbios.reflecthost */\n    if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_NONE ||\n        def->os.smbios_mode == VIR_DOMAIN_SMBIOS_EMULATE) {\n        /* nothing */\n    } else if (def->os.smbios_mode == VIR_DOMAIN_SMBIOS_HOST) {\n        virBufferAddLit(&buffer, \"smbios.reflecthost = \\\"true\\\"\\n\");\n    } else {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"Unsupported SMBIOS mode '%s'\"),\n                       virDomainSmbiosModeTypeToString(def->os.smbios_mode));\n        goto cleanup;\n    }\n\n    /* def:uuid -> vmx:uuid.action, vmx:uuid.bios */\n    if (memcmp(def->uuid, zero, VIR_UUID_BUFLEN) == 0) {\n        virBufferAddLit(&buffer, \"uuid.action = \\\"create\\\"\\n\");\n    } else {\n        virBufferAsprintf(&buffer, \"uuid.bios = \\\"%02x %02x %02x %02x %02x %02x \"\n                          \"%02x %02x-%02x %02x %02x %02x %02x %02x %02x %02x\\\"\\n\",\n                          def->uuid[0], def->uuid[1], def->uuid[2], def->uuid[3],\n                          def->uuid[4], def->uuid[5], def->uuid[6], def->uuid[7],\n                          def->uuid[8], def->uuid[9], def->uuid[10], def->uuid[11],\n                          def->uuid[12], def->uuid[13], def->uuid[14],\n                          def->uuid[15]);\n    }\n\n    /* def:name -> vmx:displayName */\n    preliminaryDisplayName = virVMXEscapeHexPipe(def->name);\n\n    if (preliminaryDisplayName == NULL)\n        goto cleanup;\n\n    displayName = virVMXEscapeHexPercent(preliminaryDisplayName);\n\n    if (displayName == NULL)\n        goto cleanup;\n\n    virBufferAsprintf(&buffer, \"displayName = \\\"%s\\\"\\n\", displayName);\n\n    /* def:description -> vmx:annotation */\n    if (def->description != NULL) {\n        if (!(annotation = virVMXEscapeHexPipe(def->description)))\n            goto cleanup;\n\n        virBufferAsprintf(&buffer, \"annotation = \\\"%s\\\"\\n\", annotation);\n    }\n\n    /* def:mem.max_balloon -> vmx:memsize */\n    /* max-memory must be a multiple of 4096 kilobyte */\n    max_balloon = VIR_DIV_UP(virDomainDefGetMemoryTotal(def), 4096) * 4096;\n\n    virBufferAsprintf(&buffer, \"memsize = \\\"%llu\\\"\\n\",\n                      max_balloon / 1024); /* Scale from kilobytes to megabytes */\n\n    /* def:mem.cur_balloon -> vmx:sched.mem.max */\n    if (def->mem.cur_balloon < max_balloon) {\n        virBufferAsprintf(&buffer, \"sched.mem.max = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.cur_balloon,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:mem.min_guarantee -> vmx:sched.mem.minsize */\n    if (def->mem.min_guarantee > 0) {\n        virBufferAsprintf(&buffer, \"sched.mem.minsize = \\\"%llu\\\"\\n\",\n                          VIR_DIV_UP(def->mem.min_guarantee,\n                                     1024)); /* Scale from kilobytes to megabytes */\n    }\n\n    /* def:maxvcpus -> vmx:numvcpus */\n    if (virDomainDefHasVcpusOffline(def)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"No support for domain XML entry 'vcpu' attribute \"\n                         \"'current'\"));\n        goto cleanup;\n    }\n    maxvcpus = virDomainDefGetVcpusMax(def);\n    if (maxvcpus == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Expecting domain XML entry 'vcpu' to be greater \"\n                         \"than 0\"));\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"numvcpus = \\\"%d\\\"\\n\", maxvcpus);\n\n    if (def->cpu) {\n        unsigned int calculated_vcpus;\n\n        if (def->cpu->mode != VIR_CPU_MODE_CUSTOM) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU mode 'custom' but \"\n                             \"found '%s'\"),\n                           virCPUModeTypeToString(def->cpu->mode));\n            goto cleanup;\n        }\n\n        if (def->cpu->threads != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 thread per core is supported\"));\n            goto cleanup;\n        }\n\n        if (def->cpu->dies != 1) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Only 1 die per socket is supported\"));\n            goto cleanup;\n        }\n\n        calculated_vcpus = def->cpu->sockets * def->cpu->cores;\n        if (calculated_vcpus != maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML CPU sockets per core as %d \"\n                             \"but found %d\"),\n                           maxvcpus, calculated_vcpus);\n            goto cleanup;\n        }\n\n        virBufferAsprintf(&buffer, \"cpuid.coresPerSocket = \\\"%d\\\"\\n\", def->cpu->cores);\n    }\n\n    /* def:cpumask -> vmx:sched.cpu.affinity */\n    if (def->cpumask && virBitmapSize(def->cpumask) > 0) {\n        int bit;\n        virBufferAddLit(&buffer, \"sched.cpu.affinity = \\\"\");\n\n        sched_cpu_affinity_length = 0;\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0)\n            ++sched_cpu_affinity_length;\n\n        if (sched_cpu_affinity_length < maxvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting domain XML attribute 'cpuset' of entry \"\n                             \"'vcpu' to contain at least %d CPU(s)\"),\n                           maxvcpus);\n            goto cleanup;\n        }\n\n        bit = -1;\n        while ((bit = virBitmapNextSetBit(def->cpumask, bit)) >= 0) {\n            virBufferAsprintf(&buffer, \"%d\", bit);\n\n            if (sched_cpu_affinity_length > 1)\n                virBufferAddChar(&buffer, ',');\n\n            --sched_cpu_affinity_length;\n        }\n\n        virBufferAddLit(&buffer, \"\\\"\\n\");\n    }\n\n    /* def:cputune.shares -> vmx:sched.cpu.shares */\n    if (def->cputune.sharesSpecified) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (def->cputune.shares == vcpus * 500) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"low\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 1000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"normal\\\"\\n\");\n        } else if (def->cputune.shares == vcpus * 2000) {\n            virBufferAddLit(&buffer, \"sched.cpu.shares = \\\"high\\\"\\n\");\n        } else {\n            virBufferAsprintf(&buffer, \"sched.cpu.shares = \\\"%llu\\\"\\n\",\n                              def->cputune.shares);\n        }\n    }\n\n    /* def:graphics */\n    for (i = 0; i < def->ngraphics; ++i) {\n        switch (def->graphics[i]->type) {\n          case VIR_DOMAIN_GRAPHICS_TYPE_VNC:\n            if (virVMXFormatVNC(def->graphics[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_SDL:\n          case VIR_DOMAIN_GRAPHICS_TYPE_RDP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_DESKTOP:\n          case VIR_DOMAIN_GRAPHICS_TYPE_SPICE:\n          case VIR_DOMAIN_GRAPHICS_TYPE_EGL_HEADLESS:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported graphics type '%s'\"),\n                           virDomainGraphicsTypeToString(def->graphics[i]->type));\n            goto cleanup;\n\n          case VIR_DOMAIN_GRAPHICS_TYPE_LAST:\n          default:\n              virReportEnumRangeError(virDomainGraphicsType, def->graphics[i]->type);\n              goto cleanup;\n        }\n    }\n\n    /* def:disks */\n    for (i = 0; i < def->ndisks; ++i) {\n        if (virVMXVerifyDiskAddress(xmlopt, def->disks[i], def) < 0 ||\n            virVMXHandleLegacySCSIDiskDriverName(def, def->disks[i]) < 0) {\n            goto cleanup;\n        }\n    }\n\n    if (virVMXGatherSCSIControllers(ctx, def, scsi_virtualDev,\n                                    scsi_present) < 0) {\n        goto cleanup;\n    }\n\n    for (i = 0; i < 4; ++i) {\n        if (scsi_present[i]) {\n            hasSCSI = true;\n\n            virBufferAsprintf(&buffer, \"scsi%zu.present = \\\"true\\\"\\n\", i);\n\n            if (scsi_virtualDev[i] != -1) {\n                virBufferAsprintf(&buffer, \"scsi%zu.virtualDev = \\\"%s\\\"\\n\", i,\n                                  virVMXControllerModelSCSITypeToString\n                                    (scsi_virtualDev[i]));\n            }\n        }\n    }\n\n    for (i = 0; i < def->ndisks; ++i) {\n        switch (def->disks[i]->device) {\n          case VIR_DOMAIN_DISK_DEVICE_DISK:\n          case VIR_DOMAIN_DISK_DEVICE_CDROM:\n          case VIR_DOMAIN_DISK_DEVICE_LUN:\n            if (virVMXFormatDisk(ctx, def->disks[i], &buffer) < 0)\n                goto cleanup;\n\n            break;\n\n          case VIR_DOMAIN_DISK_DEVICE_FLOPPY:\n            if (virVMXFormatFloppy(ctx, def->disks[i], &buffer,\n                                   floppy_present) < 0) {\n                goto cleanup;\n            }\n\n            break;\n\n          default:\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"Unsupported disk device type '%s'\"),\n                           virDomainDiskDeviceTypeToString(def->disks[i]->device));\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < 2; ++i) {\n        /* floppy[0..1].present defaults to true, disable it explicitly */\n        if (! floppy_present[i])\n            virBufferAsprintf(&buffer, \"floppy%zu.present = \\\"false\\\"\\n\", i);\n    }\n\n    /* def:fss */\n    if (def->nfss > 0) {\n        virBufferAddLit(&buffer, \"isolation.tools.hgfs.disable = \\\"false\\\"\\n\");\n        virBufferAsprintf(&buffer, \"sharedFolder.maxNum = \\\"%zu\\\"\\n\", def->nfss);\n    }\n\n    for (i = 0; i < def->nfss; ++i) {\n        if (virVMXFormatFileSystem(def->fss[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:nets */\n    for (i = 0; i < def->nnets; ++i) {\n        if (virVMXFormatEthernet(def->nets[i], i, &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:videos */\n    if (def->nvideos > 0) {\n        if (def->nvideos > 1) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"No support for multiple video devices\"));\n            goto cleanup;\n        }\n\n        if (virVMXFormatSVGA(def->videos[0], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    for (i = 0; i < def->nserials; ++i) {\n        if (virVMXFormatSerial(ctx, def->serials[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* def:parallels */\n    for (i = 0; i < def->nparallels; ++i) {\n        if (virVMXFormatParallel(ctx, def->parallels[i], &buffer) < 0)\n            goto cleanup;\n    }\n\n    /* vmx:firmware */\n    if (def->os.firmware == VIR_DOMAIN_OS_DEF_FIRMWARE_EFI)\n        virBufferAddLit(&buffer, \"firmware = \\\"efi\\\"\\n\");\n\n    if (virtualHW_version >= 7) {\n        if (hasSCSI) {\n            virBufferAddLit(&buffer, \"pciBridge0.present = \\\"true\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge4.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge4.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge5.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge5.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge6.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge6.functions = \\\"8\\\"\\n\");\n\n            virBufferAddLit(&buffer, \"pciBridge7.present = \\\"true\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.virtualDev = \\\"pcieRootPort\\\"\\n\");\n            virBufferAddLit(&buffer, \"pciBridge7.functions = \\\"8\\\"\\n\");\n        }\n\n        virBufferAddLit(&buffer, \"vmci0.present = \\\"true\\\"\\n\");\n    }\n\n    /* Get final VMX output */\n    vmx = virBufferContentAndReset(&buffer);\n\n cleanup:\n    if (vmx == NULL)\n        virBufferFreeAndReset(&buffer);\n\n    VIR_FREE(preliminaryDisplayName);\n    VIR_FREE(displayName);\n    VIR_FREE(annotation);\n\n    return vmx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefParseString",
          "args": [
            "domainXml",
            "priv->xmlopt",
            "NULL",
            "VIR_DOMAIN_DEF_PARSE_INACTIVE"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "22134-22141",
          "snippet": "virDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDefPtr\nvirDomainDefParseString(const char *xmlStr,\n                        virDomainXMLOptionPtr xmlopt,\n                        void *parseOpaque,\n                        unsigned int flags)\n{\n    return virDomainDefParse(xmlStr, NULL, xmlopt, parseOpaque, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ProductVersionToDefaultVirtualHWVersion",
          "args": [
            "priv->primary->productLine",
            "priv->primary->productVersion"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductVersionToDefaultVirtualHWVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4472-4544",
          "snippet": "int\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_ProductVersionToDefaultVirtualHWVersion(esxVI_ProductLine productLine,\n                                              unsigned long productVersion)\n{\n    /* product version == 1000000 * major + 1000 * minor + micro */\n    int major = productVersion / 1000000;\n    int minor = productVersion / 1000 - major * 1000;\n\n    /*\n     * virtualHW.version compatibility matrix:\n     *\n     *              4 7 8 9 10   API\n     *   ESX 3.5    +            2.5\n     *   ESX 4.0    + +          4.0\n     *   ESX 4.1    + +          4.1\n     *   ESX 5.0    + + +        5.0\n     *   ESX 5.1    + + + +      5.1\n     *   ESX 5.5    + + + + +    5.5\n     *   ESX 6.0    + + + + +    6.0\n     *   GSX 2.0    + +          2.5\n     */\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return 7;\n\n      case esxVI_ProductLine_ESX:\n        switch (major) {\n          case 3:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      case esxVI_ProductLine_VPX:\n        switch (major) {\n          case 2:\n            return 4;\n\n          case 4:\n            return 7;\n\n          case 5:\n            if (minor < 5)\n                return 9;\n\n            return 10;\n\n          case 6:\n            return 10;\n\n          default:\n            return 8;\n        }\n\n      default:\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unexpected product line\"));\n        return -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Unsupported config format '%s'\")",
            "nativeFormat"
          ],
          "line": 2736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported config format '%s'\""
          ],
          "line": 2737
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "nativeFormat",
            "VMX_CONFIG_FORMAT_ARGV"
          ],
          "line": 2735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxConnectDomainXMLToNative(virConnectPtr conn, const char *nativeFormat,\n                            const char *domainXml,\n                            unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    int virtualHW_version;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *vmx = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    virtualHW_version = esxVI_ProductVersionToDefaultVirtualHWVersion\n                          (priv->primary->productLine, priv->primary->productVersion);\n\n    if (virtualHW_version < 0)\n        return NULL;\n\n    def = virDomainDefParseString(domainXml, priv->xmlopt,\n                                  NULL, VIR_DOMAIN_DEF_PARSE_INACTIVE);\n\n    if (!def)\n        return NULL;\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = NULL;\n\n    ctx.opaque = &data;\n    ctx.parseFileName = NULL;\n    ctx.formatFileName = esxFormatVMXFileName;\n    ctx.autodetectSCSIControllerModel = esxAutodetectSCSIControllerModel;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    vmx = virVMXFormatConfig(&ctx, priv->xmlopt, def, virtualHW_version);\n\n    virDomainDefFree(def);\n\n    return vmx;\n}"
  },
  {
    "function_name": "esxConnectDomainXMLFromNative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2675-2715",
    "snippet": "static char *\nesxConnectDomainXMLFromNative(virConnectPtr conn, const char *nativeFormat,\n                              const char *nativeConfig,\n                              unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = (char *)\"[?] ?\";\n\n    ctx.opaque = &data;\n    ctx.parseFileName = esxParseVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    def = virVMXParseConfig(&ctx, priv->xmlopt, priv->caps, nativeConfig);\n\n    if (def)\n        xml = virDomainDefFormat(def, priv->xmlopt,\n                                 VIR_DOMAIN_DEF_FORMAT_INACTIVE);\n\n    virDomainDefFree(def);\n\n    return xml;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 2712
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "priv->xmlopt",
            "VIR_DOMAIN_DEF_FORMAT_INACTIVE"
          ],
          "line": 2709
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseConfig",
          "args": [
            "&ctx",
            "priv->xmlopt",
            "priv->caps",
            "nativeConfig"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1275-1867",
          "snippet": "virDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Unsupported config format '%s'\")",
            "nativeFormat"
          ],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unsupported config format '%s'\""
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "nativeFormat",
            "VMX_CONFIG_FORMAT_ARGV"
          ],
          "line": 2690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2686
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxConnectDomainXMLFromNative(virConnectPtr conn, const char *nativeFormat,\n                              const char *nativeConfig,\n                              unsigned int flags)\n{\n    esxPrivate *priv = conn->privateData;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(0, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (STRNEQ(nativeFormat, VMX_CONFIG_FORMAT_ARGV)) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Unsupported config format '%s'\"), nativeFormat);\n        return NULL;\n    }\n\n    data.ctx = priv->primary;\n    data.datastorePathWithoutFileName = (char *)\"[?] ?\";\n\n    ctx.opaque = &data;\n    ctx.parseFileName = esxParseVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = NULL;\n    ctx.moref = NULL;\n\n    def = virVMXParseConfig(&ctx, priv->xmlopt, priv->caps, nativeConfig);\n\n    if (def)\n        xml = virDomainDefFormat(def, priv->xmlopt,\n                                 VIR_DOMAIN_DEF_FORMAT_INACTIVE);\n\n    virDomainDefFree(def);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxDomainGetXMLDesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2569-2671",
    "snippet": "static char *\nesxDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id;\n    char *moref = NULL;\n    char *vmPathName = NULL;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *vmx = NULL;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.files.vmPathName\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineMORef(virtualMachine, &moref) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0 ||\n        esxVI_GetStringValue(virtualMachine, \"config.files.vmPathName\",\n                             &vmPathName, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(vmPathName, &datastoreName, &directoryName,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      domain->conn->uri->server, domain->conn->uri->port);\n    virBufferURIEncodeString(&buffer, directoryAndFileName);\n    virBufferAddLit(&buffer, \"?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    if (esxVI_CURL_Download(priv->primary->curl, url, &vmx, 0, NULL) < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n\n    if (!directoryName) {\n        data.datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n    } else {\n        data.datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\",\n                                                            datastoreName, directoryName);\n    }\n\n    ctx.opaque = &data;\n    ctx.parseFileName = esxParseVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = priv->primary->datacenterPath;\n    ctx.moref = moref;\n\n    def = virVMXParseConfig(&ctx, priv->xmlopt, priv->caps, vmx);\n\n    if (def) {\n        if (powerState != esxVI_VirtualMachinePowerState_PoweredOff)\n            def->id = id;\n\n        xml = virDomainDefFormat(def, priv->xmlopt,\n                                 virDomainDefFormatConvertXMLFlags(flags));\n    }\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    VIR_FREE(moref);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(url);\n    VIR_FREE(data.datastorePathWithoutFileName);\n    VIR_FREE(vmx);\n    virDomainDefFree(def);\n\n    return xml;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainDefFree",
          "args": [
            "def"
          ],
          "line": 2668
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "3325-3513",
          "snippet": "void virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvoid virDomainDefFree(virDomainDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    virDomainResourceDefFree(def->resource);\n\n    for (i = 0; i < def->maxvcpus; i++)\n        virDomainVcpuDefFree(def->vcpus[i]);\n    VIR_FREE(def->vcpus);\n\n    /* hostdevs must be freed before nets (or any future \"intelligent\n     * hostdevs\") because the pointer to the hostdev is really\n     * pointing into the middle of the higher level device's object,\n     * so the original object must still be available during the call\n     * to virDomainHostdevDefFree().\n     */\n    for (i = 0; i < def->nhostdevs; i++)\n        virDomainHostdevDefFree(def->hostdevs[i]);\n    VIR_FREE(def->hostdevs);\n\n    for (i = 0; i < def->nleases; i++)\n        virDomainLeaseDefFree(def->leases[i]);\n    VIR_FREE(def->leases);\n\n    for (i = 0; i < def->ngraphics; i++)\n        virDomainGraphicsDefFree(def->graphics[i]);\n    VIR_FREE(def->graphics);\n\n    for (i = 0; i < def->ninputs; i++)\n        virDomainInputDefFree(def->inputs[i]);\n    VIR_FREE(def->inputs);\n\n    for (i = 0; i < def->ndisks; i++)\n        virDomainDiskDefFree(def->disks[i]);\n    VIR_FREE(def->disks);\n\n    for (i = 0; i < def->ncontrollers; i++)\n        virDomainControllerDefFree(def->controllers[i]);\n    VIR_FREE(def->controllers);\n\n    for (i = 0; i < def->nfss; i++)\n        virDomainFSDefFree(def->fss[i]);\n    VIR_FREE(def->fss);\n\n    for (i = 0; i < def->nnets; i++)\n        virDomainNetDefFree(def->nets[i]);\n    VIR_FREE(def->nets);\n\n    for (i = 0; i < def->nsmartcards; i++)\n        virDomainSmartcardDefFree(def->smartcards[i]);\n    VIR_FREE(def->smartcards);\n\n    for (i = 0; i < def->nserials; i++)\n        virDomainChrDefFree(def->serials[i]);\n    VIR_FREE(def->serials);\n\n    for (i = 0; i < def->nparallels; i++)\n        virDomainChrDefFree(def->parallels[i]);\n    VIR_FREE(def->parallels);\n\n    for (i = 0; i < def->nchannels; i++)\n        virDomainChrDefFree(def->channels[i]);\n    VIR_FREE(def->channels);\n\n    for (i = 0; i < def->nconsoles; i++)\n        virDomainChrDefFree(def->consoles[i]);\n    VIR_FREE(def->consoles);\n\n    for (i = 0; i < def->nsounds; i++)\n        virDomainSoundDefFree(def->sounds[i]);\n    VIR_FREE(def->sounds);\n\n    for (i = 0; i < def->nvideos; i++)\n        virDomainVideoDefFree(def->videos[i]);\n    VIR_FREE(def->videos);\n\n    for (i = 0; i < def->nhubs; i++)\n        virDomainHubDefFree(def->hubs[i]);\n    VIR_FREE(def->hubs);\n\n    for (i = 0; i < def->nredirdevs; i++)\n        virDomainRedirdevDefFree(def->redirdevs[i]);\n    VIR_FREE(def->redirdevs);\n\n    for (i = 0; i < def->nrngs; i++)\n        virDomainRNGDefFree(def->rngs[i]);\n    VIR_FREE(def->rngs);\n\n    for (i = 0; i < def->nmems; i++)\n        virDomainMemoryDefFree(def->mems[i]);\n    VIR_FREE(def->mems);\n\n    virDomainTPMDefFree(def->tpm);\n\n    for (i = 0; i < def->npanics; i++)\n        virDomainPanicDefFree(def->panics[i]);\n    VIR_FREE(def->panics);\n\n    VIR_FREE(def->iommu);\n\n    VIR_FREE(def->idmap.uidmap);\n    VIR_FREE(def->idmap.gidmap);\n\n    VIR_FREE(def->os.machine);\n    VIR_FREE(def->os.init);\n    for (i = 0; def->os.initargv && def->os.initargv[i]; i++)\n        VIR_FREE(def->os.initargv[i]);\n    VIR_FREE(def->os.initargv);\n    for (i = 0; def->os.initenv && def->os.initenv[i]; i++) {\n        VIR_FREE(def->os.initenv[i]->name);\n        VIR_FREE(def->os.initenv[i]->value);\n        VIR_FREE(def->os.initenv[i]);\n    }\n    VIR_FREE(def->os.initdir);\n    VIR_FREE(def->os.inituser);\n    VIR_FREE(def->os.initgroup);\n    VIR_FREE(def->os.initenv);\n    VIR_FREE(def->os.kernel);\n    VIR_FREE(def->os.initrd);\n    VIR_FREE(def->os.cmdline);\n    VIR_FREE(def->os.dtb);\n    VIR_FREE(def->os.root);\n    VIR_FREE(def->os.slic_table);\n    virDomainLoaderDefFree(def->os.loader);\n    VIR_FREE(def->os.bootloader);\n    VIR_FREE(def->os.bootloaderArgs);\n\n    virDomainClockDefClear(&def->clock);\n\n    VIR_FREE(def->name);\n    virBitmapFree(def->cpumask);\n    VIR_FREE(def->emulator);\n    VIR_FREE(def->description);\n    VIR_FREE(def->title);\n    VIR_FREE(def->hyperv_vendor_id);\n\n    virBlkioDeviceArrayClear(def->blkio.devices,\n                             def->blkio.ndevices);\n    VIR_FREE(def->blkio.devices);\n\n    virDomainWatchdogDefFree(def->watchdog);\n\n    virDomainMemballoonDefFree(def->memballoon);\n    virDomainNVRAMDefFree(def->nvram);\n    virDomainVsockDefFree(def->vsock);\n\n    for (i = 0; i < def->mem.nhugepages; i++)\n        virBitmapFree(def->mem.hugepages[i].nodemask);\n    VIR_FREE(def->mem.hugepages);\n\n    for (i = 0; i < def->nseclabels; i++)\n        virSecurityLabelDefFree(def->seclabels[i]);\n    VIR_FREE(def->seclabels);\n\n    virCPUDefFree(def->cpu);\n\n    virDomainIOThreadIDDefArrayFree(def->iothreadids, def->niothreadids);\n\n    virBitmapFree(def->cputune.emulatorpin);\n    VIR_FREE(def->cputune.emulatorsched);\n\n    virDomainNumaFree(def->numa);\n\n    virSysinfoDefFree(def->sysinfo);\n\n    virDomainRedirFilterDefFree(def->redirfilter);\n\n    for (i = 0; i < def->nshmems; i++)\n        virDomainShmemDefFree(def->shmems[i]);\n    VIR_FREE(def->shmems);\n\n    for (i = 0; i < def->nresctrls; i++)\n        virDomainResctrlDefFree(def->resctrls[i]);\n    VIR_FREE(def->resctrls);\n\n    VIR_FREE(def->keywrap);\n\n    if (def->namespaceData && def->ns.free)\n        (def->ns.free)(def->namespaceData);\n\n    virDomainSEVDefFree(def->sev);\n\n    xmlFreeNode(def->metadata);\n\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vmx"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data.datastorePathWithoutFileName"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "url"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryName"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreName"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "moref"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 2657
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormat",
          "args": [
            "def",
            "priv->xmlopt",
            "virDomainDefFormatConvertXMLFlags(flags)"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29496-29508",
          "snippet": "char *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\n#define VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS \\\n    (VIR_DOMAIN_DEF_FORMAT_SECURE | \\\n     VIR_DOMAIN_DEF_FORMAT_INACTIVE | \\\n     VIR_DOMAIN_DEF_FORMAT_MIGRATABLE)\n\nchar *\nvirDomainDefFormat(virDomainDefPtr def,\n                   virDomainXMLOptionPtr xmlopt,\n                   unsigned int flags)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virCheckFlags(VIR_DOMAIN_DEF_FORMAT_COMMON_FLAGS, NULL);\n    if (virDomainDefFormatInternal(def, xmlopt, &buf, flags) < 0)\n        return NULL;\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefFormatConvertXMLFlags",
          "args": [
            "flags"
          ],
          "line": 2652
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefFormatConvertXMLFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29481-29493",
          "snippet": "unsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nunsigned int virDomainDefFormatConvertXMLFlags(unsigned int flags)\n{\n    unsigned int formatFlags = 0;\n\n    if (flags & VIR_DOMAIN_XML_SECURE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_SECURE;\n    if (flags & VIR_DOMAIN_XML_INACTIVE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_INACTIVE;\n    if (flags & VIR_DOMAIN_XML_MIGRATABLE)\n        formatFlags |= VIR_DOMAIN_DEF_FORMAT_MIGRATABLE;\n\n    return formatFlags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXParseConfig",
          "args": [
            "&ctx",
            "priv->xmlopt",
            "priv->caps",
            "vmx"
          ],
          "line": 2645
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXParseConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "1275-1867",
          "snippet": "virDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirDomainDefPtr\nvirVMXParseConfig(virVMXContext *ctx,\n                  virDomainXMLOptionPtr xmlopt,\n                  virCapsPtr caps G_GNUC_UNUSED,\n                  const char *vmx)\n{\n    bool success = false;\n    g_autoptr(virConf) conf = NULL;\n    char *encoding = NULL;\n    char *utf8;\n    virDomainDefPtr def = NULL;\n    long long config_version = 0;\n    long long virtualHW_version = 0;\n    long long memsize = 0;\n    long long sched_mem_max = 0;\n    long long sched_mem_minsize = 0;\n    long long numvcpus = 0;\n    char *sched_cpu_affinity = NULL;\n    char *sched_cpu_shares = NULL;\n    char *guestOS = NULL;\n    bool smbios_reflecthost = false;\n    int controller;\n    int bus;\n    int port;\n    bool present;\n    int scsi_virtualDev[4] = { -1, -1, -1, -1 };\n    int unit;\n    bool hgfs_disabled = true;\n    long long sharedFolder_maxNum = 0;\n    struct virVMXConfigScanResults results = { -1 };\n    long long coresPerSocket = 0;\n    virCPUDefPtr cpu = NULL;\n    char *firmware = NULL;\n\n    if (ctx->parseFileName == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virVMXContext has no parseFileName function set\"));\n        return NULL;\n    }\n\n    conf = virConfReadString(vmx, VIR_CONF_FLAG_VMX_FORMAT);\n\n    if (conf == NULL)\n        return NULL;\n\n    /* vmx:.encoding */\n    if (virVMXGetConfigString(conf, \".encoding\", &encoding, true) < 0)\n        goto cleanup;\n\n    if (encoding == NULL || STRCASEEQ(encoding, \"UTF-8\")) {\n        /* nothing */\n    } else {\n        virConfFree(conf);\n        conf = NULL;\n\n        utf8 = virVMXConvertToUTF8(encoding, vmx);\n\n        if (utf8 == NULL)\n            goto cleanup;\n\n        conf = virConfReadString(utf8, VIR_CONF_FLAG_VMX_FORMAT);\n\n        VIR_FREE(utf8);\n\n        if (conf == NULL)\n            goto cleanup;\n    }\n\n    if (virConfWalk(conf, virVMXConfigScanResultsCollector, &results) < 0)\n        goto cleanup;\n\n    /* Allocate domain def */\n    if (!(def = virDomainDefNew()))\n        goto cleanup;\n\n    def->virtType = VIR_DOMAIN_VIRT_VMWARE;\n    def->id = -1;\n\n    /* vmx:config.version */\n    if (virVMXGetConfigLong(conf, \"config.version\", &config_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (config_version != 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'config.version' to be 8 but found \"\n                         \"%lld\"), config_version);\n        goto cleanup;\n    }\n\n    /* vmx:virtualHW.version */\n    if (virVMXGetConfigLong(conf, \"virtualHW.version\", &virtualHW_version, 0,\n                            false) < 0) {\n        goto cleanup;\n    }\n\n    if (virtualHW_version < 4) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'virtualHW.version' to be \"\n                         \"4 or higher but found %lld\"),\n                       virtualHW_version);\n        goto cleanup;\n    }\n\n    /* vmx:uuid.bios -> def:uuid */\n    /* FIXME: Need to handle 'uuid.action = \"create\"' */\n    if (virVMXGetConfigUUID(conf, \"uuid.bios\", def->uuid, true) < 0)\n        goto cleanup;\n\n    /* vmx:displayName -> def:name */\n    if (virVMXGetConfigString(conf, \"displayName\", &def->name, true) < 0)\n        goto cleanup;\n\n    if (def->name != NULL) {\n        if (virVMXUnescapeHexPercent(def->name) < 0 ||\n            virVMXUnescapeHexPipe(def->name) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'name' contains invalid escape sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:annotation -> def:description */\n    if (virVMXGetConfigString(conf, \"annotation\", &def->description,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (def->description != NULL) {\n        if (virVMXUnescapeHexPipe(def->description) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'annotation' contains invalid escape \"\n                             \"sequence\"));\n            goto cleanup;\n        }\n    }\n\n    /* vmx:memsize -> def:mem.max_balloon */\n    if (virVMXGetConfigLong(conf, \"memsize\", &memsize, 32, true) < 0)\n        goto cleanup;\n\n    if (memsize <= 0 || memsize % 4 != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'memsize' to be an unsigned \"\n                         \"integer (multiple of 4) but found %lld\"), memsize);\n        goto cleanup;\n    }\n\n    virDomainDefSetMemoryTotal(def, memsize * 1024); /* Scale from megabytes to kilobytes */\n\n    /* vmx:sched.mem.max -> def:mem.cur_balloon */\n    if (virVMXGetConfigLong(conf, \"sched.mem.max\", &sched_mem_max, memsize,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_max < 0)\n        sched_mem_max = memsize;\n\n    def->mem.cur_balloon = sched_mem_max * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.cur_balloon > virDomainDefGetMemoryTotal(def))\n        def->mem.cur_balloon = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:sched.mem.minsize -> def:mem.min_guarantee */\n    if (virVMXGetConfigLong(conf, \"sched.mem.minsize\", &sched_mem_minsize, 0,\n                            true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_mem_minsize < 0)\n        sched_mem_minsize = 0;\n\n    def->mem.min_guarantee = sched_mem_minsize * 1024; /* Scale from megabytes to kilobytes */\n\n    if (def->mem.min_guarantee > virDomainDefGetMemoryTotal(def))\n        def->mem.min_guarantee = virDomainDefGetMemoryTotal(def);\n\n    /* vmx:numvcpus -> def:vcpus */\n    if (virVMXGetConfigLong(conf, \"numvcpus\", &numvcpus, 1, true) < 0)\n        goto cleanup;\n\n    if (numvcpus <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting VMX entry 'numvcpus' to be an unsigned \"\n                         \"integer greater than 0 but found %lld\"), numvcpus);\n        goto cleanup;\n    }\n\n    if (virDomainDefSetVcpusMax(def, numvcpus, xmlopt) < 0)\n        goto cleanup;\n\n    if (virDomainDefSetVcpus(def, numvcpus) < 0)\n        goto cleanup;\n\n    /* vmx:cpuid.coresPerSocket -> def:cpu */\n    if (virVMXGetConfigLong(conf, \"cpuid.coresPerSocket\", &coresPerSocket, 1,\n                            true) < 0)\n        goto cleanup;\n\n    if (coresPerSocket > 1) {\n        cpu = virCPUDefNew();\n\n        cpu->type = VIR_CPU_TYPE_GUEST;\n        cpu->mode = VIR_CPU_MODE_CUSTOM;\n\n        cpu->sockets = numvcpus / coresPerSocket;\n        if (cpu->sockets <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"VMX entry 'cpuid.coresPerSocket' smaller than \"\n                             \"'numvcpus'\"));\n            goto cleanup;\n        }\n        cpu->dies = 1;\n        cpu->cores = coresPerSocket;\n        cpu->threads = 1;\n\n        def->cpu = g_steal_pointer(&cpu);\n    }\n\n    /* vmx:sched.cpu.affinity -> def:cpumask */\n    /* NOTE: maps to VirtualMachine:config.cpuAffinity.affinitySet */\n    if (virVMXGetConfigString(conf, \"sched.cpu.affinity\", &sched_cpu_affinity,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_affinity != NULL && STRCASENEQ(sched_cpu_affinity, \"all\")) {\n        VIR_AUTOSTRINGLIST afflist = NULL;\n        char **aff;\n        size_t naffs;\n\n        def->cpumask = virBitmapNew(VIR_DOMAIN_CPUMASK_LEN);\n        if (!def->cpumask)\n            goto cleanup;\n\n        if (!(afflist = virStringSplitCount(sched_cpu_affinity, \",\", 0, &naffs)))\n            goto cleanup;\n\n        if (naffs < numvcpus) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.affinity' to contain \"\n                             \"at least as many values as 'numvcpus' (%lld) but \"\n                             \"found only %zu value(s)\"), numvcpus, naffs);\n            goto cleanup;\n        }\n\n        for (aff = afflist; *aff; aff++) {\n            const char *current = *aff;\n            unsigned int number;\n            int rc;\n\n            virSkipSpaces(&current);\n            rc = virStrToLong_uip(current, (char **) &current, 10, &number);\n            virSkipSpaces(&current);\n\n            if (rc < 0 || *current != '\\0') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Expecting VMX entry 'sched.cpu.affinity' to be \"\n                                 \"a comma separated list of unsigned integers but \"\n                                 \"found '%s'\"), sched_cpu_affinity);\n                goto cleanup;\n            }\n\n            if (number >= VIR_DOMAIN_CPUMASK_LEN) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"VMX entry 'sched.cpu.affinity' contains a %d, \"\n                                 \"this value is too large\"), number);\n                goto cleanup;\n            }\n\n            ignore_value(virBitmapSetBit(def->cpumask, number));\n        }\n    }\n\n    /* vmx:sched.cpu.shares -> def:cputune.shares */\n    if (virVMXGetConfigString(conf, \"sched.cpu.shares\", &sched_cpu_shares,\n                              true) < 0) {\n        goto cleanup;\n    }\n\n    if (sched_cpu_shares != NULL) {\n        unsigned int vcpus = virDomainDefGetVcpus(def);\n        /* See http://www.vmware.com/support/developer/vc-sdk/visdk41pubs/ApiReference/vim.SharesInfo.Level.html */\n        if (STRCASEEQ(sched_cpu_shares, \"low\")) {\n            def->cputune.shares = vcpus * 500;\n        } else if (STRCASEEQ(sched_cpu_shares, \"normal\")) {\n            def->cputune.shares = vcpus * 1000;\n        } else if (STRCASEEQ(sched_cpu_shares, \"high\")) {\n            def->cputune.shares = vcpus * 2000;\n        } else if (virStrToLong_ull(sched_cpu_shares, NULL, 10,\n                                    &def->cputune.shares) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Expecting VMX entry 'sched.cpu.shares' to be an \"\n                             \"unsigned integer or 'low', 'normal' or 'high' but \"\n                             \"found '%s'\"), sched_cpu_shares);\n            goto cleanup;\n        }\n        def->cputune.sharesSpecified = true;\n    }\n\n    /* def:lifecycle */\n    def->onReboot = VIR_DOMAIN_LIFECYCLE_ACTION_RESTART;\n    def->onPoweroff = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n    def->onCrash = VIR_DOMAIN_LIFECYCLE_ACTION_DESTROY;\n\n    /* def:os */\n    def->os.type = VIR_DOMAIN_OSTYPE_HVM;\n\n    /* vmx:guestOS -> def:os.arch */\n    if (virVMXGetConfigString(conf, \"guestOS\", &guestOS, true) < 0)\n        goto cleanup;\n\n    if (guestOS != NULL && virStringHasSuffix(guestOS, \"-64\")) {\n        def->os.arch = VIR_ARCH_X86_64;\n    } else {\n        def->os.arch = VIR_ARCH_I686;\n    }\n\n    /* vmx:smbios.reflecthost -> def:os.smbios_mode */\n    if (virVMXGetConfigBoolean(conf, \"smbios.reflecthost\",\n                               &smbios_reflecthost, false, true) < 0) {\n        goto cleanup;\n    }\n\n    if (smbios_reflecthost)\n        def->os.smbios_mode = VIR_DOMAIN_SMBIOS_HOST;\n\n    /* def:features */\n    /* FIXME */\n\n    /* def:clock */\n    /* FIXME */\n\n    /* def:graphics */\n    if (VIR_ALLOC_N(def->graphics, 1) < 0)\n        goto cleanup;\n\n    def->ngraphics = 0;\n\n    if (virVMXParseVNC(conf, &def->graphics[def->ngraphics]) < 0)\n        goto cleanup;\n\n    if (def->graphics[def->ngraphics] != NULL)\n        ++def->ngraphics;\n\n    /* def:disks: 4 * 15 scsi + 2 * 2 ide + 2 floppy = 66 */\n    if (VIR_ALLOC_N(def->disks, 66) < 0)\n        goto cleanup;\n\n    def->ndisks = 0;\n\n    /* def:disks (scsi) */\n    for (controller = 0; controller < 4; ++controller) {\n        if (virVMXParseSCSIController(conf, controller, &present,\n                                      &scsi_virtualDev[controller]) < 0) {\n            goto cleanup;\n        }\n\n        if (! present)\n            continue;\n\n        for (unit = 0; unit < 16; ++unit) {\n            if (unit == 7) {\n                /*\n                 * SCSI unit 7 is assigned to the SCSI controller and cannot be\n                 * used for disk devices.\n                 */\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                 VIR_DOMAIN_DISK_BUS_SCSI, controller, unit,\n                                 &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n\n    }\n\n    /* add all the SCSI controllers we've seen, up until the last one that is\n     * currently used by a disk */\n    if (def->ndisks != 0) {\n        virDomainDeviceInfoPtr info = &def->disks[def->ndisks - 1]->info;\n        for (controller = 0; controller <= info->addr.drive.controller; controller++) {\n            if (!virDomainDefAddController(def, VIR_DOMAIN_CONTROLLER_TYPE_SCSI,\n                                           controller, scsi_virtualDev[controller]))\n                goto cleanup;\n        }\n    }\n\n    /* def:disks (ide) */\n    for (bus = 0; bus < 2; ++bus) {\n        for (unit = 0; unit < 2; ++unit) {\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_DISK,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL) {\n                ++def->ndisks;\n                continue;\n            }\n\n            if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_CDROM,\n                                VIR_DOMAIN_DISK_BUS_IDE, bus, unit,\n                                &def->disks[def->ndisks], def) < 0) {\n                goto cleanup;\n            }\n\n            if (def->disks[def->ndisks] != NULL)\n                ++def->ndisks;\n        }\n    }\n\n    /* def:disks (floppy) */\n    for (unit = 0; unit < 2; ++unit) {\n        if (virVMXParseDisk(ctx, xmlopt, conf, VIR_DOMAIN_DISK_DEVICE_FLOPPY,\n                            VIR_DOMAIN_DISK_BUS_FDC, 0, unit,\n                            &def->disks[def->ndisks], def) < 0) {\n            goto cleanup;\n        }\n\n        if (def->disks[def->ndisks] != NULL)\n            ++def->ndisks;\n    }\n\n    /* def:fss */\n    if (virVMXGetConfigBoolean(conf, \"isolation.tools.hgfs.disable\",\n                               &hgfs_disabled, true, true) < 0) {\n        goto cleanup;\n    }\n\n    if (!hgfs_disabled) {\n        if (virVMXGetConfigLong(conf, \"sharedFolder.maxNum\", &sharedFolder_maxNum,\n                                0, true) < 0) {\n            goto cleanup;\n        }\n\n        if (sharedFolder_maxNum > 0) {\n            int number;\n\n            if (VIR_ALLOC_N(def->fss, sharedFolder_maxNum) < 0)\n                goto cleanup;\n\n            def->nfss = 0;\n\n            for (number = 0; number < sharedFolder_maxNum; ++number) {\n                if (virVMXParseFileSystem(conf, number,\n                                          &def->fss[def->nfss]) < 0) {\n                    goto cleanup;\n                }\n\n                if (def->fss[def->nfss] != NULL)\n                    ++def->nfss;\n            }\n        }\n    }\n\n    /* def:nets */\n    for (controller = 0; controller <= results.networks_max_index; ++controller) {\n        virDomainNetDefPtr net = NULL;\n        if (virVMXParseEthernet(conf, controller, &net) < 0)\n            goto cleanup;\n\n        if (!net)\n            continue;\n\n        if (VIR_APPEND_ELEMENT(def->nets, def->nnets, net) < 0)\n            goto cleanup;\n    }\n\n    /* def:inputs */\n    /* FIXME */\n\n    /* def:videos */\n    if (VIR_ALLOC_N(def->videos, 1) < 0)\n        goto cleanup;\n\n    def->nvideos = 0;\n\n    if (virVMXParseSVGA(conf, &def->videos[def->nvideos]) < 0)\n        goto cleanup;\n\n    def->nvideos = 1;\n\n    /* def:sounds */\n    /* FIXME */\n\n    /* def:hostdevs */\n    /* FIXME */\n\n    /* def:serials */\n    if (VIR_ALLOC_N(def->serials, 4) < 0)\n        goto cleanup;\n\n    def->nserials = 0;\n\n    for (port = 0; port < 4; ++port) {\n        if (virVMXParseSerial(ctx, conf, port,\n                              &def->serials[def->nserials]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->serials[def->nserials] != NULL)\n            ++def->nserials;\n    }\n\n    /* def:parallels */\n    if (VIR_ALLOC_N(def->parallels, 3) < 0)\n        goto cleanup;\n\n    def->nparallels = 0;\n\n    for (port = 0; port < 3; ++port) {\n        if (virVMXParseParallel(ctx, conf, port,\n                                &def->parallels[def->nparallels]) < 0) {\n            goto cleanup;\n        }\n\n        if (def->parallels[def->nparallels] != NULL)\n            ++def->nparallels;\n    }\n\n    /* ctx:datacenterPath -> def:namespaceData */\n    if (ctx->datacenterPath || ctx->moref) {\n        struct virVMXDomainDefNamespaceData *nsdata = NULL;\n\n        if (VIR_ALLOC(nsdata) < 0) {\n            virVMXDomainDefNamespaceFree(nsdata);\n            goto cleanup;\n        }\n\n        nsdata->datacenterPath = g_strdup(ctx->datacenterPath);\n\n        nsdata->moref = g_strdup(ctx->moref);\n\n        def->ns = *virDomainXMLOptionGetNamespace(xmlopt);\n        def->namespaceData = nsdata;\n    }\n\n    /* vmx:firmware */\n    if (virVMXGetConfigString(conf, \"firmware\", &firmware, true) < 0)\n        goto cleanup;\n\n    if (firmware != NULL) {\n        if (STREQ(firmware, \"efi\")) {\n            def->os.firmware = VIR_DOMAIN_OS_DEF_FIRMWARE_EFI;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"VMX entry 'firmware' has unknown value '%s'\"),\n                           firmware);\n            goto cleanup;\n        }\n    }\n\n    if (virDomainDefPostParse(def, VIR_DOMAIN_DEF_PARSE_ABI_UPDATE,\n                              xmlopt, NULL) < 0)\n        goto cleanup;\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virDomainDefFree(def);\n        def = NULL;\n    }\n\n    VIR_FREE(encoding);\n    VIR_FREE(sched_cpu_affinity);\n    VIR_FREE(sched_cpu_shares);\n    VIR_FREE(guestOS);\n    virCPUDefFree(cpu);\n    VIR_FREE(firmware);\n\n    return def;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%s] %s\"",
            "datastoreName",
            "directoryName"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_CURL_Download",
          "args": [
            "priv->primary->curl",
            "url",
            "&vmx",
            "0",
            "NULL"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_CURL_Download",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "368-430",
          "snippet": "int\nesxVI_CURL_Download(esxVI_CURL *curl, const char *url, char **content,\n                    unsigned long long offset, unsigned long long *length)\n{\n    char *range = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    int responseCode = 0;\n\n    ESX_VI_CHECK_ARG_LIST(content);\n\n    if (length && *length > 0) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download is meant to download\n         * small things such as VMX of VMDK metadata files.\n         */\n        if (*length > INT32_MAX / 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Download length it too large\"));\n            return -1;\n        }\n\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + *length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, range);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPGET, 1);\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        goto cleanup;\n    } else if (responseCode != 200 && responseCode != 206) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for download from '%s'\"),\n                       responseCode, url);\n        goto cleanup;\n    }\n\n    if (length)\n        *length = virBufferUse(&buffer);\n\n    *content = virBufferContentAndReset(&buffer);\n\n cleanup:\n    VIR_FREE(range);\n\n    if (!(*content)) {\n        virBufferFreeAndReset(&buffer);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_CURL_Download(esxVI_CURL *curl, const char *url, char **content,\n                    unsigned long long offset, unsigned long long *length)\n{\n    char *range = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    int responseCode = 0;\n\n    ESX_VI_CHECK_ARG_LIST(content);\n\n    if (length && *length > 0) {\n        /*\n         * Using a virBuffer to store the download data limits the downloadable\n         * size. This is no problem as esxVI_CURL_Download is meant to download\n         * small things such as VMX of VMDK metadata files.\n         */\n        if (*length > INT32_MAX / 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Download length it too large\"));\n            return -1;\n        }\n\n        range = g_strdup_printf(\"%llu-%llu\", offset, offset + *length - 1);\n    } else if (offset > 0) {\n        range = g_strdup_printf(\"%llu-\", offset);\n    }\n\n    virMutexLock(&curl->lock);\n\n    curl_easy_setopt(curl->handle, CURLOPT_URL, url);\n    curl_easy_setopt(curl->handle, CURLOPT_RANGE, range);\n    curl_easy_setopt(curl->handle, CURLOPT_WRITEDATA, &buffer);\n    curl_easy_setopt(curl->handle, CURLOPT_UPLOAD, 0);\n    curl_easy_setopt(curl->handle, CURLOPT_HTTPGET, 1);\n\n    responseCode = esxVI_CURL_Perform(curl, url);\n\n    virMutexUnlock(&curl->lock);\n\n    if (responseCode < 0) {\n        goto cleanup;\n    } else if (responseCode != 200 && responseCode != 206) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"HTTP response code %d for download from '%s'\"),\n                       responseCode, url);\n        goto cleanup;\n    }\n\n    if (length)\n        *length = virBufferUse(&buffer);\n\n    *content = virBufferContentAndReset(&buffer);\n\n cleanup:\n    VIR_FREE(range);\n\n    if (!(*content)) {\n        virBufferFreeAndReset(&buffer);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferURIEncodeString",
          "args": [
            "&buffer",
            "datastoreName"
          ],
          "line": 2622
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferURIEncodeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "534-544",
          "snippet": "void\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"&dsName=\""
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "&buffer",
            "\"?dcPath=\""
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buffer",
            "\"%s://%s:%d/folder/\"",
            "priv->parsedUri->transport",
            "domain->conn->uri->server",
            "domain->conn->uri->port"
          ],
          "line": 2616
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "vmPathName",
            "&datastoreName",
            "&directoryName",
            "&directoryAndFileName"
          ],
          "line": 2611
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "virtualMachine",
            "\"config.files.vmPathName\"",
            "&vmPathName",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2606
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id",
            "NULL",
            "NULL"
          ],
          "line": 2605
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 2604
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineMORef",
          "args": [
            "virtualMachine",
            "&moref"
          ],
          "line": 2603
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineMORef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2214-2227",
          "snippet": "int\nesxVI_GetVirtualMachineMORef(esxVI_ObjectContent *virtualMachine,\n                             char **moref)\n{\n    for (; virtualMachine != NULL; virtualMachine = virtualMachine->_next) {\n        if (virtualMachine->obj &&\n            STREQ(virtualMachine->obj->type, \"VirtualMachine\") &&\n            virtualMachine->obj->value) {\n            *moref = g_strdup(virtualMachine->obj->value);\n            return 0;\n        }\n    }\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineMORef(esxVI_ObjectContent *virtualMachine,\n                             char **moref)\n{\n    for (; virtualMachine != NULL; virtualMachine = virtualMachine->_next) {\n        if (virtualMachine->obj &&\n            STREQ(virtualMachine->obj->type, \"VirtualMachine\") &&\n            virtualMachine->obj->value) {\n            *moref = g_strdup(virtualMachine->obj->value);\n            return 0;\n        }\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2600
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"config.files.vmPathName\\0\"\n                                           \"runtime.powerState\\0\""
          ],
          "line": 2597
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2594
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 2592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_XML_COMMON_FLAGS",
            "NULL"
          ],
          "line": 2590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic char *\nesxDomainGetXMLDesc(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id;\n    char *moref = NULL;\n    char *vmPathName = NULL;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n    char *vmx = NULL;\n    virVMXContext ctx;\n    esxVMX_Data data;\n    virDomainDefPtr def = NULL;\n    char *xml = NULL;\n\n    virCheckFlags(VIR_DOMAIN_XML_COMMON_FLAGS, NULL);\n\n    memset(&data, 0, sizeof(data));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"config.files.vmPathName\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineMORef(virtualMachine, &moref) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, NULL) < 0 ||\n        esxVI_GetStringValue(virtualMachine, \"config.files.vmPathName\",\n                             &vmPathName, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxUtil_ParseDatastorePath(vmPathName, &datastoreName, &directoryName,\n                                   &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    virBufferAsprintf(&buffer, \"%s://%s:%d/folder/\", priv->parsedUri->transport,\n                      domain->conn->uri->server, domain->conn->uri->port);\n    virBufferURIEncodeString(&buffer, directoryAndFileName);\n    virBufferAddLit(&buffer, \"?dcPath=\");\n    virBufferURIEncodeString(&buffer, priv->primary->datacenterPath);\n    virBufferAddLit(&buffer, \"&dsName=\");\n    virBufferURIEncodeString(&buffer, datastoreName);\n\n    url = virBufferContentAndReset(&buffer);\n\n    if (esxVI_CURL_Download(priv->primary->curl, url, &vmx, 0, NULL) < 0)\n        goto cleanup;\n\n    data.ctx = priv->primary;\n\n    if (!directoryName) {\n        data.datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n    } else {\n        data.datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\",\n                                                            datastoreName, directoryName);\n    }\n\n    ctx.opaque = &data;\n    ctx.parseFileName = esxParseVMXFileName;\n    ctx.formatFileName = NULL;\n    ctx.autodetectSCSIControllerModel = NULL;\n    ctx.datacenterPath = priv->primary->datacenterPath;\n    ctx.moref = moref;\n\n    def = virVMXParseConfig(&ctx, priv->xmlopt, priv->caps, vmx);\n\n    if (def) {\n        if (powerState != esxVI_VirtualMachinePowerState_PoweredOff)\n            def->id = id;\n\n        xml = virDomainDefFormat(def, priv->xmlopt,\n                                 virDomainDefFormatConvertXMLFlags(flags));\n    }\n\n cleanup:\n    if (!url)\n        virBufferFreeAndReset(&buffer);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    VIR_FREE(moref);\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(url);\n    VIR_FREE(data.datastorePathWithoutFileName);\n    VIR_FREE(vmx);\n    virDomainDefFree(def);\n\n    return xml;\n}"
  },
  {
    "function_name": "esxDomainGetMaxVcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2560-2565",
    "snippet": "static int\nesxDomainGetMaxVcpus(virDomainPtr domain)\n{\n    return esxDomainGetVcpusFlags(domain, (VIR_DOMAIN_AFFECT_LIVE |\n                                           VIR_DOMAIN_VCPU_MAXIMUM));\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainGetVcpusFlags",
          "args": [
            "domain",
            "(VIR_DOMAIN_AFFECT_LIVE |\n                                           VIR_DOMAIN_VCPU_MAXIMUM)"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainGetVcpusFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "2510-2556",
          "snippet": "static int\nesxDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_VCPU_MAXIMUM, -1);\n\n    if (priv->maxVcpus > 0)\n        return priv->maxVcpus;\n\n    priv->maxVcpus = -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.maxSupportedVcpus\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"capability.maxSupportedVcpus\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            priv->maxVcpus = dynamicProperty->val->int32;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->maxVcpus;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_VCPU_MAXIMUM, -1);\n\n    if (priv->maxVcpus > 0)\n        return priv->maxVcpus;\n\n    priv->maxVcpus = -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.maxSupportedVcpus\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"capability.maxSupportedVcpus\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            priv->maxVcpus = dynamicProperty->val->int32;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->maxVcpus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetMaxVcpus(virDomainPtr domain)\n{\n    return esxDomainGetVcpusFlags(domain, (VIR_DOMAIN_AFFECT_LIVE |\n                                           VIR_DOMAIN_VCPU_MAXIMUM));\n}"
  },
  {
    "function_name": "esxDomainGetVcpusFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2510-2556",
    "snippet": "static int\nesxDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_VCPU_MAXIMUM, -1);\n\n    if (priv->maxVcpus > 0)\n        return priv->maxVcpus;\n\n    priv->maxVcpus = -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.maxSupportedVcpus\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"capability.maxSupportedVcpus\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            priv->maxVcpus = dynamicProperty->val->int32;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->maxVcpus;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Int"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"capability.maxSupportedVcpus\""
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"capability.maxSupportedVcpus\""
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2526
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_VCPU_MAXIMUM",
            "-1"
          ],
          "line": 2518
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetVcpusFlags(virDomainPtr domain, unsigned int flags)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE |\n                  VIR_DOMAIN_VCPU_MAXIMUM, -1);\n\n    if (priv->maxVcpus > 0)\n        return priv->maxVcpus;\n\n    priv->maxVcpus = -1;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.maxSupportedVcpus\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"capability.maxSupportedVcpus\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            priv->maxVcpus = dynamicProperty->val->int32;\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->maxVcpus;\n}"
  },
  {
    "function_name": "esxDomainSetVcpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2502-2506",
    "snippet": "static int\nesxDomainSetVcpus(virDomainPtr domain, unsigned int nvcpus)\n{\n    return esxDomainSetVcpusFlags(domain, nvcpus, VIR_DOMAIN_AFFECT_LIVE);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainSetVcpusFlags",
          "args": [
            "domain",
            "nvcpus",
            "VIR_DOMAIN_AFFECT_LIVE"
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainSetVcpusFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "2426-2498",
          "snippet": "static int\nesxDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    int maxVcpus;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    if (nvcpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Requested number of virtual CPUs must at least be 1\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    maxVcpus = esxDomainGetMaxVcpus(domain);\n\n    if (maxVcpus < 0)\n        return -1;\n\n    if (nvcpus > maxVcpus) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Requested number of virtual CPUs is greater than max \"\n                         \"allowable number of virtual CPUs for the domain: %d > %d\"),\n                       nvcpus, maxVcpus);\n        return -1;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Int_Alloc(&spec->numCPUs) < 0) {\n        goto cleanup;\n    }\n\n    spec->numCPUs->value = nvcpus;\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set number of virtual CPUs to %d: %s\"), nvcpus,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    int maxVcpus;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    if (nvcpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Requested number of virtual CPUs must at least be 1\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    maxVcpus = esxDomainGetMaxVcpus(domain);\n\n    if (maxVcpus < 0)\n        return -1;\n\n    if (nvcpus > maxVcpus) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Requested number of virtual CPUs is greater than max \"\n                         \"allowable number of virtual CPUs for the domain: %d > %d\"),\n                       nvcpus, maxVcpus);\n        return -1;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Int_Alloc(&spec->numCPUs) < 0) {\n        goto cleanup;\n    }\n\n    spec->numCPUs->value = nvcpus;\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set number of virtual CPUs to %d: %s\"), nvcpus,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetVcpus(virDomainPtr domain, unsigned int nvcpus)\n{\n    return esxDomainSetVcpusFlags(domain, nvcpus, VIR_DOMAIN_AFFECT_LIVE);\n}"
  },
  {
    "function_name": "esxDomainSetVcpusFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2426-2498",
    "snippet": "static int\nesxDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    int maxVcpus;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    if (nvcpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Requested number of virtual CPUs must at least be 1\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    maxVcpus = esxDomainGetMaxVcpus(domain);\n\n    if (maxVcpus < 0)\n        return -1;\n\n    if (nvcpus > maxVcpus) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Requested number of virtual CPUs is greater than max \"\n                         \"allowable number of virtual CPUs for the domain: %d > %d\"),\n                       nvcpus, maxVcpus);\n        return -1;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Int_Alloc(&spec->numCPUs) < 0) {\n        goto cleanup;\n    }\n\n    spec->numCPUs->value = nvcpus;\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set number of virtual CPUs to %d: %s\"), nvcpus,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 2495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Free",
          "args": [
            "&spec"
          ],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not set number of virtual CPUs to %d: %s\")",
            "nvcpus",
            "taskInfoErrorMessage"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not set number of virtual CPUs to %d: %s\""
          ],
          "line": 2484
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 2475
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "spec",
            "&task"
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&spec->numCPUs"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Alloc",
          "args": [
            "&spec"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "_(\"Requested number of virtual CPUs is greater than max \"\n                         \"allowable number of virtual CPUs for the domain: %d > %d\")",
            "nvcpus",
            "maxVcpus"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxDomainGetMaxVcpus",
          "args": [
            "domain"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainGetMaxVcpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "2560-2565",
          "snippet": "static int\nesxDomainGetMaxVcpus(virDomainPtr domain)\n{\n    return esxDomainGetVcpusFlags(domain, (VIR_DOMAIN_AFFECT_LIVE |\n                                           VIR_DOMAIN_VCPU_MAXIMUM));\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetMaxVcpus(virDomainPtr domain)\n{\n    return esxDomainGetVcpusFlags(domain, (VIR_DOMAIN_AFFECT_LIVE |\n                                           VIR_DOMAIN_VCPU_MAXIMUM));\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Requested number of virtual CPUs must at least be 1\")"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_DOMAIN_AFFECT_LIVE",
            "-1"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetVcpusFlags(virDomainPtr domain, unsigned int nvcpus,\n                       unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    int maxVcpus;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(VIR_DOMAIN_AFFECT_LIVE, -1);\n\n    if (nvcpus < 1) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Requested number of virtual CPUs must at least be 1\"));\n        return -1;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    maxVcpus = esxDomainGetMaxVcpus(domain);\n\n    if (maxVcpus < 0)\n        return -1;\n\n    if (nvcpus > maxVcpus) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Requested number of virtual CPUs is greater than max \"\n                         \"allowable number of virtual CPUs for the domain: %d > %d\"),\n                       nvcpus, maxVcpus);\n        return -1;\n    }\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Int_Alloc(&spec->numCPUs) < 0) {\n        goto cleanup;\n    }\n\n    spec->numCPUs->value = nvcpus;\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set number of virtual CPUs to %d: %s\"), nvcpus,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainScreenshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2352-2422",
    "snippet": "static char *\nesxDomainScreenshot(virDomainPtr domain, virStreamPtr stream,\n                    unsigned int screen, unsigned int flags)\n{\n    char *mimeType = NULL;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Boolean supportsScreenshot = esxVI_Boolean_Undefined;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (screen != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Screen cannot be selected\"));\n        return NULL;\n    }\n\n    supportsScreenshot = esxSupportsScreenshot(priv);\n\n    if (supportsScreenshot == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsScreenshot != esxVI_Boolean_True) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Screenshot feature is unsupported\"));\n        return NULL;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0)\n        goto cleanup;\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    /* Build URL */\n    virBufferAsprintf(&buffer, \"%s://%s:%d/screen?id=\", priv->parsedUri->transport,\n                      domain->conn->uri->server, domain->conn->uri->port);\n    virBufferURIEncodeString(&buffer, virtualMachine->obj->value);\n\n    url = virBufferContentAndReset(&buffer);\n\n    mimeType = g_strdup(\"image/png\");\n\n    if (esxStreamOpenDownload(stream, priv, url, 0, 0) < 0) {\n        VIR_FREE(mimeType);\n        goto cleanup;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buffer);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return mimeType;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mimeType"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxStreamOpenDownload",
          "args": [
            "stream",
            "priv",
            "url",
            "0",
            "0"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "esxStreamOpenDownload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_stream.c",
          "lines": "484-489",
          "snippet": "int\nesxStreamOpenDownload(virStreamPtr stream, esxPrivate *priv, const char *url,\n                      unsigned long long offset, unsigned long long length)\n{\n    return esxStreamOpen(stream, priv, url, offset, length, ESX_STREAM_MODE_DOWNLOAD);\n}",
          "includes": [
            "#include \"esx_stream.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_stream.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxStreamOpenDownload(virStreamPtr stream, esxPrivate *priv, const char *url,\n                      unsigned long long offset, unsigned long long length)\n{\n    return esxStreamOpen(stream, priv, url, offset, length, ESX_STREAM_MODE_DOWNLOAD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"image/png\""
          ],
          "line": 2408
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferURIEncodeString",
          "args": [
            "&buffer",
            "virtualMachine->obj->value"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferURIEncodeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "534-544",
          "snippet": "void\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferURIEncodeString(virBufferPtr buf, const char *str)\n{\n    if ((buf == NULL) || (str == NULL))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    g_string_append_uri_escaped(buf->str, str, NULL, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&buffer",
            "\"%s://%s:%d/screen?id=\"",
            "priv->parsedUri->transport",
            "domain->conn->uri->server",
            "domain->conn->uri->port"
          ],
          "line": 2402
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered on\")"
          ],
          "line": 2396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not powered on\""
          ],
          "line": 2397
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2389
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_UNSUPPORTED",
            "\"%s\"",
            "_(\"Screenshot feature is unsupported\")"
          ],
          "line": 2379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxSupportsScreenshot",
          "args": [
            "priv"
          ],
          "line": 2373
        },
        "resolved": true,
        "details": {
          "function_name": "esxSupportsScreenshot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "1011-1041",
          "snippet": "static esxVI_Boolean\nesxSupportsScreenshot(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsScreenshot != esxVI_Boolean_Undefined)\n        return priv->supportsScreenshot;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.screenshotSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.screenshotSupported\",\n                         &priv->supportsScreenshot,\n                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsScreenshot is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsScreenshot;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsScreenshot(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsScreenshot != esxVI_Boolean_Undefined)\n        return priv->supportsScreenshot;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.screenshotSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.screenshotSupported\",\n                         &priv->supportsScreenshot,\n                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsScreenshot is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsScreenshot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Screen cannot be selected\")"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "NULL"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic char *\nesxDomainScreenshot(virDomainPtr domain, virStreamPtr stream,\n                    unsigned int screen, unsigned int flags)\n{\n    char *mimeType = NULL;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Boolean supportsScreenshot = esxVI_Boolean_Undefined;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *url = NULL;\n\n    virCheckFlags(0, NULL);\n\n    if (screen != 0) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Screen cannot be selected\"));\n        return NULL;\n    }\n\n    supportsScreenshot = esxSupportsScreenshot(priv);\n\n    if (supportsScreenshot == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsScreenshot != esxVI_Boolean_True) {\n        virReportError(VIR_ERR_OPERATION_UNSUPPORTED, \"%s\",\n                       _(\"Screenshot feature is unsupported\"));\n        return NULL;\n    }\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0)\n        goto cleanup;\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    /* Build URL */\n    virBufferAsprintf(&buffer, \"%s://%s:%d/screen?id=\", priv->parsedUri->transport,\n                      domain->conn->uri->server, domain->conn->uri->port);\n    virBufferURIEncodeString(&buffer, virtualMachine->obj->value);\n\n    url = virBufferContentAndReset(&buffer);\n\n    mimeType = g_strdup(\"image/png\");\n\n    if (esxStreamOpenDownload(stream, priv, url, 0, 0) < 0) {\n        VIR_FREE(mimeType);\n        goto cleanup;\n    }\n\n cleanup:\n    virBufferFreeAndReset(&buffer);\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return mimeType;\n}"
  },
  {
    "function_name": "esxDomainGetState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2310-2348",
    "snippet": "static int\nesxDomainGetState(virDomainPtr domain,\n                  int *state,\n                  int *reason,\n                  unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    *state = esxVI_VirtualMachinePowerState_ConvertToLibvirt(powerState);\n\n    if (reason)\n        *reason = 0;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_ConvertToLibvirt",
          "args": [
            "powerState"
          ],
          "line": 2336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2329
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetState(virDomainPtr domain,\n                  int *state,\n                  int *reason,\n                  unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    *state = esxVI_VirtualMachinePowerState_ConvertToLibvirt(powerState);\n\n    if (reason)\n        *reason = 0;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2037-2306",
    "snippet": "static int\nesxDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int64_t memory_limit = -1;\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    esxVI_PerfMetricId *perfMetricId = NULL;\n    esxVI_PerfMetricId *perfMetricIdList = NULL;\n    esxVI_Int *counterId = NULL;\n    esxVI_Int *counterIdList = NULL;\n    esxVI_PerfCounterInfo *perfCounterInfo = NULL;\n    esxVI_PerfCounterInfo *perfCounterInfoList = NULL;\n    esxVI_PerfQuerySpec *querySpec = NULL;\n    esxVI_PerfEntityMetricBase *perfEntityMetricBase = NULL;\n    esxVI_PerfEntityMetricBase *perfEntityMetricBaseList = NULL;\n    esxVI_PerfEntityMetric *perfEntityMetric = NULL;\n    esxVI_PerfMetricIntSeries *perfMetricIntSeries = NULL;\n    esxVI_Long *value = NULL;\n#endif\n\n    memset(info, 0, sizeof(*info));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.powerState\\0\"\n                                           \"config.hardware.memoryMB\\0\"\n                                           \"config.hardware.numCPU\\0\"\n                                           \"config.memoryAllocation.limit\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    info->state = VIR_DOMAIN_NOSTATE;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                  (dynamicProperty->val, &powerState) < 0) {\n                goto cleanup;\n            }\n\n            info->state = esxVI_VirtualMachinePowerState_ConvertToLibvirt\n                            (powerState);\n        } else if (STREQ(dynamicProperty->name, \"config.hardware.memoryMB\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            info->maxMem = dynamicProperty->val->int32 * 1024; /* Scale from megabyte to kilobyte */\n        } else if (STREQ(dynamicProperty->name, \"config.hardware.numCPU\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            info->nrVirtCpu = dynamicProperty->val->int32;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.memoryAllocation.limit\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            memory_limit = dynamicProperty->val->int64;\n\n            if (memory_limit > 0)\n                memory_limit *= 1024; /* Scale from megabyte to kilobyte */\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* memory_limit < 0 means no memory limit is set */\n    info->memory = memory_limit < 0 ? info->maxMem : memory_limit;\n\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    /* Verify the cached 'used CPU time' performance counter ID */\n    /* FIXME: Currently no host for a vpx:// connection */\n    if (priv->host) {\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId >= 0) {\n            if (esxVI_Int_Alloc(&counterId) < 0)\n                goto cleanup;\n\n            counterId->value = priv->usedCpuTimeCounterId;\n\n            if (esxVI_Int_AppendToList(&counterIdList, counterId) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryPerfCounter(priv->host, counterIdList,\n                                       &perfCounterInfo) < 0) {\n                goto cleanup;\n            }\n\n            if (STRNEQ(perfCounterInfo->groupInfo->key, \"cpu\") ||\n                STRNEQ(perfCounterInfo->nameInfo->key, \"used\") ||\n                STRNEQ(perfCounterInfo->unitInfo->key, \"millisecond\")) {\n                VIR_DEBUG(\"Cached usedCpuTimeCounterId %d is invalid\",\n                          priv->usedCpuTimeCounterId);\n\n                priv->usedCpuTimeCounterId = -1;\n            }\n\n            esxVI_Int_Free(&counterIdList);\n            esxVI_PerfCounterInfo_Free(&perfCounterInfo);\n        }\n\n        /*\n         * Query the PerformanceManager for the 'used CPU time' performance\n         * counter ID and cache it, if it's not already cached.\n         */\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId < 0) {\n            if (esxVI_QueryAvailablePerfMetric(priv->host, virtualMachine->obj,\n                                               NULL, NULL, NULL,\n                                               &perfMetricIdList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfMetricId = perfMetricIdList; perfMetricId;\n                 perfMetricId = perfMetricId->_next) {\n                VIR_DEBUG(\"perfMetricId counterId %d, instance '%s'\",\n                          perfMetricId->counterId->value, perfMetricId->instance);\n\n                counterId = NULL;\n\n                if (esxVI_Int_DeepCopy(&counterId, perfMetricId->counterId) < 0 ||\n                    esxVI_Int_AppendToList(&counterIdList, counterId) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            if (esxVI_QueryPerfCounter(priv->host, counterIdList,\n                                       &perfCounterInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfCounterInfo = perfCounterInfoList; perfCounterInfo;\n                 perfCounterInfo = perfCounterInfo->_next) {\n                VIR_DEBUG(\"perfCounterInfo key %d, nameInfo '%s', groupInfo '%s', \"\n                          \"unitInfo '%s', rollupType %d, statsType %d\",\n                          perfCounterInfo->key->value,\n                          perfCounterInfo->nameInfo->key,\n                          perfCounterInfo->groupInfo->key,\n                          perfCounterInfo->unitInfo->key,\n                          perfCounterInfo->rollupType,\n                          perfCounterInfo->statsType);\n\n                if (STREQ(perfCounterInfo->groupInfo->key, \"cpu\") &&\n                    STREQ(perfCounterInfo->nameInfo->key, \"used\") &&\n                    STREQ(perfCounterInfo->unitInfo->key, \"millisecond\")) {\n                    priv->usedCpuTimeCounterId = perfCounterInfo->key->value;\n                    break;\n                }\n            }\n\n            if (priv->usedCpuTimeCounterId < 0)\n                VIR_WARN(\"Could not find 'used CPU time' performance counter\");\n        }\n\n        /*\n         * Query the PerformanceManager for the 'used CPU time' performance\n         * counter value.\n         */\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId >= 0) {\n            VIR_DEBUG(\"usedCpuTimeCounterId %d BEGIN\", priv->usedCpuTimeCounterId);\n\n            if (esxVI_PerfQuerySpec_Alloc(&querySpec) < 0 ||\n                esxVI_Int_Alloc(&querySpec->maxSample) < 0 ||\n                esxVI_PerfMetricId_Alloc(&querySpec->metricId) < 0 ||\n                esxVI_Int_Alloc(&querySpec->metricId->counterId) < 0) {\n                goto cleanup;\n            }\n\n            querySpec->entity = virtualMachine->obj;\n            querySpec->maxSample->value = 1;\n            querySpec->metricId->counterId->value = priv->usedCpuTimeCounterId;\n            querySpec->metricId->instance = (char *)\"\";\n            querySpec->format = (char *)\"normal\";\n\n            if (esxVI_QueryPerf(priv->host, querySpec,\n                                &perfEntityMetricBaseList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfEntityMetricBase = perfEntityMetricBaseList;\n                 perfEntityMetricBase;\n                 perfEntityMetricBase = perfEntityMetricBase->_next) {\n                VIR_DEBUG(\"perfEntityMetric ...\");\n\n                perfEntityMetric =\n                  esxVI_PerfEntityMetric_DynamicCast(perfEntityMetricBase);\n\n                if (!perfEntityMetric) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"QueryPerf returned object with unexpected type '%s'\"),\n                                   esxVI_Type_ToString(perfEntityMetricBase->_type));\n                    goto cleanup;\n                }\n\n                perfMetricIntSeries =\n                  esxVI_PerfMetricIntSeries_DynamicCast(perfEntityMetric->value);\n\n                if (!perfMetricIntSeries) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"QueryPerf returned object with unexpected type '%s'\"),\n                                   esxVI_Type_ToString(perfEntityMetric->value->_type));\n                    goto cleanup;\n                }\n\n                for (; perfMetricIntSeries;\n                     perfMetricIntSeries = perfMetricIntSeries->_next) {\n                    VIR_DEBUG(\"perfMetricIntSeries ...\");\n\n                    for (value = perfMetricIntSeries->value;\n                         value;\n                         value = value->_next) {\n                        VIR_DEBUG(\"value %lld\", (long long int)value->value);\n                    }\n                }\n            }\n\n            VIR_DEBUG(\"usedCpuTimeCounterId %d END\", priv->usedCpuTimeCounterId);\n\n            /*\n             * FIXME: Cannot map between relative used-cpu-time and absolute\n             *        info->cpuTime\n             */\n        }\n    }\n#endif\n\n    result = 0;\n\n cleanup:\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    /*\n     * Remove values owned by data structures to prevent them from being freed\n     * by the call to esxVI_PerfQuerySpec_Free().\n     */\n    if (querySpec) {\n        querySpec->entity = NULL;\n        querySpec->format = NULL;\n\n        if (querySpec->metricId)\n            querySpec->metricId->instance = NULL;\n    }\n#endif\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    esxVI_PerfMetricId_Free(&perfMetricIdList);\n    esxVI_Int_Free(&counterIdList);\n    esxVI_PerfCounterInfo_Free(&perfCounterInfoList);\n    esxVI_PerfQuerySpec_Free(&querySpec);\n    esxVI_PerfEntityMetricBase_Free(&perfEntityMetricBaseList);\n#endif\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define ESX_QUERY_FOR_USED_CPU_TIME 0"
    ],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_PerfEntityMetricBase_Free",
          "args": [
            "&perfEntityMetricBaseList"
          ],
          "line": 2302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfQuerySpec_Free",
          "args": [
            "&querySpec"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfCounterInfo_Free",
          "args": [
            "&perfCounterInfoList"
          ],
          "line": 2300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Free",
          "args": [
            "&counterIdList"
          ],
          "line": 2299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfMetricId_Free",
          "args": [
            "&perfMetricIdList"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"usedCpuTimeCounterId %d END\"",
            "priv->usedCpuTimeCounterId"
          ],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"value %lld\"",
            "(long long int)value->value"
          ],
          "line": 2263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"perfMetricIntSeries ...\""
          ],
          "line": 2258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"QueryPerf returned object with unexpected type '%s'\")",
            "esxVI_Type_ToString(perfEntityMetric->value->_type)"
          ],
          "line": 2250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Type_ToString",
          "args": [
            "perfEntityMetric->value->_type"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Type_ToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "785-834",
          "snippet": "const char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_Type_ToString(esxVI_Type type)\n{\n    switch (type) {\n      default:\n      case esxVI_Type_Undefined:\n        return \"<undefined>\";\n\n      case esxVI_Type_Boolean:\n        return \"xsd:boolean\";\n\n      case esxVI_Type_AnyType:\n        return \"xsd:anyType\";\n\n      case esxVI_Type_String:\n        return \"xsd:string\";\n\n      case esxVI_Type_Byte:\n        return \"xsd:byte\";\n\n      case esxVI_Type_Short:\n        return \"xsd:short\";\n\n      case esxVI_Type_Int:\n        return \"xsd:int\";\n\n      case esxVI_Type_Long:\n        return \"xsd:long\";\n\n      case esxVI_Type_DateTime:\n        return \"xsd:dateTime\";\n\n      case esxVI_Type_Fault:\n        return \"Fault\";\n\n      case esxVI_Type_MethodFault:\n        return \"MethodFault\";\n\n      case esxVI_Type_ManagedObjectReference:\n        return \"ManagedObjectReference\";\n\n      case esxVI_Type_Event:\n        return \"Event\";\n\n#include \"esx_vi_types.generated.typetostring\"\n\n      case esxVI_Type_Other:\n        return \"<other>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"QueryPerf returned object with unexpected type '%s'\""
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PerfMetricIntSeries_DynamicCast",
          "args": [
            "perfEntityMetric->value"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"QueryPerf returned object with unexpected type '%s'\")",
            "esxVI_Type_ToString(perfEntityMetricBase->_type)"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfEntityMetric_DynamicCast",
          "args": [
            "perfEntityMetricBase"
          ],
          "line": 2237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"perfEntityMetric ...\""
          ],
          "line": 2234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_QueryPerf",
          "args": [
            "priv->host",
            "querySpec",
            "&perfEntityMetricBaseList"
          ],
          "line": 2226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&querySpec->metricId->counterId"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfMetricId_Alloc",
          "args": [
            "&querySpec->metricId"
          ],
          "line": 2215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&querySpec->maxSample"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfQuerySpec_Alloc",
          "args": [
            "&querySpec"
          ],
          "line": 2213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"usedCpuTimeCounterId %d BEGIN\"",
            "priv->usedCpuTimeCounterId"
          ],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not find 'used CPU time' performance counter\""
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "perfCounterInfo->unitInfo->key",
            "\"millisecond\""
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "perfCounterInfo->nameInfo->key",
            "\"used\""
          ],
          "line": 2195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "perfCounterInfo->groupInfo->key",
            "\"cpu\""
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"perfCounterInfo key %d, nameInfo '%s', groupInfo '%s', \"\n                          \"unitInfo '%s', rollupType %d, statsType %d\"",
            "perfCounterInfo->key->value",
            "perfCounterInfo->nameInfo->key",
            "perfCounterInfo->groupInfo->key",
            "perfCounterInfo->unitInfo->key",
            "perfCounterInfo->rollupType",
            "perfCounterInfo->statsType"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_QueryPerfCounter",
          "args": [
            "priv->host",
            "counterIdList",
            "&perfCounterInfoList"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_AppendToList",
          "args": [
            "&counterIdList",
            "counterId"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_DeepCopy",
          "args": [
            "&counterId",
            "perfMetricId->counterId"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"perfMetricId counterId %d, instance '%s'\"",
            "perfMetricId->counterId->value",
            "perfMetricId->instance"
          ],
          "line": 2167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_QueryAvailablePerfMetric",
          "args": [
            "priv->host",
            "virtualMachine->obj",
            "NULL",
            "NULL",
            "NULL",
            "&perfMetricIdList"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_PerfCounterInfo_Free",
          "args": [
            "&perfCounterInfo"
          ],
          "line": 2151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Free",
          "args": [
            "&counterIdList"
          ],
          "line": 2150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Cached usedCpuTimeCounterId %d is invalid\"",
            "priv->usedCpuTimeCounterId"
          ],
          "line": 2144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "perfCounterInfo->unitInfo->key",
            "\"millisecond\""
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "perfCounterInfo->nameInfo->key",
            "\"used\""
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "perfCounterInfo->groupInfo->key",
            "\"cpu\""
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_QueryPerfCounter",
          "args": [
            "priv->host",
            "counterIdList",
            "&perfCounterInfo"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_AppendToList",
          "args": [
            "&counterIdList",
            "counterId"
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Int_Alloc",
          "args": [
            "&counterId"
          ],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Long"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.memoryAllocation.limit\""
          ],
          "line": 2104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.hardware.numCPU\""
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.hardware.memoryMB\""
          ],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_ConvertToLibvirt",
          "args": [
            "powerState"
          ],
          "line": 2088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachinePowerState_CastFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&powerState"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"runtime.powerState\""
          ],
          "line": 2082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 2072
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\\0\"\n                                           \"config.hardware.memoryMB\\0\"\n                                           \"config.hardware.numCPU\\0\"\n                                           \"config.memoryAllocation.limit\\0\""
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "info",
            "0",
            "sizeof(*info)"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\n#define ESX_QUERY_FOR_USED_CPU_TIME 0\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainGetInfo(virDomainPtr domain, virDomainInfoPtr info)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int64_t memory_limit = -1;\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    esxVI_PerfMetricId *perfMetricId = NULL;\n    esxVI_PerfMetricId *perfMetricIdList = NULL;\n    esxVI_Int *counterId = NULL;\n    esxVI_Int *counterIdList = NULL;\n    esxVI_PerfCounterInfo *perfCounterInfo = NULL;\n    esxVI_PerfCounterInfo *perfCounterInfoList = NULL;\n    esxVI_PerfQuerySpec *querySpec = NULL;\n    esxVI_PerfEntityMetricBase *perfEntityMetricBase = NULL;\n    esxVI_PerfEntityMetricBase *perfEntityMetricBaseList = NULL;\n    esxVI_PerfEntityMetric *perfEntityMetric = NULL;\n    esxVI_PerfMetricIntSeries *perfMetricIntSeries = NULL;\n    esxVI_Long *value = NULL;\n#endif\n\n    memset(info, 0, sizeof(*info));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.powerState\\0\"\n                                           \"config.hardware.memoryMB\\0\"\n                                           \"config.hardware.numCPU\\0\"\n                                           \"config.memoryAllocation.limit\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    info->state = VIR_DOMAIN_NOSTATE;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                  (dynamicProperty->val, &powerState) < 0) {\n                goto cleanup;\n            }\n\n            info->state = esxVI_VirtualMachinePowerState_ConvertToLibvirt\n                            (powerState);\n        } else if (STREQ(dynamicProperty->name, \"config.hardware.memoryMB\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            info->maxMem = dynamicProperty->val->int32 * 1024; /* Scale from megabyte to kilobyte */\n        } else if (STREQ(dynamicProperty->name, \"config.hardware.numCPU\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            info->nrVirtCpu = dynamicProperty->val->int32;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.memoryAllocation.limit\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            memory_limit = dynamicProperty->val->int64;\n\n            if (memory_limit > 0)\n                memory_limit *= 1024; /* Scale from megabyte to kilobyte */\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    /* memory_limit < 0 means no memory limit is set */\n    info->memory = memory_limit < 0 ? info->maxMem : memory_limit;\n\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    /* Verify the cached 'used CPU time' performance counter ID */\n    /* FIXME: Currently no host for a vpx:// connection */\n    if (priv->host) {\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId >= 0) {\n            if (esxVI_Int_Alloc(&counterId) < 0)\n                goto cleanup;\n\n            counterId->value = priv->usedCpuTimeCounterId;\n\n            if (esxVI_Int_AppendToList(&counterIdList, counterId) < 0)\n                goto cleanup;\n\n            if (esxVI_QueryPerfCounter(priv->host, counterIdList,\n                                       &perfCounterInfo) < 0) {\n                goto cleanup;\n            }\n\n            if (STRNEQ(perfCounterInfo->groupInfo->key, \"cpu\") ||\n                STRNEQ(perfCounterInfo->nameInfo->key, \"used\") ||\n                STRNEQ(perfCounterInfo->unitInfo->key, \"millisecond\")) {\n                VIR_DEBUG(\"Cached usedCpuTimeCounterId %d is invalid\",\n                          priv->usedCpuTimeCounterId);\n\n                priv->usedCpuTimeCounterId = -1;\n            }\n\n            esxVI_Int_Free(&counterIdList);\n            esxVI_PerfCounterInfo_Free(&perfCounterInfo);\n        }\n\n        /*\n         * Query the PerformanceManager for the 'used CPU time' performance\n         * counter ID and cache it, if it's not already cached.\n         */\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId < 0) {\n            if (esxVI_QueryAvailablePerfMetric(priv->host, virtualMachine->obj,\n                                               NULL, NULL, NULL,\n                                               &perfMetricIdList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfMetricId = perfMetricIdList; perfMetricId;\n                 perfMetricId = perfMetricId->_next) {\n                VIR_DEBUG(\"perfMetricId counterId %d, instance '%s'\",\n                          perfMetricId->counterId->value, perfMetricId->instance);\n\n                counterId = NULL;\n\n                if (esxVI_Int_DeepCopy(&counterId, perfMetricId->counterId) < 0 ||\n                    esxVI_Int_AppendToList(&counterIdList, counterId) < 0) {\n                    goto cleanup;\n                }\n            }\n\n            if (esxVI_QueryPerfCounter(priv->host, counterIdList,\n                                       &perfCounterInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfCounterInfo = perfCounterInfoList; perfCounterInfo;\n                 perfCounterInfo = perfCounterInfo->_next) {\n                VIR_DEBUG(\"perfCounterInfo key %d, nameInfo '%s', groupInfo '%s', \"\n                          \"unitInfo '%s', rollupType %d, statsType %d\",\n                          perfCounterInfo->key->value,\n                          perfCounterInfo->nameInfo->key,\n                          perfCounterInfo->groupInfo->key,\n                          perfCounterInfo->unitInfo->key,\n                          perfCounterInfo->rollupType,\n                          perfCounterInfo->statsType);\n\n                if (STREQ(perfCounterInfo->groupInfo->key, \"cpu\") &&\n                    STREQ(perfCounterInfo->nameInfo->key, \"used\") &&\n                    STREQ(perfCounterInfo->unitInfo->key, \"millisecond\")) {\n                    priv->usedCpuTimeCounterId = perfCounterInfo->key->value;\n                    break;\n                }\n            }\n\n            if (priv->usedCpuTimeCounterId < 0)\n                VIR_WARN(\"Could not find 'used CPU time' performance counter\");\n        }\n\n        /*\n         * Query the PerformanceManager for the 'used CPU time' performance\n         * counter value.\n         */\n        if (info->state == VIR_DOMAIN_RUNNING && priv->usedCpuTimeCounterId >= 0) {\n            VIR_DEBUG(\"usedCpuTimeCounterId %d BEGIN\", priv->usedCpuTimeCounterId);\n\n            if (esxVI_PerfQuerySpec_Alloc(&querySpec) < 0 ||\n                esxVI_Int_Alloc(&querySpec->maxSample) < 0 ||\n                esxVI_PerfMetricId_Alloc(&querySpec->metricId) < 0 ||\n                esxVI_Int_Alloc(&querySpec->metricId->counterId) < 0) {\n                goto cleanup;\n            }\n\n            querySpec->entity = virtualMachine->obj;\n            querySpec->maxSample->value = 1;\n            querySpec->metricId->counterId->value = priv->usedCpuTimeCounterId;\n            querySpec->metricId->instance = (char *)\"\";\n            querySpec->format = (char *)\"normal\";\n\n            if (esxVI_QueryPerf(priv->host, querySpec,\n                                &perfEntityMetricBaseList) < 0) {\n                goto cleanup;\n            }\n\n            for (perfEntityMetricBase = perfEntityMetricBaseList;\n                 perfEntityMetricBase;\n                 perfEntityMetricBase = perfEntityMetricBase->_next) {\n                VIR_DEBUG(\"perfEntityMetric ...\");\n\n                perfEntityMetric =\n                  esxVI_PerfEntityMetric_DynamicCast(perfEntityMetricBase);\n\n                if (!perfEntityMetric) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"QueryPerf returned object with unexpected type '%s'\"),\n                                   esxVI_Type_ToString(perfEntityMetricBase->_type));\n                    goto cleanup;\n                }\n\n                perfMetricIntSeries =\n                  esxVI_PerfMetricIntSeries_DynamicCast(perfEntityMetric->value);\n\n                if (!perfMetricIntSeries) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"QueryPerf returned object with unexpected type '%s'\"),\n                                   esxVI_Type_ToString(perfEntityMetric->value->_type));\n                    goto cleanup;\n                }\n\n                for (; perfMetricIntSeries;\n                     perfMetricIntSeries = perfMetricIntSeries->_next) {\n                    VIR_DEBUG(\"perfMetricIntSeries ...\");\n\n                    for (value = perfMetricIntSeries->value;\n                         value;\n                         value = value->_next) {\n                        VIR_DEBUG(\"value %lld\", (long long int)value->value);\n                    }\n                }\n            }\n\n            VIR_DEBUG(\"usedCpuTimeCounterId %d END\", priv->usedCpuTimeCounterId);\n\n            /*\n             * FIXME: Cannot map between relative used-cpu-time and absolute\n             *        info->cpuTime\n             */\n        }\n    }\n#endif\n\n    result = 0;\n\n cleanup:\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    /*\n     * Remove values owned by data structures to prevent them from being freed\n     * by the call to esxVI_PerfQuerySpec_Free().\n     */\n    if (querySpec) {\n        querySpec->entity = NULL;\n        querySpec->format = NULL;\n\n        if (querySpec->metricId)\n            querySpec->metricId->instance = NULL;\n    }\n#endif\n\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n#if ESX_QUERY_FOR_USED_CPU_TIME\n    esxVI_PerfMetricId_Free(&perfMetricIdList);\n    esxVI_Int_Free(&counterIdList);\n    esxVI_PerfCounterInfo_Free(&perfCounterInfoList);\n    esxVI_PerfQuerySpec_Free(&querySpec);\n    esxVI_PerfEntityMetricBase_Free(&perfEntityMetricBaseList);\n#endif\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSetMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "2021-2025",
    "snippet": "static int\nesxDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    return esxDomainSetMemoryFlags(domain, memory, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainSetMemoryFlags",
          "args": [
            "domain",
            "memory",
            "0"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainSetMemoryFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "1963-2018",
          "snippet": "static int\nesxDomainSetMemoryFlags(virDomainPtr domain,\n                        unsigned long memory,\n                        unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryAllocation->limit) < 0) {\n        goto cleanup;\n    }\n\n    spec->memoryAllocation->limit->value =\n      VIR_DIV_UP(memory, 1024); /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetMemoryFlags(virDomainPtr domain,\n                        unsigned long memory,\n                        unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryAllocation->limit) < 0) {\n        goto cleanup;\n    }\n\n    spec->memoryAllocation->limit->value =\n      VIR_DIV_UP(memory, 1024); /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetMemory(virDomainPtr domain, unsigned long memory)\n{\n    return esxDomainSetMemoryFlags(domain, memory, 0);\n}"
  },
  {
    "function_name": "esxDomainSetMemoryFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1963-2018",
    "snippet": "static int\nesxDomainSetMemoryFlags(virDomainPtr domain,\n                        unsigned long memory,\n                        unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryAllocation->limit) < 0) {\n        goto cleanup;\n    }\n\n    spec->memoryAllocation->limit->value =\n      VIR_DIV_UP(memory, 1024); /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 2014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Free",
          "args": [
            "&spec"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not set memory to %lu kilobytes: %s\")",
            "memory",
            "taskInfoErrorMessage"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not set memory to %lu kilobytes: %s\""
          ],
          "line": 2004
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "spec",
            "&task"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "memory",
            "1024"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&spec->memoryAllocation->limit"
          ],
          "line": 1986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ResourceAllocationInfo_Alloc",
          "args": [
            "&spec->memoryAllocation"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Alloc",
          "args": [
            "&spec"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "NULL",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetMemoryFlags(virDomainPtr domain,\n                        unsigned long memory,\n                        unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, NULL, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_ResourceAllocationInfo_Alloc(&spec->memoryAllocation) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryAllocation->limit) < 0) {\n        goto cleanup;\n    }\n\n    spec->memoryAllocation->limit->value =\n      VIR_DIV_UP(memory, 1024); /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSetMaxMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1893-1959",
    "snippet": "static int\nesxDomainSetMaxMemory(virDomainPtr domain, unsigned long memory)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryMB) < 0) {\n        goto cleanup;\n    }\n\n    /* max-memory must be a multiple of 4096 kilobyte */\n    spec->memoryMB->value =\n      VIR_DIV_UP(memory, 4096) * 4; /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set max-memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Free",
          "args": [
            "&spec"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not set max-memory to %lu kilobytes: %s\")",
            "memory",
            "taskInfoErrorMessage"
          ],
          "line": 1943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not set max-memory to %lu kilobytes: %s\""
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1935
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ReconfigVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "spec",
            "&task"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DIV_UP",
          "args": [
            "memory",
            "4096"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Long_Alloc",
          "args": [
            "&spec->memoryMB"
          ],
          "line": 1925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VirtualMachineConfigSpec_Alloc",
          "args": [
            "&spec"
          ],
          "line": 1924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered off\")"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1914
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSetMaxMemory(virDomainPtr domain, unsigned long memory)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_VirtualMachineConfigSpec *spec = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOff) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered off\"));\n        goto cleanup;\n    }\n\n    if (esxVI_VirtualMachineConfigSpec_Alloc(&spec) < 0 ||\n        esxVI_Long_Alloc(&spec->memoryMB) < 0) {\n        goto cleanup;\n    }\n\n    /* max-memory must be a multiple of 4096 kilobyte */\n    spec->memoryMB->value =\n      VIR_DIV_UP(memory, 4096) * 4; /* Scale from kilobytes to megabytes */\n\n    if (esxVI_ReconfigVM_Task(priv->primary, virtualMachine->obj, spec,\n                              &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not set max-memory to %lu kilobytes: %s\"), memory,\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_VirtualMachineConfigSpec_Free(&spec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainGetMaxMemory",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1842-1889",
    "snippet": "static unsigned long long\nesxDomainGetMaxMemory(virDomainPtr domain)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    unsigned long memoryMB = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.hardware.memoryMB\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.hardware.memoryMB\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            if (dynamicProperty->val->int32 < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got invalid memory size %d\"),\n                               dynamicProperty->val->int32);\n            } else {\n                memoryMB = dynamicProperty->val->int32;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return memoryMB * 1024; /* Scale from megabyte to kilobyte */\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Got invalid memory size %d\")",
            "dynamicProperty->val->int32"
          ],
          "line": 1871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Got invalid memory size %d\""
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_Int"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.hardware.memoryMB\""
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1856
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"config.hardware.memoryMB\""
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic unsigned long long\nesxDomainGetMaxMemory(virDomainPtr domain)\n{\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    unsigned long memoryMB = 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"config.hardware.memoryMB\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"config.hardware.memoryMB\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            if (dynamicProperty->val->int32 < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got invalid memory size %d\"),\n                               dynamicProperty->val->int32);\n            } else {\n                memoryMB = dynamicProperty->val->int32;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return memoryMB * 1024; /* Scale from megabyte to kilobyte */\n}"
  },
  {
    "function_name": "esxDomainGetOSType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1831-1838",
    "snippet": "static char *\nesxDomainGetOSType(virDomainPtr domain G_GNUC_UNUSED)\n{\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "\"hvm\""
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic char *\nesxDomainGetOSType(virDomainPtr domain G_GNUC_UNUSED)\n{\n    char *osType;\n\n    osType = g_strdup(\"hvm\");\n    return osType;\n}"
  },
  {
    "function_name": "esxDomainDestroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1824-1828",
    "snippet": "static int\nesxDomainDestroy(virDomainPtr dom)\n{\n    return esxDomainDestroyFlags(dom, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainDestroyFlags",
          "args": [
            "dom",
            "0"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainDestroyFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "1757-1821",
          "snippet": "static int\nesxDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (ctx, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOffVM_Task(ctx, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not destroy domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = -1;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (ctx, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOffVM_Task(ctx, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not destroy domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = -1;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxDomainDestroy(virDomainPtr dom)\n{\n    return esxDomainDestroyFlags(dom, 0);\n}"
  },
  {
    "function_name": "esxDomainDestroyFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1757-1821",
    "snippet": "static int\nesxDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (ctx, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOffVM_Task(ctx, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not destroy domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = -1;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not destroy domain: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not destroy domain: %s\""
          ],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "ctx",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PowerOffVM_Task",
          "args": [
            "ctx",
            "virtualMachine->obj",
            "&task"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered on\")"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "ctx",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1782
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "ctx"
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainDestroyFlags(virDomainPtr domain,\n                      unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_Context *ctx = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    virCheckFlags(0, -1);\n\n    if (priv->vCenter) {\n        ctx = priv->vCenter;\n    } else {\n        ctx = priv->host;\n    }\n\n    if (esxVI_EnsureSession(ctx) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (ctx, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOffVM_Task(ctx, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not destroy domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    domain->id = -1;\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainReboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1714-1753",
    "snippet": "static int\nesxDomainReboot(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_RebootGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_RebootGuest",
          "args": [
            "priv->primary",
            "virtualMachine->obj"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered on\")"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not powered on\""
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainReboot(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_RebootGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainShutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1707-1711",
    "snippet": "static int\nesxDomainShutdown(virDomainPtr domain)\n{\n    return esxDomainShutdownFlags(domain, 0);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxDomainShutdownFlags",
          "args": [
            "domain",
            "0"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "esxDomainShutdownFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "1665-1704",
          "snippet": "static int\nesxDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_ShutdownGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_ShutdownGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainShutdown(virDomainPtr domain)\n{\n    return esxDomainShutdownFlags(domain, 0);\n}"
  },
  {
    "function_name": "esxDomainShutdownFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1665-1704",
    "snippet": "static int\nesxDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_ShutdownGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ShutdownGuest",
          "args": [
            "priv->primary",
            "virtualMachine->obj"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered on\")"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Domain is not powered on\""
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1681
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 1674
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainShutdownFlags(virDomainPtr domain, unsigned int flags)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n\n    virCheckFlags(0, -1);\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, domain->uuid,\n                                         propertyNameList, &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_ShutdownGuest(priv->primary, virtualMachine->obj) < 0)\n        goto cleanup;\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainResume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1608-1661",
    "snippet": "static int\nesxDomainResume(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\", _(\"Domain is not suspended\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not resume domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not resume domain: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not resume domain: %s\""
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_PowerOnVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "NULL",
            "&task"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not suspended\")"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainResume(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_Suspended) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\", _(\"Domain is not suspended\"));\n        goto cleanup;\n    }\n\n    if (esxVI_PowerOnVM_Task(priv->primary, virtualMachine->obj, NULL,\n                             &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not resume domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainSuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1551-1604",
    "snippet": "static int\nesxDomainSuspend(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_SuspendVM_Task(priv->primary, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not suspend domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "taskInfoErrorMessage"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ManagedObjectReference_Free",
          "args": [
            "&task"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not suspend domain: %s\")",
            "taskInfoErrorMessage"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not suspend domain: %s\""
          ],
          "line": 1590
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_WaitForTaskCompletion",
          "args": [
            "priv->primary",
            "task",
            "domain->uuid",
            "esxVI_Occurrence_RequiredItem",
            "priv->parsedUri->autoAnswer",
            "&taskInfoState",
            "&taskInfoErrorMessage"
          ],
          "line": 1582
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_WaitForTaskCompletion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4225-4403",
          "snippet": "int\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_WaitForTaskCompletion(esxVI_Context *ctx,\n                            esxVI_ManagedObjectReference *task,\n                            const unsigned char *virtualMachineUuid,\n                            esxVI_Occurrence virtualMachineOccurrence,\n                            bool autoAnswer, esxVI_TaskInfoState *finalState,\n                            char **errorMessage)\n{\n    int result = -1;\n    esxVI_ObjectSpec *objectSpec = NULL;\n    bool objectSpec_isAppended = false;\n    esxVI_PropertySpec *propertySpec = NULL;\n    bool propertySpec_isAppended = false;\n    esxVI_PropertyFilterSpec *propertyFilterSpec = NULL;\n    esxVI_ManagedObjectReference *propertyFilter = NULL;\n    char *version = NULL;\n    esxVI_UpdateSet *updateSet = NULL;\n    esxVI_PropertyFilterUpdate *propertyFilterUpdate = NULL;\n    esxVI_ObjectUpdate *objectUpdate = NULL;\n    esxVI_PropertyChange *propertyChange = NULL;\n    esxVI_AnyType *propertyValue = NULL;\n    esxVI_TaskInfoState state = esxVI_TaskInfoState_Undefined;\n    bool blocked;\n    esxVI_TaskInfo *taskInfo = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(errorMessage);\n\n    version = g_strdup(\"\");\n\n    if (esxVI_ObjectSpec_Alloc(&objectSpec) < 0)\n        goto cleanup;\n\n    objectSpec->obj = task;\n    objectSpec->skip = esxVI_Boolean_False;\n\n    if (esxVI_PropertySpec_Alloc(&propertySpec) < 0)\n        goto cleanup;\n\n    propertySpec->type = task->type;\n\n    if (esxVI_String_AppendValueToList(&propertySpec->pathSet,\n                                       \"info.state\") < 0 ||\n        esxVI_PropertyFilterSpec_Alloc(&propertyFilterSpec) < 0 ||\n        esxVI_PropertySpec_AppendToList(&propertyFilterSpec->propSet,\n                                        propertySpec) < 0) {\n        goto cleanup;\n    }\n\n    propertySpec_isAppended = true;\n\n    if (esxVI_ObjectSpec_AppendToList(&propertyFilterSpec->objectSet,\n                                      objectSpec) < 0) {\n        goto cleanup;\n    }\n\n    objectSpec_isAppended = true;\n\n    if (esxVI_CreateFilter(ctx, propertyFilterSpec, esxVI_Boolean_True,\n                           &propertyFilter) < 0) {\n        goto cleanup;\n    }\n\n    while (state != esxVI_TaskInfoState_Success &&\n           state != esxVI_TaskInfoState_Error) {\n        esxVI_UpdateSet_Free(&updateSet);\n\n        if (virtualMachineUuid) {\n            if (esxVI_LookupAndHandleVirtualMachineQuestion\n                  (ctx, virtualMachineUuid, virtualMachineOccurrence,\n                   autoAnswer, &blocked) < 0) {\n                /*\n                 * FIXME: Disable error reporting here, so possible errors from\n                 *        esxVI_LookupTaskInfoByTask() and esxVI_CancelTask()\n                 *        don't overwrite the actual error\n                 */\n                if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n                    goto cleanup;\n\n                if (taskInfo->cancelable == esxVI_Boolean_True) {\n                    if (esxVI_CancelTask(ctx, task) < 0 && blocked) {\n                        VIR_ERROR(_(\"Cancelable task is blocked by an \"\n                                     \"unanswered question but cancellation \"\n                                     \"failed\"));\n                    }\n                } else if (blocked) {\n                    VIR_ERROR(_(\"Non-cancelable task is blocked by an \"\n                                 \"unanswered question\"));\n                }\n\n                /* FIXME: Enable error reporting here again */\n\n                goto cleanup;\n            }\n        }\n\n        if (esxVI_WaitForUpdates(ctx, version, &updateSet) < 0)\n            goto cleanup;\n\n        VIR_FREE(version);\n        version = g_strdup(updateSet->version);\n\n        if (!updateSet->filterSet)\n            continue;\n\n        for (propertyFilterUpdate = updateSet->filterSet;\n             propertyFilterUpdate;\n             propertyFilterUpdate = propertyFilterUpdate->_next) {\n            for (objectUpdate = propertyFilterUpdate->objectSet;\n                 objectUpdate; objectUpdate = objectUpdate->_next) {\n                for (propertyChange = objectUpdate->changeSet;\n                     propertyChange;\n                     propertyChange = propertyChange->_next) {\n                    if (STREQ(propertyChange->name, \"info.state\")) {\n                        if (propertyChange->op == esxVI_PropertyChangeOp_Add ||\n                            propertyChange->op == esxVI_PropertyChangeOp_Assign) {\n                            propertyValue = propertyChange->val;\n                        } else {\n                            propertyValue = NULL;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!propertyValue)\n            continue;\n\n        if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, &state) < 0)\n            goto cleanup;\n    }\n\n    if (esxVI_DestroyPropertyFilter(ctx, propertyFilter) < 0)\n        VIR_DEBUG(\"DestroyPropertyFilter failed\");\n\n    if (esxVI_TaskInfoState_CastFromAnyType(propertyValue, finalState) < 0)\n        goto cleanup;\n\n    if (*finalState != esxVI_TaskInfoState_Success) {\n        if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo))\n            goto cleanup;\n\n        if (!taskInfo->error) {\n            *errorMessage = g_strdup(_(\"Unknown error\"));\n        } else if (!taskInfo->error->localizedMessage) {\n            *errorMessage = g_strdup(taskInfo->error->fault->_actualType);\n        } else {\n            *errorMessage = g_strdup_printf(\"%s - %s\",\n                                            taskInfo->error->fault->_actualType,\n                                            taskInfo->error->localizedMessage);\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    /*\n     * Remove values given by the caller from the data structures to prevent\n     * them from being freed by the call to esxVI_PropertyFilterSpec_Free().\n     */\n    if (objectSpec)\n        objectSpec->obj = NULL;\n\n    if (propertySpec)\n        propertySpec->type = NULL;\n\n    if (!objectSpec_isAppended)\n        esxVI_ObjectSpec_Free(&objectSpec);\n\n    if (!propertySpec_isAppended)\n        esxVI_PropertySpec_Free(&propertySpec);\n\n    esxVI_PropertyFilterSpec_Free(&propertyFilterSpec);\n    esxVI_ManagedObjectReference_Free(&propertyFilter);\n    VIR_FREE(version);\n    esxVI_UpdateSet_Free(&updateSet);\n    esxVI_TaskInfo_Free(&taskInfo);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_SuspendVM_Task",
          "args": [
            "priv->primary",
            "virtualMachine->obj",
            "&task"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Domain is not powered on\")"
          ],
          "line": 1576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1571
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "args": [
            "priv->primary",
            "domain->uuid",
            "propertyNameList",
            "&virtualMachine",
            "priv->parsedUri->autoAnswer"
          ],
          "line": 1568
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1566
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic int\nesxDomainSuspend(virDomainPtr domain)\n{\n    int result = -1;\n    esxPrivate *priv = domain->conn->privateData;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineByUuidAndPrepareForTask\n          (priv->primary, domain->uuid, propertyNameList, &virtualMachine,\n           priv->parsedUri->autoAnswer) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    if (powerState != esxVI_VirtualMachinePowerState_PoweredOn) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Domain is not powered on\"));\n        goto cleanup;\n    }\n\n    if (esxVI_SuspendVM_Task(priv->primary, virtualMachine->obj, &task) < 0 ||\n        esxVI_WaitForTaskCompletion(priv->primary, task, domain->uuid,\n                                    esxVI_Occurrence_RequiredItem,\n                                    priv->parsedUri->autoAnswer, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, _(\"Could not suspend domain: %s\"),\n                       taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ObjectContent_Free(&virtualMachine);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n\n    return result;\n}"
  },
  {
    "function_name": "esxDomainLookupByName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1507-1547",
    "snippet": "static virDomainPtr\nesxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByName(priv->primary, name, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, uuid) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return domain;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "name",
            "uuid",
            "id"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id",
            "NULL",
            "uuid"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByName",
          "args": [
            "priv->primary",
            "name",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2775-2829",
          "snippet": "int\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByName(esxVI_Context *ctx, const char *name,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **virtualMachine,\n                                 esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(virtualMachine);\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList, \"name\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, completePropertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (candidate = virtualMachineList; candidate;\n         candidate = candidate->_next) {\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(candidate, NULL, &name_candidate,\n                                            NULL) < 0) {\n            goto cleanup;\n        }\n\n        if (STRNEQ(name, name_candidate))\n            continue;\n\n        if (esxVI_ObjectContent_DeepCopy(virtualMachine, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*virtualMachine) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_NO_DOMAIN,\n                       _(\"Could not find domain with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"configStatus\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\""
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainLookupByName(virConnectPtr conn, const char *name)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    unsigned char uuid[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByName(priv->primary, name, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (esxVI_GetVirtualMachineIdentity(virtualMachine, &id, NULL, uuid) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n\n    return domain;\n}"
  },
  {
    "function_name": "esxDomainLookupByUUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1466-1503",
    "snippet": "static virDomainPtr\nesxDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    char *name = NULL;\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, &name, NULL) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    VIR_FREE(name);\n\n    return domain;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name"
          ],
          "line": 1500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachine"
          ],
          "line": 1499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "name",
            "uuid",
            "id"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id",
            "&name",
            "NULL"
          ],
          "line": 1486
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineByUuid",
          "args": [
            "priv->primary",
            "uuid",
            "propertyNameList",
            "&virtualMachine",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineByUuidAndPrepareForTask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2833-2881",
          "snippet": "int\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineByUuidAndPrepareForTask\n  (esxVI_Context *ctx, const unsigned char *uuid,\n   esxVI_String *propertyNameList, esxVI_ObjectContent **virtualMachine,\n   bool autoAnswer)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_VirtualMachineQuestionInfo *questionInfo = NULL;\n    esxVI_TaskInfo *pendingTaskInfoList = NULL;\n    bool blocked;\n\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueListToList(&completePropertyNameList,\n                                           \"runtime.question\\0\"\n                                           \"recentTask\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(ctx, uuid, completePropertyNameList,\n                                         virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineQuestionInfo(*virtualMachine,\n                                            &questionInfo) < 0 ||\n        esxVI_LookupPendingTaskInfoListByVirtualMachine\n           (ctx, *virtualMachine, &pendingTaskInfoList) < 0) {\n        goto cleanup;\n    }\n\n    if (questionInfo &&\n        esxVI_HandleVirtualMachineQuestion(ctx, (*virtualMachine)->obj,\n                                           questionInfo, autoAnswer,\n                                           &blocked) < 0) {\n        goto cleanup;\n    }\n\n    if (pendingTaskInfoList) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Other tasks are pending for this domain\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_VirtualMachineQuestionInfo_Free(&questionInfo);\n    esxVI_TaskInfo_Free(&pendingTaskInfoList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"name\\0\"\n                                           \"runtime.powerState\\0\""
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainLookupByUUID(virConnectPtr conn, const unsigned char *uuid)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id = -1;\n    char *name = NULL;\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\") < 0 ||\n        esxVI_LookupVirtualMachineByUuid(priv->primary, uuid, propertyNameList,\n                                         &virtualMachine,\n                                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetVirtualMachineIdentity(virtualMachine, &id, &name, NULL) < 0 ||\n        esxVI_GetVirtualMachinePowerState(virtualMachine, &powerState) < 0) {\n        goto cleanup;\n    }\n\n    /* Only running/suspended virtual machines have an ID != -1 */\n    if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n        id = -1;\n\n    domain = virGetDomain(conn, name, uuid, id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachine);\n    VIR_FREE(name);\n\n    return domain;\n}"
  },
  {
    "function_name": "esxDomainLookupByID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1397-1462",
    "snippet": "static virDomainPtr\nesxDomainLookupByID(virConnectPtr conn, int id)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id_candidate = -1;\n    char *name_candidate = NULL;\n    unsigned char uuid_candidate[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        /* Only running/suspended domains have an ID != -1 */\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n            continue;\n\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(virtualMachine,\n                                            &id_candidate, &name_candidate,\n                                            uuid_candidate) < 0) {\n            goto cleanup;\n        }\n\n        if (id != id_candidate)\n            continue;\n\n        domain = virGetDomain(conn, name_candidate, uuid_candidate, id);\n\n        if (!domain)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!domain)\n        virReportError(VIR_ERR_NO_DOMAIN, _(\"No domain with ID %d\"), id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return domain;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int esxDomainGetMaxVcpus(virDomainPtr domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name_candidate"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_NO_DOMAIN",
            "_(\"No domain with ID %d\")",
            "id"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No domain with ID %d\""
          ],
          "line": 1454
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetDomain",
          "args": [
            "conn",
            "name_candidate",
            "uuid_candidate",
            "id"
          ],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "virGetDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/datatypes.c",
          "lines": "275-304",
          "snippet": "virDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "virClassPtr virDomainClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirClassPtr virDomainClass;\n\nvirDomainPtr\nvirGetDomain(virConnectPtr conn,\n             const char *name,\n             const unsigned char *uuid,\n             int id)\n{\n    virDomainPtr ret = NULL;\n\n    if (virDataTypesInitialize() < 0)\n        return NULL;\n\n    virCheckConnectGoto(conn, error);\n    virCheckNonNullArgGoto(name, error);\n    virCheckNonNullArgGoto(uuid, error);\n\n    if (!(ret = virObjectNew(virDomainClass)))\n        goto error;\n\n    ret->name = g_strdup(name);\n\n    ret->conn = virObjectRef(conn);\n    ret->id = id;\n    memcpy(&(ret->uuid[0]), uuid, VIR_UUID_BUFLEN);\n\n    return ret;\n\n error:\n    virObjectUnref(ret);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachineIdentity",
          "args": [
            "virtualMachine",
            "&id_candidate",
            "&name_candidate",
            "uuid_candidate"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachineIdentity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2441-2547",
          "snippet": "int\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachineIdentity(esxVI_ObjectContent *virtualMachine,\n                                int *id, char **name, unsigned char *uuid)\n{\n    const char *uuid_string = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_ManagedEntityStatus configStatus = esxVI_ManagedEntityStatus_Undefined;\n\n    if (STRNEQ(virtualMachine->obj->type, \"VirtualMachine\")) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"ObjectContent does not reference a virtual machine\"));\n        return -1;\n    }\n\n    if (id) {\n        if (esxUtil_ParseVirtualMachineIDString\n              (virtualMachine->obj->value, id) < 0 || *id <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto failure;\n        }\n    }\n\n    if (name) {\n        if (*name) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n            goto failure;\n        }\n\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"name\")) {\n                if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                             esxVI_Type_String) < 0) {\n                    goto failure;\n                }\n\n                *name = g_strdup(dynamicProperty->val->string);\n\n                if (virVMXUnescapeHexPercent(*name) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"Domain name contains invalid escape sequence\"));\n                    goto failure;\n                }\n\n                break;\n            }\n        }\n\n        if (!(*name)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get name of virtual machine\"));\n            goto failure;\n        }\n    }\n\n    if (uuid) {\n        if (esxVI_GetManagedEntityStatus(virtualMachine, \"configStatus\",\n                                         &configStatus) < 0) {\n            goto failure;\n        }\n\n        if (configStatus == esxVI_ManagedEntityStatus_Green) {\n            for (dynamicProperty = virtualMachine->propSet;\n                 dynamicProperty;\n                 dynamicProperty = dynamicProperty->_next) {\n                if (STREQ(dynamicProperty->name, \"config.uuid\")) {\n                    if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                                 esxVI_Type_String) < 0) {\n                        goto failure;\n                    }\n\n                    uuid_string = dynamicProperty->val->string;\n                    break;\n                }\n            }\n\n            if (!uuid_string) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Could not get UUID of virtual machine\"));\n                goto failure;\n            }\n\n            if (virUUIDParse(uuid_string, uuid) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not parse UUID from string '%s'\"),\n                               uuid_string);\n                goto failure;\n            }\n        } else {\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n\n            VIR_WARN(\"Cannot access UUID, because 'configStatus' property \"\n                      \"indicates a config problem\");\n        }\n    }\n\n    return 0;\n\n failure:\n    if (name)\n        VIR_FREE(*name);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "name_candidate"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&virtualMachineList"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"configStatus\\0\"\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\""
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int esxDomainGetMaxVcpus(virDomainPtr domain);\n\nstatic virDomainPtr\nesxDomainLookupByID(virConnectPtr conn, int id)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int id_candidate = -1;\n    char *name_candidate = NULL;\n    unsigned char uuid_candidate[VIR_UUID_BUFLEN];\n    virDomainPtr domain = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"configStatus\\0\"\n                                           \"name\\0\"\n                                           \"runtime.powerState\\0\"\n                                           \"config.uuid\\0\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        /* Only running/suspended domains have an ID != -1 */\n        if (powerState == esxVI_VirtualMachinePowerState_PoweredOff)\n            continue;\n\n        VIR_FREE(name_candidate);\n\n        if (esxVI_GetVirtualMachineIdentity(virtualMachine,\n                                            &id_candidate, &name_candidate,\n                                            uuid_candidate) < 0) {\n            goto cleanup;\n        }\n\n        if (id != id_candidate)\n            continue;\n\n        domain = virGetDomain(conn, name_candidate, uuid_candidate, id);\n\n        if (!domain)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!domain)\n        virReportError(VIR_ERR_NO_DOMAIN, _(\"No domain with ID %d\"), id);\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n    VIR_FREE(name_candidate);\n\n    return domain;\n}"
  },
  {
    "function_name": "esxConnectNumOfDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1383-1393",
    "snippet": "static int\nesxConnectNumOfDomains(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return esxVI_LookupNumberOfDomainsByPowerState\n             (priv->primary, esxVI_VirtualMachinePowerState_PoweredOn, false);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_LookupNumberOfDomainsByPowerState",
          "args": [
            "priv->primary",
            "esxVI_VirtualMachinePowerState_PoweredOn",
            "false"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupNumberOfDomainsByPowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2389-2437",
          "snippet": "int\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupNumberOfDomainsByPowerState(esxVI_Context *ctx,\n                                        esxVI_VirtualMachinePowerState powerState,\n                                        bool inverse)\n{\n    bool success = false;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_VirtualMachinePowerState powerState_;\n    int count = 0;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(ctx, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        for (dynamicProperty = virtualMachine->propSet;\n             dynamicProperty;\n             dynamicProperty = dynamicProperty->_next) {\n            if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n                if (esxVI_VirtualMachinePowerState_CastFromAnyType\n                      (dynamicProperty->val, &powerState_) < 0) {\n                    goto cleanup;\n                }\n\n                if ((!inverse && powerState_ == powerState) ||\n                    (inverse && powerState_ != powerState)) {\n                    count++;\n                }\n            } else {\n                VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n            }\n        }\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1388
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectNumOfDomains(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    return esxVI_LookupNumberOfDomainsByPowerState\n             (priv->primary, esxVI_VirtualMachinePowerState_PoweredOn, false);\n}"
  },
  {
    "function_name": "esxConnectListDomains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1323-1379",
    "snippet": "static int\nesxConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int count = 0;\n\n    if (maxids == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        if (powerState != esxVI_VirtualMachinePowerState_PoweredOn)\n            continue;\n\n        if (esxUtil_ParseVirtualMachineIDString(virtualMachine->obj->value,\n                                                &ids[count]) < 0 ||\n            ids[count] <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto cleanup;\n        }\n\n        count++;\n\n        if (count >= maxids)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&virtualMachineList"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to parse positive integer from '%s'\")",
            "virtualMachine->obj->value"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse positive integer from '%s'\""
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseVirtualMachineIDString",
          "args": [
            "virtualMachine->obj->value",
            "&ids[count]"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseVirtualMachineIDString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "185-202",
          "snippet": "int\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseVirtualMachineIDString(const char *id_string, int *id)\n{\n    /* Try to parse an integer from the complete string. */\n    if (virStrToLong_i(id_string, NULL, 10, id) == 0)\n        return 0;\n\n    /*\n     * If that fails try to parse an integer from the string tail\n     * assuming the naming scheme Virtual Center seems to use.\n     */\n    if (STRPREFIX(id_string, \"vm-\")) {\n        if (virStrToLong_i(id_string + 3, NULL, 10, id) == 0)\n            return 0;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetVirtualMachinePowerState",
          "args": [
            "virtualMachine",
            "&powerState"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetVirtualMachinePowerState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2169-2187",
          "snippet": "int\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetVirtualMachinePowerState(esxVI_ObjectContent *virtualMachine,\n                                  esxVI_VirtualMachinePowerState *powerState)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    for (dynamicProperty = virtualMachine->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"runtime.powerState\")) {\n            return esxVI_VirtualMachinePowerState_CastFromAnyType\n                     (dynamicProperty->val, powerState);\n        }\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"Missing 'runtime.powerState' property\"));\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupVirtualMachineList",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&virtualMachineList"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupVirtualMachineList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2710-2721",
          "snippet": "int\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupVirtualMachineList(esxVI_Context *ctx,\n                               esxVI_String *propertyNameList,\n                               esxVI_ObjectContent **virtualMachineList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource->resourcePool\n     *        for cluster support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"VirtualMachine\", propertyNameList,\n                                           virtualMachineList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"runtime.powerState\""
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1337
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectListDomains(virConnectPtr conn, int *ids, int maxids)\n{\n    bool success = false;\n    esxPrivate *priv = conn->privateData;\n    esxVI_ObjectContent *virtualMachineList = NULL;\n    esxVI_ObjectContent *virtualMachine = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_VirtualMachinePowerState powerState;\n    int count = 0;\n\n    if (maxids == 0)\n        return 0;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"runtime.powerState\") < 0 ||\n        esxVI_LookupVirtualMachineList(priv->primary, propertyNameList,\n                                       &virtualMachineList) < 0) {\n        goto cleanup;\n    }\n\n    for (virtualMachine = virtualMachineList; virtualMachine;\n         virtualMachine = virtualMachine->_next) {\n        if (esxVI_GetVirtualMachinePowerState(virtualMachine,\n                                              &powerState) < 0) {\n            goto cleanup;\n        }\n\n        if (powerState != esxVI_VirtualMachinePowerState_PoweredOn)\n            continue;\n\n        if (esxUtil_ParseVirtualMachineIDString(virtualMachine->obj->value,\n                                                &ids[count]) < 0 ||\n            ids[count] <= 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to parse positive integer from '%s'\"),\n                           virtualMachine->obj->value);\n            goto cleanup;\n        }\n\n        count++;\n\n        if (count >= maxids)\n            break;\n    }\n\n    success = true;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&virtualMachineList);\n\n    return success ? count : -1;\n}"
  },
  {
    "function_name": "esxConnectGetCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1313-1319",
    "snippet": "static char *\nesxConnectGetCapabilities(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return virCapabilitiesFormatXML(priv->caps);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesFormatXML",
          "args": [
            "priv->caps"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFormatXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1335-1358",
          "snippet": "char *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nchar *\nvirCapabilitiesFormatXML(virCapsPtr caps)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n\n    virBufferAddLit(&buf, \"<capabilities>\\n\\n\");\n    virBufferAdjustIndent(&buf, 2);\n\n    if (virCapabilitiesFormatHostXML(&caps->host, &buf) < 0)\n        goto error;\n\n    virCapabilitiesFormatGuestXML(caps->guests, caps->nguests, &buf);\n\n    virCapabilitiesFormatStoragePoolXML(caps->pools, caps->npools, &buf);\n\n    virBufferAdjustIndent(&buf, -2);\n    virBufferAddLit(&buf, \"</capabilities>\\n\");\n\n    return virBufferContentAndReset(&buf);\n\n error:\n    virBufferFreeAndReset(&buf);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxConnectGetCapabilities(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n\n    return virCapabilitiesFormatXML(priv->caps);\n}"
  },
  {
    "function_name": "esxNodeGetInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1170-1309",
    "snippet": "static int\nesxNodeGetInfo(virConnectPtr conn, virNodeInfoPtr nodeinfo)\n{\n    int result = -1;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    int64_t cpuInfo_hz = 0;\n    int16_t cpuInfo_numCpuCores = 0;\n    int16_t cpuInfo_numCpuPackages = 0;\n    int16_t cpuInfo_numCpuThreads = 0;\n    int64_t memorySize = 0;\n    int32_t numaInfo_numNodes = 0;\n    char *ptr = NULL;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"hardware.cpuInfo.hz\\0\"\n                                           \"hardware.cpuInfo.numCpuCores\\0\"\n                                           \"hardware.cpuInfo.numCpuPackages\\0\"\n                                           \"hardware.cpuInfo.numCpuThreads\\0\"\n                                           \"hardware.memorySize\\0\"\n                                           \"hardware.numaInfo.numNodes\\0\"\n                                           \"summary.hardware.cpuModel\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuInfo.hz\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_hz = dynamicProperty->val->int64;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuCores\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuCores = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuPackages\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuPackages = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuThreads\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuThreads = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name, \"hardware.memorySize\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            memorySize = dynamicProperty->val->int64;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.numaInfo.numNodes\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            numaInfo_numNodes = dynamicProperty->val->int32;\n        } else if (STREQ(dynamicProperty->name,\n                         \"summary.hardware.cpuModel\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            ptr = dynamicProperty->val->string;\n\n            /* Strip the string to fit more relevant information in 32 chars */\n            while (*ptr != '\\0') {\n                if (STRPREFIX(ptr, \"  \")) {\n                    memmove(ptr, ptr + 1, strlen(ptr + 1) + 1);\n                    continue;\n                } else if (STRPREFIX(ptr, \"(R)\") || STRPREFIX(ptr, \"(C)\")) {\n                    memmove(ptr, ptr + 3, strlen(ptr + 3) + 1);\n                    continue;\n                } else if (STRPREFIX(ptr, \"(TM)\")) {\n                    memmove(ptr, ptr + 4, strlen(ptr + 4) + 1);\n                    continue;\n                }\n\n                ++ptr;\n            }\n\n            /* Make sure the string fits in mode */\n            dynamicProperty->val->string[sizeof(nodeinfo->model) - 1] = '\\0';\n            if (virStrcpyStatic(nodeinfo->model, dynamicProperty->val->string) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"CPU Model %s too long for destination\"),\n                               dynamicProperty->val->string);\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    nodeinfo->memory = memorySize / 1024; /* Scale from bytes to kilobytes */\n    nodeinfo->cpus = cpuInfo_numCpuCores;\n    nodeinfo->mhz = cpuInfo_hz / (1000 * 1000); /* Scale from hz to mhz */\n    nodeinfo->nodes = numaInfo_numNodes;\n    nodeinfo->sockets = cpuInfo_numCpuPackages;\n    nodeinfo->cores = cpuInfo_numCpuPackages > 0\n                        ? cpuInfo_numCpuCores / cpuInfo_numCpuPackages\n                        : 0;\n    nodeinfo->threads = cpuInfo_numCpuCores > 0\n                          ? cpuInfo_numCpuThreads / cpuInfo_numCpuCores\n                          : 0;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU Model %s too long for destination\")",
            "dynamicProperty->val->string"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU Model %s too long for destination\""
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "nodeinfo->model",
            "dynamicProperty->val->string"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr",
            "ptr + 4",
            "strlen(ptr + 4) + 1"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr + 4"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ptr",
            "\"(TM)\""
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr",
            "ptr + 3",
            "strlen(ptr + 3) + 1"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr + 3"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ptr",
            "\"(C)\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ptr",
            "\"(R)\""
          ],
          "line": 1266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "ptr",
            "ptr + 1",
            "strlen(ptr + 1) + 1"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ptr + 1"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ptr",
            "\"  \""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_String"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"summary.hardware.cpuModel\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.numaInfo.numNodes\""
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.memorySize\""
          ],
          "line": 1237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.cpuInfo.numCpuThreads\""
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.cpuInfo.numCpuPackages\""
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.cpuInfo.numCpuCores\""
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.cpuInfo.hz\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"hardware.cpuInfo.hz\\0\"\n                                           \"hardware.cpuInfo.numCpuCores\\0\"\n                                           \"hardware.cpuInfo.numCpuPackages\\0\"\n                                           \"hardware.cpuInfo.numCpuThreads\\0\"\n                                           \"hardware.memorySize\\0\"\n                                           \"hardware.numaInfo.numNodes\\0\"\n                                           \"summary.hardware.cpuModel\\0\""
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "nodeinfo",
            "0",
            "sizeof(*nodeinfo)"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxNodeGetInfo(virConnectPtr conn, virNodeInfoPtr nodeinfo)\n{\n    int result = -1;\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    int64_t cpuInfo_hz = 0;\n    int16_t cpuInfo_numCpuCores = 0;\n    int16_t cpuInfo_numCpuPackages = 0;\n    int16_t cpuInfo_numCpuThreads = 0;\n    int64_t memorySize = 0;\n    int32_t numaInfo_numNodes = 0;\n    char *ptr = NULL;\n\n    memset(nodeinfo, 0, sizeof(*nodeinfo));\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"hardware.cpuInfo.hz\\0\"\n                                           \"hardware.cpuInfo.numCpuCores\\0\"\n                                           \"hardware.cpuInfo.numCpuPackages\\0\"\n                                           \"hardware.cpuInfo.numCpuThreads\\0\"\n                                           \"hardware.memorySize\\0\"\n                                           \"hardware.numaInfo.numNodes\\0\"\n                                           \"summary.hardware.cpuModel\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuInfo.hz\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_hz = dynamicProperty->val->int64;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuCores\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuCores = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuPackages\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuPackages = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.cpuInfo.numCpuThreads\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Short) < 0) {\n                goto cleanup;\n            }\n\n            cpuInfo_numCpuThreads = dynamicProperty->val->int16;\n        } else if (STREQ(dynamicProperty->name, \"hardware.memorySize\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Long) < 0) {\n                goto cleanup;\n            }\n\n            memorySize = dynamicProperty->val->int64;\n        } else if (STREQ(dynamicProperty->name,\n                         \"hardware.numaInfo.numNodes\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Int) < 0) {\n                goto cleanup;\n            }\n\n            numaInfo_numNodes = dynamicProperty->val->int32;\n        } else if (STREQ(dynamicProperty->name,\n                         \"summary.hardware.cpuModel\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            ptr = dynamicProperty->val->string;\n\n            /* Strip the string to fit more relevant information in 32 chars */\n            while (*ptr != '\\0') {\n                if (STRPREFIX(ptr, \"  \")) {\n                    memmove(ptr, ptr + 1, strlen(ptr + 1) + 1);\n                    continue;\n                } else if (STRPREFIX(ptr, \"(R)\") || STRPREFIX(ptr, \"(C)\")) {\n                    memmove(ptr, ptr + 3, strlen(ptr + 3) + 1);\n                    continue;\n                } else if (STRPREFIX(ptr, \"(TM)\")) {\n                    memmove(ptr, ptr + 4, strlen(ptr + 4) + 1);\n                    continue;\n                }\n\n                ++ptr;\n            }\n\n            /* Make sure the string fits in mode */\n            dynamicProperty->val->string[sizeof(nodeinfo->model) - 1] = '\\0';\n            if (virStrcpyStatic(nodeinfo->model, dynamicProperty->val->string) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"CPU Model %s too long for destination\"),\n                               dynamicProperty->val->string);\n                goto cleanup;\n            }\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    nodeinfo->memory = memorySize / 1024; /* Scale from bytes to kilobytes */\n    nodeinfo->cpus = cpuInfo_numCpuCores;\n    nodeinfo->mhz = cpuInfo_hz / (1000 * 1000); /* Scale from hz to mhz */\n    nodeinfo->nodes = numaInfo_numNodes;\n    nodeinfo->sockets = cpuInfo_numCpuPackages;\n    nodeinfo->cores = cpuInfo_numCpuPackages > 0\n                        ? cpuInfo_numCpuCores / cpuInfo_numCpuPackages\n                        : 0;\n    nodeinfo->threads = cpuInfo_numCpuCores > 0\n                          ? cpuInfo_numCpuThreads / cpuInfo_numCpuCores\n                          : 0;\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectGetHostname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1103-1166",
    "snippet": "static char *\nesxConnectGetHostname(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    const char *hostName = NULL;\n    const char *domainName = NULL;\n    char *complete = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList\n          (&propertyNameList,\n           \"config.network.dnsConfig.hostName\\0\"\n           \"config.network.dnsConfig.domainName\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.network.dnsConfig.hostName\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            hostName = dynamicProperty->val->string;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.network.dnsConfig.domainName\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            domainName = dynamicProperty->val->string;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostName || strlen(hostName) < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or empty 'hostName' property\"));\n        goto cleanup;\n    }\n\n    if (!domainName || strlen(domainName) < 1) {\n        complete = g_strdup(hostName);\n    } else {\n        complete = g_strdup_printf(\"%s.%s\", hostName, domainName);\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return complete;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.%s\"",
            "hostName",
            "domainName"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domainName"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing or empty 'hostName' property\")"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or empty 'hostName' property\""
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hostName"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_AnyType_ExpectType",
          "args": [
            "dynamicProperty->val",
            "esxVI_Type_String"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_AnyType_ExpectType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "918-930",
          "snippet": "int\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_AnyType_ExpectType(esxVI_AnyType *anyType, esxVI_Type type)\n{\n    if (anyType->type != type) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting type '%s' but found '%s'\"),\n                       esxVI_Type_ToString(type),\n                       esxVI_AnyType_TypeToString(anyType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.network.dnsConfig.domainName\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"config.network.dnsConfig.hostName\""
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"config.network.dnsConfig.hostName\\0\"\n           \"config.network.dnsConfig.domainName\\0\""
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxConnectGetHostname(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    const char *hostName = NULL;\n    const char *domainName = NULL;\n    char *complete = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return NULL;\n\n    if (esxVI_String_AppendValueListToList\n          (&propertyNameList,\n           \"config.network.dnsConfig.hostName\\0\"\n           \"config.network.dnsConfig.domainName\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name,\n                  \"config.network.dnsConfig.hostName\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            hostName = dynamicProperty->val->string;\n        } else if (STREQ(dynamicProperty->name,\n                         \"config.network.dnsConfig.domainName\")) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                goto cleanup;\n            }\n\n            domainName = dynamicProperty->val->string;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!hostName || strlen(hostName) < 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Missing or empty 'hostName' property\"));\n        goto cleanup;\n    }\n\n    if (!domainName || strlen(domainName) < 1) {\n        complete = g_strdup(hostName);\n    } else {\n        complete = g_strdup_printf(\"%s.%s\", hostName, domainName);\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return complete;\n}"
  },
  {
    "function_name": "esxConnectGetVersion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1091-1099",
    "snippet": "static int\nesxConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    esxPrivate *priv = conn->privateData;\n\n    *version = priv->primary->productVersion;\n\n    return 0;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectGetVersion(virConnectPtr conn, unsigned long *version)\n{\n    esxPrivate *priv = conn->privateData;\n\n    *version = priv->primary->productVersion;\n\n    return 0;\n}"
  },
  {
    "function_name": "esxConnectGetType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1083-1087",
    "snippet": "static const char *\nesxConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"ESX\";\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic const char *\nesxConnectGetType(virConnectPtr conn G_GNUC_UNUSED)\n{\n    return \"ESX\";\n}"
  },
  {
    "function_name": "esxConnectSupportsFeature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1045-1079",
    "snippet": "static int\nesxConnectSupportsFeature(virConnectPtr conn, int feature)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_Boolean supportsVMotion = esxVI_Boolean_Undefined;\n\n    switch ((virDrvFeature) feature) {\n      case VIR_DRV_FEATURE_MIGRATION_V1:\n        supportsVMotion = esxSupportsVMotion(priv);\n\n        if (supportsVMotion == esxVI_Boolean_Undefined)\n            return -1;\n\n        /* Migration is only possible via a vCenter and if VMotion is enabled */\n        return priv->vCenter &&\n               supportsVMotion == esxVI_Boolean_True ? 1 : 0;\n\n    case VIR_DRV_FEATURE_FD_PASSING:\n    case VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION:\n    case VIR_DRV_FEATURE_MIGRATION_DIRECT:\n    case VIR_DRV_FEATURE_MIGRATION_OFFLINE:\n    case VIR_DRV_FEATURE_MIGRATION_P2P:\n    case VIR_DRV_FEATURE_MIGRATION_PARAMS:\n    case VIR_DRV_FEATURE_MIGRATION_V2:\n    case VIR_DRV_FEATURE_MIGRATION_V3:\n    case VIR_DRV_FEATURE_PROGRAM_KEEPALIVE:\n    case VIR_DRV_FEATURE_REMOTE:\n    case VIR_DRV_FEATURE_REMOTE_CLOSE_CALLBACK:\n    case VIR_DRV_FEATURE_REMOTE_EVENT_CALLBACK:\n    case VIR_DRV_FEATURE_TYPED_PARAM_STRING:\n    case VIR_DRV_FEATURE_XML_MIGRATABLE:\n    default:\n        return 0;\n    }\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxSupportsVMotion",
          "args": [
            "priv"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "esxSupportsVMotion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "976-1007",
          "snippet": "static esxVI_Boolean\nesxSupportsVMotion(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsVMotion != esxVI_Boolean_Undefined)\n        return priv->supportsVMotion;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.vmotionSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.vmotionSupported\",\n                         &priv->supportsVMotion,\n                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsVMotion is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsVMotion;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsVMotion(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsVMotion != esxVI_Boolean_Undefined)\n        return priv->supportsVMotion;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.vmotionSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.vmotionSupported\",\n                         &priv->supportsVMotion,\n                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsVMotion is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsVMotion;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectSupportsFeature(virConnectPtr conn, int feature)\n{\n    esxPrivate *priv = conn->privateData;\n    esxVI_Boolean supportsVMotion = esxVI_Boolean_Undefined;\n\n    switch ((virDrvFeature) feature) {\n      case VIR_DRV_FEATURE_MIGRATION_V1:\n        supportsVMotion = esxSupportsVMotion(priv);\n\n        if (supportsVMotion == esxVI_Boolean_Undefined)\n            return -1;\n\n        /* Migration is only possible via a vCenter and if VMotion is enabled */\n        return priv->vCenter &&\n               supportsVMotion == esxVI_Boolean_True ? 1 : 0;\n\n    case VIR_DRV_FEATURE_FD_PASSING:\n    case VIR_DRV_FEATURE_MIGRATE_CHANGE_PROTECTION:\n    case VIR_DRV_FEATURE_MIGRATION_DIRECT:\n    case VIR_DRV_FEATURE_MIGRATION_OFFLINE:\n    case VIR_DRV_FEATURE_MIGRATION_P2P:\n    case VIR_DRV_FEATURE_MIGRATION_PARAMS:\n    case VIR_DRV_FEATURE_MIGRATION_V2:\n    case VIR_DRV_FEATURE_MIGRATION_V3:\n    case VIR_DRV_FEATURE_PROGRAM_KEEPALIVE:\n    case VIR_DRV_FEATURE_REMOTE:\n    case VIR_DRV_FEATURE_REMOTE_CLOSE_CALLBACK:\n    case VIR_DRV_FEATURE_REMOTE_EVENT_CALLBACK:\n    case VIR_DRV_FEATURE_TYPED_PARAM_STRING:\n    case VIR_DRV_FEATURE_XML_MIGRATABLE:\n    default:\n        return 0;\n    }\n}"
  },
  {
    "function_name": "esxSupportsScreenshot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "1011-1041",
    "snippet": "static esxVI_Boolean\nesxSupportsScreenshot(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsScreenshot != esxVI_Boolean_Undefined)\n        return priv->supportsScreenshot;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.screenshotSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.screenshotSupported\",\n                         &priv->supportsScreenshot,\n                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsScreenshot is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsScreenshot;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetBoolean",
          "args": [
            "hostSystem",
            "\"capability.screenshotSupported\"",
            "&priv->supportsScreenshot",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2229-2261",
          "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"capability.screenshotSupported\""
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsScreenshot(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsScreenshot != esxVI_Boolean_Undefined)\n        return priv->supportsScreenshot;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.screenshotSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.screenshotSupported\",\n                         &priv->supportsScreenshot,\n                         esxVI_Occurrence_RequiredItem) < 0)\n        goto cleanup;\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsScreenshot is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsScreenshot;\n}"
  },
  {
    "function_name": "esxSupportsVMotion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "976-1007",
    "snippet": "static esxVI_Boolean\nesxSupportsVMotion(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsVMotion != esxVI_Boolean_Undefined)\n        return priv->supportsVMotion;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.vmotionSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.vmotionSupported\",\n                         &priv->supportsVMotion,\n                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsVMotion is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsVMotion;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetBoolean",
          "args": [
            "hostSystem",
            "\"capability.vmotionSupported\"",
            "&priv->supportsVMotion",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2229-2261",
          "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 990
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"capability.vmotionSupported\""
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsVMotion(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n\n    if (priv->supportsVMotion != esxVI_Boolean_Undefined)\n        return priv->supportsVMotion;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"capability.vmotionSupported\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"capability.vmotionSupported\",\n                         &priv->supportsVMotion,\n                         esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsVMotion is\n     * still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return priv->supportsVMotion;\n}"
  },
  {
    "function_name": "esxConnectClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "947-972",
    "snippet": "static int\nesxConnectClose(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    int result = 0;\n\n    if (priv->host) {\n        if (esxVI_EnsureSession(priv->host) < 0 ||\n            esxVI_Logout(priv->host) < 0) {\n            result = -1;\n        }\n    }\n\n    if (priv->vCenter) {\n        if (esxVI_EnsureSession(priv->vCenter) < 0 ||\n            esxVI_Logout(priv->vCenter) < 0) {\n            result = -1;\n        }\n    }\n\n    esxFreePrivate(&priv);\n\n    conn->privateData = NULL;\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxFreePrivate",
          "args": [
            "&priv"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "esxFreePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "63-75",
          "snippet": "static void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Logout",
          "args": [
            "priv->vCenter"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->vCenter"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Logout",
          "args": [
            "priv->host"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectClose(virConnectPtr conn)\n{\n    esxPrivate *priv = conn->privateData;\n    int result = 0;\n\n    if (priv->host) {\n        if (esxVI_EnsureSession(priv->host) < 0 ||\n            esxVI_Logout(priv->host) < 0) {\n            result = -1;\n        }\n    }\n\n    if (priv->vCenter) {\n        if (esxVI_EnsureSession(priv->vCenter) < 0 ||\n            esxVI_Logout(priv->vCenter) < 0) {\n            result = -1;\n        }\n    }\n\n    esxFreePrivate(&priv);\n\n    conn->privateData = NULL;\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "810-943",
    "snippet": "static virDrvOpenStatus\nesxConnectOpen(virConnectPtr conn, virConnectAuthPtr auth,\n               virConfPtr conf G_GNUC_UNUSED,\n               unsigned int flags)\n{\n    virDrvOpenStatus result = VIR_DRV_OPEN_ERROR;\n    esxPrivate *priv = NULL;\n    char *potentialVCenterIPAddress = NULL;\n    char vCenterIPAddress[NI_MAXHOST] = \"\";\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (STRCASENEQ(conn->uri->scheme, \"vpx\") &&\n        STRNEQ(conn->uri->path, \"/\")) {\n        VIR_WARN(\"Ignoring unexpected path '%s' for non-vpx scheme '%s'\",\n                 conn->uri->path, conn->uri->scheme);\n    }\n\n    /* Allocate per-connection private data */\n    if (VIR_ALLOC(priv) < 0)\n        goto cleanup;\n\n    if (esxUtil_ParseUri(&priv->parsedUri, conn->uri) < 0)\n        goto cleanup;\n\n    priv->maxVcpus = -1;\n    priv->supportsVMotion = esxVI_Boolean_Undefined;\n    priv->supportsLongMode = esxVI_Boolean_Undefined;\n    priv->supportsScreenshot = esxVI_Boolean_Undefined;\n    priv->usedCpuTimeCounterId = -1;\n\n    /*\n     * Set the port dependent on the transport protocol if no port is\n     * specified. This allows us to rely on the port parameter being\n     * correctly set when building URIs later on, without the need to\n     * distinguish between the situations port == 0 and port != 0\n     */\n    if (conn->uri->port == 0) {\n        if (STRCASEEQ(conn->uri->scheme, \"vpx\") ||\n            STRCASEEQ(conn->uri->scheme, \"esx\")) {\n            if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n                conn->uri->port = 443;\n            } else {\n                conn->uri->port = 80;\n            }\n        } else { /* GSX */\n            if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n                conn->uri->port = 8333;\n            } else {\n                conn->uri->port = 8222;\n            }\n        }\n    }\n\n    if (STRCASEEQ(conn->uri->scheme, \"esx\") ||\n        STRCASEEQ(conn->uri->scheme, \"gsx\")) {\n        /* Connect to host */\n        if (esxConnectToHost(priv, conn, auth,\n                             &potentialVCenterIPAddress) < 0) {\n            goto cleanup;\n        }\n\n        /* Connect to vCenter */\n        if (priv->parsedUri->vCenter) {\n            if (STREQ(priv->parsedUri->vCenter, \"*\")) {\n                if (!potentialVCenterIPAddress) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"This host is not managed by a vCenter\"));\n                    goto cleanup;\n                }\n\n                if (virStrcpyStatic(vCenterIPAddress,\n                                    potentialVCenterIPAddress) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vCenter IP address %s too big for destination\"),\n                                   potentialVCenterIPAddress);\n                    goto cleanup;\n                }\n            } else {\n                if (esxUtil_ResolveHostname(priv->parsedUri->vCenter,\n                                            vCenterIPAddress, NI_MAXHOST) < 0) {\n                    goto cleanup;\n                }\n\n                if (potentialVCenterIPAddress &&\n                    STRNEQ(vCenterIPAddress, potentialVCenterIPAddress)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"This host is managed by a vCenter with IP \"\n                                     \"address %s, but a mismatching vCenter '%s' \"\n                                     \"(%s) has been specified\"),\n                                   potentialVCenterIPAddress, priv->parsedUri->vCenter,\n                                   vCenterIPAddress);\n                    goto cleanup;\n                }\n            }\n\n            if (esxConnectToVCenter(priv, conn, auth,\n                                    vCenterIPAddress,\n                                    priv->host->ipAddress) < 0) {\n                goto cleanup;\n            }\n        }\n\n        priv->primary = priv->host;\n    } else { /* VPX */\n        /* Connect to vCenter */\n        if (esxConnectToVCenter(priv, conn, auth,\n                                conn->uri->server,\n                                NULL) < 0) {\n            goto cleanup;\n        }\n\n        priv->primary = priv->vCenter;\n    }\n\n    /* Setup capabilities */\n    priv->caps = esxCapsInit(priv);\n\n    if (!priv->caps)\n        goto cleanup;\n\n    if (!(priv->xmlopt = virVMXDomainXMLConfInit(priv->caps)))\n        goto cleanup;\n\n    conn->privateData = priv;\n    priv = NULL;\n    result = VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    esxFreePrivate(&priv);\n    VIR_FREE(potentialVCenterIPAddress);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "potentialVCenterIPAddress"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxFreePrivate",
          "args": [
            "&priv"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "esxFreePrivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "63-75",
          "snippet": "static void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virVMXDomainXMLConfInit",
          "args": [
            "priv->caps"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virVMXDomainXMLConfInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/vmx/vmx.c",
          "lines": "611-617",
          "snippet": "virDomainXMLOptionPtr\nvirVMXDomainXMLConfInit(virCapsPtr caps)\n{\n    virVMXDomainDefParserConfig.priv = caps;\n    return virDomainXMLOptionNew(&virVMXDomainDefParserConfig, NULL,\n                                 &virVMXDomainXMLNamespace, NULL, NULL);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"viruri.h\"",
            "#include \"vmx.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virDomainDefParserConfig virVMXDomainDefParserConfig = {\n    .macPrefix = {0x00, 0x0c, 0x29},\n    .devicesPostParseCallback = virVMXDomainDevicesDefPostParse,\n    .domainPostParseCallback = virVMXDomainDefPostParse,\n    .features = (VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI |\n                 VIR_DOMAIN_DEF_FEATURE_NAME_SLASH |\n                 VIR_DOMAIN_DEF_FEATURE_NO_BOOT_ORDER),\n    .defArch = VIR_ARCH_I686,\n};",
            "static virXMLNamespace virVMXDomainXMLNamespace = {\n    .parse = NULL,\n    .free = virVMXDomainDefNamespaceFree,\n    .format = virVMXDomainDefNamespaceFormatXML,\n    .prefix = \"vmware\",\n    .uri = \"http://libvirt.org/schemas/domain/vmware/1.0\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"viruri.h\"\n#include \"vmx.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDefParserConfig virVMXDomainDefParserConfig = {\n    .macPrefix = {0x00, 0x0c, 0x29},\n    .devicesPostParseCallback = virVMXDomainDevicesDefPostParse,\n    .domainPostParseCallback = virVMXDomainDefPostParse,\n    .features = (VIR_DOMAIN_DEF_FEATURE_WIDE_SCSI |\n                 VIR_DOMAIN_DEF_FEATURE_NAME_SLASH |\n                 VIR_DOMAIN_DEF_FEATURE_NO_BOOT_ORDER),\n    .defArch = VIR_ARCH_I686,\n};\nstatic virXMLNamespace virVMXDomainXMLNamespace = {\n    .parse = NULL,\n    .free = virVMXDomainDefNamespaceFree,\n    .format = virVMXDomainDefNamespaceFormatXML,\n    .prefix = \"vmware\",\n    .uri = \"http://libvirt.org/schemas/domain/vmware/1.0\",\n};\n\nvirDomainXMLOptionPtr\nvirVMXDomainXMLConfInit(virCapsPtr caps)\n{\n    virVMXDomainDefParserConfig.priv = caps;\n    return virDomainXMLOptionNew(&virVMXDomainDefParserConfig, NULL,\n                                 &virVMXDomainXMLNamespace, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxCapsInit",
          "args": [
            "priv"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "esxCapsInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "539-596",
          "snippet": "static virCapsPtr\nesxCapsInit(esxPrivate *priv)\n{\n    esxVI_Boolean supportsLongMode = esxSupportsLongMode(priv);\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if (supportsLongMode == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsLongMode == esxVI_Boolean_True) {\n        caps = virCapabilitiesNew(VIR_ARCH_X86_64, true, true);\n    } else {\n        caps = virCapabilitiesNew(VIR_ARCH_I686, true, true);\n    }\n\n    if (!caps)\n        return NULL;\n\n    virCapabilitiesAddHostMigrateTransport(caps, \"vpxmigr\");\n\n\n    if (esxLookupHostSystemBiosUuid(priv, caps->host.host_uuid) < 0)\n        goto failure;\n\n    /* i686 */\n    guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                    VIR_ARCH_I686,\n                                    NULL, NULL, 0,\n                                    NULL);\n\n    if (!guest)\n        goto failure;\n\n    if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n        goto failure;\n\n    /* x86_64 */\n    if (supportsLongMode == esxVI_Boolean_True) {\n        guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                        VIR_ARCH_X86_64,\n                                        NULL, NULL,\n                                        0, NULL);\n\n        if (!guest)\n            goto failure;\n\n        if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n            goto failure;\n    }\n\n    return caps;\n\n failure:\n    virObjectUnref(caps);\n\n    return NULL;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virCapsPtr\nesxCapsInit(esxPrivate *priv)\n{\n    esxVI_Boolean supportsLongMode = esxSupportsLongMode(priv);\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if (supportsLongMode == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsLongMode == esxVI_Boolean_True) {\n        caps = virCapabilitiesNew(VIR_ARCH_X86_64, true, true);\n    } else {\n        caps = virCapabilitiesNew(VIR_ARCH_I686, true, true);\n    }\n\n    if (!caps)\n        return NULL;\n\n    virCapabilitiesAddHostMigrateTransport(caps, \"vpxmigr\");\n\n\n    if (esxLookupHostSystemBiosUuid(priv, caps->host.host_uuid) < 0)\n        goto failure;\n\n    /* i686 */\n    guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                    VIR_ARCH_I686,\n                                    NULL, NULL, 0,\n                                    NULL);\n\n    if (!guest)\n        goto failure;\n\n    if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n        goto failure;\n\n    /* x86_64 */\n    if (supportsLongMode == esxVI_Boolean_True) {\n        guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                        VIR_ARCH_X86_64,\n                                        NULL, NULL,\n                                        0, NULL);\n\n        if (!guest)\n            goto failure;\n\n        if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n            goto failure;\n    }\n\n    return caps;\n\n failure:\n    virObjectUnref(caps);\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxConnectToVCenter",
          "args": [
            "priv",
            "conn",
            "auth",
            "conn->uri->server",
            "NULL"
          ],
          "line": 916
        },
        "resolved": true,
        "details": {
          "function_name": "esxConnectToVCenter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "689-761",
          "snippet": "static int\nesxConnectToVCenter(esxPrivate *priv,\n                    virConnectPtr conn,\n                    virConnectAuthPtr auth,\n                    const char *hostname,\n                    const char *hostSystemIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n\n    if (!hostSystemIPAddress &&\n        (!priv->parsedUri->path || STREQ(priv->parsedUri->path, \"/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Path has to specify the datacenter and compute resource\"));\n        return -1;\n    }\n\n    if (esxUtil_ResolveHostname(hostname, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"administrator\",\n                                            hostname)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username, hostname)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport, hostname,\n                          conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->vCenter) < 0 ||\n        esxVI_Context_Connect(priv->vCenter, url, ipAddress, username,\n                              password, priv->parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->vCenter->productLine != esxVI_ProductLine_VPX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       hostname,\n                       esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                       esxVI_ProductLineToDisplayName(priv->vCenter->productLine));\n        goto cleanup;\n    }\n\n    if (hostSystemIPAddress) {\n        if (esxVI_Context_LookupManagedObjectsByHostSystemIp\n              (priv->vCenter, hostSystemIPAddress) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (esxVI_Context_LookupManagedObjectsByPath(priv->vCenter,\n                                                     priv->parsedUri->path) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectToVCenter(esxPrivate *priv,\n                    virConnectPtr conn,\n                    virConnectAuthPtr auth,\n                    const char *hostname,\n                    const char *hostSystemIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n\n    if (!hostSystemIPAddress &&\n        (!priv->parsedUri->path || STREQ(priv->parsedUri->path, \"/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Path has to specify the datacenter and compute resource\"));\n        return -1;\n    }\n\n    if (esxUtil_ResolveHostname(hostname, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"administrator\",\n                                            hostname)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username, hostname)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport, hostname,\n                          conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->vCenter) < 0 ||\n        esxVI_Context_Connect(priv->vCenter, url, ipAddress, username,\n                              password, priv->parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->vCenter->productLine != esxVI_ProductLine_VPX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       hostname,\n                       esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                       esxVI_ProductLineToDisplayName(priv->vCenter->productLine));\n        goto cleanup;\n    }\n\n    if (hostSystemIPAddress) {\n        if (esxVI_Context_LookupManagedObjectsByHostSystemIp\n              (priv->vCenter, hostSystemIPAddress) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (esxVI_Context_LookupManagedObjectsByPath(priv->vCenter,\n                                                     priv->parsedUri->path) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"This host is managed by a vCenter with IP \"\n                                     \"address %s, but a mismatching vCenter '%s' \"\n                                     \"(%s) has been specified\")",
            "potentialVCenterIPAddress",
            "priv->parsedUri->vCenter",
            "vCenterIPAddress"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"This host is managed by a vCenter with IP \"\n                                     \"address %s, but a mismatching vCenter '%s' \"\n                                     \"(%s) has been specified\""
          ],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "vCenterIPAddress",
            "potentialVCenterIPAddress"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ResolveHostname",
          "args": [
            "priv->parsedUri->vCenter",
            "vCenterIPAddress",
            "NI_MAXHOST"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ResolveHostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "281-326",
          "snippet": "int\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"vCenter IP address %s too big for destination\")",
            "potentialVCenterIPAddress"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "vCenterIPAddress",
            "potentialVCenterIPAddress"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"This host is not managed by a vCenter\")"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "priv->parsedUri->vCenter",
            "\"*\""
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxConnectToHost",
          "args": [
            "priv",
            "conn",
            "auth",
            "&potentialVCenterIPAddress"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "esxConnectToHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "600-685",
          "snippet": "static int\nesxConnectToHost(esxPrivate *priv,\n                 virConnectPtr conn,\n                 virConnectAuthPtr auth,\n                 char **vCenterIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Boolean inMaintenanceMode = esxVI_Boolean_Undefined;\n    esxVI_ProductLine expectedProductLine = STRCASEEQ(conn->uri->scheme, \"esx\")\n        ? esxVI_ProductLine_ESX\n        : esxVI_ProductLine_GSX;\n\n    ESX_VI_CHECK_ARG_LIST(vCenterIPAddress);\n\n    if (esxUtil_ResolveHostname(conn->uri->server, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"root\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport,\n                          conn->uri->server, conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->host) < 0 ||\n        esxVI_Context_Connect(priv->host, url, ipAddress, username, password,\n                              priv->parsedUri) < 0 ||\n        esxVI_Context_LookupManagedObjects(priv->host) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->host->productLine != expectedProductLine) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       conn->uri->server,\n                       esxVI_ProductLineToDisplayName(expectedProductLine),\n                       esxVI_ProductLineToDisplayName(priv->host->productLine));\n        goto cleanup;\n    }\n\n    /* Query the host for maintenance mode and vCenter IP address */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.inMaintenanceMode\\0\"\n                                           \"summary.managementServerIp\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->host, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"runtime.inMaintenanceMode\",\n                         &inMaintenanceMode,\n                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"summary.managementServerIp\",\n                             vCenterIPAddress,\n                             esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Warn if host is in maintenance mode */\n    if (inMaintenanceMode == esxVI_Boolean_True)\n        VIR_WARN(\"The server is in maintenance mode\");\n\n    *vCenterIPAddress = g_strdup(*vCenterIPAddress);\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectToHost(esxPrivate *priv,\n                 virConnectPtr conn,\n                 virConnectAuthPtr auth,\n                 char **vCenterIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Boolean inMaintenanceMode = esxVI_Boolean_Undefined;\n    esxVI_ProductLine expectedProductLine = STRCASEEQ(conn->uri->scheme, \"esx\")\n        ? esxVI_ProductLine_ESX\n        : esxVI_ProductLine_GSX;\n\n    ESX_VI_CHECK_ARG_LIST(vCenterIPAddress);\n\n    if (esxUtil_ResolveHostname(conn->uri->server, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"root\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport,\n                          conn->uri->server, conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->host) < 0 ||\n        esxVI_Context_Connect(priv->host, url, ipAddress, username, password,\n                              priv->parsedUri) < 0 ||\n        esxVI_Context_LookupManagedObjects(priv->host) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->host->productLine != expectedProductLine) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       conn->uri->server,\n                       esxVI_ProductLineToDisplayName(expectedProductLine),\n                       esxVI_ProductLineToDisplayName(priv->host->productLine));\n        goto cleanup;\n    }\n\n    /* Query the host for maintenance mode and vCenter IP address */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.inMaintenanceMode\\0\"\n                                           \"summary.managementServerIp\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->host, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"runtime.inMaintenanceMode\",\n                         &inMaintenanceMode,\n                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"summary.managementServerIp\",\n                             vCenterIPAddress,\n                             esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Warn if host is in maintenance mode */\n    if (inMaintenanceMode == esxVI_Boolean_True)\n        VIR_WARN(\"The server is in maintenance mode\");\n\n    *vCenterIPAddress = g_strdup(*vCenterIPAddress);\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "conn->uri->scheme",
            "\"gsx\""
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "conn->uri->scheme",
            "\"esx\""
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "priv->parsedUri->transport",
            "\"https\""
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "conn->uri->scheme",
            "\"esx\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "conn->uri->scheme",
            "\"vpx\""
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseUri",
          "args": [
            "&priv->parsedUri",
            "conn->uri"
          ],
          "line": 832
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseUri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "41-164",
          "snippet": "int\nesxUtil_ParseUri(esxUtil_ParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n    int noVerify;\n    int autoAnswer;\n    char *tmp;\n\n    ESX_VI_CHECK_ARG_LIST(parsedUri);\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else if (STRCASEEQ(queryParam->name, \"vcenter\")) {\n            VIR_FREE((*parsedUri)->vCenter);\n\n            (*parsedUri)->vCenter = g_strdup(queryParam->value);\n        } else if (STRCASEEQ(queryParam->name, \"no_verify\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &noVerify) < 0 ||\n                (noVerify != 0 && noVerify != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'no_verify' has unexpected value \"\n                                 \"'%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->noVerify = noVerify != 0;\n        } else if (STRCASEEQ(queryParam->name, \"auto_answer\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &autoAnswer) < 0 ||\n                (autoAnswer != 0 && autoAnswer != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'auto_answer' has unexpected \"\n                                 \"value '%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->autoAnswer = autoAnswer != 0;\n        } else if (STRCASEEQ(queryParam->name, \"proxy\")) {\n            /* Expected format: [<type>://]<hostname>[:<port>] */\n            (*parsedUri)->proxy = true;\n            (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            VIR_FREE((*parsedUri)->proxy_hostname);\n            (*parsedUri)->proxy_port = 1080;\n\n            if ((tmp = STRSKIP(queryParam->value, \"http://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks://\")) ||\n                       (tmp = STRSKIP(queryParam->value, \"socks5://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS5;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4a://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4A;\n            } else if ((tmp = strstr(queryParam->value, \"://\"))) {\n                *tmp = '\\0';\n\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'proxy' contains unexpected \"\n                                 \"type '%s' (should be (http|socks(|4|4a|5))\"),\n                               queryParam->value);\n                goto cleanup;\n            } else {\n                tmp = queryParam->value;\n            }\n\n            (*parsedUri)->proxy_hostname = g_strdup(tmp);\n\n            if ((tmp = strchr((*parsedUri)->proxy_hostname, ':'))) {\n                if (tmp == (*parsedUri)->proxy_hostname) {\n                    virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                                   _(\"Query parameter 'proxy' doesn't contain a \"\n                                     \"hostname\"));\n                    goto cleanup;\n                }\n\n                *tmp++ = '\\0';\n\n                if (virStrToLong_i(tmp, NULL, 10,\n                                   &(*parsedUri)->proxy_port) < 0 ||\n                    (*parsedUri)->proxy_port < 1 ||\n                    (*parsedUri)->proxy_port > 65535) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\"),\n                                   tmp);\n                    goto cleanup;\n                }\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    (*parsedUri)->path = g_strdup(uri->path);\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxUtil_FreeParsedUri(parsedUri);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseUri(esxUtil_ParsedUri **parsedUri, virURIPtr uri)\n{\n    int result = -1;\n    size_t i;\n    int noVerify;\n    int autoAnswer;\n    char *tmp;\n\n    ESX_VI_CHECK_ARG_LIST(parsedUri);\n\n    if (VIR_ALLOC(*parsedUri) < 0)\n        return -1;\n\n    for (i = 0; i < uri->paramsCount; i++) {\n        virURIParamPtr queryParam = &uri->params[i];\n\n        if (STRCASEEQ(queryParam->name, \"transport\")) {\n            VIR_FREE((*parsedUri)->transport);\n\n            (*parsedUri)->transport = g_strdup(queryParam->value);\n\n            if (STRNEQ((*parsedUri)->transport, \"http\") &&\n                STRNEQ((*parsedUri)->transport, \"https\")) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'transport' has unexpected value \"\n                                 \"'%s' (should be http|https)\"),\n                               (*parsedUri)->transport);\n                goto cleanup;\n            }\n        } else if (STRCASEEQ(queryParam->name, \"vcenter\")) {\n            VIR_FREE((*parsedUri)->vCenter);\n\n            (*parsedUri)->vCenter = g_strdup(queryParam->value);\n        } else if (STRCASEEQ(queryParam->name, \"no_verify\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &noVerify) < 0 ||\n                (noVerify != 0 && noVerify != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'no_verify' has unexpected value \"\n                                 \"'%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->noVerify = noVerify != 0;\n        } else if (STRCASEEQ(queryParam->name, \"auto_answer\")) {\n            if (virStrToLong_i(queryParam->value, NULL, 10, &autoAnswer) < 0 ||\n                (autoAnswer != 0 && autoAnswer != 1)) {\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'auto_answer' has unexpected \"\n                                 \"value '%s' (should be 0 or 1)\"), queryParam->value);\n                goto cleanup;\n            }\n\n            (*parsedUri)->autoAnswer = autoAnswer != 0;\n        } else if (STRCASEEQ(queryParam->name, \"proxy\")) {\n            /* Expected format: [<type>://]<hostname>[:<port>] */\n            (*parsedUri)->proxy = true;\n            (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            VIR_FREE((*parsedUri)->proxy_hostname);\n            (*parsedUri)->proxy_port = 1080;\n\n            if ((tmp = STRSKIP(queryParam->value, \"http://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_HTTP;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks://\")) ||\n                       (tmp = STRSKIP(queryParam->value, \"socks5://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS5;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4;\n            } else if ((tmp = STRSKIP(queryParam->value, \"socks4a://\"))) {\n                (*parsedUri)->proxy_type = CURLPROXY_SOCKS4A;\n            } else if ((tmp = strstr(queryParam->value, \"://\"))) {\n                *tmp = '\\0';\n\n                virReportError(VIR_ERR_INVALID_ARG,\n                               _(\"Query parameter 'proxy' contains unexpected \"\n                                 \"type '%s' (should be (http|socks(|4|4a|5))\"),\n                               queryParam->value);\n                goto cleanup;\n            } else {\n                tmp = queryParam->value;\n            }\n\n            (*parsedUri)->proxy_hostname = g_strdup(tmp);\n\n            if ((tmp = strchr((*parsedUri)->proxy_hostname, ':'))) {\n                if (tmp == (*parsedUri)->proxy_hostname) {\n                    virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                                   _(\"Query parameter 'proxy' doesn't contain a \"\n                                     \"hostname\"));\n                    goto cleanup;\n                }\n\n                *tmp++ = '\\0';\n\n                if (virStrToLong_i(tmp, NULL, 10,\n                                   &(*parsedUri)->proxy_port) < 0 ||\n                    (*parsedUri)->proxy_port < 1 ||\n                    (*parsedUri)->proxy_port > 65535) {\n                    virReportError(VIR_ERR_INVALID_ARG,\n                                   _(\"Query parameter 'proxy' has unexpected \"\n                                     \"port value '%s' (should be [1..65535])\"),\n                                   tmp);\n                    goto cleanup;\n                }\n            }\n        } else {\n            VIR_WARN(\"Ignoring unexpected query parameter '%s'\",\n                     queryParam->name);\n        }\n    }\n\n    (*parsedUri)->path = g_strdup(uri->path);\n\n    if (!(*parsedUri)->transport)\n        (*parsedUri)->transport = g_strdup(\"https\");\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        esxUtil_FreeParsedUri(parsedUri);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "priv"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Ignoring unexpected path '%s' for non-vpx scheme '%s'\"",
            "conn->uri->path",
            "conn->uri->scheme"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "conn->uri->path",
            "\"/\""
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASENEQ",
          "args": [
            "conn->uri->scheme",
            "\"vpx\""
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_CONNECT_RO",
            "VIR_DRV_OPEN_ERROR"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDrvOpenStatus\nesxConnectOpen(virConnectPtr conn, virConnectAuthPtr auth,\n               virConfPtr conf G_GNUC_UNUSED,\n               unsigned int flags)\n{\n    virDrvOpenStatus result = VIR_DRV_OPEN_ERROR;\n    esxPrivate *priv = NULL;\n    char *potentialVCenterIPAddress = NULL;\n    char vCenterIPAddress[NI_MAXHOST] = \"\";\n\n    virCheckFlags(VIR_CONNECT_RO, VIR_DRV_OPEN_ERROR);\n\n    if (STRCASENEQ(conn->uri->scheme, \"vpx\") &&\n        STRNEQ(conn->uri->path, \"/\")) {\n        VIR_WARN(\"Ignoring unexpected path '%s' for non-vpx scheme '%s'\",\n                 conn->uri->path, conn->uri->scheme);\n    }\n\n    /* Allocate per-connection private data */\n    if (VIR_ALLOC(priv) < 0)\n        goto cleanup;\n\n    if (esxUtil_ParseUri(&priv->parsedUri, conn->uri) < 0)\n        goto cleanup;\n\n    priv->maxVcpus = -1;\n    priv->supportsVMotion = esxVI_Boolean_Undefined;\n    priv->supportsLongMode = esxVI_Boolean_Undefined;\n    priv->supportsScreenshot = esxVI_Boolean_Undefined;\n    priv->usedCpuTimeCounterId = -1;\n\n    /*\n     * Set the port dependent on the transport protocol if no port is\n     * specified. This allows us to rely on the port parameter being\n     * correctly set when building URIs later on, without the need to\n     * distinguish between the situations port == 0 and port != 0\n     */\n    if (conn->uri->port == 0) {\n        if (STRCASEEQ(conn->uri->scheme, \"vpx\") ||\n            STRCASEEQ(conn->uri->scheme, \"esx\")) {\n            if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n                conn->uri->port = 443;\n            } else {\n                conn->uri->port = 80;\n            }\n        } else { /* GSX */\n            if (STRCASEEQ(priv->parsedUri->transport, \"https\")) {\n                conn->uri->port = 8333;\n            } else {\n                conn->uri->port = 8222;\n            }\n        }\n    }\n\n    if (STRCASEEQ(conn->uri->scheme, \"esx\") ||\n        STRCASEEQ(conn->uri->scheme, \"gsx\")) {\n        /* Connect to host */\n        if (esxConnectToHost(priv, conn, auth,\n                             &potentialVCenterIPAddress) < 0) {\n            goto cleanup;\n        }\n\n        /* Connect to vCenter */\n        if (priv->parsedUri->vCenter) {\n            if (STREQ(priv->parsedUri->vCenter, \"*\")) {\n                if (!potentialVCenterIPAddress) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"This host is not managed by a vCenter\"));\n                    goto cleanup;\n                }\n\n                if (virStrcpyStatic(vCenterIPAddress,\n                                    potentialVCenterIPAddress) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"vCenter IP address %s too big for destination\"),\n                                   potentialVCenterIPAddress);\n                    goto cleanup;\n                }\n            } else {\n                if (esxUtil_ResolveHostname(priv->parsedUri->vCenter,\n                                            vCenterIPAddress, NI_MAXHOST) < 0) {\n                    goto cleanup;\n                }\n\n                if (potentialVCenterIPAddress &&\n                    STRNEQ(vCenterIPAddress, potentialVCenterIPAddress)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"This host is managed by a vCenter with IP \"\n                                     \"address %s, but a mismatching vCenter '%s' \"\n                                     \"(%s) has been specified\"),\n                                   potentialVCenterIPAddress, priv->parsedUri->vCenter,\n                                   vCenterIPAddress);\n                    goto cleanup;\n                }\n            }\n\n            if (esxConnectToVCenter(priv, conn, auth,\n                                    vCenterIPAddress,\n                                    priv->host->ipAddress) < 0) {\n                goto cleanup;\n            }\n        }\n\n        priv->primary = priv->host;\n    } else { /* VPX */\n        /* Connect to vCenter */\n        if (esxConnectToVCenter(priv, conn, auth,\n                                conn->uri->server,\n                                NULL) < 0) {\n            goto cleanup;\n        }\n\n        priv->primary = priv->vCenter;\n    }\n\n    /* Setup capabilities */\n    priv->caps = esxCapsInit(priv);\n\n    if (!priv->caps)\n        goto cleanup;\n\n    if (!(priv->xmlopt = virVMXDomainXMLConfInit(priv->caps)))\n        goto cleanup;\n\n    conn->privateData = priv;\n    priv = NULL;\n    result = VIR_DRV_OPEN_SUCCESS;\n\n cleanup:\n    esxFreePrivate(&priv);\n    VIR_FREE(potentialVCenterIPAddress);\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectToVCenter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "689-761",
    "snippet": "static int\nesxConnectToVCenter(esxPrivate *priv,\n                    virConnectPtr conn,\n                    virConnectAuthPtr auth,\n                    const char *hostname,\n                    const char *hostSystemIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n\n    if (!hostSystemIPAddress &&\n        (!priv->parsedUri->path || STREQ(priv->parsedUri->path, \"/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Path has to specify the datacenter and compute resource\"));\n        return -1;\n    }\n\n    if (esxUtil_ResolveHostname(hostname, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"administrator\",\n                                            hostname)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username, hostname)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport, hostname,\n                          conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->vCenter) < 0 ||\n        esxVI_Context_Connect(priv->vCenter, url, ipAddress, username,\n                              password, priv->parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->vCenter->productLine != esxVI_ProductLine_VPX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       hostname,\n                       esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                       esxVI_ProductLineToDisplayName(priv->vCenter->productLine));\n        goto cleanup;\n    }\n\n    if (hostSystemIPAddress) {\n        if (esxVI_Context_LookupManagedObjectsByHostSystemIp\n              (priv->vCenter, hostSystemIPAddress) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (esxVI_Context_LookupManagedObjectsByPath(priv->vCenter,\n                                                     priv->parsedUri->path) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "url"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "password"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "username"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Context_LookupManagedObjectsByPath",
          "args": [
            "priv->vCenter",
            "priv->parsedUri->path"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Context_LookupManagedObjectsByPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1020-1199",
          "snippet": "int\nesxVI_Context_LookupManagedObjectsByPath(esxVI_Context *ctx, const char *path)\n{\n    int result = -1;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *previousItem = NULL;\n    char *item = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ManagedObjectReference *root = NULL;\n    esxVI_Folder *folder = NULL;\n\n    tmp = g_strdup(path);\n\n    /* Lookup Datacenter */\n    item = strtok_r(tmp, \"/\", &saveptr);\n\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a datacenter\"), path);\n        goto cleanup;\n    }\n\n    root = ctx->service->rootFolder;\n\n    while (!ctx->datacenter && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->service->rootFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a datacenter */\n            if (esxVI_LookupDatacenter(ctx, item, root, NULL, &ctx->datacenter,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build datacenter path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->datacenter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datacenter specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    ctx->datacenterPath = virBufferContentAndReset(&buffer);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a compute resource\"), path);\n        goto cleanup;\n    }\n\n    if (root != ctx->service->rootFolder)\n        esxVI_ManagedObjectReference_Free(&root);\n\n    root = ctx->datacenter->hostFolder;\n\n    while (!ctx->computeResource && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->datacenter->hostFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a compute resource */\n            if (esxVI_LookupComputeResource(ctx, item, root, NULL,\n                                            &ctx->computeResource,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build compute resource path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->computeResource) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find compute resource specified in '%s'\"),\n                       path);\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    ctx->computeResourcePath = virBufferContentAndReset(&buffer);\n\n    /* Lookup HostSystem */\n    if (STREQ(ctx->computeResource->_reference->type,\n              \"ClusterComputeResource\")) {\n        if (!item) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Path '%s' does not specify a host system\"), path);\n            goto cleanup;\n        }\n\n        /* The path specified a cluster, it has to specify a host system too */\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' ends with an excess item\"), path);\n        goto cleanup;\n    }\n\n    ctx->hostSystemName = g_strdup(previousItem);\n\n    if (esxVI_LookupHostSystem(ctx, ctx->hostSystemName,\n                               ctx->computeResource->_reference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->hostSystem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find host system specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    if (root != ctx->service->rootFolder &&\n        (!ctx->datacenter || root != ctx->datacenter->hostFolder)) {\n        esxVI_ManagedObjectReference_Free(&root);\n    }\n\n    VIR_FREE(tmp);\n    esxVI_Folder_Free(&folder);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjectsByPath(esxVI_Context *ctx, const char *path)\n{\n    int result = -1;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *previousItem = NULL;\n    char *item = NULL;\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    esxVI_ManagedObjectReference *root = NULL;\n    esxVI_Folder *folder = NULL;\n\n    tmp = g_strdup(path);\n\n    /* Lookup Datacenter */\n    item = strtok_r(tmp, \"/\", &saveptr);\n\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a datacenter\"), path);\n        goto cleanup;\n    }\n\n    root = ctx->service->rootFolder;\n\n    while (!ctx->datacenter && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->service->rootFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a datacenter */\n            if (esxVI_LookupDatacenter(ctx, item, root, NULL, &ctx->datacenter,\n                                       esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build datacenter path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->datacenter) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datacenter specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    ctx->datacenterPath = virBufferContentAndReset(&buffer);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (!item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' does not specify a compute resource\"), path);\n        goto cleanup;\n    }\n\n    if (root != ctx->service->rootFolder)\n        esxVI_ManagedObjectReference_Free(&root);\n\n    root = ctx->datacenter->hostFolder;\n\n    while (!ctx->computeResource && item) {\n        esxVI_Folder_Free(&folder);\n\n        /* Try to lookup item as a folder */\n        if (esxVI_LookupFolder(ctx, item, root, NULL, &folder,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n            goto cleanup;\n        }\n\n        if (folder) {\n            /* It's a folder, use it as new lookup root */\n            if (root != ctx->datacenter->hostFolder)\n                esxVI_ManagedObjectReference_Free(&root);\n\n            root = folder->_reference;\n            folder->_reference = NULL;\n        } else {\n            /* Try to lookup item as a compute resource */\n            if (esxVI_LookupComputeResource(ctx, item, root, NULL,\n                                            &ctx->computeResource,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n        }\n\n        /* Build compute resource path */\n        if (virBufferUse(&buffer) > 0)\n            virBufferAddChar(&buffer, '/');\n\n        virBufferAdd(&buffer, item, -1);\n\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (!ctx->computeResource) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find compute resource specified in '%s'\"),\n                       path);\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    ctx->computeResourcePath = virBufferContentAndReset(&buffer);\n\n    /* Lookup HostSystem */\n    if (STREQ(ctx->computeResource->_reference->type,\n              \"ClusterComputeResource\")) {\n        if (!item) {\n            virReportError(VIR_ERR_INVALID_ARG,\n                           _(\"Path '%s' does not specify a host system\"), path);\n            goto cleanup;\n        }\n\n        /* The path specified a cluster, it has to specify a host system too */\n        previousItem = item;\n        item = strtok_r(NULL, \"/\", &saveptr);\n    }\n\n    if (item) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Path '%s' ends with an excess item\"), path);\n        goto cleanup;\n    }\n\n    ctx->hostSystemName = g_strdup(previousItem);\n\n    if (esxVI_LookupHostSystem(ctx, ctx->hostSystemName,\n                               ctx->computeResource->_reference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->hostSystem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find host system specified in '%s'\"), path);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0)\n        virBufferFreeAndReset(&buffer);\n\n    if (root != ctx->service->rootFolder &&\n        (!ctx->datacenter || root != ctx->datacenter->hostFolder)) {\n        esxVI_ManagedObjectReference_Free(&root);\n    }\n\n    VIR_FREE(tmp);\n    esxVI_Folder_Free(&folder);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Context_LookupManagedObjectsByHostSystemIp",
          "args": [
            "priv->vCenter",
            "hostSystemIPAddress"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Context_LookupManagedObjectsByHostSystemIp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1201-1243",
          "snippet": "int\nesxVI_Context_LookupManagedObjectsByHostSystemIp(esxVI_Context *ctx,\n                                                 const char *hostSystemIPAddress)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n\n    /* Lookup HostSystem */\n    if (esxVI_FindByIp(ctx, NULL, hostSystemIPAddress, esxVI_Boolean_False,\n                       &managedObjectReference) < 0 ||\n        esxVI_LookupHostSystem(ctx, NULL, managedObjectReference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->hostSystem->_reference,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjectsByHostSystemIp(esxVI_Context *ctx,\n                                                 const char *hostSystemIPAddress)\n{\n    int result = -1;\n    esxVI_ManagedObjectReference *managedObjectReference = NULL;\n\n    /* Lookup HostSystem */\n    if (esxVI_FindByIp(ctx, NULL, hostSystemIPAddress, esxVI_Boolean_False,\n                       &managedObjectReference) < 0 ||\n        esxVI_LookupHostSystem(ctx, NULL, managedObjectReference, NULL,\n                               &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->hostSystem->_reference,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        goto cleanup;\n    }\n\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_ManagedObjectReference_Free(&managedObjectReference);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting '%s' to be a %s host but found a %s host\")",
            "hostname",
            "esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX)",
            "esxVI_ProductLineToDisplayName(priv->vCenter->productLine)"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ProductLineToDisplayName",
          "args": [
            "priv->vCenter->productLine"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Connect",
          "args": [
            "priv->vCenter",
            "url",
            "ipAddress",
            "username",
            "password",
            "priv->parsedUri"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Alloc",
          "args": [
            "&priv->vCenter"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s://%s:%d/sdk\"",
            "priv->parsedUri->transport",
            "hostname",
            "conn->uri->port"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetPassword",
          "args": [
            "conn",
            "auth",
            "\"esx\"",
            "username",
            "hostname"
          ],
          "line": 720
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetPassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "276-289",
          "snippet": "char *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetUsername",
          "args": [
            "conn",
            "auth",
            "\"esx\"",
            "\"administrator\"",
            "hostname"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetUsername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "197-211",
          "snippet": "char *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ResolveHostname",
          "args": [
            "hostname",
            "ipAddress",
            "NI_MAXHOST"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ResolveHostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "281-326",
          "snippet": "int\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"Path has to specify the datacenter and compute resource\")"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "priv->parsedUri->path",
            "\"/\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectToVCenter(esxPrivate *priv,\n                    virConnectPtr conn,\n                    virConnectAuthPtr auth,\n                    const char *hostname,\n                    const char *hostSystemIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n\n    if (!hostSystemIPAddress &&\n        (!priv->parsedUri->path || STREQ(priv->parsedUri->path, \"/\"))) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"Path has to specify the datacenter and compute resource\"));\n        return -1;\n    }\n\n    if (esxUtil_ResolveHostname(hostname, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"administrator\",\n                                            hostname)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username, hostname)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport, hostname,\n                          conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->vCenter) < 0 ||\n        esxVI_Context_Connect(priv->vCenter, url, ipAddress, username,\n                              password, priv->parsedUri) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->vCenter->productLine != esxVI_ProductLine_VPX) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       hostname,\n                       esxVI_ProductLineToDisplayName(esxVI_ProductLine_VPX),\n                       esxVI_ProductLineToDisplayName(priv->vCenter->productLine));\n        goto cleanup;\n    }\n\n    if (hostSystemIPAddress) {\n        if (esxVI_Context_LookupManagedObjectsByHostSystemIp\n              (priv->vCenter, hostSystemIPAddress) < 0) {\n            goto cleanup;\n        }\n    } else {\n        if (esxVI_Context_LookupManagedObjectsByPath(priv->vCenter,\n                                                     priv->parsedUri->path) < 0) {\n            goto cleanup;\n        }\n    }\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n\n    return result;\n}"
  },
  {
    "function_name": "esxConnectToHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "600-685",
    "snippet": "static int\nesxConnectToHost(esxPrivate *priv,\n                 virConnectPtr conn,\n                 virConnectAuthPtr auth,\n                 char **vCenterIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Boolean inMaintenanceMode = esxVI_Boolean_Undefined;\n    esxVI_ProductLine expectedProductLine = STRCASEEQ(conn->uri->scheme, \"esx\")\n        ? esxVI_ProductLine_ESX\n        : esxVI_ProductLine_GSX;\n\n    ESX_VI_CHECK_ARG_LIST(vCenterIPAddress);\n\n    if (esxUtil_ResolveHostname(conn->uri->server, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"root\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport,\n                          conn->uri->server, conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->host) < 0 ||\n        esxVI_Context_Connect(priv->host, url, ipAddress, username, password,\n                              priv->parsedUri) < 0 ||\n        esxVI_Context_LookupManagedObjects(priv->host) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->host->productLine != expectedProductLine) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       conn->uri->server,\n                       esxVI_ProductLineToDisplayName(expectedProductLine),\n                       esxVI_ProductLineToDisplayName(priv->host->productLine));\n        goto cleanup;\n    }\n\n    /* Query the host for maintenance mode and vCenter IP address */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.inMaintenanceMode\\0\"\n                                           \"summary.managementServerIp\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->host, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"runtime.inMaintenanceMode\",\n                         &inMaintenanceMode,\n                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"summary.managementServerIp\",\n                             vCenterIPAddress,\n                             esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Warn if host is in maintenance mode */\n    if (inMaintenanceMode == esxVI_Boolean_True)\n        VIR_WARN(\"The server is in maintenance mode\");\n\n    *vCenterIPAddress = g_strdup(*vCenterIPAddress);\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "url"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "password"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "username"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "*vCenterIPAddress"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"The server is in maintenance mode\""
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "hostSystem",
            "\"summary.managementServerIp\"",
            "vCenterIPAddress",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_GetBoolean",
          "args": [
            "hostSystem",
            "\"runtime.inMaintenanceMode\"",
            "&inMaintenanceMode",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2229-2261",
          "snippet": "int\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetBoolean(esxVI_ObjectContent *objectContent, const char *propertyName,\n                 esxVI_Boolean *value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    if (!value || *value != esxVI_Boolean_Undefined) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_Boolean) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->boolean;\n            break;\n        }\n    }\n\n    if (*value == esxVI_Boolean_Undefined &&\n        occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->host",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueListToList",
          "args": [
            "&propertyNameList",
            "\"runtime.inMaintenanceMode\\0\"\n                                           \"summary.managementServerIp\\0\""
          ],
          "line": 655
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueListToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1167-1190",
          "snippet": "int\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_String_AppendValueListToList(esxVI_String **stringList,\n                                   const char *valueList)\n{\n    esxVI_String *stringListToAppend = NULL;\n    const char *value = valueList;\n\n    while (value && *value != '\\0') {\n        if (esxVI_String_AppendValueToList(&stringListToAppend, value) < 0)\n            goto failure;\n\n        value += strlen(value) + 1;\n    }\n\n    if (esxVI_String_AppendToList(stringList, stringListToAppend) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&stringListToAppend);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Expecting '%s' to be a %s host but found a %s host\")",
            "conn->uri->server",
            "esxVI_ProductLineToDisplayName(expectedProductLine)",
            "esxVI_ProductLineToDisplayName(priv->host->productLine)"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ProductLineToDisplayName",
          "args": [
            "priv->host->productLine"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Context_LookupManagedObjects",
          "args": [
            "priv->host"
          ],
          "line": 641
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_Context_LookupManagedObjects",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "981-1018",
          "snippet": "int\nesxVI_Context_LookupManagedObjects(esxVI_Context *ctx)\n{\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->service->rootFolder, NULL,\n                               &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->datacenterPath = g_strdup(ctx->datacenter->name);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->datacenter->hostFolder,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        return -1;\n    }\n\n    ctx->computeResourcePath = g_strdup(ctx->computeResource->name);\n\n    /* Lookup HostSystem */\n    if (esxVI_LookupHostSystem(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->hostSystemName = g_strdup(ctx->hostSystem->name);\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_Context_LookupManagedObjects(esxVI_Context *ctx)\n{\n    /* Lookup Datacenter */\n    if (esxVI_LookupDatacenter(ctx, NULL, ctx->service->rootFolder, NULL,\n                               &ctx->datacenter,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->datacenterPath = g_strdup(ctx->datacenter->name);\n\n    /* Lookup (Cluster)ComputeResource */\n    if (esxVI_LookupComputeResource(ctx, NULL, ctx->datacenter->hostFolder,\n                                    NULL, &ctx->computeResource,\n                                    esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    if (!ctx->computeResource->resourcePool) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not retrieve resource pool\"));\n        return -1;\n    }\n\n    ctx->computeResourcePath = g_strdup(ctx->computeResource->name);\n\n    /* Lookup HostSystem */\n    if (esxVI_LookupHostSystem(ctx, NULL, ctx->computeResource->_reference,\n                               NULL, &ctx->hostSystem,\n                               esxVI_Occurrence_RequiredItem) < 0) {\n        return -1;\n    }\n\n    ctx->hostSystemName = g_strdup(ctx->hostSystem->name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Connect",
          "args": [
            "priv->host",
            "url",
            "ipAddress",
            "username",
            "password",
            "priv->parsedUri"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Alloc",
          "args": [
            "&priv->host"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virAuthGetPassword",
          "args": [
            "conn",
            "auth",
            "\"esx\"",
            "username",
            "conn->uri->server"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetPassword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "276-289",
          "snippet": "char *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetPassword(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *username,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetPasswordPath(path, auth, servicename, username, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virAuthGetUsername",
          "args": [
            "conn",
            "auth",
            "\"esx\"",
            "\"root\"",
            "conn->uri->server"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virAuthGetUsername",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virauth.c",
          "lines": "197-211",
          "snippet": "char *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virauthconfig.h\"",
            "#include \"configmake.h\"",
            "#include \"virerror.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virauthconfig.h\"\n#include \"configmake.h\"\n#include \"virerror.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include <config.h>\n\nchar *\nvirAuthGetUsername(virConnectPtr conn,\n                   virConnectAuthPtr auth,\n                   const char *servicename,\n                   const char *defaultUsername,\n                   const char *hostname)\n{\n    g_autofree char *path = NULL;\n\n    if (virAuthGetConfigFilePath(conn, &path) < 0)\n        return NULL;\n\n    return virAuthGetUsernamePath(path, auth, servicename,\n                                  defaultUsername, hostname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ResolveHostname",
          "args": [
            "conn->uri->server",
            "ipAddress",
            "NI_MAXHOST"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ResolveHostname",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "281-326",
          "snippet": "int\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ResolveHostname(const char *hostname,\n                        char *ipAddress, size_t ipAddress_length)\n{\n    struct addrinfo hints;\n    struct addrinfo *result = NULL;\n    int errcode;\n\n    memset(&hints, 0, sizeof(hints));\n\n    hints.ai_flags = AI_ADDRCONFIG;\n    hints.ai_family = AF_INET;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_protocol = 0;\n\n    errcode = getaddrinfo(hostname, NULL, &hints, &result);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"IP address lookup for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    if (!result) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No IP address for host '%s' found: %s\"), hostname,\n                       gai_strerror(errcode));\n        return -1;\n    }\n\n    errcode = getnameinfo(result->ai_addr, result->ai_addrlen, ipAddress,\n                          ipAddress_length, NULL, 0, NI_NUMERICHOST);\n\n    if (errcode != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Formatting IP address for host '%s' failed: %s\"), hostname,\n                       gai_strerror(errcode));\n        freeaddrinfo(result);\n        return -1;\n    }\n\n    freeaddrinfo(result);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ESX_VI_CHECK_ARG_LIST",
          "args": [
            "vCenterIPAddress"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "conn->uri->scheme",
            "\"esx\""
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxConnectToHost(esxPrivate *priv,\n                 virConnectPtr conn,\n                 virConnectAuthPtr auth,\n                 char **vCenterIPAddress)\n{\n    int result = -1;\n    char ipAddress[NI_MAXHOST] = \"\";\n    char *username = NULL;\n    char *password = NULL;\n    char *url = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_Boolean inMaintenanceMode = esxVI_Boolean_Undefined;\n    esxVI_ProductLine expectedProductLine = STRCASEEQ(conn->uri->scheme, \"esx\")\n        ? esxVI_ProductLine_ESX\n        : esxVI_ProductLine_GSX;\n\n    ESX_VI_CHECK_ARG_LIST(vCenterIPAddress);\n\n    if (esxUtil_ResolveHostname(conn->uri->server, ipAddress, NI_MAXHOST) < 0)\n        return -1;\n\n    if (conn->uri->user) {\n        username = g_strdup(conn->uri->user);\n    } else {\n        if (!(username = virAuthGetUsername(conn, auth, \"esx\", \"root\",\n                                            conn->uri->server)))\n            goto cleanup;\n    }\n\n    if (!(password = virAuthGetPassword(conn, auth, \"esx\", username,\n                                        conn->uri->server)))\n        goto cleanup;\n\n    url = g_strdup_printf(\"%s://%s:%d/sdk\", priv->parsedUri->transport,\n                          conn->uri->server, conn->uri->port);\n\n    if (esxVI_Context_Alloc(&priv->host) < 0 ||\n        esxVI_Context_Connect(priv->host, url, ipAddress, username, password,\n                              priv->parsedUri) < 0 ||\n        esxVI_Context_LookupManagedObjects(priv->host) < 0) {\n        goto cleanup;\n    }\n\n    if (priv->host->productLine != expectedProductLine) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Expecting '%s' to be a %s host but found a %s host\"),\n                       conn->uri->server,\n                       esxVI_ProductLineToDisplayName(expectedProductLine),\n                       esxVI_ProductLineToDisplayName(priv->host->productLine));\n        goto cleanup;\n    }\n\n    /* Query the host for maintenance mode and vCenter IP address */\n    if (esxVI_String_AppendValueListToList(&propertyNameList,\n                                           \"runtime.inMaintenanceMode\\0\"\n                                           \"summary.managementServerIp\\0\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->host, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetBoolean(hostSystem, \"runtime.inMaintenanceMode\",\n                         &inMaintenanceMode,\n                         esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"summary.managementServerIp\",\n                             vCenterIPAddress,\n                             esxVI_Occurrence_OptionalItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Warn if host is in maintenance mode */\n    if (inMaintenanceMode == esxVI_Boolean_True)\n        VIR_WARN(\"The server is in maintenance mode\");\n\n    *vCenterIPAddress = g_strdup(*vCenterIPAddress);\n\n    result = 0;\n\n cleanup:\n    VIR_FREE(username);\n    VIR_FREE(password);\n    VIR_FREE(url);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxCapsInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "539-596",
    "snippet": "static virCapsPtr\nesxCapsInit(esxPrivate *priv)\n{\n    esxVI_Boolean supportsLongMode = esxSupportsLongMode(priv);\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if (supportsLongMode == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsLongMode == esxVI_Boolean_True) {\n        caps = virCapabilitiesNew(VIR_ARCH_X86_64, true, true);\n    } else {\n        caps = virCapabilitiesNew(VIR_ARCH_I686, true, true);\n    }\n\n    if (!caps)\n        return NULL;\n\n    virCapabilitiesAddHostMigrateTransport(caps, \"vpxmigr\");\n\n\n    if (esxLookupHostSystemBiosUuid(priv, caps->host.host_uuid) < 0)\n        goto failure;\n\n    /* i686 */\n    guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                    VIR_ARCH_I686,\n                                    NULL, NULL, 0,\n                                    NULL);\n\n    if (!guest)\n        goto failure;\n\n    if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n        goto failure;\n\n    /* x86_64 */\n    if (supportsLongMode == esxVI_Boolean_True) {\n        guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                        VIR_ARCH_X86_64,\n                                        NULL, NULL,\n                                        0, NULL);\n\n        if (!guest)\n            goto failure;\n\n        if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n            goto failure;\n    }\n\n    return caps;\n\n failure:\n    virObjectUnref(caps);\n\n    return NULL;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_VMWARE",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "VIR_DOMAIN_OSTYPE_HVM",
            "VIR_ARCH_X86_64",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxLookupHostSystemBiosUuid",
          "args": [
            "priv",
            "caps->host.host_uuid"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "esxLookupHostSystemBiosUuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "497-536",
          "snippet": "static int\nesxLookupHostSystemBiosUuid(esxPrivate *priv, unsigned char *uuid)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    char *uuid_string = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.systemInfo.uuid\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"hardware.systemInfo.uuid\",\n                             &uuid_string, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (strlen(uuid_string) > 0) {\n        if (virUUIDParse(uuid_string, uuid) < 0) {\n            VIR_WARN(\"Could not parse host UUID from string '%s'\", uuid_string);\n\n            /* HostSystem has an invalid UUID, ignore it */\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n        }\n    } else {\n        /* HostSystem has an empty UUID */\n        memset(uuid, 0, VIR_UUID_BUFLEN);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxLookupHostSystemBiosUuid(esxPrivate *priv, unsigned char *uuid)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    char *uuid_string = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.systemInfo.uuid\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"hardware.systemInfo.uuid\",\n                             &uuid_string, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (strlen(uuid_string) > 0) {\n        if (virUUIDParse(uuid_string, uuid) < 0) {\n            VIR_WARN(\"Could not parse host UUID from string '%s'\", uuid_string);\n\n            /* HostSystem has an invalid UUID, ignore it */\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n        }\n    } else {\n        /* HostSystem has an empty UUID */\n        memset(uuid, 0, VIR_UUID_BUFLEN);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddHostMigrateTransport",
          "args": [
            "caps",
            "\"vpxmigr\""
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddHostMigrateTransport",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "300-312",
          "snippet": "int\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddHostMigrateTransport(virCapsPtr caps,\n                                       const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.migrateTrans, caps->host.nmigrateTrans_max,\n                     caps->host.nmigrateTrans, 1) < 0)\n        return -1;\n\n    caps->host.migrateTrans[caps->host.nmigrateTrans] = g_strdup(name);\n    caps->host.nmigrateTrans++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "VIR_ARCH_I686",
            "true",
            "true"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxSupportsLongMode",
          "args": [
            "priv"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "esxSupportsLongMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
          "lines": "418-493",
          "snippet": "static esxVI_Boolean\nesxSupportsLongMode(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfoList = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfo = NULL;\n    esxVI_ParsedHostCpuIdInfo parsedHostCpuIdInfo;\n    char edxLongModeBit = '?';\n\n    if (priv->supportsLongMode != esxVI_Boolean_Undefined)\n        return priv->supportsLongMode;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.cpuFeature\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuFeature\")) {\n            if (esxVI_HostCpuIdInfo_CastListFromAnyType\n                  (dynamicProperty->val, &hostCpuIdInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (hostCpuIdInfo = hostCpuIdInfoList; hostCpuIdInfo;\n                 hostCpuIdInfo = hostCpuIdInfo->_next) {\n                if (hostCpuIdInfo->level->value == -2147483647) { /* 0x80000001 */\n                    if (esxVI_ParseHostCpuIdInfo(&parsedHostCpuIdInfo,\n                                                 hostCpuIdInfo) < 0) {\n                        goto cleanup;\n                    }\n\n                    edxLongModeBit = parsedHostCpuIdInfo.edx[29];\n\n                    if (edxLongModeBit == '1') {\n                        priv->supportsLongMode = esxVI_Boolean_True;\n                    } else if (edxLongModeBit == '0') {\n                        priv->supportsLongMode = esxVI_Boolean_False;\n                    } else {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\"), hostCpuIdInfo->edx, edxLongModeBit);\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsLongMode\n     * is still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostCpuIdInfo_Free(&hostCpuIdInfoList);\n\n    return priv->supportsLongMode;\n}",
          "includes": [
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_stream.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"esx_private.h\"",
            "#include \"esx_storage_driver.h\"",
            "#include \"esx_network_driver.h\"",
            "#include \"esx_interface_driver.h\"",
            "#include \"esx_driver.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virauth.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"virdomainobjlist.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsLongMode(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfoList = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfo = NULL;\n    esxVI_ParsedHostCpuIdInfo parsedHostCpuIdInfo;\n    char edxLongModeBit = '?';\n\n    if (priv->supportsLongMode != esxVI_Boolean_Undefined)\n        return priv->supportsLongMode;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.cpuFeature\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuFeature\")) {\n            if (esxVI_HostCpuIdInfo_CastListFromAnyType\n                  (dynamicProperty->val, &hostCpuIdInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (hostCpuIdInfo = hostCpuIdInfoList; hostCpuIdInfo;\n                 hostCpuIdInfo = hostCpuIdInfo->_next) {\n                if (hostCpuIdInfo->level->value == -2147483647) { /* 0x80000001 */\n                    if (esxVI_ParseHostCpuIdInfo(&parsedHostCpuIdInfo,\n                                                 hostCpuIdInfo) < 0) {\n                        goto cleanup;\n                    }\n\n                    edxLongModeBit = parsedHostCpuIdInfo.edx[29];\n\n                    if (edxLongModeBit == '1') {\n                        priv->supportsLongMode = esxVI_Boolean_True;\n                    } else if (edxLongModeBit == '0') {\n                        priv->supportsLongMode = esxVI_Boolean_False;\n                    } else {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\"), hostCpuIdInfo->edx, edxLongModeBit);\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsLongMode\n     * is still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostCpuIdInfo_Free(&hostCpuIdInfoList);\n\n    return priv->supportsLongMode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virCapsPtr\nesxCapsInit(esxPrivate *priv)\n{\n    esxVI_Boolean supportsLongMode = esxSupportsLongMode(priv);\n    virCapsPtr caps = NULL;\n    virCapsGuestPtr guest = NULL;\n\n    if (supportsLongMode == esxVI_Boolean_Undefined)\n        return NULL;\n\n    if (supportsLongMode == esxVI_Boolean_True) {\n        caps = virCapabilitiesNew(VIR_ARCH_X86_64, true, true);\n    } else {\n        caps = virCapabilitiesNew(VIR_ARCH_I686, true, true);\n    }\n\n    if (!caps)\n        return NULL;\n\n    virCapabilitiesAddHostMigrateTransport(caps, \"vpxmigr\");\n\n\n    if (esxLookupHostSystemBiosUuid(priv, caps->host.host_uuid) < 0)\n        goto failure;\n\n    /* i686 */\n    guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                    VIR_ARCH_I686,\n                                    NULL, NULL, 0,\n                                    NULL);\n\n    if (!guest)\n        goto failure;\n\n    if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n        goto failure;\n\n    /* x86_64 */\n    if (supportsLongMode == esxVI_Boolean_True) {\n        guest = virCapabilitiesAddGuest(caps, VIR_DOMAIN_OSTYPE_HVM,\n                                        VIR_ARCH_X86_64,\n                                        NULL, NULL,\n                                        0, NULL);\n\n        if (!guest)\n            goto failure;\n\n        if (!virCapabilitiesAddGuestDomain(guest, VIR_DOMAIN_VIRT_VMWARE, NULL, NULL, 0, NULL))\n            goto failure;\n    }\n\n    return caps;\n\n failure:\n    virObjectUnref(caps);\n\n    return NULL;\n}"
  },
  {
    "function_name": "esxLookupHostSystemBiosUuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "497-536",
    "snippet": "static int\nesxLookupHostSystemBiosUuid(esxPrivate *priv, unsigned char *uuid)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    char *uuid_string = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.systemInfo.uuid\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"hardware.systemInfo.uuid\",\n                             &uuid_string, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (strlen(uuid_string) > 0) {\n        if (virUUIDParse(uuid_string, uuid) < 0) {\n            VIR_WARN(\"Could not parse host UUID from string '%s'\", uuid_string);\n\n            /* HostSystem has an invalid UUID, ignore it */\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n        }\n    } else {\n        /* HostSystem has an empty UUID */\n        memset(uuid, 0, VIR_UUID_BUFLEN);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "uuid",
            "0",
            "VIR_UUID_BUFLEN"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "uuid",
            "0",
            "VIR_UUID_BUFLEN"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Could not parse host UUID from string '%s'\"",
            "uuid_string"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "uuid_string",
            "uuid"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "uuid_string"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "hostSystem",
            "\"hardware.systemInfo.uuid\"",
            "&uuid_string",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"hardware.systemInfo.uuid\""
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxLookupHostSystemBiosUuid(esxPrivate *priv, unsigned char *uuid)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    char *uuid_string = NULL;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return -1;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.systemInfo.uuid\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0 ||\n        esxVI_GetStringValue(hostSystem, \"hardware.systemInfo.uuid\",\n                             &uuid_string, esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    if (strlen(uuid_string) > 0) {\n        if (virUUIDParse(uuid_string, uuid) < 0) {\n            VIR_WARN(\"Could not parse host UUID from string '%s'\", uuid_string);\n\n            /* HostSystem has an invalid UUID, ignore it */\n            memset(uuid, 0, VIR_UUID_BUFLEN);\n        }\n    } else {\n        /* HostSystem has an empty UUID */\n        memset(uuid, 0, VIR_UUID_BUFLEN);\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n\n    return result;\n}"
  },
  {
    "function_name": "esxSupportsLongMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "418-493",
    "snippet": "static esxVI_Boolean\nesxSupportsLongMode(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfoList = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfo = NULL;\n    esxVI_ParsedHostCpuIdInfo parsedHostCpuIdInfo;\n    char edxLongModeBit = '?';\n\n    if (priv->supportsLongMode != esxVI_Boolean_Undefined)\n        return priv->supportsLongMode;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.cpuFeature\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuFeature\")) {\n            if (esxVI_HostCpuIdInfo_CastListFromAnyType\n                  (dynamicProperty->val, &hostCpuIdInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (hostCpuIdInfo = hostCpuIdInfoList; hostCpuIdInfo;\n                 hostCpuIdInfo = hostCpuIdInfo->_next) {\n                if (hostCpuIdInfo->level->value == -2147483647) { /* 0x80000001 */\n                    if (esxVI_ParseHostCpuIdInfo(&parsedHostCpuIdInfo,\n                                                 hostCpuIdInfo) < 0) {\n                        goto cleanup;\n                    }\n\n                    edxLongModeBit = parsedHostCpuIdInfo.edx[29];\n\n                    if (edxLongModeBit == '1') {\n                        priv->supportsLongMode = esxVI_Boolean_True;\n                    } else if (edxLongModeBit == '0') {\n                        priv->supportsLongMode = esxVI_Boolean_False;\n                    } else {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\"), hostCpuIdInfo->edx, edxLongModeBit);\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsLongMode\n     * is still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostCpuIdInfo_Free(&hostCpuIdInfoList);\n\n    return priv->supportsLongMode;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_HostCpuIdInfo_Free",
          "args": [
            "&hostCpuIdInfoList"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&hostSystem"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unexpected '%s' property\"",
            "dynamicProperty->name"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\")",
            "hostCpuIdInfo->edx",
            "edxLongModeBit"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\""
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ParseHostCpuIdInfo",
          "args": [
            "&parsedHostCpuIdInfo",
            "hostCpuIdInfo"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ParseHostCpuIdInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4407-4448",
          "snippet": "int\nesxVI_ParseHostCpuIdInfo(esxVI_ParsedHostCpuIdInfo *parsedHostCpuIdInfo,\n                         esxVI_HostCpuIdInfo *hostCpuIdInfo)\n{\n    int expectedLength = 39; /* = strlen(\"----:----:----:----:----:----:----:----\"); */\n    char *input[4] = { hostCpuIdInfo->eax, hostCpuIdInfo->ebx,\n                       hostCpuIdInfo->ecx, hostCpuIdInfo->edx };\n    char *output[4] = { parsedHostCpuIdInfo->eax, parsedHostCpuIdInfo->ebx,\n                        parsedHostCpuIdInfo->ecx, parsedHostCpuIdInfo->edx };\n    const char *name[4] = { \"eax\", \"ebx\", \"ecx\", \"edx\" };\n    size_t r, i, o;\n\n    memset(parsedHostCpuIdInfo, 0, sizeof(*parsedHostCpuIdInfo));\n\n    parsedHostCpuIdInfo->level = hostCpuIdInfo->level->value;\n\n    for (r = 0; r < 4; ++r) {\n        if (strlen(input[r]) != expectedLength) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HostCpuIdInfo register '%s' has an unexpected length\"),\n                           name[r]);\n            return -1;\n        }\n\n        /* Strip the ':' and invert the \"bit\" order from 31..0 to 0..31 */\n        for (i = 0, o = 31; i < expectedLength; i += 5, o -= 4) {\n            output[r][o] = input[r][i];\n            output[r][o - 1] = input[r][i + 1];\n            output[r][o - 2] = input[r][i + 2];\n            output[r][o - 3] = input[r][i + 3];\n\n            if (i + 4 < expectedLength && input[r][i + 4] != ':') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HostCpuIdInfo register '%s' has an unexpected format\"),\n                               name[r]);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_ParseHostCpuIdInfo(esxVI_ParsedHostCpuIdInfo *parsedHostCpuIdInfo,\n                         esxVI_HostCpuIdInfo *hostCpuIdInfo)\n{\n    int expectedLength = 39; /* = strlen(\"----:----:----:----:----:----:----:----\"); */\n    char *input[4] = { hostCpuIdInfo->eax, hostCpuIdInfo->ebx,\n                       hostCpuIdInfo->ecx, hostCpuIdInfo->edx };\n    char *output[4] = { parsedHostCpuIdInfo->eax, parsedHostCpuIdInfo->ebx,\n                        parsedHostCpuIdInfo->ecx, parsedHostCpuIdInfo->edx };\n    const char *name[4] = { \"eax\", \"ebx\", \"ecx\", \"edx\" };\n    size_t r, i, o;\n\n    memset(parsedHostCpuIdInfo, 0, sizeof(*parsedHostCpuIdInfo));\n\n    parsedHostCpuIdInfo->level = hostCpuIdInfo->level->value;\n\n    for (r = 0; r < 4; ++r) {\n        if (strlen(input[r]) != expectedLength) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"HostCpuIdInfo register '%s' has an unexpected length\"),\n                           name[r]);\n            return -1;\n        }\n\n        /* Strip the ':' and invert the \"bit\" order from 31..0 to 0..31 */\n        for (i = 0, o = 31; i < expectedLength; i += 5, o -= 4) {\n            output[r][o] = input[r][i];\n            output[r][o - 1] = input[r][i + 1];\n            output[r][o - 2] = input[r][i + 2];\n            output[r][o - 3] = input[r][i + 3];\n\n            if (i + 4 < expectedLength && input[r][i + 4] != ':') {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"HostCpuIdInfo register '%s' has an unexpected format\"),\n                               name[r]);\n                return -1;\n            }\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_HostCpuIdInfo_CastListFromAnyType",
          "args": [
            "dynamicProperty->val",
            "&hostCpuIdInfoList"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "dynamicProperty->name",
            "\"hardware.cpuFeature\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupHostSystemProperties",
          "args": [
            "priv->primary",
            "propertyNameList",
            "&hostSystem"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupHostSystemProperties",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2697-2706",
          "snippet": "int\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupHostSystemProperties(esxVI_Context *ctx,\n                                 esxVI_String *propertyNameList,\n                                 esxVI_ObjectContent **hostSystem)\n{\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"HostSystem\", propertyNameList,\n                                           hostSystem,\n                                           esxVI_Occurrence_RequiredItem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"hardware.cpuFeature\""
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_EnsureSession",
          "args": [
            "priv->primary"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_EnsureSession",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "1902-1980",
          "snippet": "int\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_EnsureSession(esxVI_Context *ctx)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *sessionManager = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_UserSession *currentSession = NULL;\n    char *escapedPassword = NULL;\n\n    if (!ctx->sessionLock) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no mutex\"));\n        return -1;\n    }\n\n    virMutexLock(ctx->sessionLock);\n\n    if (!ctx->session) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid call, no session\"));\n        goto cleanup;\n    }\n\n    escapedPassword = esxUtil_EscapeForXml(ctx->password);\n\n    if (!escapedPassword) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to escape password for XML\"));\n        goto cleanup;\n    }\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"currentSession\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, ctx->service->sessionManager,\n                                        \"SessionManager\", propertyNameList,\n                                        &sessionManager,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = sessionManager->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"currentSession\")) {\n            if (esxVI_UserSession_CastFromAnyType(dynamicProperty->val,\n                                                  &currentSession) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    if (!currentSession) {\n        esxVI_UserSession_Free(&ctx->session);\n\n        if (esxVI_Login(ctx, ctx->username, escapedPassword, NULL,\n                        &ctx->session) < 0) {\n            goto cleanup;\n        }\n    } else if (STRNEQ(ctx->session->key, currentSession->key)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Key of the current session differs from the key at \"\n                         \"last login\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    virMutexUnlock(ctx->sessionLock);\n\n    VIR_FREE(escapedPassword);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&sessionManager);\n    esxVI_UserSession_Free(&currentSession);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic esxVI_Boolean\nesxSupportsLongMode(esxPrivate *priv)\n{\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *hostSystem = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfoList = NULL;\n    esxVI_HostCpuIdInfo *hostCpuIdInfo = NULL;\n    esxVI_ParsedHostCpuIdInfo parsedHostCpuIdInfo;\n    char edxLongModeBit = '?';\n\n    if (priv->supportsLongMode != esxVI_Boolean_Undefined)\n        return priv->supportsLongMode;\n\n    if (esxVI_EnsureSession(priv->primary) < 0)\n        return esxVI_Boolean_Undefined;\n\n    if (esxVI_String_AppendValueToList(&propertyNameList,\n                                       \"hardware.cpuFeature\") < 0 ||\n        esxVI_LookupHostSystemProperties(priv->primary, propertyNameList,\n                                         &hostSystem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = hostSystem->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"hardware.cpuFeature\")) {\n            if (esxVI_HostCpuIdInfo_CastListFromAnyType\n                  (dynamicProperty->val, &hostCpuIdInfoList) < 0) {\n                goto cleanup;\n            }\n\n            for (hostCpuIdInfo = hostCpuIdInfoList; hostCpuIdInfo;\n                 hostCpuIdInfo = hostCpuIdInfo->_next) {\n                if (hostCpuIdInfo->level->value == -2147483647) { /* 0x80000001 */\n                    if (esxVI_ParseHostCpuIdInfo(&parsedHostCpuIdInfo,\n                                                 hostCpuIdInfo) < 0) {\n                        goto cleanup;\n                    }\n\n                    edxLongModeBit = parsedHostCpuIdInfo.edx[29];\n\n                    if (edxLongModeBit == '1') {\n                        priv->supportsLongMode = esxVI_Boolean_True;\n                    } else if (edxLongModeBit == '0') {\n                        priv->supportsLongMode = esxVI_Boolean_False;\n                    } else {\n                        virReportError(VIR_ERR_INTERNAL_ERROR,\n                                       _(\"Bit 29 (Long Mode) of HostSystem property \"\n                                         \"'hardware.cpuFeature[].edx' with value '%s' \"\n                                         \"has unexpected value '%c', expecting '0' \"\n                                         \"or '1'\"), hostCpuIdInfo->edx, edxLongModeBit);\n                        goto cleanup;\n                    }\n\n                    break;\n                }\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n cleanup:\n    /*\n     * If we goto cleanup in case of an error then priv->supportsLongMode\n     * is still esxVI_Boolean_Undefined, therefore we don't need to set it.\n     */\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&hostSystem);\n    esxVI_HostCpuIdInfo_Free(&hostCpuIdInfoList);\n\n    return priv->supportsLongMode;\n}"
  },
  {
    "function_name": "esxAutodetectSCSIControllerModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "354-414",
    "snippet": "static int\nesxAutodetectSCSIControllerModel(virDomainDiskDefPtr def, int *model,\n                                 void *opaque)\n{\n    int result = -1;\n    esxVMX_Data *data = opaque;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK ||\n        def->bus != VIR_DOMAIN_DISK_BUS_SCSI ||\n        virDomainDiskGetType(def) != VIR_STORAGE_TYPE_FILE ||\n        !src || !STRPREFIX(src, \"[\")) {\n        /*\n         * This isn't a file-based SCSI disk device with a datastore related\n         * source path => do nothing.\n         */\n        return 0;\n    }\n\n    if (esxVI_LookupFileInfoByDatastorePath(data->ctx, src,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n\n    if (!vmDiskFileInfo || !vmDiskFileInfo->controllerType) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup controller model for '%s'\"), src);\n        goto cleanup;\n    }\n\n    if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                  \"VirtualBusLogicController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"VirtualLsiLogicController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"VirtualLsiLogicSASController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"ParaVirtualSCSIController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Found unexpected controller model '%s' for disk '%s'\"),\n                       vmDiskFileInfo->controllerType, src);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_FileInfo_Free",
          "args": [
            "&fileInfo"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Found unexpected controller model '%s' for disk '%s'\")",
            "vmDiskFileInfo->controllerType",
            "src"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Found unexpected controller model '%s' for disk '%s'\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "vmDiskFileInfo->controllerType",
            "\"ParaVirtualSCSIController\""
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "vmDiskFileInfo->controllerType",
            "\"VirtualLsiLogicSASController\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "vmDiskFileInfo->controllerType",
            "\"VirtualLsiLogicController\""
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRCASEEQ",
          "args": [
            "vmDiskFileInfo->controllerType",
            "\"VirtualBusLogicController\""
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not lookup controller model for '%s'\")",
            "src"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_VmDiskFileInfo_DynamicCast",
          "args": [
            "fileInfo"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupFileInfoByDatastorePath",
          "args": [
            "data->ctx",
            "src",
            "false",
            "&fileInfo",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupFileInfoByDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3385-3578",
          "snippet": "int\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupFileInfoByDatastorePath(esxVI_Context *ctx,\n                                    const char *datastorePath,\n                                    bool lookupFolder,\n                                    esxVI_FileInfo **fileInfo,\n                                    esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    char *datastoreName = NULL;\n    char *directoryName = NULL;\n    char *directoryAndFileName = NULL;\n    char *fileName = NULL;\n    size_t length;\n    char *datastorePathWithoutFileName = NULL;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_ManagedObjectReference *hostDatastoreBrowser = NULL;\n    esxVI_HostDatastoreBrowserSearchSpec *searchSpec = NULL;\n    esxVI_FolderFileQuery *folderFileQuery = NULL;\n    esxVI_VmDiskFileQuery *vmDiskFileQuery = NULL;\n    esxVI_IsoImageFileQuery *isoImageFileQuery = NULL;\n    esxVI_FloppyImageFileQuery *floppyImageFileQuery = NULL;\n    esxVI_ManagedObjectReference *task = NULL;\n    esxVI_TaskInfoState taskInfoState;\n    char *taskInfoErrorMessage = NULL;\n    esxVI_TaskInfo *taskInfo = NULL;\n    esxVI_HostDatastoreBrowserSearchResults *searchResults = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(fileInfo);\n\n    if (esxUtil_ParseDatastorePath(datastorePath, &datastoreName,\n                                   &directoryName, &directoryAndFileName) < 0) {\n        goto cleanup;\n    }\n\n    if (STREQ(directoryName, directoryAndFileName)) {\n        /*\n         * The <path> part of the datatore path didn't contain a '/', assume\n         * that the <path> part is actually the file name.\n         */\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s]\", datastoreName);\n\n        fileName = g_strdup(directoryAndFileName);\n    } else {\n        datastorePathWithoutFileName = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                                       directoryName);\n\n        length = strlen(directoryName);\n\n        if (directoryAndFileName[length] != '/' ||\n            directoryAndFileName[length + 1] == '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Datastore path '%s' doesn't reference a file\"),\n                           datastorePath);\n            goto cleanup;\n        }\n\n        fileName = g_strdup(directoryAndFileName + length + 1);\n    }\n\n    /* Lookup HostDatastoreBrowser */\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"browser\") < 0 ||\n        esxVI_LookupDatastoreByName(ctx, datastoreName, propertyNameList,\n                                    &datastore,\n                                    esxVI_Occurrence_RequiredItem) < 0 ||\n        esxVI_GetManagedObjectReference(datastore, \"browser\",\n                                        &hostDatastoreBrowser,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    /* Build HostDatastoreBrowserSearchSpec */\n    if (esxVI_HostDatastoreBrowserSearchSpec_Alloc(&searchSpec) < 0 ||\n        esxVI_FileQueryFlags_Alloc(&searchSpec->details) < 0) {\n        goto cleanup;\n    }\n\n    searchSpec->details->fileType = esxVI_Boolean_True;\n    searchSpec->details->fileSize = esxVI_Boolean_True;\n    searchSpec->details->modification = esxVI_Boolean_False;\n\n    if (lookupFolder) {\n        if (esxVI_FolderFileQuery_Alloc(&folderFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(folderFileQuery)) < 0) {\n            goto cleanup;\n        }\n        folderFileQuery = NULL;\n    } else {\n        if (esxVI_VmDiskFileQuery_Alloc(&vmDiskFileQuery) < 0 ||\n            esxVI_VmDiskFileQueryFlags_Alloc(&vmDiskFileQuery->details) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(vmDiskFileQuery)) < 0) {\n            goto cleanup;\n        }\n\n        vmDiskFileQuery->details->diskType = esxVI_Boolean_False;\n        vmDiskFileQuery->details->capacityKb = esxVI_Boolean_True;\n        vmDiskFileQuery->details->hardwareVersion = esxVI_Boolean_False;\n        vmDiskFileQuery->details->controllerType = esxVI_Boolean_True;\n        vmDiskFileQuery->details->diskExtents = esxVI_Boolean_False;\n        vmDiskFileQuery = NULL;\n\n        if (esxVI_IsoImageFileQuery_Alloc(&isoImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(isoImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        isoImageFileQuery = NULL;\n\n        if (esxVI_FloppyImageFileQuery_Alloc(&floppyImageFileQuery) < 0 ||\n            esxVI_FileQuery_AppendToList\n              (&searchSpec->query,\n               esxVI_FileQuery_DynamicCast(floppyImageFileQuery)) < 0) {\n            goto cleanup;\n        }\n        floppyImageFileQuery = NULL;\n    }\n\n    if (esxVI_String_Alloc(&searchSpec->matchPattern) < 0)\n        goto cleanup;\n\n    searchSpec->matchPattern->value = fileName;\n\n    /* Search datastore for file */\n    if (esxVI_SearchDatastore_Task(ctx, hostDatastoreBrowser,\n                                   datastorePathWithoutFileName, searchSpec,\n                                   &task) < 0 ||\n        esxVI_WaitForTaskCompletion(ctx, task, NULL, esxVI_Occurrence_None,\n                                    false, &taskInfoState,\n                                    &taskInfoErrorMessage) < 0) {\n        goto cleanup;\n    }\n\n    if (taskInfoState != esxVI_TaskInfoState_Success) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not search in datastore '%s': %s\"),\n                       datastoreName, taskInfoErrorMessage);\n        goto cleanup;\n    }\n\n    if (esxVI_LookupTaskInfoByTask(ctx, task, &taskInfo) < 0 ||\n        esxVI_HostDatastoreBrowserSearchResults_CastFromAnyType\n          (taskInfo->result, &searchResults) < 0) {\n        goto cleanup;\n    }\n\n    /* Interpret search result */\n    if (!searchResults->file) {\n        if (occurrence == esxVI_Occurrence_OptionalItem) {\n            result = 0;\n\n            goto cleanup;\n        } else {\n            virReportError(VIR_ERR_NO_STORAGE_VOL,\n                           _(\"No storage volume with key or path '%s'\"),\n                           datastorePath);\n            goto cleanup;\n        }\n    }\n\n    *fileInfo = searchResults->file;\n    searchResults->file = NULL;\n\n    result = 0;\n\n cleanup:\n    /* Don't double free fileName */\n    if (searchSpec && searchSpec->matchPattern)\n        searchSpec->matchPattern->value = NULL;\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryName);\n    VIR_FREE(directoryAndFileName);\n    VIR_FREE(fileName);\n    VIR_FREE(datastorePathWithoutFileName);\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_ManagedObjectReference_Free(&hostDatastoreBrowser);\n    esxVI_HostDatastoreBrowserSearchSpec_Free(&searchSpec);\n    esxVI_ManagedObjectReference_Free(&task);\n    VIR_FREE(taskInfoErrorMessage);\n    esxVI_TaskInfo_Free(&taskInfo);\n    esxVI_HostDatastoreBrowserSearchResults_Free(&searchResults);\n    esxVI_FolderFileQuery_Free(&folderFileQuery);\n    esxVI_VmDiskFileQuery_Free(&vmDiskFileQuery);\n    esxVI_IsoImageFileQuery_Free(&isoImageFileQuery);\n    esxVI_FloppyImageFileQuery_Free(&floppyImageFileQuery);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "src",
            "\"[\""
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetType",
          "args": [
            "def"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2141-2145",
          "snippet": "int\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskGetType(virDomainDiskDefPtr def)\n{\n    return def->src->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "def"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nesxAutodetectSCSIControllerModel(virDomainDiskDefPtr def, int *model,\n                                 void *opaque)\n{\n    int result = -1;\n    esxVMX_Data *data = opaque;\n    esxVI_FileInfo *fileInfo = NULL;\n    esxVI_VmDiskFileInfo *vmDiskFileInfo = NULL;\n    const char *src = virDomainDiskGetSource(def);\n\n    if (def->device != VIR_DOMAIN_DISK_DEVICE_DISK ||\n        def->bus != VIR_DOMAIN_DISK_BUS_SCSI ||\n        virDomainDiskGetType(def) != VIR_STORAGE_TYPE_FILE ||\n        !src || !STRPREFIX(src, \"[\")) {\n        /*\n         * This isn't a file-based SCSI disk device with a datastore related\n         * source path => do nothing.\n         */\n        return 0;\n    }\n\n    if (esxVI_LookupFileInfoByDatastorePath(data->ctx, src,\n                                            false, &fileInfo,\n                                            esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    vmDiskFileInfo = esxVI_VmDiskFileInfo_DynamicCast(fileInfo);\n\n    if (!vmDiskFileInfo || !vmDiskFileInfo->controllerType) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not lookup controller model for '%s'\"), src);\n        goto cleanup;\n    }\n\n    if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                  \"VirtualBusLogicController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_BUSLOGIC;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"VirtualLsiLogicController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSILOGIC;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"VirtualLsiLogicSASController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_LSISAS1068;\n    } else if (STRCASEEQ(vmDiskFileInfo->controllerType,\n                         \"ParaVirtualSCSIController\")) {\n        *model = VIR_DOMAIN_CONTROLLER_MODEL_SCSI_VMPVSCSI;\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Found unexpected controller model '%s' for disk '%s'\"),\n                       vmDiskFileInfo->controllerType, src);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_FileInfo_Free(&fileInfo);\n\n    return result;\n}"
  },
  {
    "function_name": "esxFormatVMXFileName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "267-350",
    "snippet": "static char *\nesxFormatVMXFileName(const char *fileName, void *opaque)\n{\n    bool success = false;\n    char *result = NULL;\n    esxVMX_Data *data = opaque;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    char separator = '/';\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *tmp;\n    size_t length;\n\n    if (*fileName == '[') {\n        /* Parse datastore path and lookup datastore */\n        if (esxUtil_ParseDatastorePath(fileName, &datastoreName, NULL,\n                                       &directoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_LookupDatastoreByName(data->ctx, datastoreName, NULL, &datastore,\n                                        esxVI_Occurrence_RequiredItem) < 0 ||\n            esxVI_LookupDatastoreHostMount(data->ctx, datastore->obj,\n                                           &hostMount,\n                                           esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        /* Detect separator type */\n        if (strchr(hostMount->mountInfo->path, '\\\\'))\n            separator = '\\\\';\n\n        /* Strip trailing separators */\n        length = strlen(hostMount->mountInfo->path);\n\n        while (length > 0 && hostMount->mountInfo->path[length - 1] == separator)\n            --length;\n\n        /* Format as <mount>[/<directory>]/<file>, convert / to \\ when necessary */\n        virBufferAdd(&buffer, hostMount->mountInfo->path, length);\n\n        if (separator != '/') {\n            tmp = directoryAndFileName;\n\n            while (*tmp != '\\0') {\n                if (*tmp == '/')\n                    *tmp = separator;\n\n                ++tmp;\n            }\n        }\n\n        virBufferAddChar(&buffer, separator);\n        virBufferAdd(&buffer, directoryAndFileName, -1);\n\n        result = virBufferContentAndReset(&buffer);\n    } else if (*fileName == '/') {\n        /* FIXME: need to deal with Windows paths here too */\n        result = g_strdup(fileName);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not handle file name '%s'\"), fileName);\n        goto cleanup;\n    }\n\n    /* FIXME: Check if referenced path/file really exists */\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virBufferFreeAndReset(&buffer);\n        VIR_FREE(result);\n    }\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastore"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "directoryAndFileName"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "datastoreName"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "result"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferFreeAndReset",
          "args": [
            "&buffer"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferFreeAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "268-277",
          "snippet": "void virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virBufferFreeAndReset(virBufferPtr buf)\n{\n    if (!buf)\n        return;\n\n    if (buf->str)\n        g_string_free(buf->str, true);\n\n    memset(buf, 0, sizeof(*buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not handle file name '%s'\")",
            "fileName"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not handle file name '%s'\""
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "fileName"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferContentAndReset",
          "args": [
            "&buffer"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferContentAndReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "247-260",
          "snippet": "char *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirBufferContentAndReset(virBufferPtr buf)\n{\n    char *str = NULL;\n\n    if (!buf)\n        return NULL;\n\n    if (buf->str)\n        str = g_string_free(buf->str, false);\n\n    memset(buf, 0, sizeof(*buf));\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAdd",
          "args": [
            "&buffer",
            "directoryAndFileName",
            "-1"
          ],
          "line": 322
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "156-169",
          "snippet": "void\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdd(virBufferPtr buf, const char *str, int len)\n{\n    if (!str || !buf || (len == 0 && buf->indent == 0))\n        return;\n\n    virBufferInitialize(buf);\n    virBufferApplyIndent(buf);\n\n    if (len < 0)\n        g_string_append(buf->str, str);\n    else\n        g_string_append_len(buf->str, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddChar",
          "args": [
            "&buffer",
            "separator"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAddChar",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "206-210",
          "snippet": "void\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAddChar(virBufferPtr buf, char c)\n{\n    virBufferAdd(buf, &c, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hostMount->mountInfo->path"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "hostMount->mountInfo->path",
            "'\\\\'"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreHostMount",
          "args": [
            "data->ctx",
            "datastore->obj",
            "&hostMount",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 291
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreHostMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3045-3106",
          "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "data->ctx",
            "datastoreName",
            "NULL",
            "&datastore",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_ParseDatastorePath",
          "args": [
            "fileName",
            "&datastoreName",
            "NULL",
            "&directoryAndFileName"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_ParseDatastorePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "206-277",
          "snippet": "int\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nesxUtil_ParseDatastorePath(const char *datastorePath, char **datastoreName,\n                           char **directoryName, char **directoryAndFileName)\n{\n    int result = -1;\n    char *copyOfDatastorePath = NULL;\n    char *tmp = NULL;\n    char *saveptr = NULL;\n    char *preliminaryDatastoreName = NULL;\n    char *preliminaryDirectoryAndFileName = NULL;\n\n    if ((datastoreName && *datastoreName) ||\n        (directoryName && *directoryName) ||\n        (directoryAndFileName && *directoryAndFileName)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(\"Invalid argument\"));\n        return -1;\n    }\n\n    copyOfDatastorePath = g_strdup(datastorePath);\n\n    /* Expected format: '[<datastore>] <path>' where <path> is optional */\n    if (!(tmp = STRSKIP(copyOfDatastorePath, \"[\")) || *tmp == ']' ||\n        !(preliminaryDatastoreName = strtok_r(tmp, \"]\", &saveptr))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Datastore path '%s' doesn't have expected format \"\n                         \"'[<datastore>] <path>'\"), datastorePath);\n        goto cleanup;\n    }\n\n    if (datastoreName)\n        *datastoreName = g_strdup(preliminaryDatastoreName);\n\n    preliminaryDirectoryAndFileName = strtok_r(NULL, \"\", &saveptr);\n\n    if (!preliminaryDirectoryAndFileName) {\n        preliminaryDirectoryAndFileName = (char *)\"\";\n    } else {\n        preliminaryDirectoryAndFileName +=\n          strspn(preliminaryDirectoryAndFileName, \" \");\n    }\n\n    if (directoryAndFileName)\n        *directoryAndFileName = g_strdup(preliminaryDirectoryAndFileName);\n\n    if (directoryName) {\n        /* Split <path> into <directory>/<file> and remove /<file> */\n        tmp = strrchr(preliminaryDirectoryAndFileName, '/');\n\n        if (tmp)\n            *tmp = '\\0';\n\n        *directoryName = g_strdup(preliminaryDirectoryAndFileName);\n    }\n\n    result = 0;\n\n cleanup:\n    if (result < 0) {\n        if (datastoreName)\n            VIR_FREE(*datastoreName);\n\n        if (directoryName)\n            VIR_FREE(*directoryName);\n\n        if (directoryAndFileName)\n            VIR_FREE(*directoryAndFileName);\n    }\n\n    VIR_FREE(copyOfDatastorePath);\n\n    return result;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxFormatVMXFileName(const char *fileName, void *opaque)\n{\n    bool success = false;\n    char *result = NULL;\n    esxVMX_Data *data = opaque;\n    char *datastoreName = NULL;\n    char *directoryAndFileName = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    char separator = '/';\n    virBuffer buffer = VIR_BUFFER_INITIALIZER;\n    char *tmp;\n    size_t length;\n\n    if (*fileName == '[') {\n        /* Parse datastore path and lookup datastore */\n        if (esxUtil_ParseDatastorePath(fileName, &datastoreName, NULL,\n                                       &directoryAndFileName) < 0) {\n            goto cleanup;\n        }\n\n        if (esxVI_LookupDatastoreByName(data->ctx, datastoreName, NULL, &datastore,\n                                        esxVI_Occurrence_RequiredItem) < 0 ||\n            esxVI_LookupDatastoreHostMount(data->ctx, datastore->obj,\n                                           &hostMount,\n                                           esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        /* Detect separator type */\n        if (strchr(hostMount->mountInfo->path, '\\\\'))\n            separator = '\\\\';\n\n        /* Strip trailing separators */\n        length = strlen(hostMount->mountInfo->path);\n\n        while (length > 0 && hostMount->mountInfo->path[length - 1] == separator)\n            --length;\n\n        /* Format as <mount>[/<directory>]/<file>, convert / to \\ when necessary */\n        virBufferAdd(&buffer, hostMount->mountInfo->path, length);\n\n        if (separator != '/') {\n            tmp = directoryAndFileName;\n\n            while (*tmp != '\\0') {\n                if (*tmp == '/')\n                    *tmp = separator;\n\n                ++tmp;\n            }\n        }\n\n        virBufferAddChar(&buffer, separator);\n        virBufferAdd(&buffer, directoryAndFileName, -1);\n\n        result = virBufferContentAndReset(&buffer);\n    } else if (*fileName == '/') {\n        /* FIXME: need to deal with Windows paths here too */\n        result = g_strdup(fileName);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not handle file name '%s'\"), fileName);\n        goto cleanup;\n    }\n\n    /* FIXME: Check if referenced path/file really exists */\n\n    success = true;\n\n cleanup:\n    if (! success) {\n        virBufferFreeAndReset(&buffer);\n        VIR_FREE(result);\n    }\n\n    VIR_FREE(datastoreName);\n    VIR_FREE(directoryAndFileName);\n    esxVI_ObjectContent_Free(&datastore);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n\n    return result;\n}"
  },
  {
    "function_name": "esxParseVMXFileName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "128-250",
    "snippet": "static char *\nesxParseVMXFileName(const char *fileName, void *opaque)\n{\n    char *result = NULL;\n    esxVMX_Data *data = opaque;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    char *datastoreName;\n    char *tmp;\n    char *saveptr;\n    char *strippedFileName = NULL;\n    char *copyOfFileName = NULL;\n    char *directoryAndFileName;\n\n    if (!strchr(fileName, '/') && !strchr(fileName, '\\\\')) {\n        /* Plain file name, use same directory as for the .vmx file */\n        result = g_strdup_printf(\"%s/%s\", data->datastorePathWithoutFileName,\n                                 fileName);\n    } else {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"summary.name\") < 0 ||\n            esxVI_LookupDatastoreList(data->ctx, propertyNameList,\n                                      &datastoreList) < 0) {\n            return NULL;\n        }\n\n        /* Search for datastore by mount path */\n        for (datastore = datastoreList; datastore;\n             datastore = datastore->_next) {\n            esxVI_DatastoreHostMount_Free(&hostMount);\n            datastoreName = NULL;\n\n            if (esxVI_LookupDatastoreHostMount(data->ctx, datastore->obj,\n                                               &hostMount,\n                                               esxVI_Occurrence_RequiredItem) < 0 ||\n                esxVI_GetStringValue(datastore, \"summary.name\", &datastoreName,\n                                     esxVI_Occurrence_RequiredItem) < 0) {\n                goto cleanup;\n            }\n\n            tmp = (char *)STRSKIP(fileName, hostMount->mountInfo->path);\n\n            if (!tmp)\n                continue;\n\n            /* Found a match. Strip leading separators */\n            while (*tmp == '/' || *tmp == '\\\\')\n                ++tmp;\n\n            strippedFileName = g_strdup(tmp);\n\n            tmp = strippedFileName;\n\n            /* Convert \\ to / */\n            while (*tmp != '\\0') {\n                if (*tmp == '\\\\')\n                    *tmp = '/';\n\n                ++tmp;\n            }\n\n            result = g_strdup_printf(\"[%s] %s\", datastoreName, strippedFileName);\n\n            break;\n        }\n\n        /* Fallback to direct datastore name match */\n        if (!result && STRPREFIX(fileName, \"/vmfs/volumes/\")) {\n            copyOfFileName = g_strdup(fileName);\n\n            /* Expected format: '/vmfs/volumes/<datastore>/<path>' */\n            if (!(tmp = STRSKIP(copyOfFileName, \"/vmfs/volumes/\")) ||\n                !(datastoreName = strtok_r(tmp, \"/\", &saveptr))    ||\n                !(directoryAndFileName = strtok_r(NULL, \"\", &saveptr))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File name '%s' doesn't have expected format \"\n                                 \"'/vmfs/volumes/<datastore>/<path>'\"), fileName);\n                goto cleanup;\n            }\n\n            esxVI_ObjectContent_Free(&datastoreList);\n\n            if (esxVI_LookupDatastoreByName(data->ctx, datastoreName,\n                                            NULL, &datastoreList,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n\n            if (!datastoreList) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File name '%s' refers to non-existing datastore '%s'\"),\n                               fileName, datastoreName);\n                goto cleanup;\n            }\n\n            result = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                     directoryAndFileName);\n        }\n\n        /* If it's an absolute path outside of a datastore just use it as is */\n        if (!result && *fileName == '/') {\n            /* FIXME: need to deal with Windows paths here too */\n            result = g_strdup(fileName);\n        }\n\n        if (!result) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not handle file name '%s'\"), fileName);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n    VIR_FREE(strippedFileName);\n    VIR_FREE(copyOfFileName);\n\n    return result;\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "copyOfFileName"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "strippedFileName"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_String_Free",
          "args": [
            "&propertyNameList"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not handle file name '%s'\")",
            "fileName"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not handle file name '%s'\""
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_ProductLineToDisplayName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "4452-4468",
          "snippet": "const char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nconst char *\nesxVI_ProductLineToDisplayName(esxVI_ProductLine productLine)\n{\n    switch (productLine) {\n      case esxVI_ProductLine_GSX:\n        return \"Server/GSX\";\n\n      case esxVI_ProductLine_ESX:\n        return \"ESX(i)\";\n\n      case esxVI_ProductLine_VPX:\n        return \"vCenter/VPX\";\n\n      default:\n        return \"<unknown>\";\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "fileName"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"File name '%s' refers to non-existing datastore '%s'\")",
            "fileName",
            "datastoreName"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreByName",
          "args": [
            "data->ctx",
            "datastoreName",
            "NULL",
            "&datastoreList",
            "esxVI_Occurrence_OptionalItem"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreByName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2899-2957",
          "snippet": "int\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreByName(esxVI_Context *ctx, const char *name,\n                            esxVI_String *propertyNameList,\n                            esxVI_ObjectContent **datastore,\n                            esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *completePropertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *candidate = NULL;\n    char *name_candidate;\n\n    ESX_VI_CHECK_ARG_LIST(datastore);\n\n    /* Get all datastores */\n    if (esxVI_String_DeepCopyList(&completePropertyNameList,\n                                  propertyNameList) < 0 ||\n        esxVI_String_AppendValueToList(&completePropertyNameList,\n                                       \"summary.name\") < 0 ||\n        esxVI_LookupDatastoreList(ctx, completePropertyNameList,\n                                  &datastoreList) < 0) {\n        goto cleanup;\n    }\n\n    /* Search for a matching datastore */\n    for (candidate = datastoreList; candidate;\n         candidate = candidate->_next) {\n        name_candidate = NULL;\n\n        if (esxVI_GetStringValue(candidate, \"summary.name\", &name_candidate,\n                                 esxVI_Occurrence_RequiredItem) < 0) {\n            goto cleanup;\n        }\n\n        if (STREQ(name_candidate, name)) {\n            if (esxVI_ObjectContent_DeepCopy(datastore, candidate) < 0)\n                goto cleanup;\n\n            /* Found datastore with matching name */\n            result = 0;\n\n            goto cleanup;\n        }\n    }\n\n    if (!(*datastore) && occurrence != esxVI_Occurrence_OptionalItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not find datastore with name '%s'\"), name);\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&completePropertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_ObjectContent_Free",
          "args": [
            "&datastoreList"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"File name '%s' doesn't have expected format \"\n                                 \"'/vmfs/volumes/<datastore>/<path>'\")",
            "fileName"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "NULL",
            "\"\"",
            "&saveptr"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "tmp",
            "\"/\"",
            "&saveptr"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "copyOfFileName",
            "\"/vmfs/volumes/\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "fileName",
            "\"/vmfs/volumes/\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRSKIP",
          "args": [
            "fileName",
            "hostMount->mountInfo->path"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_GetStringValue",
          "args": [
            "datastore",
            "\"summary.name\"",
            "&datastoreName",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_GetStringValue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2323-2352",
          "snippet": "int\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_GetStringValue(esxVI_ObjectContent *objectContent,\n                     const char *propertyName,\n                     char **value, esxVI_Occurrence occurrence)\n{\n    esxVI_DynamicProperty *dynamicProperty;\n\n    ESX_VI_CHECK_ARG_LIST(value);\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, propertyName)) {\n            if (esxVI_AnyType_ExpectType(dynamicProperty->val,\n                                         esxVI_Type_String) < 0) {\n                return -1;\n            }\n\n            *value = dynamicProperty->val->string;\n            break;\n        }\n    }\n\n    if (!(*value) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing '%s' property\"), propertyName);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreHostMount",
          "args": [
            "data->ctx",
            "datastore->obj",
            "&hostMount",
            "esxVI_Occurrence_RequiredItem"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreHostMount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "3045-3106",
          "snippet": "int\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreHostMount(esxVI_Context *ctx,\n                               esxVI_ManagedObjectReference *datastore,\n                               esxVI_DatastoreHostMount **hostMount,\n                               esxVI_Occurrence occurrence)\n{\n    int result = -1;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *objectContent = NULL;\n    esxVI_DynamicProperty *dynamicProperty = NULL;\n    esxVI_DatastoreHostMount *hostMountList = NULL;\n    esxVI_DatastoreHostMount *candidate = NULL;\n\n    ESX_VI_CHECK_ARG_LIST(hostMount);\n\n    if (esxVI_String_AppendValueToList(&propertyNameList, \"host\") < 0 ||\n        esxVI_LookupObjectContentByType(ctx, datastore, \"Datastore\",\n                                        propertyNameList, &objectContent,\n                                        esxVI_Occurrence_RequiredItem) < 0) {\n        goto cleanup;\n    }\n\n    for (dynamicProperty = objectContent->propSet; dynamicProperty;\n         dynamicProperty = dynamicProperty->_next) {\n        if (STREQ(dynamicProperty->name, \"host\")) {\n            if (esxVI_DatastoreHostMount_CastListFromAnyType\n                  (dynamicProperty->val, &hostMountList) < 0) {\n                goto cleanup;\n            }\n\n            break;\n        } else {\n            VIR_WARN(\"Unexpected '%s' property\", dynamicProperty->name);\n        }\n    }\n\n    for (candidate = hostMountList; candidate;\n         candidate = candidate->_next) {\n        if (STRNEQ(ctx->hostSystem->_reference->value, candidate->key->value))\n            continue;\n\n        if (esxVI_DatastoreHostMount_DeepCopy(hostMount, candidate) < 0)\n            goto cleanup;\n\n        break;\n    }\n\n    if (!(*hostMount) && occurrence == esxVI_Occurrence_RequiredItem) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not lookup datastore host mount\"));\n        goto cleanup;\n    }\n\n    result = 0;\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&objectContent);\n    esxVI_DatastoreHostMount_Free(&hostMountList);\n\n    return result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_DatastoreHostMount_Free",
          "args": [
            "&hostMount"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_LookupDatastoreList",
          "args": [
            "data->ctx",
            "propertyNameList",
            "&datastoreList"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_LookupDatastoreList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi.c",
          "lines": "2885-2895",
          "snippet": "int\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}",
          "includes": [
            "#include \"esx_vi.generated.c\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_vi_methods.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virxml.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi.generated.c\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"virxml.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nint\nesxVI_LookupDatastoreList(esxVI_Context *ctx, esxVI_String *propertyNameList,\n                          esxVI_ObjectContent **datastoreList)\n{\n    /* FIXME: Switch from ctx->hostSystem to ctx->computeResource for cluster\n     *        support */\n    return esxVI_LookupObjectContentByType(ctx, ctx->hostSystem->_reference,\n                                           \"Datastore\", propertyNameList,\n                                           datastoreList,\n                                           esxVI_Occurrence_OptionalList);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_String_AppendValueToList",
          "args": [
            "&propertyNameList",
            "\"summary.name\""
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "esxVI_String_AppendValueToList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_vi_types.c",
          "lines": "1144-1165",
          "snippet": "ESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}",
          "includes": [
            "#include \"esx_vi_types.generated.typefromstring\"",
            "#include \"esx_vi_types.generated.typetostring\"",
            "#include \"virxml.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_vi_types.h\"",
            "#include \"esx_vi.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <libxml/parser.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"esx_vi_types.generated.typefromstring\"\n#include \"esx_vi_types.generated.typetostring\"\n#include \"virxml.h\"\n#include \"virstring.h\"\n#include \"esx_vi_types.h\"\n#include \"esx_vi.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include <libxml/xpathInternals.h>\n#include <libxml/parser.h>\n#include <config.h>\n\nESX_VI__TEMPLATE__LIST__APPEND(String)\n\nint\nesxVI_String_AppendValueToList(esxVI_String **stringList, const char *value)\n{\n    esxVI_String *string = NULL;\n\n    if (esxVI_String_Alloc(&string) < 0)\n        return -1;\n\n    string->value = g_strdup(value);\n\n    if (esxVI_String_AppendToList(stringList, string) < 0)\n        goto failure;\n\n    return 0;\n\n failure:\n    esxVI_String_Free(&string);\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fileName",
            "'\\\\'"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "fileName",
            "'/'"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nesxParseVMXFileName(const char *fileName, void *opaque)\n{\n    char *result = NULL;\n    esxVMX_Data *data = opaque;\n    esxVI_String *propertyNameList = NULL;\n    esxVI_ObjectContent *datastoreList = NULL;\n    esxVI_ObjectContent *datastore = NULL;\n    esxVI_DatastoreHostMount *hostMount = NULL;\n    char *datastoreName;\n    char *tmp;\n    char *saveptr;\n    char *strippedFileName = NULL;\n    char *copyOfFileName = NULL;\n    char *directoryAndFileName;\n\n    if (!strchr(fileName, '/') && !strchr(fileName, '\\\\')) {\n        /* Plain file name, use same directory as for the .vmx file */\n        result = g_strdup_printf(\"%s/%s\", data->datastorePathWithoutFileName,\n                                 fileName);\n    } else {\n        if (esxVI_String_AppendValueToList(&propertyNameList,\n                                           \"summary.name\") < 0 ||\n            esxVI_LookupDatastoreList(data->ctx, propertyNameList,\n                                      &datastoreList) < 0) {\n            return NULL;\n        }\n\n        /* Search for datastore by mount path */\n        for (datastore = datastoreList; datastore;\n             datastore = datastore->_next) {\n            esxVI_DatastoreHostMount_Free(&hostMount);\n            datastoreName = NULL;\n\n            if (esxVI_LookupDatastoreHostMount(data->ctx, datastore->obj,\n                                               &hostMount,\n                                               esxVI_Occurrence_RequiredItem) < 0 ||\n                esxVI_GetStringValue(datastore, \"summary.name\", &datastoreName,\n                                     esxVI_Occurrence_RequiredItem) < 0) {\n                goto cleanup;\n            }\n\n            tmp = (char *)STRSKIP(fileName, hostMount->mountInfo->path);\n\n            if (!tmp)\n                continue;\n\n            /* Found a match. Strip leading separators */\n            while (*tmp == '/' || *tmp == '\\\\')\n                ++tmp;\n\n            strippedFileName = g_strdup(tmp);\n\n            tmp = strippedFileName;\n\n            /* Convert \\ to / */\n            while (*tmp != '\\0') {\n                if (*tmp == '\\\\')\n                    *tmp = '/';\n\n                ++tmp;\n            }\n\n            result = g_strdup_printf(\"[%s] %s\", datastoreName, strippedFileName);\n\n            break;\n        }\n\n        /* Fallback to direct datastore name match */\n        if (!result && STRPREFIX(fileName, \"/vmfs/volumes/\")) {\n            copyOfFileName = g_strdup(fileName);\n\n            /* Expected format: '/vmfs/volumes/<datastore>/<path>' */\n            if (!(tmp = STRSKIP(copyOfFileName, \"/vmfs/volumes/\")) ||\n                !(datastoreName = strtok_r(tmp, \"/\", &saveptr))    ||\n                !(directoryAndFileName = strtok_r(NULL, \"\", &saveptr))) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File name '%s' doesn't have expected format \"\n                                 \"'/vmfs/volumes/<datastore>/<path>'\"), fileName);\n                goto cleanup;\n            }\n\n            esxVI_ObjectContent_Free(&datastoreList);\n\n            if (esxVI_LookupDatastoreByName(data->ctx, datastoreName,\n                                            NULL, &datastoreList,\n                                            esxVI_Occurrence_OptionalItem) < 0) {\n                goto cleanup;\n            }\n\n            if (!datastoreList) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"File name '%s' refers to non-existing datastore '%s'\"),\n                               fileName, datastoreName);\n                goto cleanup;\n            }\n\n            result = g_strdup_printf(\"[%s] %s\", datastoreName,\n                                     directoryAndFileName);\n        }\n\n        /* If it's an absolute path outside of a datastore just use it as is */\n        if (!result && *fileName == '/') {\n            /* FIXME: need to deal with Windows paths here too */\n            result = g_strdup(fileName);\n        }\n\n        if (!result) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Could not handle file name '%s'\"), fileName);\n            goto cleanup;\n        }\n    }\n\n cleanup:\n    esxVI_String_Free(&propertyNameList);\n    esxVI_ObjectContent_Free(&datastoreList);\n    esxVI_DatastoreHostMount_Free(&hostMount);\n    VIR_FREE(strippedFileName);\n    VIR_FREE(copyOfFileName);\n\n    return result;\n}"
  },
  {
    "function_name": "esxFreePrivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_driver.c",
    "lines": "63-75",
    "snippet": "static void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}",
    "includes": [
      "#include \"viruri.h\"",
      "#include \"virstring.h\"",
      "#include \"esx_stream.h\"",
      "#include \"esx_util.h\"",
      "#include \"esx_vi_methods.h\"",
      "#include \"esx_vi.h\"",
      "#include \"esx_private.h\"",
      "#include \"esx_storage_driver.h\"",
      "#include \"esx_network_driver.h\"",
      "#include \"esx_interface_driver.h\"",
      "#include \"esx_driver.h\"",
      "#include \"virtypedparam.h\"",
      "#include \"vmx.h\"",
      "#include \"viruuid.h\"",
      "#include \"virlog.h\"",
      "#include \"virfile.h\"",
      "#include \"viralloc.h\"",
      "#include \"virauth.h\"",
      "#include \"snapshot_conf.h\"",
      "#include \"virdomainobjlist.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*priv"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "(*priv)->xmlopt"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxUtil_FreeParsedUri",
          "args": [
            "&(*priv)->parsedUri"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "esxUtil_FreeParsedUri",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/esx/esx_util.c",
          "lines": "169-181",
          "snippet": "void\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virstring.h\"",
            "#include \"esx_util.h\"",
            "#include \"esx_private.h\"",
            "#include \"vmx.h\"",
            "#include \"viruuid.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virstring.h\"\n#include \"esx_util.h\"\n#include \"esx_private.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nesxUtil_FreeParsedUri(esxUtil_ParsedUri **parsedUri)\n{\n    if (!parsedUri || !(*parsedUri))\n        return;\n\n    VIR_FREE((*parsedUri)->transport);\n    VIR_FREE((*parsedUri)->vCenter);\n    VIR_FREE((*parsedUri)->proxy_hostname);\n    VIR_FREE((*parsedUri)->path);\n\n    VIR_FREE(*parsedUri);\n}"
        }
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Free",
          "args": [
            "&(*priv)->vCenter"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "esxVI_Context_Free",
          "args": [
            "&(*priv)->host"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"esx_stream.h\"\n#include \"esx_util.h\"\n#include \"esx_vi_methods.h\"\n#include \"esx_vi.h\"\n#include \"esx_private.h\"\n#include \"esx_storage_driver.h\"\n#include \"esx_network_driver.h\"\n#include \"esx_interface_driver.h\"\n#include \"esx_driver.h\"\n#include \"virtypedparam.h\"\n#include \"vmx.h\"\n#include \"viruuid.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virauth.h\"\n#include \"snapshot_conf.h\"\n#include \"virdomainobjlist.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nesxFreePrivate(esxPrivate **priv)\n{\n    if (!priv || !(*priv))\n        return;\n\n    esxVI_Context_Free(&(*priv)->host);\n    esxVI_Context_Free(&(*priv)->vCenter);\n    esxUtil_FreeParsedUri(&(*priv)->parsedUri);\n    virObjectUnref((*priv)->caps);\n    virObjectUnref((*priv)->xmlopt);\n    VIR_FREE(*priv);\n}"
  }
]