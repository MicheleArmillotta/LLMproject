[
  {
    "function_name": "virSecurityDriverLookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_driver.c",
    "lines": "48-93",
    "snippet": "virSecurityDriverPtr virSecurityDriverLookup(const char *name,\n                                             const char *virtDriver)\n{\n    virSecurityDriverPtr drv = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n\n    for (i = 0; i < G_N_ELEMENTS(security_drivers) && !drv; i++) {\n        virSecurityDriverPtr tmp = security_drivers[i];\n\n        if (name &&\n            STRNEQ(tmp->name, name))\n            continue;\n\n        switch (tmp->probe(virtDriver)) {\n        case SECURITY_DRIVER_ENABLE:\n            VIR_DEBUG(\"Probed name=%s\", tmp->name);\n            drv = tmp;\n            break;\n\n        case SECURITY_DRIVER_DISABLE:\n            VIR_DEBUG(\"Not enabled name=%s\", tmp->name);\n            if (name && STREQ(tmp->name, name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Security driver %s not enabled\"),\n                               name);\n                return NULL;\n            }\n            break;\n\n        case SECURITY_DRIVER_ERROR:\n        default:\n            return NULL;\n        }\n    }\n\n    if (!drv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Security driver %s not found\"),\n                       NULLSTR(name));\n        return NULL;\n    }\n\n    return drv;\n}",
    "includes": [
      "#include \"security_nop.h\"",
      "# include \"security_apparmor.h\"",
      "# include \"security_selinux.h\"",
      "#include \"security_driver.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virSecurityDriverPtr security_drivers[] = {\n#ifdef WITH_SECDRIVER_SELINUX\n    &virSecurityDriverSELinux,\n#endif\n#ifdef WITH_SECDRIVER_APPARMOR\n    &virAppArmorSecurityDriver,\n#endif\n    &virSecurityDriverNop, /* Must always be last, since it will always probe */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Security driver %s not found\")",
            "NULLSTR(name)"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Security driver %s not found\""
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Security driver %s not enabled\")",
            "name"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "tmp->name",
            "name"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Not enabled name=%s\"",
            "tmp->name"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Probed name=%s\"",
            "tmp->name"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tmp->probe",
          "args": [
            "virtDriver"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "tmp->name",
            "name"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "security_drivers"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"name=%s\"",
            "NULLSTR(name)"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "name"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"security_nop.h\"\n# include \"security_apparmor.h\"\n# include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virSecurityDriverPtr security_drivers[] = {\n#ifdef WITH_SECDRIVER_SELINUX\n    &virSecurityDriverSELinux,\n#endif\n#ifdef WITH_SECDRIVER_APPARMOR\n    &virAppArmorSecurityDriver,\n#endif\n    &virSecurityDriverNop, /* Must always be last, since it will always probe */\n};\n\nvirSecurityDriverPtr virSecurityDriverLookup(const char *name,\n                                             const char *virtDriver)\n{\n    virSecurityDriverPtr drv = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n\n    for (i = 0; i < G_N_ELEMENTS(security_drivers) && !drv; i++) {\n        virSecurityDriverPtr tmp = security_drivers[i];\n\n        if (name &&\n            STRNEQ(tmp->name, name))\n            continue;\n\n        switch (tmp->probe(virtDriver)) {\n        case SECURITY_DRIVER_ENABLE:\n            VIR_DEBUG(\"Probed name=%s\", tmp->name);\n            drv = tmp;\n            break;\n\n        case SECURITY_DRIVER_DISABLE:\n            VIR_DEBUG(\"Not enabled name=%s\", tmp->name);\n            if (name && STREQ(tmp->name, name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Security driver %s not enabled\"),\n                               name);\n                return NULL;\n            }\n            break;\n\n        case SECURITY_DRIVER_ERROR:\n        default:\n            return NULL;\n        }\n    }\n\n    if (!drv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Security driver %s not found\"),\n                       NULLSTR(name));\n        return NULL;\n    }\n\n    return drv;\n}"
  }
]