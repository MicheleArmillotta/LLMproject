[
  {
    "function_name": "virNetClientStreamEOF",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "805-808",
    "snippet": "bool virNetClientStreamEOF(virNetClientStreamPtr st)\n{\n    return st->incomingEOF;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nbool virNetClientStreamEOF(virNetClientStreamPtr st)\n{\n    return st->incomingEOF;\n}"
  },
  {
    "function_name": "virNetClientStreamEventRemoveCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "778-803",
    "snippet": "int virNetClientStreamEventRemoveCallback(virNetClientStreamPtr st)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (!st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no stream callback registered\"));\n        goto cleanup;\n    }\n\n    if (!st->cbDispatch &&\n        st->cbFree)\n        (st->cbFree)(st->cbOpaque);\n    st->cb = NULL;\n    st->cbOpaque = NULL;\n    st->cbFree = NULL;\n    st->cbEvents = 0;\n    virEventRemoveTimeout(st->cbTimer);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventRemoveTimeout",
          "args": [
            "st->cbTimer"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "188-195",
          "snippet": "int\nvirEventRemoveTimeout(int timer)\n{\n    if (!removeTimeoutImpl)\n        return -1;\n\n    return removeTimeoutImpl(timer);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveTimeoutFunc removeTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveTimeoutFunc removeTimeoutImpl;\n\nint\nvirEventRemoveTimeout(int timer)\n{\n    if (!removeTimeoutImpl)\n        return -1;\n\n    return removeTimeoutImpl(timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "st->cbOpaque"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no stream callback registered\")"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no stream callback registered\""
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamEventRemoveCallback(virNetClientStreamPtr st)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (!st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no stream callback registered\"));\n        goto cleanup;\n    }\n\n    if (!st->cbDispatch &&\n        st->cbFree)\n        (st->cbFree)(st->cbOpaque);\n    st->cb = NULL;\n    st->cbOpaque = NULL;\n    st->cbFree = NULL;\n    st->cbEvents = 0;\n    virEventRemoveTimeout(st->cbTimer);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamEventUpdateCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "755-776",
    "snippet": "int virNetClientStreamEventUpdateCallback(virNetClientStreamPtr st,\n                                          int events)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (!st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no stream callback registered\"));\n        goto cleanup;\n    }\n\n    st->cbEvents = events;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no stream callback registered\")"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no stream callback registered\""
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamEventUpdateCallback(virNetClientStreamPtr st,\n                                          int events)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (!st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"no stream callback registered\"));\n        goto cleanup;\n    }\n\n    st->cbEvents = events;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamEventAddCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "716-753",
    "snippet": "int virNetClientStreamEventAddCallback(virNetClientStreamPtr st,\n                                       int events,\n                                       virNetClientStreamEventCallback cb,\n                                       void *opaque,\n                                       virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"multiple stream callbacks not supported\"));\n        goto cleanup;\n    }\n\n    virObjectRef(st);\n    if ((st->cbTimer =\n         virEventAddTimeout(-1,\n                            virNetClientStreamEventTimer,\n                            st,\n                            virObjectFreeCallback)) < 0) {\n        virObjectUnref(st);\n        goto cleanup;\n    }\n\n    st->cb = cb;\n    st->cbOpaque = opaque;\n    st->cbFree = ff;\n    st->cbEvents = events;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virEventAddTimeout",
          "args": [
            "-1",
            "virNetClientStreamEventTimer",
            "st",
            "virObjectFreeCallback"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "143-153",
          "snippet": "int\nvirEventAddTimeout(int timeout,\n                   virEventTimeoutCallback cb,\n                   void *opaque,\n                   virFreeCallback ff)\n{\n    if (!addTimeoutImpl)\n        return -1;\n\n    return addTimeoutImpl(timeout, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddTimeoutFunc addTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddTimeoutFunc addTimeoutImpl;\n\nint\nvirEventAddTimeout(int timeout,\n                   virEventTimeoutCallback cb,\n                   void *opaque,\n                   virFreeCallback ff)\n{\n    if (!addTimeoutImpl)\n        return -1;\n\n    return addTimeoutImpl(timeout, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "st"
          ],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"multiple stream callbacks not supported\")"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"multiple stream callbacks not supported\""
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 724
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamEventAddCallback(virNetClientStreamPtr st,\n                                       int events,\n                                       virNetClientStreamEventCallback cb,\n                                       void *opaque,\n                                       virFreeCallback ff)\n{\n    int ret = -1;\n\n    virObjectLock(st);\n    if (st->cb) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"multiple stream callbacks not supported\"));\n        goto cleanup;\n    }\n\n    virObjectRef(st);\n    if ((st->cbTimer =\n         virEventAddTimeout(-1,\n                            virNetClientStreamEventTimer,\n                            st,\n                            virObjectFreeCallback)) < 0) {\n        virObjectUnref(st);\n        goto cleanup;\n    }\n\n    st->cb = cb;\n    st->cbOpaque = opaque;\n    st->cbFree = ff;\n    st->cbEvents = events;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(st);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamRecvHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "690-713",
    "snippet": "int\nvirNetClientStreamRecvHole(virNetClientPtr client G_GNUC_UNUSED,\n                           virNetClientStreamPtr st,\n                           long long *length)\n{\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Holes are not supported with this stream\"));\n        return -1;\n    }\n\n    virObjectLock(st);\n\n    if (virNetClientStreamCheckState(st) < 0) {\n        virObjectUnlock(st);\n        return -1;\n    }\n\n    *length = st->holeLength;\n    st->holeLength = 0;\n\n    virObjectUnlock(st);\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamCheckState",
          "args": [
            "st"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamCheckState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "200-214",
          "snippet": "int virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Holes are not supported with this stream\")"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Holes are not supported with this stream\""
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint\nvirNetClientStreamRecvHole(virNetClientPtr client G_GNUC_UNUSED,\n                           virNetClientStreamPtr st,\n                           long long *length)\n{\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Holes are not supported with this stream\"));\n        return -1;\n    }\n\n    virObjectLock(st);\n\n    if (virNetClientStreamCheckState(st) < 0) {\n        virObjectUnlock(st);\n        return -1;\n    }\n\n    *length = st->holeLength;\n    st->holeLength = 0;\n\n    virObjectUnlock(st);\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientStreamSendHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "636-687",
    "snippet": "int\nvirNetClientStreamSendHole(virNetClientStreamPtr st,\n                           virNetClientPtr client,\n                           long long length,\n                           unsigned int flags)\n{\n    virNetMessagePtr msg = NULL;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"st=%p length=%llu\", st, length);\n\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Skipping is not supported with this stream\"));\n        return -1;\n    }\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    virObjectLock(st);\n\n    msg->header.prog = virNetClientProgramGetProgram(st->prog);\n    msg->header.vers = virNetClientProgramGetVersion(st->prog);\n    msg->header.status = VIR_NET_CONTINUE;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = st->serial;\n    msg->header.proc = st->proc;\n\n    virObjectUnlock(st);\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto cleanup;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        goto cleanup;\n\n    if (virNetClientSendStream(client, msg, st) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetMessageFree(msg);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendStream",
          "args": [
            "client",
            "msg",
            "st"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2188-2219",
          "snippet": "int virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetStreamHole",
            "&data"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetVersion",
          "args": [
            "st->prog"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "99-102",
          "snippet": "unsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetProgram",
          "args": [
            "st->prog"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "93-96",
          "snippet": "unsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_INVALID",
            "\"%s\"",
            "_(\"Skipping is not supported with this stream\")"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Skipping is not supported with this stream\""
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p length=%llu\"",
            "st",
            "length"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint\nvirNetClientStreamSendHole(virNetClientStreamPtr st,\n                           virNetClientPtr client,\n                           long long length,\n                           unsigned int flags)\n{\n    virNetMessagePtr msg = NULL;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"st=%p length=%llu\", st, length);\n\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_OPERATION_INVALID, \"%s\",\n                       _(\"Skipping is not supported with this stream\"));\n        return -1;\n    }\n\n    memset(&data, 0, sizeof(data));\n    data.length = length;\n    data.flags = flags;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    virObjectLock(st);\n\n    msg->header.prog = virNetClientProgramGetProgram(st->prog);\n    msg->header.vers = virNetClientProgramGetVersion(st->prog);\n    msg->header.status = VIR_NET_CONTINUE;\n    msg->header.type = VIR_NET_STREAM_HOLE;\n    msg->header.serial = st->serial;\n    msg->header.proc = st->proc;\n\n    virObjectUnlock(st);\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto cleanup;\n\n    if (virNetMessageEncodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0)\n        goto cleanup;\n\n    if (virNetClientSendStream(client, msg, st) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virNetMessageFree(msg);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamRecvPacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "510-633",
    "snippet": "int virNetClientStreamRecvPacket(virNetClientStreamPtr st,\n                                 virNetClientPtr client,\n                                 char *data,\n                                 size_t nbytes,\n                                 bool nonblock,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    size_t want;\n\n    VIR_DEBUG(\"st=%p client=%p data=%p nbytes=%zu nonblock=%d flags=0x%x\",\n              st, client, data, nbytes, nonblock, flags);\n\n    virCheckFlags(VIR_STREAM_RECV_STOP_AT_HOLE, -1);\n\n    virObjectLock(st);\n\n reread:\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    if (!st->rx && !st->incomingEOF) {\n        virNetMessagePtr msg;\n        int ret;\n\n        if (nonblock) {\n            VIR_DEBUG(\"Non-blocking mode and no data available\");\n            rv = -2;\n            goto cleanup;\n        }\n\n        if (!(msg = virNetMessageNew(false)))\n            goto cleanup;\n\n        msg->header.prog = virNetClientProgramGetProgram(st->prog);\n        msg->header.vers = virNetClientProgramGetVersion(st->prog);\n        msg->header.type = VIR_NET_STREAM;\n        msg->header.serial = st->serial;\n        msg->header.proc = st->proc;\n        msg->header.status = VIR_NET_CONTINUE;\n\n        VIR_DEBUG(\"Dummy packet to wait for stream data\");\n        virObjectUnlock(st);\n        ret = virNetClientSendStream(client, msg, st);\n        virObjectLock(st);\n        virNetMessageFree(msg);\n\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"After IO rx=%p\", st->rx);\n\n    if (st->rx &&\n        st->rx->header.type == VIR_NET_STREAM_HOLE &&\n        st->holeLength == 0) {\n        /* Handle skip sent to us by server. */\n\n        if (virNetClientStreamHandleHole(client, st) < 0)\n            goto cleanup;\n    }\n\n    if (!st->rx && !st->incomingEOF && st->holeLength == 0) {\n        if (nonblock) {\n            VIR_DEBUG(\"Non-blocking mode and no data available\");\n            rv = -2;\n            goto cleanup;\n        }\n\n        /* We have consumed all packets from incoming queue but those\n         * were only skip packets, no data. Read the stream again. */\n        goto reread;\n    }\n\n    want = nbytes;\n\n    if (st->holeLength) {\n        /* Pretend holeLength zeroes was read from stream. */\n        size_t len = want;\n\n        /* Yes, pretend unless we are asked not to. */\n        if (flags & VIR_STREAM_RECV_STOP_AT_HOLE) {\n            /* No error reporting here. Caller knows what they are doing. */\n            rv = -3;\n            goto cleanup;\n        }\n\n        if (len > st->holeLength)\n            len = st->holeLength;\n\n        memset(data, 0, len);\n        st->holeLength -= len;\n        want -= len;\n    }\n\n    while (want &&\n           st->rx &&\n           st->rx->header.type == VIR_NET_STREAM) {\n        virNetMessagePtr msg = st->rx;\n        size_t len = want;\n\n        if (len > msg->bufferLength - msg->bufferOffset)\n            len = msg->bufferLength - msg->bufferOffset;\n\n        if (!len)\n            break;\n\n        memcpy(data + (nbytes - want), msg->buffer + msg->bufferOffset, len);\n        want -= len;\n        msg->bufferOffset += len;\n\n        if (msg->bufferOffset == msg->bufferLength) {\n            virNetMessageQueueServe(&st->rx);\n            virNetMessageFree(msg);\n        }\n    }\n    rv = nbytes - want;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n cleanup:\n    virObjectUnlock(st);\n    return rv;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueueServe",
          "args": [
            "&st->rx"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueueServe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "109-119",
          "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data + (nbytes - want)",
            "msg->buffer + msg->bufferOffset",
            "len"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "data",
            "0",
            "len"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Non-blocking mode and no data available\""
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamHandleHole",
          "args": [
            "client",
            "st"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamHandleHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "448-507",
          "snippet": "static int\nvirNetClientStreamHandleHole(virNetClientPtr client,\n                             virNetClientStreamPtr st)\n{\n    virNetMessagePtr msg;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"client=%p st=%p\", client, st);\n\n    msg = st->rx;\n    memset(&data, 0, sizeof(data));\n\n    /* We should not be called unless there's VIR_NET_STREAM_HOLE\n     * message at the head of the list. But doesn't hurt to check */\n    if (!msg) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No message in the queue\"));\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM_HOLE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid message prog=%d type=%d serial=%u proc=%d\"),\n                       msg->header.prog,\n                       msg->header.type,\n                       msg->header.serial,\n                       msg->header.proc);\n        goto cleanup;\n    }\n\n    /* Server should not send us VIR_NET_STREAM_HOLE unless we\n     * have requested so. But does not hurt to check ... */\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        goto cleanup;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed stream hole packet\"));\n        goto cleanup;\n    }\n\n    virNetMessageQueueServe(&st->rx);\n    virNetMessageFree(msg);\n\n    if (virNetClientStreamSetHole(st, data.length, data.flags) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Abort stream? */\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic int\nvirNetClientStreamHandleHole(virNetClientPtr client,\n                             virNetClientStreamPtr st)\n{\n    virNetMessagePtr msg;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"client=%p st=%p\", client, st);\n\n    msg = st->rx;\n    memset(&data, 0, sizeof(data));\n\n    /* We should not be called unless there's VIR_NET_STREAM_HOLE\n     * message at the head of the list. But doesn't hurt to check */\n    if (!msg) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No message in the queue\"));\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM_HOLE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid message prog=%d type=%d serial=%u proc=%d\"),\n                       msg->header.prog,\n                       msg->header.type,\n                       msg->header.serial,\n                       msg->header.proc);\n        goto cleanup;\n    }\n\n    /* Server should not send us VIR_NET_STREAM_HOLE unless we\n     * have requested so. But does not hurt to check ... */\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        goto cleanup;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed stream hole packet\"));\n        goto cleanup;\n    }\n\n    virNetMessageQueueServe(&st->rx);\n    virNetMessageFree(msg);\n\n    if (virNetClientStreamSetHole(st, data.length, data.flags) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Abort stream? */\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"After IO rx=%p\"",
            "st->rx"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendStream",
          "args": [
            "client",
            "msg",
            "st"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2188-2219",
          "snippet": "int virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dummy packet to wait for stream data\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetVersion",
          "args": [
            "st->prog"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "99-102",
          "snippet": "unsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetProgram",
          "args": [
            "st->prog"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "93-96",
          "snippet": "unsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Non-blocking mode and no data available\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamCheckState",
          "args": [
            "st"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamCheckState",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "200-214",
          "snippet": "int virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_STREAM_RECV_STOP_AT_HOLE",
            "-1"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p client=%p data=%p nbytes=%zu nonblock=%d flags=0x%x\"",
            "st",
            "client",
            "data",
            "nbytes",
            "nonblock",
            "flags"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamRecvPacket(virNetClientStreamPtr st,\n                                 virNetClientPtr client,\n                                 char *data,\n                                 size_t nbytes,\n                                 bool nonblock,\n                                 unsigned int flags)\n{\n    int rv = -1;\n    size_t want;\n\n    VIR_DEBUG(\"st=%p client=%p data=%p nbytes=%zu nonblock=%d flags=0x%x\",\n              st, client, data, nbytes, nonblock, flags);\n\n    virCheckFlags(VIR_STREAM_RECV_STOP_AT_HOLE, -1);\n\n    virObjectLock(st);\n\n reread:\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    if (!st->rx && !st->incomingEOF) {\n        virNetMessagePtr msg;\n        int ret;\n\n        if (nonblock) {\n            VIR_DEBUG(\"Non-blocking mode and no data available\");\n            rv = -2;\n            goto cleanup;\n        }\n\n        if (!(msg = virNetMessageNew(false)))\n            goto cleanup;\n\n        msg->header.prog = virNetClientProgramGetProgram(st->prog);\n        msg->header.vers = virNetClientProgramGetVersion(st->prog);\n        msg->header.type = VIR_NET_STREAM;\n        msg->header.serial = st->serial;\n        msg->header.proc = st->proc;\n        msg->header.status = VIR_NET_CONTINUE;\n\n        VIR_DEBUG(\"Dummy packet to wait for stream data\");\n        virObjectUnlock(st);\n        ret = virNetClientSendStream(client, msg, st);\n        virObjectLock(st);\n        virNetMessageFree(msg);\n\n        if (ret < 0)\n            goto cleanup;\n    }\n\n    VIR_DEBUG(\"After IO rx=%p\", st->rx);\n\n    if (st->rx &&\n        st->rx->header.type == VIR_NET_STREAM_HOLE &&\n        st->holeLength == 0) {\n        /* Handle skip sent to us by server. */\n\n        if (virNetClientStreamHandleHole(client, st) < 0)\n            goto cleanup;\n    }\n\n    if (!st->rx && !st->incomingEOF && st->holeLength == 0) {\n        if (nonblock) {\n            VIR_DEBUG(\"Non-blocking mode and no data available\");\n            rv = -2;\n            goto cleanup;\n        }\n\n        /* We have consumed all packets from incoming queue but those\n         * were only skip packets, no data. Read the stream again. */\n        goto reread;\n    }\n\n    want = nbytes;\n\n    if (st->holeLength) {\n        /* Pretend holeLength zeroes was read from stream. */\n        size_t len = want;\n\n        /* Yes, pretend unless we are asked not to. */\n        if (flags & VIR_STREAM_RECV_STOP_AT_HOLE) {\n            /* No error reporting here. Caller knows what they are doing. */\n            rv = -3;\n            goto cleanup;\n        }\n\n        if (len > st->holeLength)\n            len = st->holeLength;\n\n        memset(data, 0, len);\n        st->holeLength -= len;\n        want -= len;\n    }\n\n    while (want &&\n           st->rx &&\n           st->rx->header.type == VIR_NET_STREAM) {\n        virNetMessagePtr msg = st->rx;\n        size_t len = want;\n\n        if (len > msg->bufferLength - msg->bufferOffset)\n            len = msg->bufferLength - msg->bufferOffset;\n\n        if (!len)\n            break;\n\n        memcpy(data + (nbytes - want), msg->buffer + msg->bufferOffset, len);\n        want -= len;\n        msg->bufferOffset += len;\n\n        if (msg->bufferOffset == msg->bufferLength) {\n            virNetMessageQueueServe(&st->rx);\n            virNetMessageFree(msg);\n        }\n    }\n    rv = nbytes - want;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n cleanup:\n    virObjectUnlock(st);\n    return rv;\n}"
  },
  {
    "function_name": "virNetClientStreamHandleHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "448-507",
    "snippet": "static int\nvirNetClientStreamHandleHole(virNetClientPtr client,\n                             virNetClientStreamPtr st)\n{\n    virNetMessagePtr msg;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"client=%p st=%p\", client, st);\n\n    msg = st->rx;\n    memset(&data, 0, sizeof(data));\n\n    /* We should not be called unless there's VIR_NET_STREAM_HOLE\n     * message at the head of the list. But doesn't hurt to check */\n    if (!msg) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No message in the queue\"));\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM_HOLE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid message prog=%d type=%d serial=%u proc=%d\"),\n                       msg->header.prog,\n                       msg->header.type,\n                       msg->header.serial,\n                       msg->header.proc);\n        goto cleanup;\n    }\n\n    /* Server should not send us VIR_NET_STREAM_HOLE unless we\n     * have requested so. But does not hurt to check ... */\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        goto cleanup;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed stream hole packet\"));\n        goto cleanup;\n    }\n\n    virNetMessageQueueServe(&st->rx);\n    virNetMessageFree(msg);\n\n    if (virNetClientStreamSetHole(st, data.length, data.flags) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Abort stream? */\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientStreamSetHole",
          "args": [
            "st",
            "data.length",
            "data.flags"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamSetHole",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "415-433",
          "snippet": "static int\nvirNetClientStreamSetHole(virNetClientStreamPtr st,\n                          long long length,\n                          unsigned int flags)\n{\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    /* Shouldn't happen, But it's better to safe than sorry. */\n    if (st->holeLength) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unprocessed hole of size %lld already in the queue\"),\n                       st->holeLength);\n        return -1;\n    }\n\n    st->holeLength += length;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic int\nvirNetClientStreamSetHole(virNetClientStreamPtr st,\n                          long long length,\n                          unsigned int flags)\n{\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    /* Shouldn't happen, But it's better to safe than sorry. */\n    if (st->holeLength) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unprocessed hole of size %lld already in the queue\"),\n                       st->holeLength);\n        return -1;\n    }\n\n    st->holeLength += length;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueueServe",
          "args": [
            "&st->rx"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueueServe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "109-119",
          "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Malformed stream hole packet\")"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Malformed stream hole packet\""
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetStreamHole",
            "&data"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_RPC",
            "\"%s\"",
            "_(\"Unexpected stream hole\")"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid message prog=%d type=%d serial=%u proc=%d\")",
            "msg->header.prog",
            "msg->header.type",
            "msg->header.serial",
            "msg->header.proc"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "virReportErrorHelper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "1282-1308",
          "snippet": "void virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid virReportErrorHelper(int domcode,\n                          int errorcode,\n                          const char *filename,\n                          const char *funcname,\n                          size_t linenr,\n                          const char *fmt, ...)\n{\n    int save_errno = errno;\n    va_list args;\n    char errorMessage[VIR_ERROR_MAX_LENGTH];\n    const char *virerr;\n\n    if (fmt) {\n        va_start(args, fmt);\n        g_vsnprintf(errorMessage, sizeof(errorMessage)-1, fmt, args);\n        va_end(args);\n    } else {\n        errorMessage[0] = '\\0';\n    }\n\n    virerr = virErrorMsg(errorcode, (errorMessage[0] ? errorMessage : NULL));\n    virRaiseErrorFull(filename, funcname, linenr,\n                      domcode, errorcode, VIR_ERR_ERROR,\n                      virerr, errorMessage, NULL,\n                      -1, -1, virerr, errorMessage);\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"No message in the queue\")"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&data",
            "0",
            "sizeof(data)"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"client=%p st=%p\"",
            "client",
            "st"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic int\nvirNetClientStreamHandleHole(virNetClientPtr client,\n                             virNetClientStreamPtr st)\n{\n    virNetMessagePtr msg;\n    virNetStreamHole data;\n    int ret = -1;\n\n    VIR_DEBUG(\"client=%p st=%p\", client, st);\n\n    msg = st->rx;\n    memset(&data, 0, sizeof(data));\n\n    /* We should not be called unless there's VIR_NET_STREAM_HOLE\n     * message at the head of the list. But doesn't hurt to check */\n    if (!msg) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"No message in the queue\"));\n        goto cleanup;\n    }\n\n    if (msg->header.type != VIR_NET_STREAM_HOLE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid message prog=%d type=%d serial=%u proc=%d\"),\n                       msg->header.prog,\n                       msg->header.type,\n                       msg->header.serial,\n                       msg->header.proc);\n        goto cleanup;\n    }\n\n    /* Server should not send us VIR_NET_STREAM_HOLE unless we\n     * have requested so. But does not hurt to check ... */\n    if (!st->allowSkip) {\n        virReportError(VIR_ERR_RPC, \"%s\",\n                       _(\"Unexpected stream hole\"));\n        goto cleanup;\n    }\n\n    if (virNetMessageDecodePayload(msg,\n                                   (xdrproc_t)xdr_virNetStreamHole,\n                                   &data) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Malformed stream hole packet\"));\n        goto cleanup;\n    }\n\n    virNetMessageQueueServe(&st->rx);\n    virNetMessageFree(msg);\n\n    if (virNetClientStreamSetHole(st, data.length, data.flags) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        /* Abort stream? */\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamSetHole",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "415-433",
    "snippet": "static int\nvirNetClientStreamSetHole(virNetClientStreamPtr st,\n                          long long length,\n                          unsigned int flags)\n{\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    /* Shouldn't happen, But it's better to safe than sorry. */\n    if (st->holeLength) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unprocessed hole of size %lld already in the queue\"),\n                       st->holeLength);\n        return -1;\n    }\n\n    st->holeLength += length;\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"unprocessed hole of size %lld already in the queue\")",
            "st->holeLength"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unprocessed hole of size %lld already in the queue\""
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckPositiveArgReturn",
          "args": [
            "length",
            "-1"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "0",
            "-1"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic int\nvirNetClientStreamSetHole(virNetClientStreamPtr st,\n                          long long length,\n                          unsigned int flags)\n{\n    virCheckFlags(0, -1);\n    virCheckPositiveArgReturn(length, -1);\n\n    /* Shouldn't happen, But it's better to safe than sorry. */\n    if (st->holeLength) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unprocessed hole of size %lld already in the queue\"),\n                       st->holeLength);\n        return -1;\n    }\n\n    st->holeLength += length;\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientStreamSendPacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "365-412",
    "snippet": "int virNetClientStreamSendPacket(virNetClientStreamPtr st,\n                                 virNetClientPtr client,\n                                 int status,\n                                 const char *data,\n                                 size_t nbytes)\n{\n    virNetMessagePtr msg;\n    VIR_DEBUG(\"st=%p status=%d data=%p nbytes=%zu\", st, status, data, nbytes);\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    virObjectLock(st);\n\n    msg->header.prog = virNetClientProgramGetProgram(st->prog);\n    msg->header.vers = virNetClientProgramGetVersion(st->prog);\n    msg->header.status = status;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = st->serial;\n    msg->header.proc = st->proc;\n\n    virObjectUnlock(st);\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    /* Data packets are async fire&forget, but OK/ERROR packets\n     * need a synchronous confirmation\n     */\n    if (status == VIR_NET_CONTINUE) {\n        if (virNetMessageEncodePayloadRaw(msg, data, nbytes) < 0)\n            goto error;\n    } else {\n        if (virNetMessageEncodePayloadRaw(msg, NULL, 0) < 0)\n            goto error;\n    }\n\n    if (virNetClientSendStream(client, msg, st) < 0)\n        goto error;\n\n    virNetMessageFree(msg);\n\n    return nbytes;\n\n error:\n    virNetMessageFree(msg);\n    return -1;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientSendStream",
          "args": [
            "client",
            "msg",
            "st"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientSendStream",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "2188-2219",
          "snippet": "int virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nstatic int virNetClientQueueNonBlocking(virNetClientPtr client,\n                                        virNetMessagePtr msg);\n\nint virNetClientSendStream(virNetClientPtr client,\n                           virNetMessagePtr msg,\n                           virNetClientStreamPtr st)\n{\n    int ret = -1;\n    bool expectReply = !msg->bufferLength ||\n                       msg->header.status != VIR_NET_CONTINUE;\n\n    virObjectLock(client);\n\n    if (virNetClientStreamCheckState(st) < 0)\n        goto cleanup;\n\n    /* Check for EOF only if we are going to wait for incoming data */\n    if (!msg->bufferLength && virNetClientStreamEOF(st)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virNetClientSendInternal(client, msg, expectReply, false) < 0)\n        goto cleanup;\n\n    if (expectReply && virNetClientStreamCheckSendStatus(st, msg) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(client);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodePayloadRaw",
          "args": [
            "msg",
            "NULL",
            "0"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodePayloadRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "435-484",
          "snippet": "int virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodePayloadRaw(virNetMessagePtr msg,\n                                  const char *data,\n                                  size_t len)\n{\n    XDR xdr;\n    unsigned int msglen;\n\n    /* If the message buffer is too small for the payload increase it accordingly. */\n    if ((msg->bufferLength - msg->bufferOffset) < len) {\n        if ((msg->bufferOffset + len) >\n            (VIR_NET_MESSAGE_MAX + VIR_NET_MESSAGE_LEN_MAX)) {\n            virReportError(VIR_ERR_RPC,\n                           _(\"Stream data too long to send \"\n                             \"(%zu bytes needed, %zu bytes available)\"),\n                           len,\n                           VIR_NET_MESSAGE_MAX +\n                           VIR_NET_MESSAGE_LEN_MAX -\n                           msg->bufferOffset);\n            return -1;\n        }\n\n        msg->bufferLength = msg->bufferOffset + len;\n\n        if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n            return -1;\n\n        VIR_DEBUG(\"Increased message buffer length = %zu\", msg->bufferLength);\n    }\n\n    memcpy(msg->buffer + msg->bufferOffset, data, len);\n    msg->bufferOffset += len;\n\n    /* Re-encode the length word. */\n    VIR_DEBUG(\"Encode length as %zu\", msg->bufferOffset);\n    xdrmem_create(&xdr, msg->buffer, VIR_NET_MESSAGE_HEADER_XDR_LEN, XDR_ENCODE);\n    msglen = msg->bufferOffset;\n    if (!xdr_u_int(&xdr, &msglen)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto error;\n    }\n    xdr_destroy(&xdr);\n\n    msg->bufferLength = msg->bufferOffset;\n    msg->bufferOffset = 0;\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageEncodeHeader",
          "args": [
            "msg"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageEncodeHeader",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "226-272",
          "snippet": "int virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageEncodeHeader(virNetMessagePtr msg)\n{\n    XDR xdr;\n    int ret = -1;\n    unsigned int len = 0;\n\n    msg->bufferLength = VIR_NET_MESSAGE_INITIAL + VIR_NET_MESSAGE_LEN_MAX;\n    if (VIR_REALLOC_N(msg->buffer, msg->bufferLength) < 0)\n        return ret;\n    msg->bufferOffset = 0;\n\n    /* Format the header. */\n    xdrmem_create(&xdr,\n                  msg->buffer,\n                  msg->bufferLength,\n                  XDR_ENCODE);\n\n    /* The real value is filled in shortly */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message length\"));\n        goto cleanup;\n    }\n\n    if (!xdr_virNetMessageHeader(&xdr, &msg->header)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to encode message header\"));\n        goto cleanup;\n    }\n\n    len = xdr_getpos(&xdr);\n    xdr_setpos(&xdr, 0);\n\n    /* Fill in current length - may be re-written later\n     * if a payload is added\n     */\n    if (!xdr_u_int(&xdr, &len)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to re-encode message length\"));\n        goto cleanup;\n    }\n\n    msg->bufferOffset += len;\n\n    ret = 0;\n\n cleanup:\n    xdr_destroy(&xdr);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetVersion",
          "args": [
            "st->prog"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetVersion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "99-102",
          "snippet": "unsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetVersion(virNetClientProgramPtr prog)\n{\n    return prog->version;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramGetProgram",
          "args": [
            "st->prog"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramGetProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "93-96",
          "snippet": "unsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nunsigned virNetClientProgramGetProgram(virNetClientProgramPtr prog)\n{\n    return prog->program;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"st=%p status=%d data=%p nbytes=%zu\"",
            "st",
            "status",
            "data",
            "nbytes"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamSendPacket(virNetClientStreamPtr st,\n                                 virNetClientPtr client,\n                                 int status,\n                                 const char *data,\n                                 size_t nbytes)\n{\n    virNetMessagePtr msg;\n    VIR_DEBUG(\"st=%p status=%d data=%p nbytes=%zu\", st, status, data, nbytes);\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    virObjectLock(st);\n\n    msg->header.prog = virNetClientProgramGetProgram(st->prog);\n    msg->header.vers = virNetClientProgramGetVersion(st->prog);\n    msg->header.status = status;\n    msg->header.type = VIR_NET_STREAM;\n    msg->header.serial = st->serial;\n    msg->header.proc = st->proc;\n\n    virObjectUnlock(st);\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    /* Data packets are async fire&forget, but OK/ERROR packets\n     * need a synchronous confirmation\n     */\n    if (status == VIR_NET_CONTINUE) {\n        if (virNetMessageEncodePayloadRaw(msg, data, nbytes) < 0)\n            goto error;\n    } else {\n        if (virNetMessageEncodePayloadRaw(msg, NULL, 0) < 0)\n            goto error;\n    }\n\n    if (virNetClientSendStream(client, msg, st) < 0)\n        goto error;\n\n    virNetMessageFree(msg);\n\n    return nbytes;\n\n error:\n    virNetMessageFree(msg);\n    return -1;\n}"
  },
  {
    "function_name": "virNetClientStreamQueuePacket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "320-362",
    "snippet": "int virNetClientStreamQueuePacket(virNetClientStreamPtr st,\n                                  virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp_msg;\n\n    VIR_DEBUG(\"Incoming stream message: stream=%p message=%p\", st, msg);\n\n    if (msg->bufferLength == msg->bufferOffset) {\n        /* No payload means end of the stream. */\n        virObjectLock(st);\n        st->incomingEOF = true;\n        virNetClientStreamEventTimerUpdate(st);\n        virObjectUnlock(st);\n        return 0;\n    }\n\n    /* Unfortunately, we must allocate new message as the one we\n     * get in @msg is going to be cleared later in the process. */\n\n    if (!(tmp_msg = virNetMessageNew(false)))\n        return -1;\n\n    /* Copy header */\n    memcpy(&tmp_msg->header, &msg->header, sizeof(msg->header));\n\n    /* Steal message buffer */\n    tmp_msg->buffer = msg->buffer;\n    tmp_msg->bufferLength = msg->bufferLength;\n    tmp_msg->bufferOffset = msg->bufferOffset;\n    msg->buffer = NULL;\n    msg->bufferLength = msg->bufferOffset = 0;\n\n    virObjectLock(st);\n\n    /* Don't distinguish VIR_NET_STREAM and VIR_NET_STREAM_SKIP\n     * here just yet. We want in order processing! */\n    virNetMessageQueuePush(&st->rx, tmp_msg);\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueuePush",
          "args": [
            "&st->rx",
            "tmp_msg"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueuePush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "95-106",
          "snippet": "void virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageQueuePush(virNetMessagePtr *queue, virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        while (tmp->next)\n            tmp = tmp->next;\n        tmp->next = msg;\n    } else {\n        *queue = msg;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&tmp_msg->header",
            "&msg->header",
            "sizeof(msg->header)"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageNew",
          "args": [
            "false"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "37-48",
          "snippet": "virNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageNew(bool tracked)\n{\n    virNetMessagePtr msg;\n\n    if (VIR_ALLOC(msg) < 0)\n        return NULL;\n\n    msg->tracked = tracked;\n    VIR_DEBUG(\"msg=%p tracked=%d\", msg, tracked);\n\n    return msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Incoming stream message: stream=%p message=%p\"",
            "st",
            "msg"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamQueuePacket(virNetClientStreamPtr st,\n                                  virNetMessagePtr msg)\n{\n    virNetMessagePtr tmp_msg;\n\n    VIR_DEBUG(\"Incoming stream message: stream=%p message=%p\", st, msg);\n\n    if (msg->bufferLength == msg->bufferOffset) {\n        /* No payload means end of the stream. */\n        virObjectLock(st);\n        st->incomingEOF = true;\n        virNetClientStreamEventTimerUpdate(st);\n        virObjectUnlock(st);\n        return 0;\n    }\n\n    /* Unfortunately, we must allocate new message as the one we\n     * get in @msg is going to be cleared later in the process. */\n\n    if (!(tmp_msg = virNetMessageNew(false)))\n        return -1;\n\n    /* Copy header */\n    memcpy(&tmp_msg->header, &msg->header, sizeof(msg->header));\n\n    /* Steal message buffer */\n    tmp_msg->buffer = msg->buffer;\n    tmp_msg->bufferLength = msg->bufferLength;\n    tmp_msg->bufferOffset = msg->bufferOffset;\n    msg->buffer = NULL;\n    msg->bufferLength = msg->bufferOffset = 0;\n\n    virObjectLock(st);\n\n    /* Don't distinguish VIR_NET_STREAM and VIR_NET_STREAM_SKIP\n     * here just yet. We want in order processing! */\n    virNetMessageQueuePush(&st->rx, tmp_msg);\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientStreamSetError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "262-317",
    "snippet": "int virNetClientStreamSetError(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    virObjectLock(st);\n\n    if (st->err.code != VIR_ERR_OK)\n        VIR_DEBUG(\"Overwriting existing stream error %s\", NULLSTR(st->err.message));\n\n    virResetError(&st->err);\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    if (err.domain == VIR_FROM_REMOTE &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        st->err.code = VIR_ERR_NO_SUPPORT;\n    } else {\n        st->err.code = err.code;\n    }\n    if (err.message) {\n        st->err.message = *err.message;\n        *err.message = NULL;\n    }\n    st->err.domain = err.domain;\n    st->err.level = err.level;\n    if (err.str1) {\n        st->err.str1 = *err.str1;\n        *err.str1 = NULL;\n    }\n    if (err.str2) {\n        st->err.str2 = *err.str2;\n        *err.str2 = NULL;\n    }\n    if (err.str3) {\n        st->err.str3 = *err.str3;\n        *err.str3 = NULL;\n    }\n    st->err.int1 = err.int1;\n    st->err.int2 = err.int2;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    virObjectUnlock(st);\n    return ret;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xdr_free",
          "args": [
            "(xdrproc_t)xdr_virNetMessageError",
            "(void*)&err"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "*err.message",
            "\"unknown procedure\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetMessageDecodePayload",
          "args": [
            "msg",
            "(xdrproc_t)xdr_virNetMessageError",
            "&err"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageDecodePayload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "407-432",
          "snippet": "int virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetMessageDecodePayload(virNetMessagePtr msg,\n                               xdrproc_t filter,\n                               void *data)\n{\n    XDR xdr;\n\n    /* Deserialise payload of the message. This assumes that\n     * virNetMessageDecodeHeader has already been run, so\n     * just start from after that data */\n    xdrmem_create(&xdr, msg->buffer + msg->bufferOffset,\n                  msg->bufferLength - msg->bufferOffset, XDR_DECODE);\n\n    if (!(*filter)(&xdr, data, 0)) {\n        virReportError(VIR_ERR_RPC, \"%s\", _(\"Unable to decode message payload\"));\n        goto error;\n    }\n\n    /* Get the length stored in buffer. */\n    msg->bufferLength += xdr_getpos(&xdr);\n    xdr_destroy(&xdr);\n    return 0;\n\n error:\n    xdr_destroy(&xdr);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&err",
            "0",
            "sizeof(err)"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetError",
          "args": [
            "&st->err"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "virResetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "466-476",
          "snippet": "void\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Overwriting existing stream error %s\"",
            "NULLSTR(st->err.message)"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "st->err.message"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamSetError(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    virNetMessageError err;\n    int ret = -1;\n\n    virObjectLock(st);\n\n    if (st->err.code != VIR_ERR_OK)\n        VIR_DEBUG(\"Overwriting existing stream error %s\", NULLSTR(st->err.message));\n\n    virResetError(&st->err);\n    memset(&err, 0, sizeof(err));\n\n    if (virNetMessageDecodePayload(msg, (xdrproc_t)xdr_virNetMessageError, &err) < 0)\n        goto cleanup;\n\n    if (err.domain == VIR_FROM_REMOTE &&\n        err.code == VIR_ERR_RPC &&\n        err.level == VIR_ERR_ERROR &&\n        err.message &&\n        STRPREFIX(*err.message, \"unknown procedure\")) {\n        st->err.code = VIR_ERR_NO_SUPPORT;\n    } else {\n        st->err.code = err.code;\n    }\n    if (err.message) {\n        st->err.message = *err.message;\n        *err.message = NULL;\n    }\n    st->err.domain = err.domain;\n    st->err.level = err.level;\n    if (err.str1) {\n        st->err.str1 = *err.str1;\n        *err.str1 = NULL;\n    }\n    if (err.str2) {\n        st->err.str2 = *err.str2;\n        *err.str2 = NULL;\n    }\n    if (err.str3) {\n        st->err.str3 = *err.str3;\n        *err.str3 = NULL;\n    }\n    st->err.int1 = err.int1;\n    st->err.int2 = err.int2;\n\n    virNetClientStreamEventTimerUpdate(st);\n\n    ret = 0;\n\n cleanup:\n    xdr_free((xdrproc_t)xdr_virNetMessageError, (void*)&err);\n    virObjectUnlock(st);\n    return ret;\n}"
  },
  {
    "function_name": "virNetClientStreamSetClosed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "250-259",
    "snippet": "void virNetClientStreamSetClosed(virNetClientStreamPtr st,\n                                 virNetClientStreamClosed closed)\n{\n    virObjectLock(st);\n\n    st->closed = closed;\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamEventTimerUpdate",
          "args": [
            "st"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamEventTimerUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "80-97",
          "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 253
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nvoid virNetClientStreamSetClosed(virNetClientStreamPtr st,\n                                 virNetClientStreamClosed closed)\n{\n    virObjectLock(st);\n\n    st->closed = closed;\n    virNetClientStreamEventTimerUpdate(st);\n\n    virObjectUnlock(st);\n}"
  },
  {
    "function_name": "virNetClientStreamCheckSendStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "219-247",
    "snippet": "int virNetClientStreamCheckSendStatus(virNetClientStreamPtr st,\n                                      virNetMessagePtr msg)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    /* We can not check if the message is dummy in a usual way\n     * by checking msg->bufferLength because at this point message payload\n     * is cleared. As caller must not call this function for messages\n     * not expecting reply we can check for dummy messages just by status.\n     */\n    if (msg->header.status == VIR_NET_CONTINUE) {\n        if (st->closed) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"stream is closed\"));\n            return -1;\n        }\n        return 0;\n    } else if (msg->header.status == VIR_NET_OK &&\n               st->closed != VIR_NET_CLIENT_STREAM_CLOSED_FINISHED) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream aborted by another thread\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"stream aborted by another thread\")"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream aborted by another thread\""
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"stream is closed\")"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientStreamRaiseError",
          "args": [
            "st"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamRaiseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "183-196",
          "snippet": "static\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckSendStatus(virNetClientStreamPtr st,\n                                      virNetMessagePtr msg)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    /* We can not check if the message is dummy in a usual way\n     * by checking msg->bufferLength because at this point message payload\n     * is cleared. As caller must not call this function for messages\n     * not expecting reply we can check for dummy messages just by status.\n     */\n    if (msg->header.status == VIR_NET_CONTINUE) {\n        if (st->closed) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"stream is closed\"));\n            return -1;\n        }\n        return 0;\n    } else if (msg->header.status == VIR_NET_OK &&\n               st->closed != VIR_NET_CLIENT_STREAM_CLOSED_FINISHED) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream aborted by another thread\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientStreamCheckState",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "200-214",
    "snippet": "int virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"stream is closed\")"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"stream is closed\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamRaiseError",
          "args": [
            "st"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientStreamRaiseError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
          "lines": "183-196",
          "snippet": "static\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientstream.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nint virNetClientStreamCheckState(virNetClientStreamPtr st)\n{\n    if (st->err.code != VIR_ERR_OK) {\n        virNetClientStreamRaiseError(st);\n        return -1;\n    }\n\n    if (st->closed) {\n        virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                       _(\"stream is closed\"));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetClientStreamRaiseError",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "183-196",
    "snippet": "static\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virRaiseErrorFull",
          "args": [
            "__FILE__",
            "__FUNCTION__",
            "__LINE__",
            "st->err.domain",
            "st->err.code",
            "st->err.level",
            "st->err.str1",
            "st->err.str2",
            "st->err.str3",
            "st->err.int1",
            "st->err.int2",
            "\"%s\"",
            "st->err.message ? st->err.message : _(\"Unknown error\")"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "virRaiseErrorFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "784-858",
          "snippet": "void\nvirRaiseErrorFull(const char *filename,\n                  const char *funcname,\n                  size_t linenr,\n                  int domain,\n                  int code,\n                  virErrorLevel level,\n                  const char *str1,\n                  const char *str2,\n                  const char *str3,\n                  int int1,\n                  int int2,\n                  const char *fmt, ...)\n{\n    int save_errno = errno;\n    virErrorPtr to;\n    char *str;\n    virLogMetadata meta[] = {\n        { .key = \"LIBVIRT_DOMAIN\", .s = NULL, .iv = domain },\n        { .key = \"LIBVIRT_CODE\", .s = NULL, .iv = code },\n        { .key = NULL },\n    };\n\n    /*\n     * All errors are recorded in thread local storage\n     * For compatibility, public API calls will copy them\n     * to the per-connection error object when necessary\n     */\n    to = virLastErrorObject();\n    if (!to) {\n        errno = save_errno;\n        return; /* Hit OOM allocating thread error object, sod all we can do now */\n    }\n\n    virResetError(to);\n\n    if (code == VIR_ERR_OK) {\n        errno = save_errno;\n        return;\n    }\n\n    /*\n     * formats the message; drop message on OOM situations\n     */\n    if (fmt == NULL) {\n        str = g_strdup(_(\"No error message provided\"));\n    } else {\n        va_list ap;\n        va_start(ap, fmt);\n        str = g_strdup_vprintf(fmt, ap);\n        va_end(ap);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    /*\n     * Deliberately not setting conn, dom & net fields since\n     * they're utterly unsafe\n     */\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    to->str1 = g_strdup(str1);\n    to->str2 = g_strdup(str2);\n    to->str3 = g_strdup(str3);\n    to->int1 = int1;\n    to->int2 = int2;\n\n    virRaiseErrorLog(filename, funcname, linenr,\n                     to, meta);\n\n    errno = save_errno;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirRaiseErrorFull(const char *filename,\n                  const char *funcname,\n                  size_t linenr,\n                  int domain,\n                  int code,\n                  virErrorLevel level,\n                  const char *str1,\n                  const char *str2,\n                  const char *str3,\n                  int int1,\n                  int int2,\n                  const char *fmt, ...)\n{\n    int save_errno = errno;\n    virErrorPtr to;\n    char *str;\n    virLogMetadata meta[] = {\n        { .key = \"LIBVIRT_DOMAIN\", .s = NULL, .iv = domain },\n        { .key = \"LIBVIRT_CODE\", .s = NULL, .iv = code },\n        { .key = NULL },\n    };\n\n    /*\n     * All errors are recorded in thread local storage\n     * For compatibility, public API calls will copy them\n     * to the per-connection error object when necessary\n     */\n    to = virLastErrorObject();\n    if (!to) {\n        errno = save_errno;\n        return; /* Hit OOM allocating thread error object, sod all we can do now */\n    }\n\n    virResetError(to);\n\n    if (code == VIR_ERR_OK) {\n        errno = save_errno;\n        return;\n    }\n\n    /*\n     * formats the message; drop message on OOM situations\n     */\n    if (fmt == NULL) {\n        str = g_strdup(_(\"No error message provided\"));\n    } else {\n        va_list ap;\n        va_start(ap, fmt);\n        str = g_strdup_vprintf(fmt, ap);\n        va_end(ap);\n    }\n\n    /*\n     * Save the information about the error\n     */\n    /*\n     * Deliberately not setting conn, dom & net fields since\n     * they're utterly unsafe\n     */\n    to->domain = domain;\n    to->code = code;\n    to->message = str;\n    to->level = level;\n    to->str1 = g_strdup(str1);\n    to->str2 = g_strdup(str2);\n    to->str3 = g_strdup(str3);\n    to->int1 = int1;\n    to->int2 = int2;\n\n    virRaiseErrorLog(filename, funcname, linenr,\n                     to, meta);\n\n    errno = save_errno;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown error\""
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic\nvoid virNetClientStreamRaiseError(virNetClientStreamPtr st)\n{\n    virRaiseErrorFull(__FILE__, __FUNCTION__, __LINE__,\n                      st->err.domain,\n                      st->err.code,\n                      st->err.level,\n                      st->err.str1,\n                      st->err.str2,\n                      st->err.str3,\n                      st->err.int1,\n                      st->err.int2,\n                      \"%s\", st->err.message ? st->err.message : _(\"Unknown error\"));\n}"
  },
  {
    "function_name": "virNetClientStreamMatches",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "169-180",
    "snippet": "bool virNetClientStreamMatches(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    bool match = false;\n    virObjectLock(st);\n    if (virNetClientProgramMatches(st->prog, msg) &&\n        st->proc == msg->header.proc &&\n        st->serial == msg->header.serial)\n        match = true;\n    virObjectUnlock(st);\n    return match;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramMatches",
          "args": [
            "st->prog",
            "msg"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramMatches",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "105-112",
          "snippet": "int virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramMatches(virNetClientProgramPtr prog,\n                               virNetMessagePtr msg)\n{\n    if (prog->program == msg->header.prog &&\n        prog->version == msg->header.vers)\n        return 1;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nbool virNetClientStreamMatches(virNetClientStreamPtr st,\n                               virNetMessagePtr msg)\n{\n    bool match = false;\n    virObjectLock(st);\n    if (virNetClientProgramMatches(st->prog, msg) &&\n        st->proc == msg->header.proc &&\n        st->serial == msg->header.serial)\n        match = true;\n    virObjectUnlock(st);\n    return match;\n}"
  },
  {
    "function_name": "virNetClientStreamDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "156-167",
    "snippet": "void virNetClientStreamDispose(void *obj)\n{\n    virNetClientStreamPtr st = obj;\n\n    virResetError(&st->err);\n    while (st->rx) {\n        virNetMessagePtr msg = st->rx;\n        virNetMessageQueueServe(&st->rx);\n        virNetMessageFree(msg);\n    }\n    virObjectUnref(st->prog);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virNetClientStreamDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "st->prog"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageFree",
          "args": [
            "msg"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "81-93",
          "snippet": "void virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetMessageFree(virNetMessagePtr msg)\n{\n    if (!msg)\n        return;\n\n    VIR_DEBUG(\"msg=%p nfds=%zu cb=%p\", msg, msg->nfds, msg->cb);\n\n    if (msg->cb)\n        msg->cb(msg, msg->opaque);\n\n    virNetMessageClearPayload(msg);\n    VIR_FREE(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetMessageQueueServe",
          "args": [
            "&st->rx"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virNetMessageQueueServe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetmessage.c",
          "lines": "109-119",
          "snippet": "virNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetmessage.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetmessage.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirNetMessagePtr virNetMessageQueueServe(virNetMessagePtr *queue)\n{\n    virNetMessagePtr tmp = *queue;\n\n    if (tmp) {\n        *queue = tmp->next;\n        tmp->next = NULL;\n    }\n\n    return tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virResetError",
          "args": [
            "&st->err"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virResetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "466-476",
          "snippet": "void\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void virNetClientStreamDispose(void *obj);\n\nvoid virNetClientStreamDispose(void *obj)\n{\n    virNetClientStreamPtr st = obj;\n\n    virResetError(&st->err);\n    while (st->rx) {\n        virNetMessagePtr msg = st->rx;\n        virNetMessageQueueServe(&st->rx);\n        virNetMessageFree(msg);\n    }\n    virObjectUnref(st->prog);\n}"
  },
  {
    "function_name": "virNetClientStreamNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "135-154",
    "snippet": "virNetClientStreamPtr virNetClientStreamNew(virNetClientProgramPtr prog,\n                                            int proc,\n                                            unsigned serial,\n                                            bool allowSkip)\n{\n    virNetClientStreamPtr st;\n\n    if (virNetClientStreamInitialize() < 0)\n        return NULL;\n\n    if (!(st = virObjectLockableNew(virNetClientStreamClass)))\n        return NULL;\n\n    st->prog = virObjectRef(prog);\n    st->proc = proc;\n    st->serial = serial;\n    st->allowSkip = allowSkip;\n\n    return st;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virNetClientStreamClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "prog"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virNetClientStreamClass"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientStreamInitialize",
          "args": [],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic virClassPtr virNetClientStreamClass;\n\nvirNetClientStreamPtr virNetClientStreamNew(virNetClientProgramPtr prog,\n                                            int proc,\n                                            unsigned serial,\n                                            bool allowSkip)\n{\n    virNetClientStreamPtr st;\n\n    if (virNetClientStreamInitialize() < 0)\n        return NULL;\n\n    if (!(st = virObjectLockableNew(virNetClientStreamClass)))\n        return NULL;\n\n    st->prog = virObjectRef(prog);\n    st->proc = proc;\n    st->serial = serial;\n    st->allowSkip = allowSkip;\n\n    return st;\n}"
  },
  {
    "function_name": "virNetClientStreamEventTimer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "100-132",
    "snippet": "static void\nvirNetClientStreamEventTimer(int timer G_GNUC_UNUSED, void *opaque)\n{\n    virNetClientStreamPtr st = opaque;\n    int events = 0;\n\n    virObjectLock(st);\n\n    if (st->cb &&\n        (st->cbEvents & VIR_STREAM_EVENT_READABLE) &&\n        (st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed))\n        events |= VIR_STREAM_EVENT_READABLE;\n    if (st->cb &&\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE))\n        events |= VIR_STREAM_EVENT_WRITABLE;\n\n    VIR_DEBUG(\"Got Timer dispatch events=%d cbEvents=%d rx=%p\", events, st->cbEvents, st->rx);\n    if (events) {\n        virNetClientStreamEventCallback cb = st->cb;\n        void *cbOpaque = st->cbOpaque;\n        virFreeCallback cbFree = st->cbFree;\n\n        st->cbDispatch = 1;\n        virObjectUnlock(st);\n        (cb)(st, events, cbOpaque);\n        virObjectLock(st);\n        st->cbDispatch = 0;\n\n        if (!st->cb && cbFree)\n            (cbFree)(cbOpaque);\n    }\n    virObjectUnlock(st);\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "st"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "cbOpaque"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "st"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "st",
            "events",
            "cbOpaque"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got Timer dispatch events=%d cbEvents=%d rx=%p\"",
            "events",
            "st->cbEvents",
            "st->rx"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimer(int timer G_GNUC_UNUSED, void *opaque)\n{\n    virNetClientStreamPtr st = opaque;\n    int events = 0;\n\n    virObjectLock(st);\n\n    if (st->cb &&\n        (st->cbEvents & VIR_STREAM_EVENT_READABLE) &&\n        (st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed))\n        events |= VIR_STREAM_EVENT_READABLE;\n    if (st->cb &&\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE))\n        events |= VIR_STREAM_EVENT_WRITABLE;\n\n    VIR_DEBUG(\"Got Timer dispatch events=%d cbEvents=%d rx=%p\", events, st->cbEvents, st->rx);\n    if (events) {\n        virNetClientStreamEventCallback cb = st->cb;\n        void *cbOpaque = st->cbOpaque;\n        virFreeCallback cbFree = st->cbFree;\n\n        st->cbDispatch = 1;\n        virObjectUnlock(st);\n        (cb)(st, events, cbOpaque);\n        virObjectLock(st);\n        st->cbDispatch = 0;\n\n        if (!st->cb && cbFree)\n            (cbFree)(cbOpaque);\n    }\n    virObjectUnlock(st);\n}"
  },
  {
    "function_name": "virNetClientStreamEventTimerUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "80-97",
    "snippet": "static void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventUpdateTimeout",
          "args": [
            "st->cbTimer",
            "-1"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateTimeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "170-175",
          "snippet": "void\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateTimeoutFunc updateTimeoutImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateTimeoutFunc updateTimeoutImpl;\n\nvoid\nvirEventUpdateTimeout(int timer, int timeout)\n{\n    if (updateTimeoutImpl)\n        updateTimeoutImpl(timer, timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Disabling event timer\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Enabling event timer\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Check timer rx=%p cbEvents=%d\"",
            "st->rx",
            "st->cbEvents"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic void\nvirNetClientStreamEventTimerUpdate(virNetClientStreamPtr st)\n{\n    if (!st->cb)\n        return;\n\n    VIR_DEBUG(\"Check timer rx=%p cbEvents=%d\", st->rx, st->cbEvents);\n\n    if (((st->rx || st->incomingEOF || st->err.code != VIR_ERR_OK || st->closed) &&\n         (st->cbEvents & VIR_STREAM_EVENT_READABLE)) ||\n        (st->cbEvents & VIR_STREAM_EVENT_WRITABLE)) {\n        VIR_DEBUG(\"Enabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, 0);\n    } else {\n        VIR_DEBUG(\"Disabling event timer\");\n        virEventUpdateTimeout(st->cbTimer, -1);\n    }\n}"
  },
  {
    "function_name": "virNetClientStreamOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientstream.c",
    "lines": "69-75",
    "snippet": "static int virNetClientStreamOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClientStream, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virnetclient.h\"",
      "#include \"virnetclientstream.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virNetClientStream",
            "virClassForObjectLockable()"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientstream.h\"\n#include <config.h>\n\nstatic int virNetClientStreamOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virNetClientStream, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]