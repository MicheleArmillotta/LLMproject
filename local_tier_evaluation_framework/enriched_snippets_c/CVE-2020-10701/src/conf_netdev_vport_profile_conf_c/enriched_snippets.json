[
  {
    "function_name": "virNetDevVPortProfileFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
    "lines": "199-278",
    "snippet": "int\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"</virtualport>\\n\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAdjustIndent",
          "args": [
            "buf",
            "-2"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAdjustIndent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "43-62",
          "snippet": "void\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAdjustIndent(virBufferPtr buf, int indent)\n{\n    if (!buf)\n        return;\n\n    if (indent > 0) {\n        if (INT_MAX - indent < buf->indent) {\n            buf->indent = INT_MAX;\n            return;\n        }\n    } else {\n        if (buf->indent < -indent) {\n            buf->indent = 0;\n            return;\n        }\n    }\n\n    buf->indent += indent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"/>\\n\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "buf",
            "\" profileid='%s'\"",
            "virtPort->profileID"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "virtPort->interfaceID",
            "uuidstr"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<parameters\""
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "type"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "type"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAddLit",
          "args": [
            "buf",
            "\"<virtualport>\\n\""
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileFormat(const virNetDevVPortProfile *virtPort,\n                            virBufferPtr buf)\n{\n    enum virNetDevVPortProfile type;\n    bool noParameters;\n\n    if (!virtPort)\n        return 0;\n\n    noParameters = !(virtPort->managerID_specified ||\n                     virtPort->typeID_specified ||\n                     virtPort->typeIDVersion_specified ||\n                     virtPort->instanceID_specified ||\n                     virtPort->profileID[0] ||\n                     virtPort->interfaceID_specified);\n\n    type = virtPort->virtPortType;\n    if (type == VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (noParameters)\n            return 0;\n        virBufferAddLit(buf, \"<virtualport>\\n\");\n    } else {\n        if (noParameters) {\n            virBufferAsprintf(buf, \"<virtualport type='%s'/>\\n\",\n                              virNetDevVPortTypeToString(type));\n            return 0;\n        } else {\n            virBufferAsprintf(buf, \"<virtualport type='%s'>\\n\",\n                              virNetDevVPortTypeToString(type));\n        }\n    }\n    virBufferAdjustIndent(buf, 2);\n    virBufferAddLit(buf, \"<parameters\");\n\n    if (virtPort->managerID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" managerid='%d'\", virtPort->managerID);\n    }\n    if (virtPort->typeID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeid='%d'\", virtPort->typeID);\n    }\n    if (virtPort->typeIDVersion_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" typeidversion='%d'\",\n                          virtPort->typeIDVersion);\n    }\n    if (virtPort->instanceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->instanceID, uuidstr);\n        virBufferAsprintf(buf, \" instanceid='%s'\", uuidstr);\n    }\n    if (virtPort->interfaceID_specified &&\n        (type == VIR_NETDEV_VPORT_PROFILE_MIDONET ||\n         type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        char uuidstr[VIR_UUID_STRING_BUFLEN];\n\n        virUUIDFormat(virtPort->interfaceID, uuidstr);\n        virBufferAsprintf(buf, \" interfaceid='%s'\", uuidstr);\n    }\n    if (virtPort->profileID[0] &&\n        (type == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         type == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         type == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        virBufferAsprintf(buf, \" profileid='%s'\", virtPort->profileID);\n    }\n\n    virBufferAddLit(buf, \"/>\\n\");\n    virBufferAdjustIndent(buf, -2);\n    virBufferAddLit(buf, \"</virtualport>\\n\");\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/netdev_vport_profile_conf.c",
    "lines": "29-196",
    "snippet": "virNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}",
    "includes": [
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"netdev_vport_profile_conf.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPort"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortInterfaceID"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortType"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortProfileID"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortInstanceID"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortTypeIDVersion"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortTypeID"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virtPortManagerID"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileCheckNoExtras",
          "args": [
            "virtPort"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileCheckNoExtras",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "226-276",
          "snippet": "int\nvirNetDevVPortProfileCheckNoExtras(const virNetDevVPortProfile *virtport)\n{\n    const char *extra = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (virtport->profileID[0])\n            extra = \"profileid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        break;\n    }\n\n    if (extra) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"extra %s unsupported in <virtualport type='%s'>\"),\n                       extra,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileCheckNoExtras(const virNetDevVPortProfile *virtport)\n{\n    const char *extra = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (virtport->profileID[0])\n            extra = \"profileid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        break;\n    }\n\n    if (extra) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"extra %s unsupported in <virtualport type='%s'>\"),\n                       extra,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileCheckComplete",
          "args": [
            "virtPort",
            "false"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileCheckComplete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "152-218",
          "snippet": "int\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot generate a random uuid for interfaceid\")"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"cannot generate a random uuid for interfaceid\""
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "virtPort->interfaceID"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot generate a random uuid for instanceid\")"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cannot parse interfaceid parameter as a uuid\")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDParse",
          "args": [
            "virtPortInterfaceID",
            "virtPort->interfaceID"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "91-135",
          "snippet": "int\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDParse(const char *uuidstr, unsigned char *uuid)\n{\n    const char *cur;\n    size_t i;\n\n    /*\n     * do a liberal scan allowing '-' and ' ' anywhere between character\n     * pairs, and surrounding whitespace, as long as there are exactly\n     * 32 hexadecimal digits the end.\n     */\n    cur = uuidstr;\n    while (g_ascii_isspace(*cur))\n        cur++;\n\n    for (i = 0; i < VIR_UUID_BUFLEN;) {\n        int val;\n        uuid[i] = 0;\n        if (*cur == 0)\n            return -1;\n        if ((*cur == '-') || (*cur == ' ')) {\n            cur++;\n            continue;\n        }\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] = 16 * val;\n        cur++;\n        if (*cur == 0)\n            return -1;\n        if ((val = g_ascii_xdigit_value(*cur)) < 0)\n            return -1;\n        uuid[i] += val;\n        i++;\n        cur++;\n    }\n\n    while (*cur) {\n        if (!g_ascii_isspace(*cur))\n            return -1;\n        cur++;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"profileid parameter too long\")"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "virtPort->profileID",
            "virtPortProfileID"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cannot parse instanceid parameter as a uuid\")"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"value of typeidversion out of range\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cannot parse value of typeidversion parameter\")"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "virtPortTypeIDVersion",
            "NULL",
            "0",
            "&val"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"value for typeid out of range\")"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cannot parse value of typeid parameter\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"value of managerid out of range\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"cannot parse value of managerid parameter\")"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "cur",
            "\"interfaceid\""
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "cur",
            "\"parameters\""
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing required virtualport type\")"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown virtualport type %s\")",
            "virtPortType"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeFromString",
          "args": [
            "virtPortType"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "virtPort"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include <config.h>\n\nvirNetDevVPortProfilePtr\nvirNetDevVPortProfileParse(xmlNodePtr node, unsigned int flags)\n{\n    char *virtPortType;\n    char *virtPortManagerID = NULL;\n    char *virtPortTypeID = NULL;\n    char *virtPortTypeIDVersion = NULL;\n    char *virtPortInstanceID = NULL;\n    char *virtPortProfileID = NULL;\n    char *virtPortInterfaceID = NULL;\n    virNetDevVPortProfilePtr virtPort = NULL;\n    xmlNodePtr cur = node->children;\n\n    if (VIR_ALLOC(virtPort) < 0)\n        return NULL;\n\n    if ((virtPortType = virXMLPropString(node, \"type\")) &&\n        (virtPort->virtPortType = virNetDevVPortTypeFromString(virtPortType)) <= 0) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"unknown virtualport type %s\"), virtPortType);\n        goto error;\n    }\n\n    if ((virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE) &&\n        (flags & VIR_VPORT_XML_REQUIRE_TYPE)) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing required virtualport type\"));\n        goto error;\n    }\n\n    while (cur != NULL) {\n        if (virXMLNodeNameEqual(cur, \"parameters\")) {\n            virtPortManagerID = virXMLPropString(cur, \"managerid\");\n            virtPortTypeID = virXMLPropString(cur, \"typeid\");\n            virtPortTypeIDVersion = virXMLPropString(cur, \"typeidversion\");\n            virtPortInstanceID = virXMLPropString(cur, \"instanceid\");\n            virtPortProfileID = virXMLPropString(cur, \"profileid\");\n            virtPortInterfaceID = virXMLPropString(cur, \"interfaceid\");\n            break;\n        }\n        cur = cur->next;\n    }\n\n    if (virtPortManagerID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortManagerID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of managerid parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of managerid out of range\"));\n            goto error;\n        }\n        virtPort->managerID = (uint8_t)val;\n        virtPort->managerID_specified = true;\n    }\n\n    if (virtPortTypeID) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeID, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeid parameter\"));\n            goto error;\n        }\n        if (val > 0xffffff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value for typeid out of range\"));\n            goto error;\n        }\n        virtPort->typeID = (uint32_t)val;\n        virtPort->typeID_specified = true;\n    }\n\n    if (virtPortTypeIDVersion) {\n        unsigned int val;\n\n        if (virStrToLong_ui(virtPortTypeIDVersion, NULL, 0, &val)) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse value of typeidversion parameter\"));\n            goto error;\n        }\n        if (val > 0xff) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"value of typeidversion out of range\"));\n            goto error;\n        }\n        virtPort->typeIDVersion = (uint8_t)val;\n        virtPort->typeIDVersion_specified = true;\n    }\n\n    if (virtPortInstanceID) {\n        if (virUUIDParse(virtPortInstanceID, virtPort->instanceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse instanceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->instanceID_specified = true;\n    }\n\n    if (virtPortProfileID &&\n        virStrcpyStatic(virtPort->profileID, virtPortProfileID) < 0) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"profileid parameter too long\"));\n        goto error;\n    }\n\n    if (virtPortInterfaceID) {\n        if (virUUIDParse(virtPortInterfaceID, virtPort->interfaceID) < 0) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"cannot parse interfaceid parameter as a uuid\"));\n            goto error;\n        }\n        virtPort->interfaceID_specified = true;\n    }\n\n    /* generate default instanceID/interfaceID if appropriate */\n    if (flags & VIR_VPORT_XML_GENERATE_MISSING_DEFAULTS) {\n        if (!virtPort->instanceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->instanceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for instanceid\"));\n                goto error;\n            }\n            virtPort->instanceID_specified = true;\n        }\n        if (!virtPort->interfaceID_specified &&\n            (virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n             virtPort->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n            if (virUUIDGenerate(virtPort->interfaceID) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"cannot generate a random uuid for interfaceid\"));\n                goto error;\n            }\n            virtPort->interfaceID_specified = true;\n        }\n    }\n\n    /* check for required/unsupported attributes */\n\n    if ((flags & VIR_VPORT_XML_REQUIRE_ALL_ATTRIBUTES) &&\n        (virNetDevVPortProfileCheckComplete(virtPort, false) < 0)) {\n        goto error;\n    }\n\n    if (virNetDevVPortProfileCheckNoExtras(virtPort) < 0)\n        goto error;\n\n cleanup:\n    VIR_FREE(virtPortManagerID);\n    VIR_FREE(virtPortTypeID);\n    VIR_FREE(virtPortTypeIDVersion);\n    VIR_FREE(virtPortInstanceID);\n    VIR_FREE(virtPortProfileID);\n    VIR_FREE(virtPortType);\n    VIR_FREE(virtPortInterfaceID);\n\n    return virtPort;\n\n error:\n    VIR_FREE(virtPort);\n    goto cleanup;\n}"
  }
]