[
  {
    "function_name": "virNetDevVPortProfileDisassociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1365-1375",
    "snippet": "int virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Virtual port profile association not supported on this platform\")"
          ],
          "line": 1372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Virtual port profile association not supported on this platform\""
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileDisassociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                      const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                      const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                      const char *linkdev G_GNUC_UNUSED,\n                                      int vf G_GNUC_UNUSED,\n                                      virNetDevVPortProfileOp vmOp G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileAssociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1351-1363",
    "snippet": "int virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "ENOSYS",
            "\"%s\"",
            "_(\"Virtual port profile association not supported on this platform\")"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Virtual port profile association not supported on this platform\""
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileAssociate(const char *macvtap_ifname G_GNUC_UNUSED,\n                                   const virNetDevVPortProfile *virtPort G_GNUC_UNUSED,\n                                   const virMacAddr *macvtap_macaddr G_GNUC_UNUSED,\n                                   const char *linkdev G_GNUC_UNUSED,\n                                   int vf G_GNUC_UNUSED,\n                                   const unsigned char *vmuuid G_GNUC_UNUSED,\n                                   virNetDevVPortProfileOp vmOp G_GNUC_UNUSED,\n                                   bool setlink_only G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Virtual port profile association not supported on this platform\"));\n    return -1;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileDisassociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1302-1348",
    "snippet": "int\nvirNetDevVPortProfileDisassociate(const char *macvtap_ifname,\n                                  const virNetDevVPortProfile *virtPort,\n                                  const virMacAddr *macvtap_macaddr,\n                                  const char *linkdev,\n                                  int vf,\n                                  virNetDevVPortProfileOp vmOp)\n{\n    int rc = 0;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n\n    VIR_DEBUG(\"profile:'%p' vmOp: %s device: %s@%s mac: %s\",\n              virtPort, virNetDevVPortProfileOpTypeToString(vmOp),\n              NULLSTR_EMPTY(macvtap_ifname), linkdev,\n              (macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\"));\n\n    if (!virtPort)\n       return 0;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        rc = virNetDevVPortProfileOp8021Qbg(macvtap_ifname, macvtap_macaddr, vf,\n                                            virtPort,\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE, false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        /* avoid disassociating twice */\n        if (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH)\n            break;\n        if (vf < 0)\n            ignore_value(virNetDevSetOnline(linkdev, false));\n        rc = virNetDevVPortProfileOp8021Qbh(linkdev, macvtap_macaddr, vf,\n                                            virtPort, NULL,\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE);\n        break;\n    }\n\n    return rc;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOp8021Qbh",
          "args": [
            "linkdev",
            "macvtap_macaddr",
            "vf",
            "virtPort",
            "NULL",
            "VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOp8021Qbh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1110-1213",
          "snippet": "static int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevSetOnline(linkdev, false)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "linkdev",
            "false"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOp8021Qbg",
          "args": [
            "macvtap_ifname",
            "macvtap_macaddr",
            "vf",
            "virtPort",
            "VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE",
            "false"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOp8021Qbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1042-1107",
          "snippet": "static int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"profile:'%p' vmOp: %s device: %s@%s mac: %s\"",
            "virtPort",
            "virNetDevVPortProfileOpTypeToString(vmOp)",
            "NULLSTR_EMPTY(macvtap_ifname)",
            "linkdev",
            "(macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\")"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "macvtap_macaddr",
            "macStr"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "macvtap_ifname"
          ],
          "line": 1315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOpTypeToString",
          "args": [
            "vmOp"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileDisassociate(const char *macvtap_ifname,\n                                  const virNetDevVPortProfile *virtPort,\n                                  const virMacAddr *macvtap_macaddr,\n                                  const char *linkdev,\n                                  int vf,\n                                  virNetDevVPortProfileOp vmOp)\n{\n    int rc = 0;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n\n    VIR_DEBUG(\"profile:'%p' vmOp: %s device: %s@%s mac: %s\",\n              virtPort, virNetDevVPortProfileOpTypeToString(vmOp),\n              NULLSTR_EMPTY(macvtap_ifname), linkdev,\n              (macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\"));\n\n    if (!virtPort)\n       return 0;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        rc = virNetDevVPortProfileOp8021Qbg(macvtap_ifname, macvtap_macaddr, vf,\n                                            virtPort,\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE, false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        /* avoid disassociating twice */\n        if (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_FINISH)\n            break;\n        if (vf < 0)\n            ignore_value(virNetDevSetOnline(linkdev, false));\n        rc = virNetDevVPortProfileOp8021Qbh(linkdev, macvtap_macaddr, vf,\n                                            virtPort, NULL,\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE);\n        break;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileAssociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1233-1288",
    "snippet": "int\nvirNetDevVPortProfileAssociate(const char *macvtap_ifname,\n                               const virNetDevVPortProfile *virtPort,\n                               const virMacAddr *macvtap_macaddr,\n                               const char *linkdev,\n                               int vf,\n                               const unsigned char *vmuuid,\n                               virNetDevVPortProfileOp vmOp,\n                               bool setlink_only)\n{\n    int rc = 0;\n    char uuidStr[VIR_UUID_STRING_BUFLEN];\n    char macStr[VIR_MAC_STRING_BUFLEN];\n\n    VIR_DEBUG(\"profile:'%p' vmOp: %s device: %s@%s mac: %s uuid: %s\",\n              virtPort, virNetDevVPortProfileOpTypeToString(vmOp),\n              NULLSTR_EMPTY(macvtap_ifname), linkdev,\n              (macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\"),\n              vmuuid ? virUUIDFormat(vmuuid, uuidStr) : \"(unspecified)\");\n\n    if (!virtPort || vmOp == VIR_NETDEV_VPORT_PROFILE_OP_NO_OP)\n        return 0;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        rc = virNetDevVPortProfileOp8021Qbg(macvtap_ifname, macvtap_macaddr,\n                                            vf, virtPort,\n                                            (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE,\n                                            setlink_only);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        rc = virNetDevVPortProfileOp8021Qbh(linkdev, macvtap_macaddr, vf,\n                                            virtPort, vmuuid,\n                                            (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE);\n        if (vmOp != VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START && !rc) {\n            /* XXX bogus error handling */\n            ignore_value(virNetDevSetOnline(linkdev, true));\n        }\n\n        break;\n    }\n\n    return rc;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virNetDevSetOnline(linkdev, true)"
          ],
          "line": 1281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevSetOnline",
          "args": [
            "linkdev",
            "true"
          ],
          "line": 1281
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevSetOnline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "660-665",
          "snippet": "int\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevSetOnline(const char *ifname,\n                   bool online)\n{\n    return virNetDevSetIFFlag(ifname, VIR_IFF_UP, online);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOp8021Qbh",
          "args": [
            "linkdev",
            "macvtap_macaddr",
            "vf",
            "virtPort",
            "vmuuid",
            "(vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOp8021Qbh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1110-1213",
          "snippet": "static int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOp8021Qbg",
          "args": [
            "macvtap_ifname",
            "macvtap_macaddr",
            "vf",
            "virtPort",
            "(vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE",
            "setlink_only"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOp8021Qbg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1042-1107",
          "snippet": "static int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"profile:'%p' vmOp: %s device: %s@%s mac: %s uuid: %s\"",
            "virtPort",
            "virNetDevVPortProfileOpTypeToString(vmOp)",
            "NULLSTR_EMPTY(macvtap_ifname)",
            "linkdev",
            "(macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\")",
            "vmuuid ? virUUIDFormat(vmuuid, uuidStr) : \"(unspecified)\""
          ],
          "line": 1247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "vmuuid",
            "uuidStr"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "macvtap_macaddr",
            "macStr"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "NULLSTR_EMPTY",
          "args": [
            "macvtap_ifname"
          ],
          "line": 1249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOpTypeToString",
          "args": [
            "vmOp"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileAssociate(const char *macvtap_ifname,\n                               const virNetDevVPortProfile *virtPort,\n                               const virMacAddr *macvtap_macaddr,\n                               const char *linkdev,\n                               int vf,\n                               const unsigned char *vmuuid,\n                               virNetDevVPortProfileOp vmOp,\n                               bool setlink_only)\n{\n    int rc = 0;\n    char uuidStr[VIR_UUID_STRING_BUFLEN];\n    char macStr[VIR_MAC_STRING_BUFLEN];\n\n    VIR_DEBUG(\"profile:'%p' vmOp: %s device: %s@%s mac: %s uuid: %s\",\n              virtPort, virNetDevVPortProfileOpTypeToString(vmOp),\n              NULLSTR_EMPTY(macvtap_ifname), linkdev,\n              (macvtap_macaddr\n               ? virMacAddrFormat(macvtap_macaddr, macStr)\n               : \"(unspecified)\"),\n              vmuuid ? virUUIDFormat(vmuuid, uuidStr) : \"(unspecified)\");\n\n    if (!virtPort || vmOp == VIR_NETDEV_VPORT_PROFILE_OP_NO_OP)\n        return 0;\n\n    switch (virtPort->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n    case VIR_NETDEV_VPORT_PROFILE_LAST:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        rc = virNetDevVPortProfileOp8021Qbg(macvtap_ifname, macvtap_macaddr,\n                                            vf, virtPort,\n                                            (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE,\n                                            setlink_only);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        rc = virNetDevVPortProfileOp8021Qbh(linkdev, macvtap_macaddr, vf,\n                                            virtPort, vmuuid,\n                                            (vmOp == VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START)\n                                            ? VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR\n                                            : VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE);\n        if (vmOp != VIR_NETDEV_VPORT_PROFILE_OP_MIGRATE_IN_START && !rc) {\n            /* XXX bogus error handling */\n            ignore_value(virNetDevSetOnline(linkdev, true));\n        }\n\n        break;\n    }\n\n    return rc;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileOp8021Qbh",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1110-1213",
    "snippet": "static int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "physfndev"
          ],
          "line": 1211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportEnumRangeError",
          "args": [
            "virNetDevVPortProfileType",
            "virtPortOp"
          ],
          "line": 1205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"operation type %d not supported\")",
            "virtPortOp"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"operation type %d not supported\""
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOpCommon",
          "args": [
            "NULL",
            "ifindex",
            "nltarget_kernel",
            "NULL",
            "vlanid",
            "NULL",
            "NULL",
            "NULL",
            "NULL",
            "vf",
            "PORT_REQUEST_DISASSOCIATE",
            "false"
          ],
          "line": 1186
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOpCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "925-1009",
          "snippet": "static int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetHostUUID",
          "args": [
            "hostuuid"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "virGetHostUUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "258-268",
          "snippet": "int virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char host_uuid[VIR_UUID_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nstatic unsigned char host_uuid[VIR_UUID_BUFLEN];\n\nint virGetHostUUID(unsigned char *uuid)\n{\n    int ret = 0;\n\n    if (!virUUIDIsValid(host_uuid))\n        ret = virSetHostUUIDStr(NULL);\n\n    memcpy(uuid, host_uuid, sizeof(host_uuid));\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetIndex",
          "args": [
            "physfndev",
            "&ifindex"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "893-899",
          "snippet": "int virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetVirtualFunctionInfo",
          "args": [
            "ifname",
            "&physfndev",
            "&vf"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetVirtualFunctionInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1514-1522",
          "snippet": "int\nvirNetDevGetVirtualFunctionInfo(const char *vfname G_GNUC_UNUSED,\n                                char **pfname G_GNUC_UNUSED,\n                                int *vf G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get virtual function info on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetVirtualFunctionInfo(const char *vfname G_GNUC_UNUSED,\n                                char **pfname G_GNUC_UNUSED,\n                                int *vf G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get virtual function info on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevIsVirtualFunction",
          "args": [
            "ifname"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevIsVirtualFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1477-1483",
          "snippet": "int\nvirNetDevIsVirtualFunction(const char *ifname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to check virtual function status on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevIsVirtualFunction(const char *ifname G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to check virtual function status on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbh(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int32_t vf,\n                               const virNetDevVPortProfile *virtPort,\n                               const unsigned char *vm_uuid,\n                               enum virNetDevVPortProfileLinkOp virtPortOp)\n{\n    int rc = 0;\n    char *physfndev = NULL;\n    unsigned char hostuuid[VIR_UUID_BUFLEN];\n    bool nltarget_kernel = true;\n    int ifindex;\n    int vlanid = -1;\n    bool is_vf = false;\n\n    if (vf == -1) {\n        int isvf_ret = virNetDevIsVirtualFunction(ifname);\n\n        if (isvf_ret == -1)\n            goto cleanup;\n        is_vf = !!isvf_ret;\n    }\n\n    if (is_vf) {\n        if (virNetDevGetVirtualFunctionInfo(ifname, &physfndev, &vf) < 0) {\n            rc = -1;\n            goto cleanup;\n        }\n    } else {\n        physfndev = g_strdup(ifname);\n    }\n\n    rc = virNetDevGetIndex(physfndev, &ifindex);\n    if (rc < 0)\n        goto cleanup;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        errno = virGetHostUUID(hostuuid);\n        if (errno) {\n            rc = -1;\n            goto cleanup;\n        }\n\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           macaddr,\n                                           vlanid,\n                                           virtPort->profileID,\n                                           NULL,\n                                           vm_uuid,\n                                           hostuuid,\n                                           vf,\n                                           (virtPortOp ==\n                                            VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR) ?\n                                           PORT_REQUEST_PREASSOCIATE_RR\n                                           : PORT_REQUEST_ASSOCIATE,\n                                           false);\n        if (rc == -2)\n            /* Association timed out, disassociate */\n            virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                          nltarget_kernel,\n                                          NULL,\n                                          vlanid,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          NULL,\n                                          vf,\n                                          PORT_REQUEST_DISASSOCIATE,\n                                          false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        rc = virNetDevVPortProfileOpCommon(NULL, ifindex,\n                                           nltarget_kernel,\n                                           NULL,\n                                           vlanid,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           NULL,\n                                           vf,\n                                           PORT_REQUEST_DISASSOCIATE,\n                                           false);\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        rc = -1;\n        break;\n    default:\n        virReportEnumRangeError(virNetDevVPortProfileType, virtPortOp);\n        rc = -1;\n        break;\n    }\n\n cleanup:\n    VIR_FREE(physfndev);\n    return rc;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileOp8021Qbg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1042-1107",
    "snippet": "static int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOpCommon",
          "args": [
            "physdev_ifname",
            "physdev_ifindex",
            "nltarget_kernel",
            "macaddr",
            "vlanid",
            "NULL",
            "&portVsi",
            "virtPort->instanceID",
            "NULL",
            "vf",
            "op",
            "setlink_only"
          ],
          "line": 1096
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOpCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "925-1009",
          "snippet": "static int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"operation type %d not supported\")",
            "virtPortOp"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"operation type %d not supported\""
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileGetPhysdevAndVlan",
          "args": [
            "ifname",
            "&physdev_ifindex",
            "physdev_ifname",
            "&vlanid"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileGetPhysdevAndVlan",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "1012-1039",
          "snippet": "static int\nvirNetDevVPortProfileGetPhysdevAndVlan(const char *ifname, int *root_ifindex, char *root_ifname,\n                                       int *vlanid)\n{\n    int ret;\n    unsigned int nth;\n    int ifindex = -1;\n\n    *vlanid = -1;\n    while (1) {\n        if ((ret = virNetDevVPortProfileGetNthParent(ifname, ifindex, 1,\n                                                     root_ifindex, root_ifname, &nth)) < 0)\n            return ret;\n        if (nth == 0)\n            break;\n        if (*vlanid == -1) {\n            if (virNetDevGetVLanID(root_ifname, vlanid) < 0) {\n                virResetLastError();\n                *vlanid = -1;\n            }\n        }\n\n        ifindex = *root_ifindex;\n        ifname = NULL;\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetPhysdevAndVlan(const char *ifname, int *root_ifindex, char *root_ifname,\n                                       int *vlanid)\n{\n    int ret;\n    unsigned int nth;\n    int ifindex = -1;\n\n    *vlanid = -1;\n    while (1) {\n        if ((ret = virNetDevVPortProfileGetNthParent(ifname, ifindex, 1,\n                                                     root_ifindex, root_ifname, &nth)) < 0)\n            return ret;\n        if (nth == 0)\n            break;\n        if (*vlanid == -1) {\n            if (virNetDevGetVLanID(root_ifname, vlanid) < 0) {\n                virResetLastError();\n                *vlanid = -1;\n            }\n        }\n\n        ifindex = *root_ifindex;\n        ifname = NULL;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOp8021Qbg(const char *ifname,\n                               const virMacAddr *macaddr,\n                               int vf,\n                               const virNetDevVPortProfile *virtPort,\n                               enum virNetDevVPortProfileLinkOp virtPortOp,\n                               bool setlink_only)\n{\n    int op = PORT_REQUEST_ASSOCIATE;\n    struct ifla_port_vsi portVsi = {\n        .vsi_mgr_id       = virtPort->managerID,\n        .vsi_type_version = virtPort->typeIDVersion,\n    };\n    bool nltarget_kernel = false;\n    int vlanid;\n    int physdev_ifindex = 0;\n    char physdev_ifname[IFNAMSIZ] = { 0, };\n\n    if (!ifname)\n        return -1;\n\n    vf = PORT_SELF_VF;\n\n    if (virNetDevVPortProfileGetPhysdevAndVlan(ifname, &physdev_ifindex,\n                                               physdev_ifname, &vlanid) < 0) {\n        return -1;\n    }\n\n    if (vlanid < 0)\n        vlanid = 0;\n\n    portVsi.vsi_type_id[2] = virtPort->typeID >> 16;\n    portVsi.vsi_type_id[1] = virtPort->typeID >> 8;\n    portVsi.vsi_type_id[0] = virtPort->typeID;\n\n    switch (virtPortOp) {\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE:\n        op = PORT_REQUEST_PREASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_PREASSOCIATE_RR:\n        op = PORT_REQUEST_PREASSOCIATE_RR;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_ASSOCIATE:\n        op = PORT_REQUEST_ASSOCIATE;\n        break;\n    case VIR_NETDEV_VPORT_PROFILE_LINK_OP_DISASSOCIATE:\n        op = PORT_REQUEST_DISASSOCIATE;\n        break;\n    default:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"operation type %d not supported\"), virtPortOp);\n        return -1;\n    }\n\n    return virNetDevVPortProfileOpCommon(physdev_ifname, physdev_ifindex,\n                                         nltarget_kernel,\n                                         macaddr,\n                                         vlanid,\n                                         NULL,\n                                         &portVsi,\n                                         virtPort->instanceID,\n                                         NULL,\n                                         vf,\n                                         op,\n                                         setlink_only);\n}"
  },
  {
    "function_name": "virNetDevVPortProfileGetPhysdevAndVlan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "1012-1039",
    "snippet": "static int\nvirNetDevVPortProfileGetPhysdevAndVlan(const char *ifname, int *root_ifindex, char *root_ifname,\n                                       int *vlanid)\n{\n    int ret;\n    unsigned int nth;\n    int ifindex = -1;\n\n    *vlanid = -1;\n    while (1) {\n        if ((ret = virNetDevVPortProfileGetNthParent(ifname, ifindex, 1,\n                                                     root_ifindex, root_ifname, &nth)) < 0)\n            return ret;\n        if (nth == 0)\n            break;\n        if (*vlanid == -1) {\n            if (virNetDevGetVLanID(root_ifname, vlanid) < 0) {\n                virResetLastError();\n                *vlanid = -1;\n            }\n        }\n\n        ifindex = *root_ifindex;\n        ifname = NULL;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virResetLastError",
          "args": [],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "virResetLastError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "500-506",
          "snippet": "void\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetLastError(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err)\n        virResetError(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetVLanID",
          "args": [
            "root_ifname",
            "vlanid"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetVLanID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "985-991",
          "snippet": "int virNetDevGetVLanID(const char *ifname G_GNUC_UNUSED,\n                       int *vlanid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get VLAN on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevGetVLanID(const char *ifname G_GNUC_UNUSED,\n                       int *vlanid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get VLAN on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileGetNthParent",
          "args": [
            "ifname",
            "ifindex",
            "1",
            "root_ifindex",
            "root_ifname",
            "&nth"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileGetNthParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "873-921",
          "snippet": "static int\nvirNetDevVPortProfileGetNthParent(const char *ifname, int ifindex, unsigned int nthParent,\n                                  int *parent_ifindex, char *parent_ifname,\n                                  unsigned int *nth)\n{\n    int rc = -1;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    bool end = false;\n    size_t i = 0;\n\n    *nth = 0;\n\n    if (ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    while (!end && i <= nthParent) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(ifname, ifindex, &nlData, tb, 0, 0);\n        if (rc < 0)\n            break;\n\n        if (tb[IFLA_IFNAME]) {\n            if (virStrcpy(parent_ifname, (char*)RTA_DATA(tb[IFLA_IFNAME]),\n                          IFNAMSIZ) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"buffer for root interface name is too small\"));\n                rc = -1;\n                goto cleanup;\n            }\n            *parent_ifindex = ifindex;\n        }\n\n        if (tb[IFLA_LINK]) {\n            ifindex = *(int *)RTA_DATA(tb[IFLA_LINK]);\n            ifname = NULL;\n        } else {\n            end = true;\n        }\n\n        i++;\n    }\n\n    *nth = i - 1;\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetNthParent(const char *ifname, int ifindex, unsigned int nthParent,\n                                  int *parent_ifindex, char *parent_ifname,\n                                  unsigned int *nth)\n{\n    int rc = -1;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    bool end = false;\n    size_t i = 0;\n\n    *nth = 0;\n\n    if (ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    while (!end && i <= nthParent) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(ifname, ifindex, &nlData, tb, 0, 0);\n        if (rc < 0)\n            break;\n\n        if (tb[IFLA_IFNAME]) {\n            if (virStrcpy(parent_ifname, (char*)RTA_DATA(tb[IFLA_IFNAME]),\n                          IFNAMSIZ) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"buffer for root interface name is too small\"));\n                rc = -1;\n                goto cleanup;\n            }\n            *parent_ifindex = ifindex;\n        }\n\n        if (tb[IFLA_LINK]) {\n            ifindex = *(int *)RTA_DATA(tb[IFLA_LINK]);\n            ifname = NULL;\n        } else {\n            end = true;\n        }\n\n        i++;\n    }\n\n    *nth = i - 1;\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetPhysdevAndVlan(const char *ifname, int *root_ifindex, char *root_ifname,\n                                       int *vlanid)\n{\n    int ret;\n    unsigned int nth;\n    int ifindex = -1;\n\n    *vlanid = -1;\n    while (1) {\n        if ((ret = virNetDevVPortProfileGetNthParent(ifname, ifindex, 1,\n                                                     root_ifindex, root_ifname, &nth)) < 0)\n            return ret;\n        if (nth == 0)\n            break;\n        if (*vlanid == -1) {\n            if (virNetDevGetVLanID(root_ifname, vlanid) < 0) {\n                virResetLastError();\n                *vlanid = -1;\n            }\n        }\n\n        ifindex = *root_ifindex;\n        ifname = NULL;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileOpCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "925-1009",
    "snippet": "static int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nlData"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"port-profile setlink timed out\")"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"port-profile setlink timed out\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "STATUS_POLL_INTERVL_USEC"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "EINVAL",
            "_(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\")",
            "status",
            "ifname",
            "ifindex"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileGetStatus",
          "args": [
            "tb",
            "vf",
            "instanceId",
            "nltarget_kernel",
            "is8021Qbg",
            "&status"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileGetStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "513-637",
          "snippet": "static int\nvirNetDevVPortProfileGetStatus(struct nlattr **tb, int32_t vf,\n                               const unsigned char *instanceId,\n                               bool nltarget_kernel,\n                               bool is8021Qbg,\n                               uint16_t *status)\n{\n    struct nlattr *tb_port[IFLA_PORT_MAX + 1] = { NULL, };\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (tb[IFLA_PORT_SELF]) {\n            if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb[IFLA_PORT_SELF],\n                                 ifla_port_policy)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing IFLA_PORT_SELF part\"));\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_PORT_SELF is missing\"));\n            return -1;\n        }\n    } else {\n        if (tb[IFLA_VF_PORTS]) {\n            int rem;\n            bool found = false;\n            struct nlattr *tb_vf_ports = { NULL, };\n\n            nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n\n                if (nla_type(tb_vf_ports) != IFLA_VF_PORT) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error while iterating over \"\n                                     \"IFLA_VF_PORTS part\"));\n                    return -1;\n                }\n\n                if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                     ifla_port_policy)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error parsing IFLA_VF_PORT part\"));\n                    return -1;\n                }\n\n                /* This ensures that the given VF is present in the\n                 * IFLA_VF_PORTS list, and that its uuid matches the\n                 * instanceId (in case we've associated it). If no\n                 * instanceId is sent from the caller, that means we've\n                 * disassociated it from this instanceId, and the uuid\n                 * will either be unset (if still not associated with\n                 * anything) or will be set to a new and different uuid\n                 */\n                if ((tb_port[IFLA_PORT_VF] &&\n                     vf == *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF])) &&\n                    (!instanceId ||\n                     (tb_port[IFLA_PORT_INSTANCE_UUID] &&\n                      !memcmp(instanceId,\n                              (unsigned char *)\n                              RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                              VIR_UUID_BUFLEN)))) {\n                        found = true;\n                        break;\n                }\n            }\n\n            if (!found) {\n                char instanceIdStr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                if (instanceId)\n                   virUUIDFormat(instanceId, instanceIdStr);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find vf/instanceId %u/%s \"\n                                 \" in netlink response\"),\n                               vf, instanceIdStr);\n\n                /* go through all the entries again. This seems tedious,\n                 * but experience has shown the resulting log to be\n                 * very useful.\n                 */\n                VIR_WARN(\"IFLA_VF_PORTS entries that were returned:\");\n                nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n                    char uuidstr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                    if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                         ifla_port_policy)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"error parsing IFLA_VF_PORT \"\n                                         \"during error reporting\"));\n                        return -1;\n                    }\n                    if (tb_port[IFLA_PORT_INSTANCE_UUID]) {\n                        virUUIDFormat((unsigned char *)\n                                      RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                                      uuidstr);\n                    }\n                    VIR_WARN(\"  vf: %d uuid: %s\",\n                             tb_port[IFLA_PORT_VF] ?\n                             *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF]) : -1,\n                             uuidstr);\n                }\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_VF_PORTS is missing\"));\n            return -1;\n        }\n    }\n\n    if (tb_port[IFLA_PORT_RESPONSE]) {\n        *status = *(uint16_t *)RTA_DATA(tb_port[IFLA_PORT_RESPONSE]);\n    } else {\n        if (is8021Qbg) {\n            /* no in-progress here; may be missing */\n            *status = PORT_PROFILE_RESPONSE_INPROGRESS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no IFLA_PORT_RESPONSE found in netlink message\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetStatus(struct nlattr **tb, int32_t vf,\n                               const unsigned char *instanceId,\n                               bool nltarget_kernel,\n                               bool is8021Qbg,\n                               uint16_t *status)\n{\n    struct nlattr *tb_port[IFLA_PORT_MAX + 1] = { NULL, };\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (tb[IFLA_PORT_SELF]) {\n            if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb[IFLA_PORT_SELF],\n                                 ifla_port_policy)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing IFLA_PORT_SELF part\"));\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_PORT_SELF is missing\"));\n            return -1;\n        }\n    } else {\n        if (tb[IFLA_VF_PORTS]) {\n            int rem;\n            bool found = false;\n            struct nlattr *tb_vf_ports = { NULL, };\n\n            nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n\n                if (nla_type(tb_vf_ports) != IFLA_VF_PORT) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error while iterating over \"\n                                     \"IFLA_VF_PORTS part\"));\n                    return -1;\n                }\n\n                if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                     ifla_port_policy)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error parsing IFLA_VF_PORT part\"));\n                    return -1;\n                }\n\n                /* This ensures that the given VF is present in the\n                 * IFLA_VF_PORTS list, and that its uuid matches the\n                 * instanceId (in case we've associated it). If no\n                 * instanceId is sent from the caller, that means we've\n                 * disassociated it from this instanceId, and the uuid\n                 * will either be unset (if still not associated with\n                 * anything) or will be set to a new and different uuid\n                 */\n                if ((tb_port[IFLA_PORT_VF] &&\n                     vf == *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF])) &&\n                    (!instanceId ||\n                     (tb_port[IFLA_PORT_INSTANCE_UUID] &&\n                      !memcmp(instanceId,\n                              (unsigned char *)\n                              RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                              VIR_UUID_BUFLEN)))) {\n                        found = true;\n                        break;\n                }\n            }\n\n            if (!found) {\n                char instanceIdStr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                if (instanceId)\n                   virUUIDFormat(instanceId, instanceIdStr);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find vf/instanceId %u/%s \"\n                                 \" in netlink response\"),\n                               vf, instanceIdStr);\n\n                /* go through all the entries again. This seems tedious,\n                 * but experience has shown the resulting log to be\n                 * very useful.\n                 */\n                VIR_WARN(\"IFLA_VF_PORTS entries that were returned:\");\n                nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n                    char uuidstr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                    if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                         ifla_port_policy)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"error parsing IFLA_VF_PORT \"\n                                         \"during error reporting\"));\n                        return -1;\n                    }\n                    if (tb_port[IFLA_PORT_INSTANCE_UUID]) {\n                        virUUIDFormat((unsigned char *)\n                                      RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                                      uuidstr);\n                    }\n                    VIR_WARN(\"  vf: %d uuid: %s\",\n                             tb_port[IFLA_PORT_VF] ?\n                             *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF]) : -1,\n                             uuidstr);\n                }\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_VF_PORTS is missing\"));\n            return -1;\n        }\n    }\n\n    if (tb_port[IFLA_PORT_RESPONSE]) {\n        *status = *(uint16_t *)RTA_DATA(tb_port[IFLA_PORT_RESPONSE]);\n    } else {\n        if (is8021Qbg) {\n            /* no in-progress here; may be missing */\n            *status = PORT_PROFILE_RESPONSE_INPROGRESS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no IFLA_PORT_RESPONSE found in netlink message\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkDumpLink",
          "args": [
            "NULL",
            "ifindex",
            "&nlData",
            "tb",
            "src_pid",
            "dst_pid"
          ],
          "line": 975
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkDumpLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1261-1272",
          "snippet": "int\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nlData"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileGetLldpadPid",
          "args": [],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileGetLldpadPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "468-499",
          "snippet": "static uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServiceLocalPid",
          "args": [
            "NETLINK_ROUTE"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServiceLocalPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1346-1350",
          "snippet": "int virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"sending of PortProfileRequest failed.\")"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileOpSetLink",
          "args": [
            "ifname",
            "ifindex",
            "nltarget_kernel",
            "macaddr",
            "vlanid",
            "profileId",
            "portVsi",
            "instanceId",
            "hostUUID",
            "vf",
            "op"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileOpSetLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "640-852",
          "snippet": "static int\nvirNetDevVPortProfileOpSetLink(const char *ifname, int ifindex,\n                               bool nltarget_kernel,\n                               const virMacAddr *macaddr,\n                               int vlanid,\n                               const char *profileId,\n                               struct ifla_port_vsi *portVsi,\n                               const unsigned char *instanceId,\n                               const unsigned char *hostUUID,\n                               int32_t vf,\n                               uint8_t op)\n{\n    int rc = -1;\n    struct nlmsghdr *resp = NULL;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex,\n    };\n    unsigned int recvbuflen = 0;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    struct nl_msg *nl_msg;\n    struct nlattr *vfports = NULL, *vfport;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char hostUUIDStr[VIR_UUID_STRING_BUFLEN];\n    char instanceUUIDStr[VIR_UUID_STRING_BUFLEN];\n    const char *opName;\n\n    switch (op) {\n    case PORT_REQUEST_PREASSOCIATE:\n        opName = \"PREASSOCIATE\";\n        break;\n    case PORT_REQUEST_PREASSOCIATE_RR:\n        opName = \"PREASSOCIATE_RR\";\n        break;\n    case PORT_REQUEST_ASSOCIATE:\n        opName = \"ASSOCIATE\";\n        break;\n    case PORT_REQUEST_DISASSOCIATE:\n        opName = \"DISASSOCIATE\";\n        break;\n    default:\n        opName = \"(unknown)\";\n        break;\n    }\n    VIR_INFO(\"%s: ifname: %s ifindex: %d vf: %d vlanid: %d mac: %s \"\n             \"profileId: %s instanceId: %s hostUUID: %s\",\n             opName, ifname ? ifname : \"(unspecified)\",\n             ifindex, vf, vlanid,\n             macaddr ? virMacAddrFormat(macaddr, macStr) : \"(unspecified)\",\n             profileId ? profileId : \"(unspecified)\",\n             (instanceId\n              ? virUUIDFormat(instanceId, instanceUUIDStr)\n              : \"(unspecified)\"),\n             (hostUUID\n              ? virUUIDFormat(hostUUID, hostUUIDStr)\n              : \"(unspecified)\"));\n\n    nl_msg = nlmsg_alloc_simple(RTM_SETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return rc;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname &&\n        nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (macaddr || vlanid >= 0) {\n        struct nlattr *vfinfolist, *vfinfo;\n\n        if (!(vfinfolist = nla_nest_start(nl_msg, IFLA_VFINFO_LIST)))\n            goto buffer_too_small;\n\n        if (!(vfinfo = nla_nest_start(nl_msg, IFLA_VF_INFO)))\n            goto buffer_too_small;\n\n        if (macaddr) {\n            struct ifla_vf_mac ifla_vf_mac = {\n                .vf = vf,\n                .mac = { 0, },\n            };\n\n            virMacAddrGetRaw(macaddr, ifla_vf_mac.mac);\n\n            if (nla_put(nl_msg, IFLA_VF_MAC, sizeof(ifla_vf_mac),\n                        &ifla_vf_mac) < 0)\n                goto buffer_too_small;\n        }\n\n        if (vlanid >= 0) {\n            struct ifla_vf_vlan ifla_vf_vlan = {\n                .vf = vf,\n                .vlan = vlanid,\n                .qos = 0,\n            };\n\n            if (nla_put(nl_msg, IFLA_VF_VLAN, sizeof(ifla_vf_vlan),\n                        &ifla_vf_vlan) < 0)\n                goto buffer_too_small;\n        }\n\n        nla_nest_end(nl_msg, vfinfo);\n        nla_nest_end(nl_msg, vfinfolist);\n    }\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_PORT_SELF)))\n            goto buffer_too_small;\n    } else {\n        if (!(vfports = nla_nest_start(nl_msg, IFLA_VF_PORTS)))\n            goto buffer_too_small;\n\n        /* begin nesting vfports */\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_VF_PORT)))\n            goto buffer_too_small;\n    }\n\n    if (profileId) {\n        if (nla_put(nl_msg, IFLA_PORT_PROFILE, strlen(profileId) + 1,\n                    profileId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (portVsi) {\n        if (nla_put(nl_msg, IFLA_PORT_VSI_TYPE, sizeof(*portVsi),\n                    portVsi) < 0)\n            goto buffer_too_small;\n    }\n\n    if (instanceId) {\n        if (nla_put(nl_msg, IFLA_PORT_INSTANCE_UUID, VIR_UUID_BUFLEN,\n                    instanceId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (hostUUID) {\n        if (nla_put(nl_msg, IFLA_PORT_HOST_UUID, VIR_UUID_BUFLEN,\n                    hostUUID) < 0)\n            goto buffer_too_small;\n    }\n\n    if (vf != PORT_SELF_VF) {\n        if (nla_put(nl_msg, IFLA_PORT_VF, sizeof(vf), &vf) < 0)\n            goto buffer_too_small;\n    }\n\n    if (nla_put(nl_msg, IFLA_PORT_REQUEST, sizeof(op), &op) < 0)\n        goto buffer_too_small;\n\n    /* end nesting of vport */\n    nla_nest_end(nl_msg, vfport);\n\n    if (vfports) {\n        /* end nesting of vfports */\n        nla_nest_end(nl_msg, vfports);\n    }\n\n    if (!nltarget_kernel) {\n        if ((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0)\n            goto cleanup;\n        if ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0)\n            goto cleanup;\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        goto cleanup;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error during virtual port configuration of ifindex %d\"),\n                                 ifindex);\n            goto cleanup;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    rc = 0;\n cleanup:\n    nlmsg_free(nl_msg);\n    VIR_FREE(resp);\n    return rc;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    goto cleanup;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    goto cleanup;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOpSetLink(const char *ifname, int ifindex,\n                               bool nltarget_kernel,\n                               const virMacAddr *macaddr,\n                               int vlanid,\n                               const char *profileId,\n                               struct ifla_port_vsi *portVsi,\n                               const unsigned char *instanceId,\n                               const unsigned char *hostUUID,\n                               int32_t vf,\n                               uint8_t op)\n{\n    int rc = -1;\n    struct nlmsghdr *resp = NULL;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex,\n    };\n    unsigned int recvbuflen = 0;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    struct nl_msg *nl_msg;\n    struct nlattr *vfports = NULL, *vfport;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char hostUUIDStr[VIR_UUID_STRING_BUFLEN];\n    char instanceUUIDStr[VIR_UUID_STRING_BUFLEN];\n    const char *opName;\n\n    switch (op) {\n    case PORT_REQUEST_PREASSOCIATE:\n        opName = \"PREASSOCIATE\";\n        break;\n    case PORT_REQUEST_PREASSOCIATE_RR:\n        opName = \"PREASSOCIATE_RR\";\n        break;\n    case PORT_REQUEST_ASSOCIATE:\n        opName = \"ASSOCIATE\";\n        break;\n    case PORT_REQUEST_DISASSOCIATE:\n        opName = \"DISASSOCIATE\";\n        break;\n    default:\n        opName = \"(unknown)\";\n        break;\n    }\n    VIR_INFO(\"%s: ifname: %s ifindex: %d vf: %d vlanid: %d mac: %s \"\n             \"profileId: %s instanceId: %s hostUUID: %s\",\n             opName, ifname ? ifname : \"(unspecified)\",\n             ifindex, vf, vlanid,\n             macaddr ? virMacAddrFormat(macaddr, macStr) : \"(unspecified)\",\n             profileId ? profileId : \"(unspecified)\",\n             (instanceId\n              ? virUUIDFormat(instanceId, instanceUUIDStr)\n              : \"(unspecified)\"),\n             (hostUUID\n              ? virUUIDFormat(hostUUID, hostUUIDStr)\n              : \"(unspecified)\"));\n\n    nl_msg = nlmsg_alloc_simple(RTM_SETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return rc;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname &&\n        nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (macaddr || vlanid >= 0) {\n        struct nlattr *vfinfolist, *vfinfo;\n\n        if (!(vfinfolist = nla_nest_start(nl_msg, IFLA_VFINFO_LIST)))\n            goto buffer_too_small;\n\n        if (!(vfinfo = nla_nest_start(nl_msg, IFLA_VF_INFO)))\n            goto buffer_too_small;\n\n        if (macaddr) {\n            struct ifla_vf_mac ifla_vf_mac = {\n                .vf = vf,\n                .mac = { 0, },\n            };\n\n            virMacAddrGetRaw(macaddr, ifla_vf_mac.mac);\n\n            if (nla_put(nl_msg, IFLA_VF_MAC, sizeof(ifla_vf_mac),\n                        &ifla_vf_mac) < 0)\n                goto buffer_too_small;\n        }\n\n        if (vlanid >= 0) {\n            struct ifla_vf_vlan ifla_vf_vlan = {\n                .vf = vf,\n                .vlan = vlanid,\n                .qos = 0,\n            };\n\n            if (nla_put(nl_msg, IFLA_VF_VLAN, sizeof(ifla_vf_vlan),\n                        &ifla_vf_vlan) < 0)\n                goto buffer_too_small;\n        }\n\n        nla_nest_end(nl_msg, vfinfo);\n        nla_nest_end(nl_msg, vfinfolist);\n    }\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_PORT_SELF)))\n            goto buffer_too_small;\n    } else {\n        if (!(vfports = nla_nest_start(nl_msg, IFLA_VF_PORTS)))\n            goto buffer_too_small;\n\n        /* begin nesting vfports */\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_VF_PORT)))\n            goto buffer_too_small;\n    }\n\n    if (profileId) {\n        if (nla_put(nl_msg, IFLA_PORT_PROFILE, strlen(profileId) + 1,\n                    profileId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (portVsi) {\n        if (nla_put(nl_msg, IFLA_PORT_VSI_TYPE, sizeof(*portVsi),\n                    portVsi) < 0)\n            goto buffer_too_small;\n    }\n\n    if (instanceId) {\n        if (nla_put(nl_msg, IFLA_PORT_INSTANCE_UUID, VIR_UUID_BUFLEN,\n                    instanceId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (hostUUID) {\n        if (nla_put(nl_msg, IFLA_PORT_HOST_UUID, VIR_UUID_BUFLEN,\n                    hostUUID) < 0)\n            goto buffer_too_small;\n    }\n\n    if (vf != PORT_SELF_VF) {\n        if (nla_put(nl_msg, IFLA_PORT_VF, sizeof(vf), &vf) < 0)\n            goto buffer_too_small;\n    }\n\n    if (nla_put(nl_msg, IFLA_PORT_REQUEST, sizeof(op), &op) < 0)\n        goto buffer_too_small;\n\n    /* end nesting of vport */\n    nla_nest_end(nl_msg, vfport);\n\n    if (vfports) {\n        /* end nesting of vfports */\n        nla_nest_end(nl_msg, vfports);\n    }\n\n    if (!nltarget_kernel) {\n        if ((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0)\n            goto cleanup;\n        if ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0)\n            goto cleanup;\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        goto cleanup;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error during virtual port configuration of ifindex %d\"),\n                                 ifindex);\n            goto cleanup;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    rc = 0;\n cleanup:\n    nlmsg_free(nl_msg);\n    VIR_FREE(resp);\n    return rc;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    goto cleanup;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    goto cleanup;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOpCommon(const char *ifname, int ifindex,\n                              bool nltarget_kernel,\n                              const virMacAddr *macaddr,\n                              int vlanid,\n                              const char *profileId,\n                              struct ifla_port_vsi *portVsi,\n                              const unsigned char *instanceId,\n                              const unsigned char *hostUUID,\n                              int32_t vf,\n                              uint8_t op,\n                              bool setlink_only)\n{\n    int rc;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    int repeats = STATUS_POLL_TIMEOUT_USEC / STATUS_POLL_INTERVL_USEC;\n    uint16_t status = 0;\n    bool is8021Qbg = (profileId == NULL);\n\n    rc = virNetDevVPortProfileOpSetLink(ifname, ifindex,\n                                        nltarget_kernel,\n                                        macaddr,\n                                        vlanid,\n                                        profileId,\n                                        portVsi,\n                                        instanceId,\n                                        hostUUID,\n                                        vf,\n                                        op);\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"sending of PortProfileRequest failed.\"));\n        return rc;\n    }\n\n    if (setlink_only) /* for re-associations on existing links */\n        return 0;\n\n    if (!nltarget_kernel &&\n        (((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0) ||\n         ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0))) {\n        rc = -1;\n        goto cleanup;\n    }\n\n    while (--repeats >= 0) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(NULL, ifindex, &nlData, tb, src_pid, dst_pid);\n        if (rc < 0)\n            goto cleanup;\n\n        rc = virNetDevVPortProfileGetStatus(tb, vf, instanceId, nltarget_kernel,\n                                            is8021Qbg, &status);\n        if (rc < 0)\n            goto cleanup;\n        if (status == PORT_PROFILE_RESPONSE_SUCCESS ||\n            status == PORT_VDP_RESPONSE_SUCCESS) {\n            break;\n        } else if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n            /* keep trying... */\n        } else {\n            virReportSystemError(EINVAL,\n                                 _(\"error %d during port-profile setlink on \"\n                                   \"interface %s (%d)\"),\n                                 status, ifname, ifindex);\n            rc = -1;\n            break;\n        }\n\n        g_usleep(STATUS_POLL_INTERVL_USEC);\n    }\n\n    if (status == PORT_PROFILE_RESPONSE_INPROGRESS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"port-profile setlink timed out\"));\n        rc = -2;\n    }\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileGetNthParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "873-921",
    "snippet": "static int\nvirNetDevVPortProfileGetNthParent(const char *ifname, int ifindex, unsigned int nthParent,\n                                  int *parent_ifindex, char *parent_ifname,\n                                  unsigned int *nth)\n{\n    int rc = -1;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    bool end = false;\n    size_t i = 0;\n\n    *nth = 0;\n\n    if (ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    while (!end && i <= nthParent) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(ifname, ifindex, &nlData, tb, 0, 0);\n        if (rc < 0)\n            break;\n\n        if (tb[IFLA_IFNAME]) {\n            if (virStrcpy(parent_ifname, (char*)RTA_DATA(tb[IFLA_IFNAME]),\n                          IFNAMSIZ) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"buffer for root interface name is too small\"));\n                rc = -1;\n                goto cleanup;\n            }\n            *parent_ifindex = ifindex;\n        }\n\n        if (tb[IFLA_LINK]) {\n            ifindex = *(int *)RTA_DATA(tb[IFLA_LINK]);\n            ifname = NULL;\n        } else {\n            end = true;\n        }\n\n        i++;\n    }\n\n    *nth = i - 1;\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nlData"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb[IFLA_LINK]"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"buffer for root interface name is too small\")"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"buffer for root interface name is too small\""
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpy",
          "args": [
            "parent_ifname",
            "(char*)RTA_DATA(tb[IFLA_IFNAME])",
            "IFNAMSIZ"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "virStrcpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "780-784",
          "snippet": "int\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrcpy(char *dest, const char *src, size_t destbytes)\n{\n    return virStrncpy(dest, src, -1, destbytes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb[IFLA_IFNAME]"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkDumpLink",
          "args": [
            "ifname",
            "ifindex",
            "&nlData",
            "tb",
            "0",
            "0"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkDumpLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1261-1272",
          "snippet": "int\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirNetlinkDumpLink(const char *ifname G_GNUC_UNUSED,\n                   int ifindex G_GNUC_UNUSED,\n                   void **nlData G_GNUC_UNUSED,\n                   struct nlattr **tb G_GNUC_UNUSED,\n                   uint32_t src_pid G_GNUC_UNUSED,\n                   uint32_t dst_pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to dump link info on this platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nlData"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetIndex",
          "args": [
            "ifname",
            "&ifindex"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "893-899",
          "snippet": "int virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint virNetDevGetIndex(const char *ifname G_GNUC_UNUSED,\n                      int *ifindex G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Unable to get interface index on this platform\"));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetNthParent(const char *ifname, int ifindex, unsigned int nthParent,\n                                  int *parent_ifindex, char *parent_ifname,\n                                  unsigned int *nth)\n{\n    int rc = -1;\n    void *nlData = NULL;\n    struct nlattr *tb[IFLA_MAX + 1] = { NULL, };\n    bool end = false;\n    size_t i = 0;\n\n    *nth = 0;\n\n    if (ifindex <= 0 && virNetDevGetIndex(ifname, &ifindex) < 0)\n        return -1;\n\n    while (!end && i <= nthParent) {\n        VIR_FREE(nlData);\n        rc = virNetlinkDumpLink(ifname, ifindex, &nlData, tb, 0, 0);\n        if (rc < 0)\n            break;\n\n        if (tb[IFLA_IFNAME]) {\n            if (virStrcpy(parent_ifname, (char*)RTA_DATA(tb[IFLA_IFNAME]),\n                          IFNAMSIZ) < 0) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"buffer for root interface name is too small\"));\n                rc = -1;\n                goto cleanup;\n            }\n            *parent_ifindex = ifindex;\n        }\n\n        if (tb[IFLA_LINK]) {\n            ifindex = *(int *)RTA_DATA(tb[IFLA_LINK]);\n            ifname = NULL;\n        } else {\n            end = true;\n        }\n\n        i++;\n    }\n\n    *nth = i - 1;\n\n cleanup:\n    VIR_FREE(nlData);\n    return rc;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileOpSetLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "640-852",
    "snippet": "static int\nvirNetDevVPortProfileOpSetLink(const char *ifname, int ifindex,\n                               bool nltarget_kernel,\n                               const virMacAddr *macaddr,\n                               int vlanid,\n                               const char *profileId,\n                               struct ifla_port_vsi *portVsi,\n                               const unsigned char *instanceId,\n                               const unsigned char *hostUUID,\n                               int32_t vf,\n                               uint8_t op)\n{\n    int rc = -1;\n    struct nlmsghdr *resp = NULL;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex,\n    };\n    unsigned int recvbuflen = 0;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    struct nl_msg *nl_msg;\n    struct nlattr *vfports = NULL, *vfport;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char hostUUIDStr[VIR_UUID_STRING_BUFLEN];\n    char instanceUUIDStr[VIR_UUID_STRING_BUFLEN];\n    const char *opName;\n\n    switch (op) {\n    case PORT_REQUEST_PREASSOCIATE:\n        opName = \"PREASSOCIATE\";\n        break;\n    case PORT_REQUEST_PREASSOCIATE_RR:\n        opName = \"PREASSOCIATE_RR\";\n        break;\n    case PORT_REQUEST_ASSOCIATE:\n        opName = \"ASSOCIATE\";\n        break;\n    case PORT_REQUEST_DISASSOCIATE:\n        opName = \"DISASSOCIATE\";\n        break;\n    default:\n        opName = \"(unknown)\";\n        break;\n    }\n    VIR_INFO(\"%s: ifname: %s ifindex: %d vf: %d vlanid: %d mac: %s \"\n             \"profileId: %s instanceId: %s hostUUID: %s\",\n             opName, ifname ? ifname : \"(unspecified)\",\n             ifindex, vf, vlanid,\n             macaddr ? virMacAddrFormat(macaddr, macStr) : \"(unspecified)\",\n             profileId ? profileId : \"(unspecified)\",\n             (instanceId\n              ? virUUIDFormat(instanceId, instanceUUIDStr)\n              : \"(unspecified)\"),\n             (hostUUID\n              ? virUUIDFormat(hostUUID, hostUUIDStr)\n              : \"(unspecified)\"));\n\n    nl_msg = nlmsg_alloc_simple(RTM_SETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return rc;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname &&\n        nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (macaddr || vlanid >= 0) {\n        struct nlattr *vfinfolist, *vfinfo;\n\n        if (!(vfinfolist = nla_nest_start(nl_msg, IFLA_VFINFO_LIST)))\n            goto buffer_too_small;\n\n        if (!(vfinfo = nla_nest_start(nl_msg, IFLA_VF_INFO)))\n            goto buffer_too_small;\n\n        if (macaddr) {\n            struct ifla_vf_mac ifla_vf_mac = {\n                .vf = vf,\n                .mac = { 0, },\n            };\n\n            virMacAddrGetRaw(macaddr, ifla_vf_mac.mac);\n\n            if (nla_put(nl_msg, IFLA_VF_MAC, sizeof(ifla_vf_mac),\n                        &ifla_vf_mac) < 0)\n                goto buffer_too_small;\n        }\n\n        if (vlanid >= 0) {\n            struct ifla_vf_vlan ifla_vf_vlan = {\n                .vf = vf,\n                .vlan = vlanid,\n                .qos = 0,\n            };\n\n            if (nla_put(nl_msg, IFLA_VF_VLAN, sizeof(ifla_vf_vlan),\n                        &ifla_vf_vlan) < 0)\n                goto buffer_too_small;\n        }\n\n        nla_nest_end(nl_msg, vfinfo);\n        nla_nest_end(nl_msg, vfinfolist);\n    }\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_PORT_SELF)))\n            goto buffer_too_small;\n    } else {\n        if (!(vfports = nla_nest_start(nl_msg, IFLA_VF_PORTS)))\n            goto buffer_too_small;\n\n        /* begin nesting vfports */\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_VF_PORT)))\n            goto buffer_too_small;\n    }\n\n    if (profileId) {\n        if (nla_put(nl_msg, IFLA_PORT_PROFILE, strlen(profileId) + 1,\n                    profileId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (portVsi) {\n        if (nla_put(nl_msg, IFLA_PORT_VSI_TYPE, sizeof(*portVsi),\n                    portVsi) < 0)\n            goto buffer_too_small;\n    }\n\n    if (instanceId) {\n        if (nla_put(nl_msg, IFLA_PORT_INSTANCE_UUID, VIR_UUID_BUFLEN,\n                    instanceId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (hostUUID) {\n        if (nla_put(nl_msg, IFLA_PORT_HOST_UUID, VIR_UUID_BUFLEN,\n                    hostUUID) < 0)\n            goto buffer_too_small;\n    }\n\n    if (vf != PORT_SELF_VF) {\n        if (nla_put(nl_msg, IFLA_PORT_VF, sizeof(vf), &vf) < 0)\n            goto buffer_too_small;\n    }\n\n    if (nla_put(nl_msg, IFLA_PORT_REQUEST, sizeof(op), &op) < 0)\n        goto buffer_too_small;\n\n    /* end nesting of vport */\n    nla_nest_end(nl_msg, vfport);\n\n    if (vfports) {\n        /* end nesting of vfports */\n        nla_nest_end(nl_msg, vfports);\n    }\n\n    if (!nltarget_kernel) {\n        if ((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0)\n            goto cleanup;\n        if ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0)\n            goto cleanup;\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        goto cleanup;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error during virtual port configuration of ifindex %d\"),\n                                 ifindex);\n            goto cleanup;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    rc = 0;\n cleanup:\n    nlmsg_free(nl_msg);\n    VIR_FREE(resp);\n    return rc;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    goto cleanup;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    goto cleanup;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"allocated netlink buffer is too small\")"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"allocated netlink buffer is too small\""
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"malformed netlink response message\")"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "resp"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "nl_msg"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "-err->error",
            "_(\"error during virtual port configuration of ifindex %d\")",
            "ifindex"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "sizeof(*err)"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_DATA",
          "args": [
            "resp"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NLMSG_LENGTH",
          "args": [
            "0"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetlinkCommand",
          "args": [
            "nl_msg",
            "&resp",
            "&recvbuflen",
            "src_pid",
            "dst_pid",
            "NETLINK_ROUTE",
            "0"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkCommand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1236-1246",
          "snippet": "int virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkCommand(struct nl_msg *nl_msg G_GNUC_UNUSED,\n                      struct nlmsghdr **resp G_GNUC_UNUSED,\n                      unsigned int *respbuflen G_GNUC_UNUSED,\n                      uint32_t src_pid G_GNUC_UNUSED,\n                      uint32_t dst_pid G_GNUC_UNUSED,\n                      unsigned int protocol G_GNUC_UNUSED,\n                      unsigned int groups G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileGetLldpadPid",
          "args": [],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileGetLldpadPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "468-499",
          "snippet": "static uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetlinkEventServiceLocalPid",
          "args": [
            "NETLINK_ROUTE"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "virNetlinkEventServiceLocalPid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetlink.c",
          "lines": "1346-1350",
          "snippet": "int virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virnetlink.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virmacaddr.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virnetdev.h\"\n#include \"virnetlink.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetlinkEventServiceLocalPid(unsigned int protocol G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_nest_end",
          "args": [
            "nl_msg",
            "vfports"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_end",
          "args": [
            "nl_msg",
            "vfport"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_REQUEST",
            "sizeof(op)",
            "&op"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_VF",
            "sizeof(vf)",
            "&vf"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_HOST_UUID",
            "VIR_UUID_BUFLEN",
            "hostUUID"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_INSTANCE_UUID",
            "VIR_UUID_BUFLEN",
            "instanceId"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_VSI_TYPE",
            "sizeof(*portVsi)",
            "portVsi"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_PORT_PROFILE",
            "strlen(profileId) + 1",
            "profileId"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "profileId"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "nl_msg",
            "IFLA_VF_PORT"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "nl_msg",
            "IFLA_VF_PORTS"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "nl_msg",
            "IFLA_PORT_SELF"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_end",
          "args": [
            "nl_msg",
            "vfinfolist"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_end",
          "args": [
            "nl_msg",
            "vfinfo"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_VF_VLAN",
            "sizeof(ifla_vf_vlan)",
            "&ifla_vf_vlan"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_VF_MAC",
            "sizeof(ifla_vf_mac)",
            "&ifla_vf_mac"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMacAddrGetRaw",
          "args": [
            "macaddr",
            "ifla_vf_mac.mac"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrGetRaw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "126-130",
          "snippet": "void\nvirMacAddrGetRaw(const virMacAddr *src, unsigned char dst[VIR_MAC_BUFLEN])\n{\n    memcpy(dst, src->addr, VIR_MAC_BUFLEN);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nvoid\nvirMacAddrGetRaw(const virMacAddr *src, unsigned char dst[VIR_MAC_BUFLEN])\n{\n    memcpy(dst, src->addr, VIR_MAC_BUFLEN);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "nl_msg",
            "IFLA_VF_INFO"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "nl_msg",
            "IFLA_VFINFO_LIST"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "nl_msg",
            "IFLA_IFNAME",
            "strlen(ifname)+1",
            "ifname"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ifname"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_append",
          "args": [
            "nl_msg",
            "&ifinfo",
            "sizeof(ifinfo)",
            "NLMSG_ALIGNTO"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_alloc_simple",
          "args": [
            "RTM_SETLINK",
            "NLM_F_REQUEST"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_INFO",
          "args": [
            "\"%s: ifname: %s ifindex: %d vf: %d vlanid: %d mac: %s \"\n             \"profileId: %s instanceId: %s hostUUID: %s\"",
            "opName",
            "ifname ? ifname : \"(unspecified)\"",
            "ifindex",
            "vf",
            "vlanid",
            "macaddr ? virMacAddrFormat(macaddr, macStr) : \"(unspecified)\"",
            "profileId ? profileId : \"(unspecified)\"",
            "(instanceId\n              ? virUUIDFormat(instanceId, instanceUUIDStr)\n              : \"(unspecified)\")",
            "(hostUUID\n              ? virUUIDFormat(hostUUID, hostUUIDStr)\n              : \"(unspecified)\")"
          ],
          "line": 686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "hostUUID",
            "hostUUIDStr"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virMacAddrFormat",
          "args": [
            "macaddr",
            "macStr"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "virMacAddrFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmacaddr.c",
          "lines": "184-194",
          "snippet": "const char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virrandom.h\"",
            "#include \"virmacaddr.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virrandom.h\"\n#include \"virmacaddr.h\"\n#include <config.h>\n\nconst char *\nvirMacAddrFormat(const virMacAddr *addr,\n                 char *str)\n{\n    g_snprintf(str, VIR_MAC_STRING_BUFLEN,\n               \"%02x:%02x:%02x:%02x:%02x:%02x\",\n               addr->addr[0], addr->addr[1], addr->addr[2],\n               addr->addr[3], addr->addr[4], addr->addr[5]);\n    str[VIR_MAC_STRING_BUFLEN-1] = '\\0';\n    return str;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileOpSetLink(const char *ifname, int ifindex,\n                               bool nltarget_kernel,\n                               const virMacAddr *macaddr,\n                               int vlanid,\n                               const char *profileId,\n                               struct ifla_port_vsi *portVsi,\n                               const unsigned char *instanceId,\n                               const unsigned char *hostUUID,\n                               int32_t vf,\n                               uint8_t op)\n{\n    int rc = -1;\n    struct nlmsghdr *resp = NULL;\n    struct nlmsgerr *err;\n    struct ifinfomsg ifinfo = {\n        .ifi_family = AF_UNSPEC,\n        .ifi_index  = ifindex,\n    };\n    unsigned int recvbuflen = 0;\n    int src_pid = 0;\n    uint32_t dst_pid = 0;\n    struct nl_msg *nl_msg;\n    struct nlattr *vfports = NULL, *vfport;\n    char macStr[VIR_MAC_STRING_BUFLEN];\n    char hostUUIDStr[VIR_UUID_STRING_BUFLEN];\n    char instanceUUIDStr[VIR_UUID_STRING_BUFLEN];\n    const char *opName;\n\n    switch (op) {\n    case PORT_REQUEST_PREASSOCIATE:\n        opName = \"PREASSOCIATE\";\n        break;\n    case PORT_REQUEST_PREASSOCIATE_RR:\n        opName = \"PREASSOCIATE_RR\";\n        break;\n    case PORT_REQUEST_ASSOCIATE:\n        opName = \"ASSOCIATE\";\n        break;\n    case PORT_REQUEST_DISASSOCIATE:\n        opName = \"DISASSOCIATE\";\n        break;\n    default:\n        opName = \"(unknown)\";\n        break;\n    }\n    VIR_INFO(\"%s: ifname: %s ifindex: %d vf: %d vlanid: %d mac: %s \"\n             \"profileId: %s instanceId: %s hostUUID: %s\",\n             opName, ifname ? ifname : \"(unspecified)\",\n             ifindex, vf, vlanid,\n             macaddr ? virMacAddrFormat(macaddr, macStr) : \"(unspecified)\",\n             profileId ? profileId : \"(unspecified)\",\n             (instanceId\n              ? virUUIDFormat(instanceId, instanceUUIDStr)\n              : \"(unspecified)\"),\n             (hostUUID\n              ? virUUIDFormat(hostUUID, hostUUIDStr)\n              : \"(unspecified)\"));\n\n    nl_msg = nlmsg_alloc_simple(RTM_SETLINK, NLM_F_REQUEST);\n    if (!nl_msg) {\n        virReportOOMError();\n        return rc;\n    }\n\n    if (nlmsg_append(nl_msg,  &ifinfo, sizeof(ifinfo), NLMSG_ALIGNTO) < 0)\n        goto buffer_too_small;\n\n    if (ifname &&\n        nla_put(nl_msg, IFLA_IFNAME, strlen(ifname)+1, ifname) < 0)\n        goto buffer_too_small;\n\n    if (macaddr || vlanid >= 0) {\n        struct nlattr *vfinfolist, *vfinfo;\n\n        if (!(vfinfolist = nla_nest_start(nl_msg, IFLA_VFINFO_LIST)))\n            goto buffer_too_small;\n\n        if (!(vfinfo = nla_nest_start(nl_msg, IFLA_VF_INFO)))\n            goto buffer_too_small;\n\n        if (macaddr) {\n            struct ifla_vf_mac ifla_vf_mac = {\n                .vf = vf,\n                .mac = { 0, },\n            };\n\n            virMacAddrGetRaw(macaddr, ifla_vf_mac.mac);\n\n            if (nla_put(nl_msg, IFLA_VF_MAC, sizeof(ifla_vf_mac),\n                        &ifla_vf_mac) < 0)\n                goto buffer_too_small;\n        }\n\n        if (vlanid >= 0) {\n            struct ifla_vf_vlan ifla_vf_vlan = {\n                .vf = vf,\n                .vlan = vlanid,\n                .qos = 0,\n            };\n\n            if (nla_put(nl_msg, IFLA_VF_VLAN, sizeof(ifla_vf_vlan),\n                        &ifla_vf_vlan) < 0)\n                goto buffer_too_small;\n        }\n\n        nla_nest_end(nl_msg, vfinfo);\n        nla_nest_end(nl_msg, vfinfolist);\n    }\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_PORT_SELF)))\n            goto buffer_too_small;\n    } else {\n        if (!(vfports = nla_nest_start(nl_msg, IFLA_VF_PORTS)))\n            goto buffer_too_small;\n\n        /* begin nesting vfports */\n        if (!(vfport = nla_nest_start(nl_msg, IFLA_VF_PORT)))\n            goto buffer_too_small;\n    }\n\n    if (profileId) {\n        if (nla_put(nl_msg, IFLA_PORT_PROFILE, strlen(profileId) + 1,\n                    profileId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (portVsi) {\n        if (nla_put(nl_msg, IFLA_PORT_VSI_TYPE, sizeof(*portVsi),\n                    portVsi) < 0)\n            goto buffer_too_small;\n    }\n\n    if (instanceId) {\n        if (nla_put(nl_msg, IFLA_PORT_INSTANCE_UUID, VIR_UUID_BUFLEN,\n                    instanceId) < 0)\n            goto buffer_too_small;\n    }\n\n    if (hostUUID) {\n        if (nla_put(nl_msg, IFLA_PORT_HOST_UUID, VIR_UUID_BUFLEN,\n                    hostUUID) < 0)\n            goto buffer_too_small;\n    }\n\n    if (vf != PORT_SELF_VF) {\n        if (nla_put(nl_msg, IFLA_PORT_VF, sizeof(vf), &vf) < 0)\n            goto buffer_too_small;\n    }\n\n    if (nla_put(nl_msg, IFLA_PORT_REQUEST, sizeof(op), &op) < 0)\n        goto buffer_too_small;\n\n    /* end nesting of vport */\n    nla_nest_end(nl_msg, vfport);\n\n    if (vfports) {\n        /* end nesting of vfports */\n        nla_nest_end(nl_msg, vfports);\n    }\n\n    if (!nltarget_kernel) {\n        if ((src_pid = virNetlinkEventServiceLocalPid(NETLINK_ROUTE)) < 0)\n            goto cleanup;\n        if ((dst_pid = virNetDevVPortProfileGetLldpadPid()) == 0)\n            goto cleanup;\n    }\n\n    if (virNetlinkCommand(nl_msg, &resp, &recvbuflen,\n                          src_pid, dst_pid, NETLINK_ROUTE, 0) < 0)\n        goto cleanup;\n\n    if (recvbuflen < NLMSG_LENGTH(0) || resp == NULL)\n        goto malformed_resp;\n\n    switch (resp->nlmsg_type) {\n    case NLMSG_ERROR:\n        err = (struct nlmsgerr *)NLMSG_DATA(resp);\n        if (resp->nlmsg_len < NLMSG_LENGTH(sizeof(*err)))\n            goto malformed_resp;\n\n        if (err->error) {\n            virReportSystemError(-err->error,\n                                 _(\"error during virtual port configuration of ifindex %d\"),\n                                 ifindex);\n            goto cleanup;\n        }\n        break;\n\n    case NLMSG_DONE:\n        break;\n\n    default:\n        goto malformed_resp;\n    }\n\n    rc = 0;\n cleanup:\n    nlmsg_free(nl_msg);\n    VIR_FREE(resp);\n    return rc;\n\n malformed_resp:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"malformed netlink response message\"));\n    goto cleanup;\n\n buffer_too_small:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"allocated netlink buffer is too small\"));\n    goto cleanup;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileGetStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "513-637",
    "snippet": "static int\nvirNetDevVPortProfileGetStatus(struct nlattr **tb, int32_t vf,\n                               const unsigned char *instanceId,\n                               bool nltarget_kernel,\n                               bool is8021Qbg,\n                               uint16_t *status)\n{\n    struct nlattr *tb_port[IFLA_PORT_MAX + 1] = { NULL, };\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (tb[IFLA_PORT_SELF]) {\n            if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb[IFLA_PORT_SELF],\n                                 ifla_port_policy)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing IFLA_PORT_SELF part\"));\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_PORT_SELF is missing\"));\n            return -1;\n        }\n    } else {\n        if (tb[IFLA_VF_PORTS]) {\n            int rem;\n            bool found = false;\n            struct nlattr *tb_vf_ports = { NULL, };\n\n            nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n\n                if (nla_type(tb_vf_ports) != IFLA_VF_PORT) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error while iterating over \"\n                                     \"IFLA_VF_PORTS part\"));\n                    return -1;\n                }\n\n                if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                     ifla_port_policy)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error parsing IFLA_VF_PORT part\"));\n                    return -1;\n                }\n\n                /* This ensures that the given VF is present in the\n                 * IFLA_VF_PORTS list, and that its uuid matches the\n                 * instanceId (in case we've associated it). If no\n                 * instanceId is sent from the caller, that means we've\n                 * disassociated it from this instanceId, and the uuid\n                 * will either be unset (if still not associated with\n                 * anything) or will be set to a new and different uuid\n                 */\n                if ((tb_port[IFLA_PORT_VF] &&\n                     vf == *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF])) &&\n                    (!instanceId ||\n                     (tb_port[IFLA_PORT_INSTANCE_UUID] &&\n                      !memcmp(instanceId,\n                              (unsigned char *)\n                              RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                              VIR_UUID_BUFLEN)))) {\n                        found = true;\n                        break;\n                }\n            }\n\n            if (!found) {\n                char instanceIdStr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                if (instanceId)\n                   virUUIDFormat(instanceId, instanceIdStr);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find vf/instanceId %u/%s \"\n                                 \" in netlink response\"),\n                               vf, instanceIdStr);\n\n                /* go through all the entries again. This seems tedious,\n                 * but experience has shown the resulting log to be\n                 * very useful.\n                 */\n                VIR_WARN(\"IFLA_VF_PORTS entries that were returned:\");\n                nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n                    char uuidstr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                    if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                         ifla_port_policy)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"error parsing IFLA_VF_PORT \"\n                                         \"during error reporting\"));\n                        return -1;\n                    }\n                    if (tb_port[IFLA_PORT_INSTANCE_UUID]) {\n                        virUUIDFormat((unsigned char *)\n                                      RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                                      uuidstr);\n                    }\n                    VIR_WARN(\"  vf: %d uuid: %s\",\n                             tb_port[IFLA_PORT_VF] ?\n                             *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF]) : -1,\n                             uuidstr);\n                }\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_VF_PORTS is missing\"));\n            return -1;\n        }\n    }\n\n    if (tb_port[IFLA_PORT_RESPONSE]) {\n        *status = *(uint16_t *)RTA_DATA(tb_port[IFLA_PORT_RESPONSE]);\n    } else {\n        if (is8021Qbg) {\n            /* no in-progress here; may be missing */\n            *status = PORT_PROFILE_RESPONSE_INPROGRESS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no IFLA_PORT_RESPONSE found in netlink message\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no IFLA_PORT_RESPONSE found in netlink message\")"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no IFLA_PORT_RESPONSE found in netlink message\""
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb_port[IFLA_PORT_RESPONSE]"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"IFLA_VF_PORTS is missing\")"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"  vf: %d uuid: %s\"",
            "tb_port[IFLA_PORT_VF] ?\n                             *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF]) : -1",
            "uuidstr"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb_port[IFLA_PORT_VF]"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "(unsigned char *)\n                                      RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID])",
            "uuidstr"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb_port[IFLA_PORT_INSTANCE_UUID]"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error parsing IFLA_VF_PORT \"\n                                         \"during error reporting\")"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_parse_nested",
          "args": [
            "tb_port",
            "IFLA_PORT_MAX",
            "tb_vf_ports",
            "ifla_port_policy"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_for_each_nested",
          "args": [
            "tb_vf_ports",
            "tb[IFLA_VF_PORTS]",
            "rem"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"IFLA_VF_PORTS entries that were returned:\""
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find vf/instanceId %u/%s \"\n                                 \" in netlink response\")",
            "vf",
            "instanceIdStr"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "instanceId",
            "(unsigned char *)\n                              RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID])",
            "VIR_UUID_BUFLEN"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb_port[IFLA_PORT_INSTANCE_UUID]"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RTA_DATA",
          "args": [
            "tb_port[IFLA_PORT_VF]"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error parsing IFLA_VF_PORT part\")"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_parse_nested",
          "args": [
            "tb_port",
            "IFLA_PORT_MAX",
            "tb_vf_ports",
            "ifla_port_policy"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error while iterating over \"\n                                     \"IFLA_VF_PORTS part\")"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_type",
          "args": [
            "tb_vf_ports"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_for_each_nested",
          "args": [
            "tb_vf_ports",
            "tb[IFLA_VF_PORTS]",
            "rem"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"IFLA_PORT_SELF is missing\")"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error parsing IFLA_PORT_SELF part\")"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_parse_nested",
          "args": [
            "tb_port",
            "IFLA_PORT_MAX",
            "tb[IFLA_PORT_SELF]",
            "ifla_port_policy"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileGetStatus(struct nlattr **tb, int32_t vf,\n                               const unsigned char *instanceId,\n                               bool nltarget_kernel,\n                               bool is8021Qbg,\n                               uint16_t *status)\n{\n    struct nlattr *tb_port[IFLA_PORT_MAX + 1] = { NULL, };\n\n    if (vf == PORT_SELF_VF && nltarget_kernel) {\n        if (tb[IFLA_PORT_SELF]) {\n            if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb[IFLA_PORT_SELF],\n                                 ifla_port_policy)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing IFLA_PORT_SELF part\"));\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_PORT_SELF is missing\"));\n            return -1;\n        }\n    } else {\n        if (tb[IFLA_VF_PORTS]) {\n            int rem;\n            bool found = false;\n            struct nlattr *tb_vf_ports = { NULL, };\n\n            nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n\n                if (nla_type(tb_vf_ports) != IFLA_VF_PORT) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error while iterating over \"\n                                     \"IFLA_VF_PORTS part\"));\n                    return -1;\n                }\n\n                if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                     ifla_port_policy)) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"error parsing IFLA_VF_PORT part\"));\n                    return -1;\n                }\n\n                /* This ensures that the given VF is present in the\n                 * IFLA_VF_PORTS list, and that its uuid matches the\n                 * instanceId (in case we've associated it). If no\n                 * instanceId is sent from the caller, that means we've\n                 * disassociated it from this instanceId, and the uuid\n                 * will either be unset (if still not associated with\n                 * anything) or will be set to a new and different uuid\n                 */\n                if ((tb_port[IFLA_PORT_VF] &&\n                     vf == *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF])) &&\n                    (!instanceId ||\n                     (tb_port[IFLA_PORT_INSTANCE_UUID] &&\n                      !memcmp(instanceId,\n                              (unsigned char *)\n                              RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                              VIR_UUID_BUFLEN)))) {\n                        found = true;\n                        break;\n                }\n            }\n\n            if (!found) {\n                char instanceIdStr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                if (instanceId)\n                   virUUIDFormat(instanceId, instanceIdStr);\n\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find vf/instanceId %u/%s \"\n                                 \" in netlink response\"),\n                               vf, instanceIdStr);\n\n                /* go through all the entries again. This seems tedious,\n                 * but experience has shown the resulting log to be\n                 * very useful.\n                 */\n                VIR_WARN(\"IFLA_VF_PORTS entries that were returned:\");\n                nla_for_each_nested(tb_vf_ports, tb[IFLA_VF_PORTS], rem) {\n                    char uuidstr[VIR_UUID_STRING_BUFLEN] = \"(none)\";\n\n                    if (nla_parse_nested(tb_port, IFLA_PORT_MAX, tb_vf_ports,\n                                         ifla_port_policy)) {\n                        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                       _(\"error parsing IFLA_VF_PORT \"\n                                         \"during error reporting\"));\n                        return -1;\n                    }\n                    if (tb_port[IFLA_PORT_INSTANCE_UUID]) {\n                        virUUIDFormat((unsigned char *)\n                                      RTA_DATA(tb_port[IFLA_PORT_INSTANCE_UUID]),\n                                      uuidstr);\n                    }\n                    VIR_WARN(\"  vf: %d uuid: %s\",\n                             tb_port[IFLA_PORT_VF] ?\n                             *(uint32_t *)RTA_DATA(tb_port[IFLA_PORT_VF]) : -1,\n                             uuidstr);\n                }\n                return -1;\n            }\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"IFLA_VF_PORTS is missing\"));\n            return -1;\n        }\n    }\n\n    if (tb_port[IFLA_PORT_RESPONSE]) {\n        *status = *(uint16_t *)RTA_DATA(tb_port[IFLA_PORT_RESPONSE]);\n    } else {\n        if (is8021Qbg) {\n            /* no in-progress here; may be missing */\n            *status = PORT_PROFILE_RESPONSE_INPROGRESS;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no IFLA_PORT_RESPONSE found in netlink message\"));\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileGetLldpadPid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "468-499",
    "snippet": "static uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Error opening file %s\")",
            "LLDPAD_PID_FILE"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Error opening file %s\""
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"error parsing pid of lldpad\")"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_isspace",
          "args": [
            "*endptr"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "buffer",
            "&endptr",
            "10",
            "&res"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "fd",
            "buffer",
            "sizeof(buffer)"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "LLDPAD_PID_FILE",
            "O_RDONLY"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic uint32_t\nvirNetDevVPortProfileGetLldpadPid(void)\n{\n    int fd;\n    uint32_t pid = 0;\n\n    fd = open(LLDPAD_PID_FILE, O_RDONLY);\n    if (fd >= 0) {\n        char buffer[10];\n\n        if (saferead(fd, buffer, sizeof(buffer)) <= sizeof(buffer)) {\n            unsigned int res;\n            char *endptr;\n\n            if (virStrToLong_ui(buffer, &endptr, 10, &res) == 0\n                && (*endptr == '\\0' || g_ascii_isspace(*endptr))\n                && res != 0) {\n                pid = res;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"error parsing pid of lldpad\"));\n            }\n        }\n    } else {\n        virReportSystemError(errno,\n                             _(\"Error opening file %s\"), LLDPAD_PID_FILE);\n    }\n\n    VIR_FORCE_CLOSE(fd);\n\n    return pid;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileMerge3",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "423-458",
    "snippet": "int virNetDevVPortProfileMerge3(virNetDevVPortProfilePtr *result,\n                                const virNetDevVPortProfile *fromInterface,\n                                const virNetDevVPortProfile *fromNetwork,\n                                const virNetDevVPortProfile *fromPortgroup)\n{\n    int ret = -1;\n    *result = NULL;\n\n    if ((!fromInterface || (fromInterface->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromNetwork   || (fromNetwork->virtPortType   == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromPortgroup || (fromPortgroup->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE))) {\n        return 0;\n    }\n\n    /* at least one of the source profiles is non-empty */\n    if (VIR_ALLOC(*result) < 0)\n        return ret;\n\n    /* start with the interface's profile. There are no pointers in a\n     * virtualPortProfile, so a shallow copy is sufficient.\n     */\n    if (fromInterface)\n        **result = *fromInterface;\n\n    if (virNetDevVPortProfileMerge(*result, fromNetwork) < 0)\n        goto error;\n    if (virNetDevVPortProfileMerge(*result, fromPortgroup) < 0)\n        goto error;\n\n    ret = 0;\n\n error:\n    if (ret < 0)\n        VIR_FREE(*result);\n    return ret;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*result"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortProfileMerge",
          "args": [
            "*result",
            "fromPortgroup"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevVPortProfileMerge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
          "lines": "282-412",
          "snippet": "static int\nvirNetDevVPortProfileMerge(virNetDevVPortProfilePtr orig,\n                           const virNetDevVPortProfile *mods)\n{\n    enum virNetDevVPortProfile otype;\n\n    if (!orig || !mods)\n        return 0;\n\n    otype = orig->virtPortType;\n\n    if (mods->virtPortType != VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (otype != VIR_NETDEV_VPORT_PROFILE_NONE &&\n            otype != mods->virtPortType) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched types (%s and %s)\"),\n                           virNetDevVPortTypeToString(otype),\n                           virNetDevVPortTypeToString(mods->virtPortType));\n            return -1;\n        }\n        otype = orig->virtPortType = mods->virtPortType;\n    }\n\n    if (mods->managerID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->managerID_specified &&\n            (orig->managerID != mods->managerID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched managerids (%d and %d)\"),\n                           orig->managerID, mods->managerID);\n            return -1;\n        }\n        orig->managerID = mods->managerID;\n        orig->managerID_specified = true;\n    }\n\n    if (mods->typeID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeID_specified &&\n            (orig->typeID != mods->typeID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched typeids (%d and %d)\"),\n                           orig->typeID, mods->typeID);\n            return -1;\n        }\n        orig->typeID = mods->typeID;\n        orig->typeID_specified = true;\n    }\n\n    if (mods->typeIDVersion_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeIDVersion_specified &&\n            (orig->typeIDVersion != mods->typeIDVersion)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched typeidversions (%d and %d)\"),\n                           orig->typeIDVersion, mods->typeIDVersion);\n            return -1;\n        }\n        orig->typeIDVersion = mods->typeIDVersion;\n        orig->typeIDVersion_specified = true;\n    }\n\n    if (mods->instanceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->instanceID_specified &&\n            memcmp(orig->instanceID, mods->instanceID,\n                   sizeof(orig->instanceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched instanceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->instanceID, origuuid),\n                           virUUIDFormat(mods->instanceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->instanceID, mods->instanceID, sizeof(orig->instanceID));\n        orig->instanceID_specified = true;\n    }\n\n    if (mods->interfaceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->interfaceID_specified &&\n            memcmp(orig->interfaceID, mods->interfaceID,\n                   sizeof(orig->interfaceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched interfaceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->interfaceID, origuuid),\n                           virUUIDFormat(mods->interfaceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->interfaceID, mods->interfaceID, sizeof(orig->interfaceID));\n        orig->interfaceID_specified = true;\n    }\n\n    if (mods->profileID[0] &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->profileID[0] &&\n            STRNEQ(orig->profileID, mods->profileID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched profileids ('%s' and '%s')\"),\n                           orig->profileID, mods->profileID);\n            return -1;\n        }\n        if (virStrcpyStatic(orig->profileID, mods->profileID) < 0) {\n            /* this should never happen - it indicates mods->profileID\n             * isn't properly null terminated. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"corrupted profileid string\"));\n            return -1;\n        }\n    }\n    return 0;\n}",
          "includes": [
            "# include \"virsocket.h\"",
            "# include \"virnetdev.h\"",
            "# include \"virlog.h\"",
            "# include \"virfile.h\"",
            "# include \"virnetlink.h\"",
            "# include <linux/if_tun.h>",
            "# include <net/if.h>",
            "# include <fcntl.h>",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"virnetdevvportprofile.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileMerge(virNetDevVPortProfilePtr orig,\n                           const virNetDevVPortProfile *mods)\n{\n    enum virNetDevVPortProfile otype;\n\n    if (!orig || !mods)\n        return 0;\n\n    otype = orig->virtPortType;\n\n    if (mods->virtPortType != VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (otype != VIR_NETDEV_VPORT_PROFILE_NONE &&\n            otype != mods->virtPortType) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched types (%s and %s)\"),\n                           virNetDevVPortTypeToString(otype),\n                           virNetDevVPortTypeToString(mods->virtPortType));\n            return -1;\n        }\n        otype = orig->virtPortType = mods->virtPortType;\n    }\n\n    if (mods->managerID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->managerID_specified &&\n            (orig->managerID != mods->managerID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched managerids (%d and %d)\"),\n                           orig->managerID, mods->managerID);\n            return -1;\n        }\n        orig->managerID = mods->managerID;\n        orig->managerID_specified = true;\n    }\n\n    if (mods->typeID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeID_specified &&\n            (orig->typeID != mods->typeID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched typeids (%d and %d)\"),\n                           orig->typeID, mods->typeID);\n            return -1;\n        }\n        orig->typeID = mods->typeID;\n        orig->typeID_specified = true;\n    }\n\n    if (mods->typeIDVersion_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeIDVersion_specified &&\n            (orig->typeIDVersion != mods->typeIDVersion)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched typeidversions (%d and %d)\"),\n                           orig->typeIDVersion, mods->typeIDVersion);\n            return -1;\n        }\n        orig->typeIDVersion = mods->typeIDVersion;\n        orig->typeIDVersion_specified = true;\n    }\n\n    if (mods->instanceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->instanceID_specified &&\n            memcmp(orig->instanceID, mods->instanceID,\n                   sizeof(orig->instanceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched instanceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->instanceID, origuuid),\n                           virUUIDFormat(mods->instanceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->instanceID, mods->instanceID, sizeof(orig->instanceID));\n        orig->instanceID_specified = true;\n    }\n\n    if (mods->interfaceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->interfaceID_specified &&\n            memcmp(orig->interfaceID, mods->interfaceID,\n                   sizeof(orig->interfaceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched interfaceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->interfaceID, origuuid),\n                           virUUIDFormat(mods->interfaceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->interfaceID, mods->interfaceID, sizeof(orig->interfaceID));\n        orig->interfaceID_specified = true;\n    }\n\n    if (mods->profileID[0] &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->profileID[0] &&\n            STRNEQ(orig->profileID, mods->profileID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched profileids ('%s' and '%s')\"),\n                           orig->profileID, mods->profileID);\n            return -1;\n        }\n        if (virStrcpyStatic(orig->profileID, mods->profileID) < 0) {\n            /* this should never happen - it indicates mods->profileID\n             * isn't properly null terminated. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"corrupted profileid string\"));\n            return -1;\n        }\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*result"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileMerge3(virNetDevVPortProfilePtr *result,\n                                const virNetDevVPortProfile *fromInterface,\n                                const virNetDevVPortProfile *fromNetwork,\n                                const virNetDevVPortProfile *fromPortgroup)\n{\n    int ret = -1;\n    *result = NULL;\n\n    if ((!fromInterface || (fromInterface->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromNetwork   || (fromNetwork->virtPortType   == VIR_NETDEV_VPORT_PROFILE_NONE)) &&\n        (!fromPortgroup || (fromPortgroup->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE))) {\n        return 0;\n    }\n\n    /* at least one of the source profiles is non-empty */\n    if (VIR_ALLOC(*result) < 0)\n        return ret;\n\n    /* start with the interface's profile. There are no pointers in a\n     * virtualPortProfile, so a shallow copy is sufficient.\n     */\n    if (fromInterface)\n        **result = *fromInterface;\n\n    if (virNetDevVPortProfileMerge(*result, fromNetwork) < 0)\n        goto error;\n    if (virNetDevVPortProfileMerge(*result, fromPortgroup) < 0)\n        goto error;\n\n    ret = 0;\n\n error:\n    if (ret < 0)\n        VIR_FREE(*result);\n    return ret;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileMerge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "282-412",
    "snippet": "static int\nvirNetDevVPortProfileMerge(virNetDevVPortProfilePtr orig,\n                           const virNetDevVPortProfile *mods)\n{\n    enum virNetDevVPortProfile otype;\n\n    if (!orig || !mods)\n        return 0;\n\n    otype = orig->virtPortType;\n\n    if (mods->virtPortType != VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (otype != VIR_NETDEV_VPORT_PROFILE_NONE &&\n            otype != mods->virtPortType) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched types (%s and %s)\"),\n                           virNetDevVPortTypeToString(otype),\n                           virNetDevVPortTypeToString(mods->virtPortType));\n            return -1;\n        }\n        otype = orig->virtPortType = mods->virtPortType;\n    }\n\n    if (mods->managerID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->managerID_specified &&\n            (orig->managerID != mods->managerID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched managerids (%d and %d)\"),\n                           orig->managerID, mods->managerID);\n            return -1;\n        }\n        orig->managerID = mods->managerID;\n        orig->managerID_specified = true;\n    }\n\n    if (mods->typeID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeID_specified &&\n            (orig->typeID != mods->typeID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched typeids (%d and %d)\"),\n                           orig->typeID, mods->typeID);\n            return -1;\n        }\n        orig->typeID = mods->typeID;\n        orig->typeID_specified = true;\n    }\n\n    if (mods->typeIDVersion_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeIDVersion_specified &&\n            (orig->typeIDVersion != mods->typeIDVersion)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched typeidversions (%d and %d)\"),\n                           orig->typeIDVersion, mods->typeIDVersion);\n            return -1;\n        }\n        orig->typeIDVersion = mods->typeIDVersion;\n        orig->typeIDVersion_specified = true;\n    }\n\n    if (mods->instanceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->instanceID_specified &&\n            memcmp(orig->instanceID, mods->instanceID,\n                   sizeof(orig->instanceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched instanceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->instanceID, origuuid),\n                           virUUIDFormat(mods->instanceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->instanceID, mods->instanceID, sizeof(orig->instanceID));\n        orig->instanceID_specified = true;\n    }\n\n    if (mods->interfaceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->interfaceID_specified &&\n            memcmp(orig->interfaceID, mods->interfaceID,\n                   sizeof(orig->interfaceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched interfaceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->interfaceID, origuuid),\n                           virUUIDFormat(mods->interfaceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->interfaceID, mods->interfaceID, sizeof(orig->interfaceID));\n        orig->interfaceID_specified = true;\n    }\n\n    if (mods->profileID[0] &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->profileID[0] &&\n            STRNEQ(orig->profileID, mods->profileID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched profileids ('%s' and '%s')\"),\n                           orig->profileID, mods->profileID);\n            return -1;\n        }\n        if (virStrcpyStatic(orig->profileID, mods->profileID) < 0) {\n            /* this should never happen - it indicates mods->profileID\n             * isn't properly null terminated. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"corrupted profileid string\"));\n            return -1;\n        }\n    }\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"corrupted profileid string\")"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"corrupted profileid string\""
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrcpyStatic",
          "args": [
            "orig->profileID",
            "mods->profileID"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports with \"\n                             \"mismatched profileids ('%s' and '%s')\")",
            "orig->profileID",
            "mods->profileID"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "orig->profileID",
            "mods->profileID"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "orig->interfaceID",
            "mods->interfaceID",
            "sizeof(orig->interfaceID)"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports with \"\n                             \"mismatched interfaceids ('%s' and '%s')\")",
            "virUUIDFormat(orig->interfaceID, origuuid)",
            "virUUIDFormat(mods->interfaceID, modsuuid)"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDFormat",
          "args": [
            "mods->interfaceID",
            "modsuuid"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "148-159",
          "snippet": "const char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nconst char *\nvirUUIDFormat(const unsigned char *uuid, char *uuidstr)\n{\n    g_snprintf(uuidstr, VIR_UUID_STRING_BUFLEN,\n               \"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x\",\n               uuid[0], uuid[1], uuid[2], uuid[3],\n               uuid[4], uuid[5], uuid[6], uuid[7],\n               uuid[8], uuid[9], uuid[10], uuid[11],\n               uuid[12], uuid[13], uuid[14], uuid[15]);\n    uuidstr[VIR_UUID_STRING_BUFLEN-1] = '\\0';\n    return uuidstr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "orig->interfaceID",
            "mods->interfaceID",
            "sizeof(orig->interfaceID)"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "orig->instanceID",
            "mods->instanceID",
            "sizeof(orig->instanceID)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports with \"\n                             \"mismatched instanceids ('%s' and '%s')\")",
            "virUUIDFormat(orig->instanceID, origuuid)",
            "virUUIDFormat(mods->instanceID, modsuuid)"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "orig->instanceID",
            "mods->instanceID",
            "sizeof(orig->instanceID)"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports with \"\n                             \"mismatched typeidversions (%d and %d)\")",
            "orig->typeIDVersion",
            "mods->typeIDVersion"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports \"\n                             \"with mismatched typeids (%d and %d)\")",
            "orig->typeID",
            "mods->typeID"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports \"\n                             \"with mismatched managerids (%d and %d)\")",
            "orig->managerID",
            "mods->managerID"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"attempt to merge virtualports \"\n                             \"with mismatched types (%s and %s)\")",
            "virNetDevVPortTypeToString(otype)",
            "virNetDevVPortTypeToString(mods->virtPortType)"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "mods->virtPortType"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "otype"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nstatic int\nvirNetDevVPortProfileMerge(virNetDevVPortProfilePtr orig,\n                           const virNetDevVPortProfile *mods)\n{\n    enum virNetDevVPortProfile otype;\n\n    if (!orig || !mods)\n        return 0;\n\n    otype = orig->virtPortType;\n\n    if (mods->virtPortType != VIR_NETDEV_VPORT_PROFILE_NONE) {\n        if (otype != VIR_NETDEV_VPORT_PROFILE_NONE &&\n            otype != mods->virtPortType) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched types (%s and %s)\"),\n                           virNetDevVPortTypeToString(otype),\n                           virNetDevVPortTypeToString(mods->virtPortType));\n            return -1;\n        }\n        otype = orig->virtPortType = mods->virtPortType;\n    }\n\n    if (mods->managerID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->managerID_specified &&\n            (orig->managerID != mods->managerID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched managerids (%d and %d)\"),\n                           orig->managerID, mods->managerID);\n            return -1;\n        }\n        orig->managerID = mods->managerID;\n        orig->managerID_specified = true;\n    }\n\n    if (mods->typeID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeID_specified &&\n            (orig->typeID != mods->typeID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports \"\n                             \"with mismatched typeids (%d and %d)\"),\n                           orig->typeID, mods->typeID);\n            return -1;\n        }\n        orig->typeID = mods->typeID;\n        orig->typeID_specified = true;\n    }\n\n    if (mods->typeIDVersion_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->typeIDVersion_specified &&\n            (orig->typeIDVersion != mods->typeIDVersion)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched typeidversions (%d and %d)\"),\n                           orig->typeIDVersion, mods->typeIDVersion);\n            return -1;\n        }\n        orig->typeIDVersion = mods->typeIDVersion;\n        orig->typeIDVersion_specified = true;\n    }\n\n    if (mods->instanceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_8021QBG ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->instanceID_specified &&\n            memcmp(orig->instanceID, mods->instanceID,\n                   sizeof(orig->instanceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched instanceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->instanceID, origuuid),\n                           virUUIDFormat(mods->instanceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->instanceID, mods->instanceID, sizeof(orig->instanceID));\n        orig->instanceID_specified = true;\n    }\n\n    if (mods->interfaceID_specified &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->interfaceID_specified &&\n            memcmp(orig->interfaceID, mods->interfaceID,\n                   sizeof(orig->interfaceID))) {\n            char origuuid[VIR_UUID_STRING_BUFLEN];\n            char modsuuid[VIR_UUID_STRING_BUFLEN];\n\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched interfaceids ('%s' and '%s')\"),\n                           virUUIDFormat(orig->interfaceID, origuuid),\n                           virUUIDFormat(mods->interfaceID, modsuuid));\n            return -1;\n        }\n        memcpy(orig->interfaceID, mods->interfaceID, sizeof(orig->interfaceID));\n        orig->interfaceID_specified = true;\n    }\n\n    if (mods->profileID[0] &&\n        (otype == VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_8021QBH ||\n         otype == VIR_NETDEV_VPORT_PROFILE_NONE)) {\n        if (orig->profileID[0] &&\n            STRNEQ(orig->profileID, mods->profileID)) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"attempt to merge virtualports with \"\n                             \"mismatched profileids ('%s' and '%s')\"),\n                           orig->profileID, mods->profileID);\n            return -1;\n        }\n        if (virStrcpyStatic(orig->profileID, mods->profileID) < 0) {\n            /* this should never happen - it indicates mods->profileID\n             * isn't properly null terminated. */\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"corrupted profileid string\"));\n            return -1;\n        }\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileCheckNoExtras",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "226-276",
    "snippet": "int\nvirNetDevVPortProfileCheckNoExtras(const virNetDevVPortProfile *virtport)\n{\n    const char *extra = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (virtport->profileID[0])\n            extra = \"profileid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        break;\n    }\n\n    if (extra) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"extra %s unsupported in <virtualport type='%s'>\"),\n                       extra,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"extra %s unsupported in <virtualport type='%s'>\")",
            "extra",
            "virNetDevVPortTypeToString(virtport->virtPortType)"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "virtport->virtPortType"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"extra %s unsupported in <virtualport type='%s'>\""
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileCheckNoExtras(const virNetDevVPortProfile *virtport)\n{\n    const char *extra = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (virtport->profileID[0])\n            extra = \"profileid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        else if (virtport->interfaceID_specified)\n            extra = \"interfaceid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (virtport->managerID_specified)\n            extra = \"managerid\";\n        else if (virtport->typeID_specified)\n            extra = \"typeid\";\n        else if (virtport->typeIDVersion_specified)\n            extra = \"typeidversion\";\n        else if (virtport->instanceID_specified)\n            extra = \"instanceid\";\n        break;\n    }\n\n    if (extra) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"extra %s unsupported in <virtualport type='%s'>\"),\n                       extra,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileCheckComplete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "152-218",
    "snippet": "int\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"missing %s in <virtualport type='%s'>\")",
            "missing",
            "virNetDevVPortTypeToString(virtport->virtPortType)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevVPortTypeToString",
          "args": [
            "virtport->virtPortType"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"missing %s in <virtualport type='%s'>\""
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot generate a random uuid for interfaceid\")"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virUUIDGenerate",
          "args": [
            "virtport->interfaceID"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "virUUIDGenerate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/viruuid.c",
          "lines": "50-79",
          "snippet": "int\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}",
          "includes": [
            "#include \"virrandom.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <fcntl.h>",
            "#include \"viruuid.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virrandom.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include <unistd.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <fcntl.h>\n#include \"viruuid.h\"\n#include <config.h>\n\nint\nvirUUIDGenerate(unsigned char *uuid)\n{\n    if (uuid == NULL)\n        return -1;\n\n    if (virRandomBytes(uuid, VIR_UUID_BUFLEN) < 0)\n        return -1;\n\n    /*\n     * Make UUID RFC 4122 compliant. Following form will be used:\n     *\n     * xxxxxxxx-xxxx-Axxx-Bxxx-xxxxxxxxxxxx\n     *\n     * where\n     * A is version defined in 4.1.3 of RFC\n     *  Msb0  Msb1  Msb2  Msb3   Version  Description\n     *   0     1     0     0        4     The randomly or pseudo-\n     *                                    randomly generated version\n     *                                    specified in this document.\n     *\n     * B is variant defined in 4.1.1 of RFC\n     *  Msb0  Msb1  Msb2  Description\n     *   1     0     x    The variant specified in this document.\n     */\n    uuid[6] = (uuid[6] & 0x0F) | (4 << 4);\n    uuid[8] = (uuid[8] & 0x3F) | (2 << 6);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"cannot generate a random uuid for instanceid\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint\nvirNetDevVPortProfileCheckComplete(virNetDevVPortProfilePtr virtport,\n                                   bool generateMissing)\n{\n    const char *missing = NULL;\n\n    if (!virtport || virtport->virtPortType == VIR_NETDEV_VPORT_PROFILE_NONE)\n        return 0;\n\n    switch (virtport->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (!virtport->managerID_specified) {\n            missing = \"managerid\";\n        } else if (!virtport->typeID_specified) {\n            missing = \"typeid\";\n        } else if (!virtport->typeIDVersion_specified) {\n            missing = \"typeidversion\";\n        } else if (!virtport->instanceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->instanceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for instanceid\"));\n                    return -1;\n                }\n                virtport->instanceID_specified = true;\n            } else {\n                missing = \"instanceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (!virtport->profileID[0])\n            missing = \"profileid\";\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        /* profileid is optional for openvswitch */\n        if (!virtport->interfaceID_specified) {\n            if (generateMissing) {\n                if (virUUIDGenerate(virtport->interfaceID) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                                   _(\"cannot generate a random uuid for interfaceid\"));\n                    return -1;\n                }\n                virtport->interfaceID_specified = true;\n            } else {\n                missing = \"interfaceid\";\n            }\n        }\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_MIDONET:\n       if (!virtport->interfaceID_specified)\n          missing = \"interfaceid\";\n       break;\n    }\n\n    if (missing) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"missing %s in <virtualport type='%s'>\"), missing,\n                       virNetDevVPortTypeToString(virtport->virtPortType));\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "129-141",
    "snippet": "int virNetDevVPortProfileCopy(virNetDevVPortProfilePtr *dst, const virNetDevVPortProfile *src)\n{\n    if (!src) {\n        *dst = NULL;\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dst) < 0)\n        return -1;\n\n    memcpy(*dst, src, sizeof(*src));\n    return 0;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*dst",
            "src",
            "sizeof(*src)"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "*dst"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nint virNetDevVPortProfileCopy(virNetDevVPortProfilePtr *dst, const virNetDevVPortProfile *src)\n{\n    if (!src) {\n        *dst = NULL;\n        return 0;\n    }\n\n    if (VIR_ALLOC(*dst) < 0)\n        return -1;\n\n    memcpy(*dst, src, sizeof(*src));\n    return 0;\n}"
  },
  {
    "function_name": "virNetDevVPortProfileEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdevvportprofile.c",
    "lines": "85-126",
    "snippet": "bool\nvirNetDevVPortProfileEqual(const virNetDevVPortProfile *a, const virNetDevVPortProfile *b)\n{\n    /* NULL resistant */\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->virtPortType != b->virtPortType)\n        return false;\n\n    switch (a->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (a->managerID != b->managerID ||\n            a->typeID != b->typeID ||\n            a->typeIDVersion != b->typeIDVersion ||\n            memcmp(a->instanceID, b->instanceID, VIR_UUID_BUFLEN) != 0)\n            return false;\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (STRNEQ(a->profileID, b->profileID))\n            return false;\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (STRNEQ(a->profileID, b->profileID) ||\n            memcmp(a->interfaceID, b->interfaceID, VIR_UUID_BUFLEN) != 0)\n            return false;\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}",
    "includes": [
      "# include \"virsocket.h\"",
      "# include \"virnetdev.h\"",
      "# include \"virlog.h\"",
      "# include \"virfile.h\"",
      "# include \"virnetlink.h\"",
      "# include <linux/if_tun.h>",
      "# include <net/if.h>",
      "# include <fcntl.h>",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"virnetdevvportprofile.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->interfaceID",
            "b->interfaceID",
            "VIR_UUID_BUFLEN"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "a->profileID",
            "b->profileID"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "a->profileID",
            "b->profileID"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "a->instanceID",
            "b->instanceID",
            "VIR_UUID_BUFLEN"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "# include \"virsocket.h\"\n# include \"virnetdev.h\"\n# include \"virlog.h\"\n# include \"virfile.h\"\n# include \"virnetlink.h\"\n# include <linux/if_tun.h>\n# include <net/if.h>\n# include <fcntl.h>\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"virnetdevvportprofile.h\"\n#include <config.h>\n\nbool\nvirNetDevVPortProfileEqual(const virNetDevVPortProfile *a, const virNetDevVPortProfile *b)\n{\n    /* NULL resistant */\n    if (!a && !b)\n        return true;\n\n    if (!a || !b)\n        return false;\n\n    if (a->virtPortType != b->virtPortType)\n        return false;\n\n    switch (a->virtPortType) {\n    case VIR_NETDEV_VPORT_PROFILE_NONE:\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBG:\n        if (a->managerID != b->managerID ||\n            a->typeID != b->typeID ||\n            a->typeIDVersion != b->typeIDVersion ||\n            memcmp(a->instanceID, b->instanceID, VIR_UUID_BUFLEN) != 0)\n            return false;\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_8021QBH:\n        if (STRNEQ(a->profileID, b->profileID))\n            return false;\n        break;\n\n    case VIR_NETDEV_VPORT_PROFILE_OPENVSWITCH:\n        if (STRNEQ(a->profileID, b->profileID) ||\n            memcmp(a->interfaceID, b->interfaceID, VIR_UUID_BUFLEN) != 0)\n            return false;\n        break;\n\n    default:\n        break;\n    }\n\n    return true;\n}"
  }
]