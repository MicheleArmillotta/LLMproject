[
  {
    "function_name": "virSecurityManagerMetadataUnlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1400-1429",
    "snippet": "void\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define METADATA_LEN 1",
      "#define METADATA_OFFSET 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*state"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*state)->paths"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*state)->fds"
          ],
          "line": 1426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to close fd %d path %s: %s\"",
            "fd",
            "path",
            "g_strerror(errno)"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to unlock fd %d path %s: %s\"",
            "fd",
            "path",
            "g_strerror(errno)"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileUnlock",
          "args": [
            "fd",
            "METADATA_OFFSET",
            "METADATA_LEN"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "virFileUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "499-504",
          "snippet": "int virFileUnlock(int fd G_GNUC_UNUSED,\n                  off_t start G_GNUC_UNUSED,\n                  off_t len G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileUnlock(int fd G_GNUC_UNUSED,\n                  off_t start G_GNUC_UNUSED,\n                  off_t len G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvoid\nvirSecurityManagerMetadataUnlock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                                 virSecurityManagerMetadataLockStatePtr *state)\n{\n    size_t i;\n\n    if (!state)\n        return;\n\n    for (i = 0; i < (*state)->nfds; i++) {\n        const char *path = (*state)->paths[i];\n        int fd = (*state)->fds[i];\n\n        /* Technically, unlock is not needed because it will\n         * happen on VIR_CLOSE() anyway. But let's play it nice. */\n        if (virFileUnlock(fd, METADATA_OFFSET, METADATA_LEN) < 0) {\n            VIR_WARN(\"Unable to unlock fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n\n        if (VIR_CLOSE(fd) < 0) {\n            VIR_WARN(\"Unable to close fd %d path %s: %s\",\n                     fd, path, g_strerror(errno));\n        }\n    }\n\n    VIR_FREE((*state)->fds);\n    VIR_FREE((*state)->paths);\n    VIR_FREE(*state);\n}"
  },
  {
    "function_name": "virSecurityManagerMetadataLock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1283-1397",
    "snippet": "virSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define METADATA_LEN 1",
      "#define METADATA_OFFSET 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "locked_paths"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fds"
          ],
          "line": 1394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fds[i - 1]"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&fds"
          ],
          "line": 1387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&locked_paths"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "ret"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT_COPY_INPLACE",
          "args": [
            "fds",
            "nfds",
            "fd"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fd"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to lock %s for metadata change\")",
            "p"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unable to lock %s for metadata change\""
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "1000"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLock",
          "args": [
            "fd",
            "false",
            "METADATA_OFFSET",
            "METADATA_LEN",
            "false"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "489-496",
          "snippet": "int virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileLock(int fd G_GNUC_UNUSED,\n                bool shared G_GNUC_UNUSED,\n                off_t start G_GNUC_UNUSED,\n                off_t len G_GNUC_UNUSED,\n                bool waitForLock G_GNUC_UNUSED)\n{\n    return -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"unable to open %s\")",
            "p"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsSharedFS",
          "args": [
            "p"
          ],
          "line": 1348
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsSharedFS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3699-3712",
          "snippet": "int virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virFileIsSharedFS(const char *path)\n{\n    return virFileIsSharedFSType(path,\n                                 VIR_FILE_SHFS_NFS |\n                                 VIR_FILE_SHFS_GFS2 |\n                                 VIR_FILE_SHFS_OCFS |\n                                 VIR_FILE_SHFS_AFS |\n                                 VIR_FILE_SHFS_SMB |\n                                 VIR_FILE_SHFS_CIFS |\n                                 VIR_FILE_SHFS_CEPH |\n                                 VIR_FILE_SHFS_GPFS|\n                                 VIR_FILE_SHFS_QB |\n                                 VIR_FILE_SHFS_ACFS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISSOCK",
          "args": [
            "sb.st_mode"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "p",
            "O_RDWR"
          ],
          "line": 1339
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "sb.st_mode"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "p",
            "&sb"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "profile_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_apparmor.c",
          "lines": "70-108",
          "snippet": "static int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}",
          "includes": [
            "#include \"virmdev.h\"",
            "#include \"virscsi.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"viruuid.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"internal.h\"",
            "#include <wait.h>",
            "#include <unistd.h>",
            "#include <sys/apparmor.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virmdev.h\"\n#include \"virscsi.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virscsivhost.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"viruuid.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"security_apparmor.h\"\n#include \"internal.h\"\n#include <wait.h>\n#include <unistd.h>\n#include <sys/apparmor.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nprofile_status(const char *str, const int check_enforcing)\n{\n    char *content = NULL;\n    char *tmp = NULL;\n    char *etmp = NULL;\n    int rc = -2;\n\n    /* create string that is '<str> \\0' for accurate matching */\n    tmp = g_strdup_printf(\"%s \", str);\n\n    if (check_enforcing != 0) {\n        /* create string that is '<str> (enforce)\\0' for accurate matching */\n        etmp = g_strdup_printf(\"%s (enforce)\", str);\n    }\n\n    if (virFileReadAll(APPARMOR_PROFILES_PATH, MAX_FILE_LEN, &content) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to read AppArmor profiles list \"\n                             \"\\'%s\\'\"), APPARMOR_PROFILES_PATH);\n        goto cleanup;\n    }\n\n    if (strstr(content, tmp) != NULL)\n        rc = 0;\n    else\n        rc = -1; /* return -1 if not loaded */\n    if (check_enforcing != 0) {\n        if (rc == 0 && strstr(content, etmp) != NULL)\n            rc = 1;                 /* return '1' if loaded and enforcing */\n    }\n\n    VIR_FREE(content);\n cleanup:\n    VIR_FREE(tmp);\n    VIR_FREE(etmp);\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "p",
            "paths[j]"
          ],
          "line": 1324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "paths",
            "npaths",
            "sizeof(*paths)",
            "cmpstringp"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "locked_paths",
            "npaths"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "fds",
            "npaths"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\n#define METADATA_LEN 1\n#define METADATA_OFFSET 1\n\nvirSecurityManagerMetadataLockStatePtr\nvirSecurityManagerMetadataLock(virSecurityManagerPtr mgr G_GNUC_UNUSED,\n                               const char **paths,\n                               size_t npaths)\n{\n    size_t i = 0;\n    size_t nfds = 0;\n    int *fds = NULL;\n    const char **locked_paths = NULL;\n    virSecurityManagerMetadataLockStatePtr ret = NULL;\n\n    if (VIR_ALLOC_N(fds, npaths) < 0 ||\n        VIR_ALLOC_N(locked_paths, npaths) < 0)\n        return NULL;\n\n    /* Sort paths to lock in order to avoid deadlocks with other\n     * processes. For instance, if one process wants to lock\n     * paths A B and there's another that is trying to lock them\n     * in reversed order a deadlock might occur.  But if we sort\n     * the paths alphabetically then both processes will try lock\n     * paths in the same order and thus no deadlock can occur.\n     * Lastly, it makes searching for duplicate paths below\n     * simpler. */\n    qsort(paths, npaths, sizeof(*paths), cmpstringp);\n\n    for (i = 0; i < npaths; i++) {\n        const char *p = paths[i];\n        struct stat sb;\n        size_t j;\n        int retries = 10 * 1000;\n        int fd;\n\n        if (!p)\n            continue;\n\n        /* If there's a duplicate path on the list, skip it over.\n         * Not only we would fail open()-ing it the second time,\n         * we would deadlock with ourselves trying to lock it the\n         * second time. After all, we've locked it when iterating\n         * over it the first time. */\n        for (j = 0; j < i; j++) {\n            if (STREQ_NULLABLE(p, paths[j]))\n                break;\n        }\n\n        if (i != j)\n            continue;\n\n        if (stat(p, &sb) < 0)\n            continue;\n\n        if (S_ISDIR(sb.st_mode)) {\n            /* Directories can't be locked */\n            continue;\n        }\n\n        if ((fd = open(p, O_RDWR)) < 0) {\n#ifndef WIN32\n            if (S_ISSOCK(sb.st_mode)) {\n                /* Sockets can be opened only if there exists the\n                 * other side that listens. */\n                continue;\n            }\n#endif /* !WIN32 */\n\n            if (virFileIsSharedFS(p)) {\n                /* Probably a root squashed NFS. */\n                continue;\n            }\n\n            virReportSystemError(errno,\n                                 _(\"unable to open %s\"),\n                                 p);\n            goto cleanup;\n        }\n\n        do {\n            if (virFileLock(fd, false,\n                            METADATA_OFFSET, METADATA_LEN, false) < 0) {\n                if (retries && (errno == EACCES || errno == EAGAIN)) {\n                    /* File is locked. Try again. */\n                    retries--;\n                    g_usleep(1000);\n                    continue;\n                } else {\n                    virReportSystemError(errno,\n                                         _(\"unable to lock %s for metadata change\"),\n                                         p);\n                    VIR_FORCE_CLOSE(fd);\n                    goto cleanup;\n                }\n            }\n\n            break;\n        } while (1);\n\n        locked_paths[nfds] = p;\n        VIR_APPEND_ELEMENT_COPY_INPLACE(fds, nfds, fd);\n    }\n\n    if (VIR_ALLOC(ret) < 0)\n        goto cleanup;\n\n    ret->paths = g_steal_pointer(&locked_paths);\n    ret->fds = g_steal_pointer(&fds);\n    ret->nfds = nfds;\n    nfds = 0;\n\n cleanup:\n    for (i = nfds; i > 0; i--)\n        VIR_FORCE_CLOSE(fds[i - 1]);\n    VIR_FREE(fds);\n    VIR_FREE(locked_paths);\n    return ret;\n}"
  },
  {
    "function_name": "cmpstringp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1248-1262",
    "snippet": "static int\ncmpstringp(const void *p1, const void *p2)\n{\n    const char *s1 = *(char * const *) p1;\n    const char *s2 = *(char * const *) p2;\n\n    if (!s1 && !s2)\n        return 0;\n\n    if (!s1 || !s2)\n        return s2 ? -1 : 1;\n\n    /* from man 3 qsort */\n    return strcmp(s1, s2);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s1",
            "s2"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\ncmpstringp(const void *p1, const void *p2)\n{\n    const char *s1 = *(char * const *) p1;\n    const char *s2 = *(char * const *) p2;\n\n    if (!s1 && !s2)\n        return 0;\n\n    if (!s1 || !s2)\n        return s2 ? -1 : 1;\n\n    /* from man 3 qsort */\n    return strcmp(s1, s2);\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreTPMLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1230-1245",
    "snippet": "int\nvirSecurityManagerRestoreTPMLabels(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    int ret;\n\n    if (mgr->drv->domainRestoreSecurityTPMLabels) {\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityTPMLabels(mgr, vm);\n        virObjectUnlock(mgr);\n\n        return ret;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityTPMLabels",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreTPMLabels(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    int ret;\n\n    if (mgr->drv->domainRestoreSecurityTPMLabels) {\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityTPMLabels(mgr, vm);\n        virObjectUnlock(mgr);\n\n        return ret;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerSetTPMLabels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1212-1227",
    "snippet": "int\nvirSecurityManagerSetTPMLabels(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    int ret;\n\n    if (mgr->drv->domainSetSecurityTPMLabels) {\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityTPMLabels(mgr, vm);\n        virObjectUnlock(mgr);\n\n        return ret;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityTPMLabels",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetTPMLabels(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    int ret;\n\n    if (mgr->drv->domainSetSecurityTPMLabels) {\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityTPMLabels(mgr, vm);\n        virObjectUnlock(mgr);\n\n        return ret;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1192-1209",
    "snippet": "int\nvirSecurityManagerRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityChardevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityChardevLabel(mgr, def, dev_source,\n                                                          chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityChardevLabel",
          "args": [
            "mgr",
            "def",
            "dev_source",
            "chardevStdioLogd"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreChardevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr def,\n                                      virDomainChrSourceDefPtr dev_source,\n                                      bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityChardevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityChardevLabel(mgr, def, dev_source,\n                                                          chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1172-1189",
    "snippet": "int\nvirSecurityManagerSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainSetSecurityChardevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityChardevLabel(mgr, def, dev_source,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityChardevLabel",
          "args": [
            "mgr",
            "def",
            "dev_source",
            "chardevStdioLogd"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetChardevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr def,\n                                  virDomainChrSourceDefPtr dev_source,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainSetSecurityChardevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityChardevLabel(mgr, def, dev_source,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1154-1169",
    "snippet": "int\nvirSecurityManagerRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm,\n                                    virDomainInputDefPtr input)\n{\n    if (mgr->drv->domainRestoreSecurityInputLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityInputLabel(mgr, vm, input);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityInputLabel",
          "args": [
            "mgr",
            "vm",
            "input"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreInputLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm,\n                                    virDomainInputDefPtr input)\n{\n    if (mgr->drv->domainRestoreSecurityInputLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityInputLabel(mgr, vm, input);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetInputLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1136-1151",
    "snippet": "int\nvirSecurityManagerSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                virDomainInputDefPtr input)\n{\n    if (mgr->drv->domainSetSecurityInputLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityInputLabel(mgr, vm, input);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityInputLabel",
          "args": [
            "mgr",
            "vm",
            "input"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1143
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetInputLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                virDomainInputDefPtr input)\n{\n    if (mgr->drv->domainSetSecurityInputLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityInputLabel(mgr, vm, input);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1118-1133",
    "snippet": "int\nvirSecurityManagerRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr vm,\n                                        virDomainMemoryDefPtr mem)\n{\n    if (mgr->drv->domainRestoreSecurityMemoryLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityMemoryLabel(mgr, vm, mem);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1127
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityMemoryLabel",
          "args": [
            "mgr",
            "vm",
            "mem"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1125
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreMemoryLabel(virSecurityManagerPtr mgr,\n                                        virDomainDefPtr vm,\n                                        virDomainMemoryDefPtr mem)\n{\n    if (mgr->drv->domainRestoreSecurityMemoryLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityMemoryLabel(mgr, vm, mem);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetMemoryLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1090-1105",
    "snippet": "int\nvirSecurityManagerSetMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     virDomainMemoryDefPtr mem)\n{\n    if (mgr->drv->domainSetSecurityMemoryLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityMemoryLabel(mgr, vm, mem);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityMemoryLabel",
          "args": [
            "mgr",
            "vm",
            "mem"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetMemoryLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     virDomainMemoryDefPtr mem)\n{\n    if (mgr->drv->domainSetSecurityMemoryLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityMemoryLabel(mgr, vm, mem);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerDomainSetPathLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1062-1077",
    "snippet": "int\nvirSecurityManagerDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     const char *path,\n                                     bool allowSubtree)\n{\n    if (mgr->drv->domainSetPathLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetPathLabel(mgr, vm, path, allowSubtree);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetPathLabel",
          "args": [
            "mgr",
            "vm",
            "path",
            "allowSubtree"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerDomainSetPathLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     const char *path,\n                                     bool allowSubtree)\n{\n    if (mgr->drv->domainSetPathLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetPathLabel(mgr, vm, path, allowSubtree);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerGetNested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1031-1045",
    "snippet": "virSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "list",
            "2"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityStackGetNested",
          "args": [
            "mgr"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityStackGetNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_stack.c",
          "lines": "612-632",
          "snippet": "virSecurityManagerPtr*\nvirSecurityStackGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr *list = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr item;\n    int len = 0;\n    size_t i;\n\n    for (item = priv->itemsHead; item; item = item->next)\n        len++;\n\n    if (VIR_ALLOC_N(list, len + 1) < 0)\n        return NULL;\n\n    for (i = 0, item = priv->itemsHead; item; item = item->next, i++)\n        list[i] = item->securityManager;\n    list[len] = NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_stack.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_stack.h\"\n#include <config.h>\n\nvirSecurityManagerPtr*\nvirSecurityStackGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr *list = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr item;\n    int len = 0;\n    size_t i;\n\n    for (item = priv->itemsHead; item; item = item->next)\n        len++;\n\n    if (VIR_ALLOC_N(list, len + 1) < 0)\n        return NULL;\n\n    for (i = 0, item = priv->itemsHead; item; item = item->next, i++)\n        list[i] = item->securityManager;\n    list[len] = NULL;\n\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "\"stack\"",
            "mgr->drv->name"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}"
  },
  {
    "function_name": "virSecurityManagerGetMountOptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "1014-1028",
    "snippet": "char *\nvirSecurityManagerGetMountOptions(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm)\n{\n    if (mgr->drv->domainGetSecurityMountOptions) {\n        char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainGetSecurityMountOptions(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainGetSecurityMountOptions",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nchar *\nvirSecurityManagerGetMountOptions(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm)\n{\n    if (mgr->drv->domainGetSecurityMountOptions) {\n        char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainGetSecurityMountOptions(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerSetTapFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "996-1011",
    "snippet": "int\nvirSecurityManagerSetTapFDLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                int fd)\n{\n    if (mgr->drv->domainSetSecurityTapFDLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityTapFDLabel(mgr, vm, fd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 1005
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityTapFDLabel",
          "args": [
            "mgr",
            "vm",
            "fd"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetTapFDLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                int fd)\n{\n    if (mgr->drv->domainSetSecurityTapFDLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityTapFDLabel(mgr, vm, fd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetImageFDLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "978-993",
    "snippet": "int\nvirSecurityManagerSetImageFDLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  int fd)\n{\n    if (mgr->drv->domainSetSecurityImageFDLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityImageFDLabel(mgr, vm, fd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 987
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityImageFDLabel",
          "args": [
            "mgr",
            "vm",
            "fd"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetImageFDLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  int fd)\n{\n    if (mgr->drv->domainSetSecurityImageFDLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityImageFDLabel(mgr, vm, fd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerVerify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "948-975",
    "snippet": "int\nvirSecurityManagerVerify(virSecurityManagerPtr mgr,\n                         virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    if (mgr == NULL || mgr->drv == NULL)\n        return 0;\n\n    /* NULL model == dynamic labelling, with whatever driver\n     * is active, so we can short circuit verify check to\n     * avoid drivers de-referencing NULLs by accident\n     */\n    secdef = virDomainDefGetSecurityLabelDef(def, mgr->drv->name);\n    if (secdef == NULL || secdef->model == NULL)\n        return 0;\n\n    if (mgr->drv->domainSecurityVerify) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSecurityVerify(mgr, def);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSecurityVerify",
          "args": [
            "mgr",
            "def"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "def",
            "mgr->drv->name"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerVerify(virSecurityManagerPtr mgr,\n                         virDomainDefPtr def)\n{\n    virSecurityLabelDefPtr secdef;\n\n    if (mgr == NULL || mgr->drv == NULL)\n        return 0;\n\n    /* NULL model == dynamic labelling, with whatever driver\n     * is active, so we can short circuit verify check to\n     * avoid drivers de-referencing NULLs by accident\n     */\n    secdef = virDomainDefGetSecurityLabelDef(def, mgr->drv->name);\n    if (secdef == NULL || secdef->model == NULL)\n        return 0;\n\n    if (mgr->drv->domainSecurityVerify) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSecurityVerify(mgr, def);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetChildProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "935-945",
    "snippet": "int\nvirSecurityManagerSetChildProcessLabel(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr vm,\n                                       virCommandPtr cmd)\n{\n    if (mgr->drv->domainSetSecurityChildProcessLabel)\n       return mgr->drv->domainSetSecurityChildProcessLabel(mgr, vm, cmd);\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityChildProcessLabel",
          "args": [
            "mgr",
            "vm",
            "cmd"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetChildProcessLabel(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr vm,\n                                       virCommandPtr cmd)\n{\n    if (mgr->drv->domainSetSecurityChildProcessLabel)\n       return mgr->drv->domainSetSecurityChildProcessLabel(mgr, vm, cmd);\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "918-932",
    "snippet": "int\nvirSecurityManagerSetProcessLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecurityProcessLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityProcessLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityProcessLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetProcessLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecurityProcessLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityProcessLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerGetProcessLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "899-915",
    "snippet": "int\nvirSecurityManagerGetProcessLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  pid_t pid,\n                                  virSecurityLabelPtr sec)\n{\n    if (mgr->drv->domainGetSecurityProcessLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainGetSecurityProcessLabel(mgr, vm, pid, sec);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 909
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainGetSecurityProcessLabel",
          "args": [
            "mgr",
            "vm",
            "pid",
            "sec"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 907
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerGetProcessLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  pid_t pid,\n                                  virSecurityLabelPtr sec)\n{\n    if (mgr->drv->domainGetSecurityProcessLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainGetSecurityProcessLabel(mgr, vm, pid, sec);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "880-897",
    "snippet": "int\nvirSecurityManagerRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityAllLabel(mgr, vm, migrated,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityAllLabel",
          "args": [
            "mgr",
            "vm",
            "migrated",
            "chardevStdioLogd"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 888
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreAllLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  bool migrated,\n                                  bool chardevStdioLogd)\n{\n    if (mgr->drv->domainRestoreSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityAllLabel(mgr, vm, migrated,\n                                                      chardevStdioLogd);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "858-877",
    "snippet": "int\nvirSecurityManagerSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr vm,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated)\n{\n    if (mgr->drv->domainSetSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityAllLabel(mgr, vm, stdin_path,\n                                                  chardevStdioLogd,\n                                                  migrated);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityAllLabel",
          "args": [
            "mgr",
            "vm",
            "stdin_path",
            "chardevStdioLogd",
            "migrated"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetAllLabel(virSecurityManagerPtr mgr,\n                              virDomainDefPtr vm,\n                              const char *stdin_path,\n                              bool chardevStdioLogd,\n                              bool migrated)\n{\n    if (mgr->drv->domainSetSecurityAllLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityAllLabel(mgr, vm, stdin_path,\n                                                  chardevStdioLogd,\n                                                  migrated);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerCheckAllLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "835-855",
    "snippet": "int virSecurityManagerCheckAllLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm)\n{\n    size_t i;\n\n    if (virSecurityManagerCheckDomainLabel(mgr, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->ndisks; i++) {\n        if (virSecurityManagerCheckDiskLabel(mgr, vm->disks[i]) < 0)\n            return -1;\n    }\n\n    if (virDomainChrDefForeach(vm,\n                               true,\n                               virSecurityManagerCheckChardevCallback,\n                               mgr) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainChrDefForeach",
          "args": [
            "vm",
            "true",
            "virSecurityManagerCheckChardevCallback",
            "mgr"
          ],
          "line": 848
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainChrDefForeach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "29835-29886",
          "snippet": "int\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainChrDefForeach(virDomainDefPtr def,\n                       bool abortOnError,\n                       virDomainChrDefIterator iter,\n                       void *opaque)\n{\n    size_t i;\n    int rc = 0;\n\n    for (i = 0; i < def->nserials; i++) {\n        if ((iter)(def,\n                   def->serials[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nparallels; i++) {\n        if ((iter)(def,\n                   def->parallels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    for (i = 0; i < def->nchannels; i++) {\n        if ((iter)(def,\n                   def->channels[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n    for (i = 0; i < def->nconsoles; i++) {\n        if (virDomainSkipBackcompatConsole(def, i, false))\n            continue;\n        if ((iter)(def,\n                   def->consoles[i],\n                   opaque) < 0)\n            rc = -1;\n\n        if (abortOnError && rc != 0)\n            return rc;\n    }\n\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerCheckDiskLabel",
          "args": [
            "mgr",
            "vm->disks[i]"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckDiskLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "795-807",
          "snippet": "static int\nvirSecurityManagerCheckDiskLabel(virSecurityManagerPtr mgr,\n                                 virDomainDiskDefPtr disk)\n{\n    size_t i;\n\n    for (i = 0; i < disk->src->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, disk->src->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckDiskLabel(virSecurityManagerPtr mgr,\n                                 virDomainDiskDefPtr disk)\n{\n    size_t i;\n\n    for (i = 0; i < disk->src->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, disk->src->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerCheckDomainLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckDomainLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "780-792",
          "snippet": "static int\nvirSecurityManagerCheckDomainLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, def->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckDomainLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, def->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint virSecurityManagerCheckAllLabel(virSecurityManagerPtr mgr,\n                                    virDomainDefPtr vm)\n{\n    size_t i;\n\n    if (virSecurityManagerCheckDomainLabel(mgr, vm) < 0)\n        return -1;\n\n    for (i = 0; i < vm->ndisks; i++) {\n        if (virSecurityManagerCheckDiskLabel(mgr, vm->disks[i]) < 0)\n            return -1;\n    }\n\n    if (virDomainChrDefForeach(vm,\n                               true,\n                               virSecurityManagerCheckChardevCallback,\n                               mgr) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerCheckChardevCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "825-832",
    "snippet": "static int\nvirSecurityManagerCheckChardevCallback(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainChrDefPtr dev,\n                                       void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityManagerCheckChardevLabel(mgr, dev);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerCheckChardevLabel",
          "args": [
            "mgr",
            "dev"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckChardevLabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "810-822",
          "snippet": "static int\nvirSecurityManagerCheckChardevLabel(virSecurityManagerPtr mgr,\n                                    virDomainChrDefPtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < dev->source->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, dev->source->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckChardevLabel(virSecurityManagerPtr mgr,\n                                    virDomainChrDefPtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < dev->source->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, dev->source->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckChardevCallback(virDomainDefPtr def G_GNUC_UNUSED,\n                                       virDomainChrDefPtr dev,\n                                       void *opaque)\n{\n    virSecurityManagerPtr mgr = opaque;\n    return virSecurityManagerCheckChardevLabel(mgr, dev);\n}"
  },
  {
    "function_name": "virSecurityManagerCheckChardevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "810-822",
    "snippet": "static int\nvirSecurityManagerCheckChardevLabel(virSecurityManagerPtr mgr,\n                                    virDomainChrDefPtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < dev->source->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, dev->source->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerCheckModel",
          "args": [
            "mgr",
            "dev->source->seclabels[i]->model"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "751-777",
          "snippet": "static int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckChardevLabel(virSecurityManagerPtr mgr,\n                                    virDomainChrDefPtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < dev->source->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, dev->source->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerCheckDiskLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "795-807",
    "snippet": "static int\nvirSecurityManagerCheckDiskLabel(virSecurityManagerPtr mgr,\n                                 virDomainDiskDefPtr disk)\n{\n    size_t i;\n\n    for (i = 0; i < disk->src->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, disk->src->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerCheckModel",
          "args": [
            "mgr",
            "disk->src->seclabels[i]->model"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "751-777",
          "snippet": "static int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckDiskLabel(virSecurityManagerPtr mgr,\n                                 virDomainDiskDefPtr disk)\n{\n    size_t i;\n\n    for (i = 0; i < disk->src->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, disk->src->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerCheckDomainLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "780-792",
    "snippet": "static int\nvirSecurityManagerCheckDomainLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, def->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerCheckModel",
          "args": [
            "mgr",
            "def->seclabels[i]->model"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerCheckModel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "751-777",
          "snippet": "static int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerCheckDomainLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (virSecurityManagerCheckModel(mgr, def->seclabels[i]->model) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerCheckModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "751-777",
    "snippet": "static int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sec_managers"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"Security driver model '%s' is not available\")",
            "secmodel"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Security driver model '%s' is not available\""
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "secmodel",
            "sec_managers[i]->drv->name"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetNested",
          "args": [
            "mgr"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1031-1045",
          "snippet": "virSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "secmodel",
            "\"none\""
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int virSecurityManagerCheckModel(virSecurityManagerPtr mgr,\n                                        char *secmodel)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr *sec_managers = NULL;\n\n    if (STREQ_NULLABLE(secmodel, \"none\"))\n        return 0;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return -1;\n\n    for (i = 0; sec_managers[i]; i++) {\n        if (STREQ_NULLABLE(secmodel, sec_managers[i]->drv->name)) {\n            ret = 0;\n            goto cleanup;\n        }\n    }\n\n    virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                   _(\"Security driver model '%s' is not available\"),\n                   secmodel);\n cleanup:\n    VIR_FREE(sec_managers);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityManagerReleaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "734-748",
    "snippet": "int\nvirSecurityManagerReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    if (mgr->drv->domainReleaseSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReleaseSecurityLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainReleaseSecurityLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerReleaseLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm)\n{\n    if (mgr->drv->domainReleaseSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReleaseSecurityLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerReserveLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "716-731",
    "snippet": "int\nvirSecurityManagerReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm,\n                               pid_t pid)\n{\n    if (mgr->drv->domainReserveSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReserveSecurityLabel(mgr, vm, pid);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainReserveSecurityLabel",
          "args": [
            "mgr",
            "vm",
            "pid"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerReserveLabel(virSecurityManagerPtr mgr,\n                               virDomainDefPtr vm,\n                               pid_t pid)\n{\n    if (mgr->drv->domainReserveSecurityLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainReserveSecurityLabel(mgr, vm, pid);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerGenLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "635-713",
    "snippet": "int\nvirSecurityManagerGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr vm)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr* sec_managers = NULL;\n    virSecurityLabelDefPtr seclabel;\n    bool generated = false;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return ret;\n\n    virObjectLock(mgr);\n\n    for (i = 0; sec_managers[i]; i++) {\n        generated = false;\n        seclabel = virDomainDefGetSecurityLabelDef(vm, sec_managers[i]->drv->name);\n        if (seclabel == NULL) {\n            /* Only generate seclabel if confinement is enabled */\n            if (!virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                VIR_DEBUG(\"Skipping auto generated seclabel\");\n                continue;\n            } else {\n                if (!(seclabel = virSecurityLabelDefNew(sec_managers[i]->drv->name)))\n                    goto cleanup;\n                generated = seclabel->implicit = true;\n                seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n            }\n        } else {\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_DEFAULT) {\n                if (virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n                } else {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_NONE;\n                    seclabel->relabel = false;\n                }\n            }\n\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_NONE) {\n                if (virSecurityManagerGetRequireConfined(sec_managers[i])) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Unconfined guests are not allowed on this host\"));\n                    goto cleanup;\n                }\n            }\n        }\n\n        if (!sec_managers[i]->drv->domainGenSecurityLabel) {\n            virReportUnsupportedError();\n            virSecurityLabelDefFree(seclabel);\n            seclabel = NULL;\n        } else {\n            /* The seclabel must be added to @vm prior calling domainGenSecurityLabel\n             * which may require seclabel to be presented already */\n            if (generated &&\n                VIR_APPEND_ELEMENT(vm->seclabels, vm->nseclabels, seclabel) < 0)\n                goto cleanup;\n\n            if (sec_managers[i]->drv->domainGenSecurityLabel(sec_managers[i], vm) < 0) {\n                if (VIR_DELETE_ELEMENT(vm->seclabels,\n                                       vm->nseclabels -1, vm->nseclabels) < 0)\n                    vm->nseclabels--;\n                goto cleanup;\n            }\n\n            seclabel = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr);\n    if (generated)\n        virSecurityLabelDefFree(seclabel);\n    VIR_FREE(sec_managers);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "sec_managers"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityLabelDefFree",
          "args": [
            "seclabel"
          ],
          "line": 710
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityLabelDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "32-42",
          "snippet": "void\nvirSecurityLabelDefFree(virSecurityLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def->imagelabel);\n    VIR_FREE(def->baselabel);\n    VIR_FREE(def);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nvirSecurityLabelDefFree(virSecurityLabelDefPtr def)\n{\n    if (!def)\n        return;\n    VIR_FREE(def->model);\n    VIR_FREE(def->label);\n    VIR_FREE(def->imagelabel);\n    VIR_FREE(def->baselabel);\n    VIR_FREE(def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "vm->seclabels",
            "vm->nseclabels -1",
            "vm->nseclabels"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sec_managers[i]->drv->domainGenSecurityLabel",
          "args": [
            "sec_managers[i]",
            "vm"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "vm->seclabels",
            "vm->nseclabels",
            "seclabel"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Unconfined guests are not allowed on this host\")"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unconfined guests are not allowed on this host\""
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetRequireConfined",
          "args": [
            "sec_managers[i]"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetRequireConfined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "398-402",
          "snippet": "bool\nvirSecurityManagerGetRequireConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetRequireConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetDefaultConfined",
          "args": [
            "sec_managers[i]"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetDefaultConfined",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "391-395",
          "snippet": "bool\nvirSecurityManagerGetDefaultConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetDefaultConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityLabelDefNew",
          "args": [
            "sec_managers[i]->drv->name"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityLabelDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virseclabel.c",
          "lines": "56-71",
          "snippet": "virSecurityLabelDefPtr\nvirSecurityLabelDefNew(const char *model)\n{\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (VIR_ALLOC(seclabel) < 0) {\n        virSecurityLabelDefFree(seclabel);\n        return NULL;\n    }\n\n    seclabel->model = g_strdup(model);\n\n    seclabel->relabel = true;\n\n    return seclabel;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virseclabel.h\"",
            "#include \"viralloc.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virseclabel.h\"\n#include \"viralloc.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirSecurityLabelDefNew(const char *model)\n{\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (VIR_ALLOC(seclabel) < 0) {\n        virSecurityLabelDefFree(seclabel);\n        return NULL;\n    }\n\n    seclabel->model = g_strdup(model);\n\n    seclabel->relabel = true;\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Skipping auto generated seclabel\""
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDefGetSecurityLabelDef",
          "args": [
            "vm",
            "sec_managers[i]->drv->name"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDefGetSecurityLabelDef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "30583-30600",
          "snippet": "virSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirSecurityLabelDefPtr\nvirDomainDefGetSecurityLabelDef(virDomainDefPtr def, const char *model)\n{\n    size_t i;\n    virSecurityLabelDefPtr seclabel = NULL;\n\n    if (def == NULL || model == NULL)\n        return NULL;\n\n    for (i = 0; i < def->nseclabels; i++) {\n        if (def->seclabels[i]->model == NULL)\n            continue;\n        if (STREQ(def->seclabels[i]->model, model))\n            return def->seclabels[i];\n    }\n\n    return seclabel;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetNested",
          "args": [
            "mgr"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "1031-1045",
          "snippet": "virSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr*\nvirSecurityManagerGetNested(virSecurityManagerPtr mgr)\n{\n    virSecurityManagerPtr* list = NULL;\n\n    if (STREQ(\"stack\", mgr->drv->name))\n        return virSecurityStackGetNested(mgr);\n\n    if (VIR_ALLOC_N(list, 2) < 0)\n        return NULL;\n\n    list[0] = mgr;\n    list[1] = NULL;\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerGenLabel(virSecurityManagerPtr mgr,\n                           virDomainDefPtr vm)\n{\n    int ret = -1;\n    size_t i;\n    virSecurityManagerPtr* sec_managers = NULL;\n    virSecurityLabelDefPtr seclabel;\n    bool generated = false;\n\n    if ((sec_managers = virSecurityManagerGetNested(mgr)) == NULL)\n        return ret;\n\n    virObjectLock(mgr);\n\n    for (i = 0; sec_managers[i]; i++) {\n        generated = false;\n        seclabel = virDomainDefGetSecurityLabelDef(vm, sec_managers[i]->drv->name);\n        if (seclabel == NULL) {\n            /* Only generate seclabel if confinement is enabled */\n            if (!virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                VIR_DEBUG(\"Skipping auto generated seclabel\");\n                continue;\n            } else {\n                if (!(seclabel = virSecurityLabelDefNew(sec_managers[i]->drv->name)))\n                    goto cleanup;\n                generated = seclabel->implicit = true;\n                seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n            }\n        } else {\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_DEFAULT) {\n                if (virSecurityManagerGetDefaultConfined(sec_managers[i])) {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_DYNAMIC;\n                } else {\n                    seclabel->type = VIR_DOMAIN_SECLABEL_NONE;\n                    seclabel->relabel = false;\n                }\n            }\n\n            if (seclabel->type == VIR_DOMAIN_SECLABEL_NONE) {\n                if (virSecurityManagerGetRequireConfined(sec_managers[i])) {\n                    virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                                   _(\"Unconfined guests are not allowed on this host\"));\n                    goto cleanup;\n                }\n            }\n        }\n\n        if (!sec_managers[i]->drv->domainGenSecurityLabel) {\n            virReportUnsupportedError();\n            virSecurityLabelDefFree(seclabel);\n            seclabel = NULL;\n        } else {\n            /* The seclabel must be added to @vm prior calling domainGenSecurityLabel\n             * which may require seclabel to be presented already */\n            if (generated &&\n                VIR_APPEND_ELEMENT(vm->seclabels, vm->nseclabels, seclabel) < 0)\n                goto cleanup;\n\n            if (sec_managers[i]->drv->domainGenSecurityLabel(sec_managers[i], vm) < 0) {\n                if (VIR_DELETE_ELEMENT(vm->seclabels,\n                                       vm->nseclabels -1, vm->nseclabels) < 0)\n                    vm->nseclabels--;\n                goto cleanup;\n            }\n\n            seclabel = NULL;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    virObjectUnlock(mgr);\n    if (generated)\n        virSecurityLabelDefFree(seclabel);\n    VIR_FREE(sec_managers);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "617-632",
    "snippet": "int\nvirSecurityManagerRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr vm,\n                                         const char *savefile)\n{\n    if (mgr->drv->domainRestoreSavedStateLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSavedStateLabel(mgr, vm, savefile);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSavedStateLabel",
          "args": [
            "mgr",
            "vm",
            "savefile"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreSavedStateLabel(virSecurityManagerPtr mgr,\n                                         virDomainDefPtr vm,\n                                         const char *savefile)\n{\n    if (mgr->drv->domainRestoreSavedStateLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSavedStateLabel(mgr, vm, savefile);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetSavedStateLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "600-615",
    "snippet": "int\nvirSecurityManagerSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     const char *savefile)\n{\n    if (mgr->drv->domainSetSavedStateLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSavedStateLabel(mgr, vm, savefile);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSavedStateLabel",
          "args": [
            "mgr",
            "vm",
            "savefile"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetSavedStateLabel(virSecurityManagerPtr mgr,\n                                     virDomainDefPtr vm,\n                                     const char *savefile)\n{\n    if (mgr->drv->domainSetSavedStateLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSavedStateLabel(mgr, vm, savefile);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "581-597",
    "snippet": "int\nvirSecurityManagerSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n{\n    if (mgr->drv->domainSetSecurityHostdevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityHostdevLabel(mgr, vm, dev, vroot);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityHostdevLabel",
          "args": [
            "mgr",
            "vm",
            "dev",
            "vroot"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetHostdevLabel(virSecurityManagerPtr mgr,\n                                  virDomainDefPtr vm,\n                                  virDomainHostdevDefPtr dev,\n                                  const char *vroot)\n{\n    if (mgr->drv->domainSetSecurityHostdevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityHostdevLabel(mgr, vm, dev, vroot);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreHostdevLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "562-578",
    "snippet": "int\nvirSecurityManagerRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr vm,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    if (mgr->drv->domainRestoreSecurityHostdevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityHostdevLabel(mgr, vm, dev, vroot);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityHostdevLabel",
          "args": [
            "mgr",
            "vm",
            "dev",
            "vroot"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 570
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreHostdevLabel(virSecurityManagerPtr mgr,\n                                      virDomainDefPtr vm,\n                                      virDomainHostdevDefPtr dev,\n                                      const char *vroot)\n{\n    if (mgr->drv->domainRestoreSecurityHostdevLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityHostdevLabel(mgr, vm, dev, vroot);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "543-559",
    "snippet": "int\nvirSecurityManagerSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    if (mgr->drv->domainSetSecurityImageLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityImageLabel(mgr, vm, src, flags);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityImageLabel",
          "args": [
            "mgr",
            "vm",
            "src",
            "flags"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetImageLabel(virSecurityManagerPtr mgr,\n                                virDomainDefPtr vm,\n                                virStorageSourcePtr src,\n                                virSecurityDomainImageLabelFlags flags)\n{\n    if (mgr->drv->domainSetSecurityImageLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityImageLabel(mgr, vm, src, flags);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerClearSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "515-529",
    "snippet": "int\nvirSecurityManagerClearSocketLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    if (mgr->drv->domainClearSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainClearSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainClearSecuritySocketLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerClearSocketLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm)\n{\n    if (mgr->drv->domainClearSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainClearSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "498-512",
    "snippet": "int\nvirSecurityManagerSetSocketLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecuritySocketLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetSocketLabel(virSecurityManagerPtr mgr,\n                                 virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecuritySocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecuritySocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerSetDaemonSocketLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "481-495",
    "snippet": "int\nvirSecurityManagerSetDaemonSocketLabel(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecurityDaemonSocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityDaemonSocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainSetSecurityDaemonSocketLabel",
          "args": [
            "mgr",
            "vm"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerSetDaemonSocketLabel(virSecurityManagerPtr mgr,\n                                       virDomainDefPtr vm)\n{\n    if (mgr->drv->domainSetSecurityDaemonSocketLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainSetSecurityDaemonSocketLabel(mgr, vm);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerMoveImageMetadata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "462-478",
    "snippet": "int\nvirSecurityManagerMoveImageMetadata(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr dst)\n{\n    if (mgr->drv->domainMoveImageMetadata) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainMoveImageMetadata(mgr, pid, src, dst);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainMoveImageMetadata",
          "args": [
            "mgr",
            "pid",
            "src",
            "dst"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerMoveImageMetadata(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    virStorageSourcePtr src,\n                                    virStorageSourcePtr dst)\n{\n    if (mgr->drv->domainMoveImageMetadata) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainMoveImageMetadata(mgr, pid, src, dst);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerRestoreImageLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "423-439",
    "snippet": "int\nvirSecurityManagerRestoreImageLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm,\n                                   virStorageSourcePtr src,\n                                   virSecurityDomainImageLabelFlags flags)\n{\n    if (mgr->drv->domainRestoreSecurityImageLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityImageLabel(mgr, vm, src, flags);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->domainRestoreSecurityImageLabel",
          "args": [
            "mgr",
            "vm",
            "src",
            "flags"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerRestoreImageLabel(virSecurityManagerPtr mgr,\n                                   virDomainDefPtr vm,\n                                   virStorageSourcePtr src,\n                                   virSecurityDomainImageLabelFlags flags)\n{\n    if (mgr->drv->domainRestoreSecurityImageLabel) {\n        int ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->domainRestoreSecurityImageLabel(mgr, vm, src, flags);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return -1;\n}"
  },
  {
    "function_name": "virSecurityManagerGetPrivileged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "405-409",
    "snippet": "bool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetPrivileged(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_PRIVILEGED;\n}"
  },
  {
    "function_name": "virSecurityManagerGetRequireConfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "398-402",
    "snippet": "bool\nvirSecurityManagerGetRequireConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetRequireConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED;\n}"
  },
  {
    "function_name": "virSecurityManagerGetDefaultConfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "391-395",
    "snippet": "bool\nvirSecurityManagerGetDefaultConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nbool\nvirSecurityManagerGetDefaultConfined(virSecurityManagerPtr mgr)\n{\n    return mgr->flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n}"
  },
  {
    "function_name": "virSecurityManagerGetBaseLabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "375-388",
    "snippet": "const char *\nvirSecurityManagerGetBaseLabel(virSecurityManagerPtr mgr,\n                               int virtType)\n{\n    if (mgr->drv->getBaseLabel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getBaseLabel(mgr, virtType);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->getBaseLabel",
          "args": [
            "mgr",
            "virtType"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetBaseLabel(virSecurityManagerPtr mgr,\n                               int virtType)\n{\n    if (mgr->drv->getBaseLabel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getBaseLabel(mgr, virtType);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerGetModel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "358-371",
    "snippet": "const char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->getModel",
          "args": [
            "mgr"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetModel(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getModel) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getModel(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerGetDOI",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "342-355",
    "snippet": "const char *\nvirSecurityManagerGetDOI(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getDOI) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getDOI(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportUnsupportedError",
          "args": [],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->getDOI",
          "args": [
            "mgr"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetDOI(virSecurityManagerPtr mgr)\n{\n    if (mgr->drv->getDOI) {\n        const char *ret;\n        virObjectLock(mgr);\n        ret = mgr->drv->getDOI(mgr);\n        virObjectUnlock(mgr);\n        return ret;\n    }\n\n    virReportUnsupportedError();\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerGetDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "335-339",
    "snippet": "const char *\nvirSecurityManagerGetDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->drv->name;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->drv->name;\n}"
  },
  {
    "function_name": "virSecurityManagerGetVirtDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "328-332",
    "snippet": "const char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}"
  },
  {
    "function_name": "virSecurityManagerGetPrivateData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "321-325",
    "snippet": "void *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid *\nvirSecurityManagerGetPrivateData(virSecurityManagerPtr mgr)\n{\n    return mgr->privateData;\n}"
  },
  {
    "function_name": "virSecurityManagerTransactionAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "311-318",
    "snippet": "void\nvirSecurityManagerTransactionAbort(virSecurityManagerPtr mgr)\n{\n    virObjectLock(mgr);\n    if (mgr->drv->transactionAbort)\n        mgr->drv->transactionAbort(mgr);\n    virObjectUnlock(mgr);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->transactionAbort",
          "args": [
            "mgr"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityManagerTransactionAbort(virSecurityManagerPtr mgr)\n{\n    virObjectLock(mgr);\n    if (mgr->drv->transactionAbort)\n        mgr->drv->transactionAbort(mgr);\n    virObjectUnlock(mgr);\n}"
  },
  {
    "function_name": "virSecurityManagerTransactionCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "290-302",
    "snippet": "int\nvirSecurityManagerTransactionCommit(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    bool lock)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->transactionCommit)\n        ret = mgr->drv->transactionCommit(mgr, pid, lock);\n    virObjectUnlock(mgr);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->transactionCommit",
          "args": [
            "mgr",
            "pid",
            "lock"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerTransactionCommit(virSecurityManagerPtr mgr,\n                                    pid_t pid,\n                                    bool lock)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->transactionCommit)\n        ret = mgr->drv->transactionCommit(mgr, pid, lock);\n    virObjectUnlock(mgr);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityManagerTransactionStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "255-265",
    "snippet": "int\nvirSecurityManagerTransactionStart(virSecurityManagerPtr mgr)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->transactionStart)\n        ret = mgr->drv->transactionStart(mgr);\n    virObjectUnlock(mgr);\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->transactionStart",
          "args": [
            "mgr"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerTransactionStart(virSecurityManagerPtr mgr)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->transactionStart)\n        ret = mgr->drv->transactionStart(mgr);\n    virObjectUnlock(mgr);\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityManagerPostFork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "238-242",
    "snippet": "void\nvirSecurityManagerPostFork(virSecurityManagerPtr mgr)\n{\n    virObjectUnlock(mgr);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityManagerPostFork(virSecurityManagerPtr mgr)\n{\n    virObjectUnlock(mgr);\n}"
  },
  {
    "function_name": "virSecurityManagerPreFork",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "218-231",
    "snippet": "int\nvirSecurityManagerPreFork(virSecurityManagerPtr mgr)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->preFork) {\n        ret = mgr->drv->preFork(mgr);\n        if (ret < 0)\n            virObjectUnlock(mgr);\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnlock",
          "args": [
            "mgr"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "501-510",
          "snippet": "void\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectUnlock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexUnlock(&obj->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mgr->drv->preFork",
          "args": [
            "mgr"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLock",
          "args": [
            "mgr"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "424-433",
          "snippet": "void\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid\nvirObjectLock(void *anyobj)\n{\n    virObjectLockablePtr obj = virObjectGetLockableObj(anyobj);\n\n    if (!obj)\n        return;\n\n    virMutexLock(&obj->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerPreFork(virSecurityManagerPtr mgr)\n{\n    int ret = 0;\n\n    virObjectLock(mgr);\n    if (mgr->drv->preFork) {\n        ret = mgr->drv->preFork(mgr);\n        if (ret < 0)\n            virObjectUnlock(mgr);\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virSecurityManagerNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "176-208",
    "snippet": "virSecurityManagerPtr\nvirSecurityManagerNew(const char *name,\n                      const char *virtDriver,\n                      unsigned int flags)\n{\n    virSecurityDriverPtr drv = virSecurityDriverLookup(name, virtDriver);\n    if (!drv)\n        return NULL;\n\n    /* driver \"none\" needs some special handling of *Confined bools */\n    if (STREQ(drv->name, \"none\")) {\n        if (flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Security driver \\\"none\\\" cannot create confined guests\"));\n            return NULL;\n        }\n\n        if (flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED) {\n            if (name != NULL) {\n                VIR_WARN(\"Configured security driver \\\"none\\\" disables default\"\n                         \" policy to create confined guests\");\n            } else {\n                VIR_DEBUG(\"Auto-probed security driver is \\\"none\\\";\"\n                          \" confined guests will not be created\");\n            }\n            flags &= ~VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n        }\n    }\n\n    return virSecurityManagerNewDriver(drv,\n                                       virtDriver,\n                                       flags);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityManagerNewDriver",
          "args": [
            "drv",
            "virtDriver",
            "flags"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerNewDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "74-109",
          "snippet": "static virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSecurityManagerClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr virSecurityManagerClass;\n\nstatic virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Auto-probed security driver is \\\"none\\\";\"\n                          \" confined guests will not be created\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Configured security driver \\\"none\\\" disables default\"\n                         \" policy to create confined guests\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"Security driver \\\"none\\\" cannot create confined guests\")"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Security driver \\\"none\\\" cannot create confined guests\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "get_files",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/virt-aa-helper.c",
          "lines": "911-1343",
          "snippet": "static int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}",
          "includes": [
            "#include \"virhostdev.h\"",
            "#include \"virgettext.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"configmake.h\"",
            "#include \"virfile.h\"",
            "#include \"virpci.h\"",
            "#include \"virutil.h\"",
            "#include \"virusb.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"domain_conf.h\"",
            "#include \"security_apparmor.h\"",
            "#include \"security_driver.h\"",
            "#include \"driver.h\"",
            "#include \"virlog.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include <sys/utsname.h>",
            "#include <getopt.h>",
            "#include <fcntl.h>",
            "#include <sys/types.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostdev.h\"\n#include \"virgettext.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"configmake.h\"\n#include \"virfile.h\"\n#include \"virpci.h\"\n#include \"virutil.h\"\n#include \"virusb.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"domain_conf.h\"\n#include \"security_apparmor.h\"\n#include \"security_driver.h\"\n#include \"driver.h\"\n#include \"virlog.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include <sys/utsname.h>\n#include <getopt.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <config.h>\n\nstatic int\nget_files(vahControl * ctl)\n{\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    int rc = -1;\n    size_t i;\n    char *uuid;\n    char *mem_path = NULL;\n    char uuidstr[VIR_UUID_STRING_BUFLEN];\n    bool needsVfio = false, needsvhost = false, needsgl = false;\n\n    /* verify uuid is same as what we were given on the command line */\n    virUUIDFormat(ctl->def->uuid, uuidstr);\n    uuid = g_strdup_printf(\"%s%s\", AA_PREFIX, uuidstr);\n\n    if (STRNEQ(uuid, ctl->uuid)) {\n        vah_error(ctl, 0, _(\"given uuid does not match XML uuid\"));\n        goto cleanup;\n    }\n\n    /* load the storage driver so that backing store can be accessed */\n#ifdef WITH_STORAGE\n    virDriverLoadModule(\"storage\", \"storageRegister\", false);\n#endif\n\n    for (i = 0; i < ctl->def->ndisks; i++) {\n        virDomainDiskDefPtr disk = ctl->def->disks[i];\n\n        if (!virDomainDiskGetSource(disk))\n            continue;\n        /* XXX - if we knew the qemu user:group here we could send it in\n         *        so that the open could be re-tried as that user:group.\n         */\n        if (!virStorageSourceHasBacking(disk->src))\n            virStorageFileGetMetadata(disk->src, -1, -1, false);\n\n         /* XXX should handle open errors more careful than just ignoring them.\n         */\n        if (storage_source_add_files(disk->src, &buf, 0) < 0)\n            goto cleanup;\n    }\n\n    for (i = 0; i < ctl->def->nserials; i++)\n        if (ctl->def->serials[i] &&\n            (ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->serials[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->serials[i]->source->data.file.path &&\n            ctl->def->serials[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->serials[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->serials[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nconsoles; i++)\n        if (ctl->def->consoles[i] &&\n            (ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->consoles[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->consoles[i]->source->data.file.path &&\n            ctl->def->consoles[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file(&buf,\n                             ctl->def->consoles[i]->source->data.file.path, \"rw\") != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nparallels; i++)\n        if (ctl->def->parallels[i] &&\n            (ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->parallels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->parallels[i]->source->data.file.path &&\n            ctl->def->parallels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->parallels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->parallels[i]->source->type) != 0)\n                goto cleanup;\n\n    for (i = 0; i < ctl->def->nchannels; i++)\n        if (ctl->def->channels[i] &&\n            (ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PTY ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_DEV ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_FILE ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_UNIX ||\n             ctl->def->channels[i]->source->type == VIR_DOMAIN_CHR_TYPE_PIPE) &&\n            ctl->def->channels[i]->source->data.file.path &&\n            ctl->def->channels[i]->source->data.file.path[0] != '\\0')\n            if (vah_add_file_chardev(&buf,\n                                     ctl->def->channels[i]->source->data.file.path,\n                                     \"rw\",\n                                     ctl->def->channels[i]->source->type) != 0)\n                goto cleanup;\n\n    if (ctl->def->os.kernel)\n        if (vah_add_file(&buf, ctl->def->os.kernel, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.initrd)\n        if (vah_add_file(&buf, ctl->def->os.initrd, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.dtb)\n        if (vah_add_file(&buf, ctl->def->os.dtb, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.slic_table)\n        if (vah_add_file(&buf, ctl->def->os.slic_table, \"r\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->path)\n        if (vah_add_file(&buf, ctl->def->os.loader->path, \"rk\") != 0)\n            goto cleanup;\n\n    if (ctl->def->os.loader && ctl->def->os.loader->nvram)\n        if (vah_add_file(&buf, ctl->def->os.loader->nvram, \"rwk\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->ngraphics; i++) {\n        virDomainGraphicsDefPtr graphics = ctl->def->graphics[i];\n        size_t n;\n        const char *rendernode = virDomainGraphicsGetRenderNode(graphics);\n\n        if (rendernode) {\n            vah_add_file(&buf, rendernode, \"rw\");\n            needsgl = true;\n        } else {\n            if (virDomainGraphicsNeedsAutoRenderNode(graphics)) {\n                char *defaultRenderNode = virHostGetDRMRenderNode();\n                needsgl = true;\n\n                if (defaultRenderNode) {\n                    vah_add_file(&buf, defaultRenderNode, \"rw\");\n                    VIR_FREE(defaultRenderNode);\n                }\n            }\n        }\n\n        for (n = 0; n < graphics->nListens; n++) {\n            virDomainGraphicsListenDef listenObj = graphics->listens[n];\n\n            if (listenObj.type == VIR_DOMAIN_GRAPHICS_LISTEN_TYPE_SOCKET &&\n                listenObj.socket &&\n                vah_add_file(&buf, listenObj.socket, \"rw\"))\n                goto cleanup;\n        }\n    }\n\n    if (ctl->def->ngraphics == 1 &&\n        ctl->def->graphics[0]->type == VIR_DOMAIN_GRAPHICS_TYPE_SDL)\n        if (vah_add_file(&buf, ctl->def->graphics[0]->data.sdl.xauth,\n                         \"r\") != 0)\n            goto cleanup;\n\n    for (i = 0; i < ctl->def->nhostdevs; i++)\n        if (ctl->def->hostdevs[i]) {\n            virDomainHostdevDefPtr dev = ctl->def->hostdevs[i];\n            virDomainHostdevSubsysUSBPtr usbsrc = &dev->source.subsys.u.usb;\n            switch (dev->source.subsys.type) {\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB: {\n                virUSBDevicePtr usb =\n                    virUSBDeviceNew(usbsrc->bus, usbsrc->device, NULL);\n\n                if (usb == NULL)\n                    continue;\n\n                if (virHostdevFindUSBDevice(dev, true, &usb) < 0)\n                    continue;\n\n                rc = virUSBDeviceFileIterate(usb, file_iterate_hostdev_cb, &buf);\n                virUSBDeviceFree(usb);\n                if (rc != 0)\n                    goto cleanup;\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_MDEV: {\n                virDomainHostdevSubsysMediatedDevPtr mdevsrc = &dev->source.subsys.u.mdev;\n                switch ((virMediatedDeviceModelType) mdevsrc->model) {\n                    case VIR_MDEV_MODEL_TYPE_VFIO_PCI:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_AP:\n                    case VIR_MDEV_MODEL_TYPE_VFIO_CCW:\n                        needsVfio = true;\n                        break;\n                    case VIR_MDEV_MODEL_TYPE_LAST:\n                    default:\n                        virReportEnumRangeError(virMediatedDeviceModelType,\n                                                mdevsrc->model);\n                        break;\n                }\n                break;\n            }\n\n            case VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI: {\n                virPCIDevicePtr pci = virPCIDeviceNew(\n                           dev->source.subsys.u.pci.addr.domain,\n                           dev->source.subsys.u.pci.addr.bus,\n                           dev->source.subsys.u.pci.addr.slot,\n                           dev->source.subsys.u.pci.addr.function);\n\n                virDomainHostdevSubsysPCIBackendType backend = dev->source.subsys.u.pci.backend;\n                if (backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_VFIO ||\n                        backend == VIR_DOMAIN_HOSTDEV_PCI_BACKEND_DEFAULT) {\n                    needsVfio = true;\n                }\n\n                if (pci == NULL)\n                    continue;\n\n                rc = virPCIDeviceFileIterate(pci, file_iterate_pci_cb, &buf);\n                virPCIDeviceFree(pci);\n\n                break;\n            }\n\n            default:\n                rc = 0;\n                break;\n            } /* switch */\n        }\n\n    for (i = 0; i < ctl->def->nfss; i++) {\n        if (ctl->def->fss[i] &&\n                ctl->def->fss[i]->type == VIR_DOMAIN_FS_TYPE_MOUNT &&\n                (ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_PATH ||\n                 ctl->def->fss[i]->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_DEFAULT) &&\n                ctl->def->fss[i]->src) {\n            virDomainFSDefPtr fs = ctl->def->fss[i];\n\n            /* We don't need to add deny rw rules for readonly mounts,\n             * this can only lead to troubles when mounting / readonly.\n             */\n            if (vah_add_path(&buf, fs->src->path, fs->readonly ? \"R\" : \"rw\", true) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->ninputs; i++) {\n        if (ctl->def->inputs[i] &&\n                ctl->def->inputs[i]->type == VIR_DOMAIN_INPUT_TYPE_PASSTHROUGH) {\n            if (vah_add_file(&buf, ctl->def->inputs[i]->source.evdev, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nnets; i++) {\n        if (ctl->def->nets[i] &&\n                ctl->def->nets[i]->type == VIR_DOMAIN_NET_TYPE_VHOSTUSER &&\n                ctl->def->nets[i]->data.vhostuser) {\n            virDomainChrSourceDefPtr vhu = ctl->def->nets[i]->data.vhostuser;\n\n            if (vah_add_file_chardev(&buf, vhu->data.nix.path, \"rw\",\n                       vhu->type) != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nmems; i++) {\n        if (ctl->def->mems[i] &&\n                ctl->def->mems[i]->model == VIR_DOMAIN_MEMORY_MODEL_NVDIMM) {\n            if (vah_add_file(&buf, ctl->def->mems[i]->nvdimmPath, \"rw\") != 0)\n                goto cleanup;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nshmems; i++) {\n        virDomainShmemDef *shmem = ctl->def->shmems[i];\n        /* explicit server paths can be on any model to overwrites defaults.\n         * When the server path is enabled, use it - otherwise fallback to\n         * model dependent defaults. */\n        if (shmem->server.enabled &&\n            shmem->server.chr.data.nix.path) {\n                if (vah_add_file(&buf, shmem->server.chr.data.nix.path,\n                        \"rw\") != 0)\n                    goto cleanup;\n        } else {\n            switch (shmem->model) {\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_PLAIN:\n                /* until exposed, recreate qemuBuildShmemBackendMemProps */\n                mem_path = g_strdup_printf(\"/dev/shm/%s\", shmem->name);\n                break;\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM_DOORBELL:\n            case VIR_DOMAIN_SHMEM_MODEL_IVSHMEM:\n                 /* until exposed, recreate qemuDomainPrepareShmemChardev */\n                mem_path = g_strdup_printf(\"/var/lib/libvirt/shmem-%s-sock\",\n                               shmem->name);\n                break;\n            }\n            if (mem_path != NULL) {\n                if (vah_add_file(&buf, mem_path, \"rw\") != 0)\n                    goto cleanup;\n            }\n        }\n    }\n\n\n    if (ctl->def->tpm) {\n        char *shortName = NULL;\n        const char *tpmpath = NULL;\n\n        switch (ctl->def->tpm->type) {\n        case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n            shortName = virDomainDefGetShortName(ctl->def);\n\n            switch (ctl->def->tpm->version) {\n            case VIR_DOMAIN_TPM_VERSION_1_2:\n                tpmpath = \"tpm1.2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_2_0:\n                tpmpath = \"tpm2\";\n                break;\n            case VIR_DOMAIN_TPM_VERSION_DEFAULT:\n            case VIR_DOMAIN_TPM_VERSION_LAST:\n                break;\n            }\n\n            /* Unix socket for QEMU and swtpm to use */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.sock\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n            /* Paths for swtpm to use: give it access to its state\n             * directory, log, and PID files.\n             */\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/lib/libvirt/swtpm/%s/%s/**\\\" rwk,\\n\",\n                LOCALSTATEDIR, uuidstr, tpmpath);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/log/swtpm/libvirt/qemu/%s-swtpm.log\\\" w,\\n\",\n                LOCALSTATEDIR, ctl->def->name);\n            virBufferAsprintf(&buf,\n                \"  \\\"%s/libvirt/qemu/swtpm/%s-swtpm.pid\\\" rw,\\n\",\n                RUNSTATEDIR, shortName);\n\n            VIR_FREE(shortName);\n            break;\n        case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n        case VIR_DOMAIN_TPM_TYPE_LAST:\n            break;\n        }\n    }\n\n    for (i = 0; i < ctl->def->nsmartcards; i++) {\n        virDomainSmartcardDefPtr sc = ctl->def->smartcards[i];\n        virDomainSmartcardType sc_type = sc->type;\n        char *sc_db = (char *)VIR_DOMAIN_SMARTCARD_DEFAULT_DATABASE;\n        if (sc->data.cert.database)\n            sc_db = sc->data.cert.database;\n        switch (sc_type) {\n            /*\n             * Note: At time of writing, to get this working, qemu seccomp sandbox has\n             * to be disabled or the host must be running QEMU with commit\n             * 9a1565a03b79d80b236bc7cc2dbce52a2ef3a1b8.\n             * It's possibly due to libcacard:vcard_emul_new_event_thread(), which calls\n             * PR_CreateThread(), which calls {g,s}etpriority(). And resourcecontrol seccomp\n             * filter forbids it (cf src/qemu/qemu_command.c which seems to always use\n             * resourcecontrol=deny).\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST:\n                virBufferAddLit(&buf, \"  \\\"/etc/pki/nssdb/{,*}\\\" rk,\\n\");\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_HOST_CERTIFICATES:\n                virBufferAsprintf(&buf, \"  \\\"%s/{,*}\\\" rk,\\n\", sc_db);\n                break;\n            /*\n             * Nothing to do for passthrough, as the smartcard\n             * access is done through TCP or Spice\n             */\n            case VIR_DOMAIN_SMARTCARD_TYPE_PASSTHROUGH:\n                break;\n            case VIR_DOMAIN_SMARTCARD_TYPE_LAST:\n                break;\n        }\n    }\n\n    if (ctl->def->virtType == VIR_DOMAIN_VIRT_KVM) {\n        for (i = 0; i < ctl->def->nnets; i++) {\n            virDomainNetDefPtr net = ctl->def->nets[i];\n            if (net && virDomainNetGetModelString(net)) {\n                if (net->driver.virtio.name == VIR_DOMAIN_NET_BACKEND_TYPE_QEMU)\n                    continue;\n                if (!virDomainNetIsVirtioModel(net))\n                    continue;\n            }\n            needsvhost = true;\n        }\n    }\n    if (needsvhost)\n        virBufferAddLit(&buf, \"  \\\"/dev/vhost-net\\\" rw,\\n\");\n\n    if (needsVfio) {\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/vfio\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/vfio/[0-9]*\\\" rw,\\n\");\n    }\n    if (needsgl) {\n        /* if using gl all sorts of further dri related paths will be needed */\n        virBufferAddLit(&buf, \"  # DRI/Mesa/(e)GL config and driver paths\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib{,32,64}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/@{multiarch}/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/lib/fglrx/dri/*.so*\\\" mr,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/drirc\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/drirc.d/{,*.conf}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/etc/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/glvnd/egl_vendor.d/{,*}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/usr/share/egl/egl_external_platform.d/*\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/modules\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/proc/driver/nvidia/params\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/nvidiactl\\\" rw,\\n\");\n        virBufferAddLit(&buf, \"  # Probe DRI device attributes\\n\");\n        virBufferAddLit(&buf, \"  \\\"/dev/dri/\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  \\\"/sys/devices/**/{uevent,vendor,device,subsystem_vendor,subsystem_device}\\\" r,\\n\");\n        virBufferAddLit(&buf, \"  # dri libs will trigger that, but t is not requited and DAC would deny it anyway\\n\");\n        virBufferAddLit(&buf, \"  deny \\\"/var/lib/libvirt/.cache/\\\" w,\\n\");\n    }\n\n    if (ctl->newfile)\n        if (vah_add_file(&buf, ctl->newfile, \"rwk\") != 0)\n            goto cleanup;\n\n    rc = 0;\n    ctl->files = virBufferContentAndReset(&buf);\n\n cleanup:\n    VIR_FREE(mem_path);\n    VIR_FREE(uuid);\n    return rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "drv->name",
            "\"none\""
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityDriverLookup",
          "args": [
            "name",
            "virtDriver"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDriverLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_driver.c",
          "lines": "48-93",
          "snippet": "virSecurityDriverPtr virSecurityDriverLookup(const char *name,\n                                             const char *virtDriver)\n{\n    virSecurityDriverPtr drv = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n\n    for (i = 0; i < G_N_ELEMENTS(security_drivers) && !drv; i++) {\n        virSecurityDriverPtr tmp = security_drivers[i];\n\n        if (name &&\n            STRNEQ(tmp->name, name))\n            continue;\n\n        switch (tmp->probe(virtDriver)) {\n        case SECURITY_DRIVER_ENABLE:\n            VIR_DEBUG(\"Probed name=%s\", tmp->name);\n            drv = tmp;\n            break;\n\n        case SECURITY_DRIVER_DISABLE:\n            VIR_DEBUG(\"Not enabled name=%s\", tmp->name);\n            if (name && STREQ(tmp->name, name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Security driver %s not enabled\"),\n                               name);\n                return NULL;\n            }\n            break;\n\n        case SECURITY_DRIVER_ERROR:\n        default:\n            return NULL;\n        }\n    }\n\n    if (!drv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Security driver %s not found\"),\n                       NULLSTR(name));\n        return NULL;\n    }\n\n    return drv;\n}",
          "includes": [
            "#include \"security_nop.h\"",
            "# include \"security_apparmor.h\"",
            "# include \"security_selinux.h\"",
            "#include \"security_driver.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virSecurityDriverPtr security_drivers[] = {\n#ifdef WITH_SECDRIVER_SELINUX\n    &virSecurityDriverSELinux,\n#endif\n#ifdef WITH_SECDRIVER_APPARMOR\n    &virAppArmorSecurityDriver,\n#endif\n    &virSecurityDriverNop, /* Must always be last, since it will always probe */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"security_nop.h\"\n# include \"security_apparmor.h\"\n# include \"security_selinux.h\"\n#include \"security_driver.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nstatic virSecurityDriverPtr security_drivers[] = {\n#ifdef WITH_SECDRIVER_SELINUX\n    &virSecurityDriverSELinux,\n#endif\n#ifdef WITH_SECDRIVER_APPARMOR\n    &virAppArmorSecurityDriver,\n#endif\n    &virSecurityDriverNop, /* Must always be last, since it will always probe */\n};\n\nvirSecurityDriverPtr virSecurityDriverLookup(const char *name,\n                                             const char *virtDriver)\n{\n    virSecurityDriverPtr drv = NULL;\n    size_t i;\n\n    VIR_DEBUG(\"name=%s\", NULLSTR(name));\n\n    for (i = 0; i < G_N_ELEMENTS(security_drivers) && !drv; i++) {\n        virSecurityDriverPtr tmp = security_drivers[i];\n\n        if (name &&\n            STRNEQ(tmp->name, name))\n            continue;\n\n        switch (tmp->probe(virtDriver)) {\n        case SECURITY_DRIVER_ENABLE:\n            VIR_DEBUG(\"Probed name=%s\", tmp->name);\n            drv = tmp;\n            break;\n\n        case SECURITY_DRIVER_DISABLE:\n            VIR_DEBUG(\"Not enabled name=%s\", tmp->name);\n            if (name && STREQ(tmp->name, name)) {\n                virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                               _(\"Security driver %s not enabled\"),\n                               name);\n                return NULL;\n            }\n            break;\n\n        case SECURITY_DRIVER_ERROR:\n        default:\n            return NULL;\n        }\n    }\n\n    if (!drv) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Security driver %s not found\"),\n                       NULLSTR(name));\n        return NULL;\n    }\n\n    return drv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr\nvirSecurityManagerNew(const char *name,\n                      const char *virtDriver,\n                      unsigned int flags)\n{\n    virSecurityDriverPtr drv = virSecurityDriverLookup(name, virtDriver);\n    if (!drv)\n        return NULL;\n\n    /* driver \"none\" needs some special handling of *Confined bools */\n    if (STREQ(drv->name, \"none\")) {\n        if (flags & VIR_SECURITY_MANAGER_REQUIRE_CONFINED) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"Security driver \\\"none\\\" cannot create confined guests\"));\n            return NULL;\n        }\n\n        if (flags & VIR_SECURITY_MANAGER_DEFAULT_CONFINED) {\n            if (name != NULL) {\n                VIR_WARN(\"Configured security driver \\\"none\\\" disables default\"\n                         \" policy to create confined guests\");\n            } else {\n                VIR_DEBUG(\"Auto-probed security driver is \\\"none\\\";\"\n                          \" confined guests will not be created\");\n            }\n            flags &= ~VIR_SECURITY_MANAGER_DEFAULT_CONFINED;\n        }\n    }\n\n    return virSecurityManagerNewDriver(drv,\n                                       virtDriver,\n                                       flags);\n}"
  },
  {
    "function_name": "virSecurityManagerNewDAC",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "143-173",
    "snippet": "virSecurityManagerPtr\nvirSecurityManagerNewDAC(const char *virtDriver,\n                         uid_t user,\n                         gid_t group,\n                         unsigned int flags,\n                         virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityManagerPtr mgr;\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK |\n                  VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP |\n                  VIR_SECURITY_MANAGER_MOUNT_NAMESPACE, NULL);\n\n    mgr = virSecurityManagerNewDriver(&virSecurityDriverDAC,\n                                      virtDriver,\n                                      flags & VIR_SECURITY_MANAGER_NEW_MASK);\n\n    if (!mgr)\n        return NULL;\n\n    if (virSecurityDACSetUserAndGroup(mgr, user, group) < 0) {\n        virSecurityManagerDispose(mgr);\n        return NULL;\n    }\n\n    virSecurityDACSetDynamicOwnership(mgr, flags & VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP);\n    virSecurityDACSetMountNamespace(mgr, flags & VIR_SECURITY_MANAGER_MOUNT_NAMESPACE);\n    virSecurityDACSetChownCallback(mgr, chownCallback);\n\n    return mgr;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityDACSetChownCallback",
          "args": [
            "mgr",
            "chownCallback"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetChownCallback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "342-348",
          "snippet": "void\nvirSecurityDACSetChownCallback(virSecurityManagerPtr mgr,\n                               virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->chownCallback = chownCallback;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetChownCallback(virSecurityManagerPtr mgr,\n                               virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->chownCallback = chownCallback;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetMountNamespace",
          "args": [
            "mgr",
            "flags & VIR_SECURITY_MANAGER_MOUNT_NAMESPACE"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetMountNamespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "333-339",
          "snippet": "void\nvirSecurityDACSetMountNamespace(virSecurityManagerPtr mgr,\n                                bool mountNamespace)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->mountNamespace = mountNamespace;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetMountNamespace(virSecurityManagerPtr mgr,\n                                bool mountNamespace)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->mountNamespace = mountNamespace;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetDynamicOwnership",
          "args": [
            "mgr",
            "flags & VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetDynamicOwnership",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "325-331",
          "snippet": "void\nvirSecurityDACSetDynamicOwnership(virSecurityManagerPtr mgr,\n                                  bool dynamicOwnership)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->dynamicOwnership = dynamicOwnership;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nvirSecurityDACSetDynamicOwnership(virSecurityManagerPtr mgr,\n                                  bool dynamicOwnership)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->dynamicOwnership = dynamicOwnership;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerDispose",
          "args": [
            "mgr"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerDispose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "51-59",
          "snippet": "static\nvoid virSecurityManagerDispose(void *obj)\n{\n    virSecurityManagerPtr mgr = obj;\n\n    if (mgr->drv->close)\n        mgr->drv->close(mgr);\n    VIR_FREE(mgr->privateData);\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic\nvoid virSecurityManagerDispose(void *obj)\n{\n    virSecurityManagerPtr mgr = obj;\n\n    if (mgr->drv->close)\n        mgr->drv->close(mgr);\n    VIR_FREE(mgr->privateData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityDACSetUserAndGroup",
          "args": [
            "mgr",
            "user",
            "group"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityDACSetUserAndGroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_dac.c",
          "lines": "310-323",
          "snippet": "int\nvirSecurityDACSetUserAndGroup(virSecurityManagerPtr mgr,\n                              uid_t user,\n                              gid_t group)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->user = user;\n    priv->group = group;\n\n    priv->baselabel = g_strdup_printf(\"+%u:+%u\", (unsigned int)user,\n                                      (unsigned int)group);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virscsivhost.h\"",
            "#include \"virscsi.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"virmdev.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"security_util.h\"",
            "#include \"security_dac.h\"",
            "# include <sys/user.h>",
            "# include <sys/sysctl.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virscsivhost.h\"\n#include \"virscsi.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"virmdev.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"security_util.h\"\n#include \"security_dac.h\"\n# include <sys/user.h>\n# include <sys/sysctl.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityDACSetUserAndGroup(virSecurityManagerPtr mgr,\n                              uid_t user,\n                              gid_t group)\n{\n    virSecurityDACDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    priv->user = user;\n    priv->group = group;\n\n    priv->baselabel = g_strdup_printf(\"+%u:+%u\", (unsigned int)user,\n                                      (unsigned int)group);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerNewDriver",
          "args": [
            "&virSecurityDriverDAC",
            "virtDriver",
            "flags & VIR_SECURITY_MANAGER_NEW_MASK"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerNewDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "74-109",
          "snippet": "static virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSecurityManagerClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr virSecurityManagerClass;\n\nstatic virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_SECURITY_MANAGER_NEW_MASK |\n                  VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP |\n                  VIR_SECURITY_MANAGER_MOUNT_NAMESPACE",
            "NULL"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr\nvirSecurityManagerNewDAC(const char *virtDriver,\n                         uid_t user,\n                         gid_t group,\n                         unsigned int flags,\n                         virSecurityManagerDACChownCallback chownCallback)\n{\n    virSecurityManagerPtr mgr;\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK |\n                  VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP |\n                  VIR_SECURITY_MANAGER_MOUNT_NAMESPACE, NULL);\n\n    mgr = virSecurityManagerNewDriver(&virSecurityDriverDAC,\n                                      virtDriver,\n                                      flags & VIR_SECURITY_MANAGER_NEW_MASK);\n\n    if (!mgr)\n        return NULL;\n\n    if (virSecurityDACSetUserAndGroup(mgr, user, group) < 0) {\n        virSecurityManagerDispose(mgr);\n        return NULL;\n    }\n\n    virSecurityDACSetDynamicOwnership(mgr, flags & VIR_SECURITY_MANAGER_DYNAMIC_OWNERSHIP);\n    virSecurityDACSetMountNamespace(mgr, flags & VIR_SECURITY_MANAGER_MOUNT_NAMESPACE);\n    virSecurityDACSetChownCallback(mgr, chownCallback);\n\n    return mgr;\n}"
  },
  {
    "function_name": "virSecurityManagerStackAddNested",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "133-140",
    "snippet": "int\nvirSecurityManagerStackAddNested(virSecurityManagerPtr stack,\n                                 virSecurityManagerPtr nested)\n{\n    if (STRNEQ(\"stack\", stack->drv->name))\n        return -1;\n    return virSecurityStackAddNested(stack, nested);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virSecurityStackAddNested",
          "args": [
            "stack",
            "nested"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityStackAddNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_stack.c",
          "lines": "47-69",
          "snippet": "int\nvirSecurityStackAddNested(virSecurityManagerPtr mgr,\n                          virSecurityManagerPtr nested)\n{\n    virSecurityStackItemPtr item = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr tmp;\n\n    tmp = priv->itemsHead;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n    item->securityManager = nested;\n    item->prev = tmp;\n    if (tmp)\n        tmp->next = item;\n    else\n        priv->itemsHead = item;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_stack.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_stack.h\"\n#include <config.h>\n\nint\nvirSecurityStackAddNested(virSecurityManagerPtr mgr,\n                          virSecurityManagerPtr nested)\n{\n    virSecurityStackItemPtr item = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr tmp;\n\n    tmp = priv->itemsHead;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n    item->securityManager = nested;\n    item->prev = tmp;\n    if (tmp)\n        tmp->next = item;\n    else\n        priv->itemsHead = item;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "\"stack\"",
            "stack->drv->name"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirSecurityManagerStackAddNested(virSecurityManagerPtr stack,\n                                 virSecurityManagerPtr nested)\n{\n    if (STRNEQ(\"stack\", stack->drv->name))\n        return -1;\n    return virSecurityStackAddNested(stack, nested);\n}"
  },
  {
    "function_name": "virSecurityManagerNewStack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "112-130",
    "snippet": "virSecurityManagerPtr\nvirSecurityManagerNewStack(virSecurityManagerPtr primary)\n{\n    virSecurityManagerPtr mgr =\n        virSecurityManagerNewDriver(&virSecurityDriverStack,\n                                    virSecurityManagerGetVirtDriver(primary),\n                                    primary->flags);\n\n    if (!mgr)\n        return NULL;\n\n    if (virSecurityStackAddNested(mgr, primary) < 0)\n        goto error;\n\n    return mgr;\n error:\n    virObjectUnref(mgr);\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mgr"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityStackAddNested",
          "args": [
            "mgr",
            "primary"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityStackAddNested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_stack.c",
          "lines": "47-69",
          "snippet": "int\nvirSecurityStackAddNested(virSecurityManagerPtr mgr,\n                          virSecurityManagerPtr nested)\n{\n    virSecurityStackItemPtr item = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr tmp;\n\n    tmp = priv->itemsHead;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n    item->securityManager = nested;\n    item->prev = tmp;\n    if (tmp)\n        tmp->next = item;\n    else\n        priv->itemsHead = item;\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_stack.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_stack.h\"\n#include <config.h>\n\nint\nvirSecurityStackAddNested(virSecurityManagerPtr mgr,\n                          virSecurityManagerPtr nested)\n{\n    virSecurityStackItemPtr item = NULL;\n    virSecurityStackDataPtr priv = virSecurityManagerGetPrivateData(mgr);\n    virSecurityStackItemPtr tmp;\n\n    tmp = priv->itemsHead;\n    while (tmp && tmp->next)\n        tmp = tmp->next;\n\n    if (VIR_ALLOC(item) < 0)\n        return -1;\n    item->securityManager = nested;\n    item->prev = tmp;\n    if (tmp)\n        tmp->next = item;\n    else\n        priv->itemsHead = item;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerNewDriver",
          "args": [
            "&virSecurityDriverStack",
            "virSecurityManagerGetVirtDriver(primary)",
            "primary->flags"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerNewDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "74-109",
          "snippet": "static virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virSecurityManagerClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr virSecurityManagerClass;\n\nstatic virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virSecurityManagerGetVirtDriver",
          "args": [
            "primary"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "virSecurityManagerGetVirtDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
          "lines": "328-332",
          "snippet": "const char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}",
          "includes": [
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virobject.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"security_dac.h\"",
            "#include \"security_stack.h\"",
            "#include \"security_driver.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nconst char *\nvirSecurityManagerGetVirtDriver(virSecurityManagerPtr mgr)\n{\n    return mgr->virtDriver;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirSecurityManagerPtr\nvirSecurityManagerNewStack(virSecurityManagerPtr primary)\n{\n    virSecurityManagerPtr mgr =\n        virSecurityManagerNewDriver(&virSecurityDriverStack,\n                                    virSecurityManagerGetVirtDriver(primary),\n                                    primary->flags);\n\n    if (!mgr)\n        return NULL;\n\n    if (virSecurityStackAddNested(mgr, primary) < 0)\n        goto error;\n\n    return mgr;\n error:\n    virObjectUnref(mgr);\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerNewDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "74-109",
    "snippet": "static virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virSecurityManagerClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mgr"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "privateData"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "drv->open",
          "args": [
            "mgr"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&privateData"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virSecurityManagerClass"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "privateData",
            "drv->privateDataLen"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCheckFlags",
          "args": [
            "VIR_SECURITY_MANAGER_NEW_MASK",
            "NULL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"drv=%p (%s) virtDriver=%s flags=0x%x\"",
            "drv",
            "drv->name",
            "virtDriver",
            "flags"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virSecurityManagerInitialize",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic virClassPtr virSecurityManagerClass;\n\nstatic virSecurityManagerPtr\nvirSecurityManagerNewDriver(virSecurityDriverPtr drv,\n                            const char *virtDriver,\n                            unsigned int flags)\n{\n    virSecurityManagerPtr mgr = NULL;\n    char *privateData = NULL;\n\n    if (virSecurityManagerInitialize() < 0)\n        return NULL;\n\n    VIR_DEBUG(\"drv=%p (%s) virtDriver=%s flags=0x%x\",\n              drv, drv->name, virtDriver, flags);\n\n    virCheckFlags(VIR_SECURITY_MANAGER_NEW_MASK, NULL);\n\n    if (VIR_ALLOC_N(privateData, drv->privateDataLen) < 0)\n        return NULL;\n\n    if (!(mgr = virObjectLockableNew(virSecurityManagerClass)))\n        goto error;\n\n    mgr->drv = drv;\n    mgr->flags = flags;\n    mgr->virtDriver = virtDriver;\n    mgr->privateData = g_steal_pointer(&privateData);\n\n    if (drv->open(mgr) < 0)\n        goto error;\n\n    return mgr;\n error:\n    VIR_FREE(privateData);\n    virObjectUnref(mgr);\n    return NULL;\n}"
  },
  {
    "function_name": "virSecurityManagerOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "62-69",
    "snippet": "static int\nvirSecurityManagerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virSecurityManager, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virSecurityManager",
            "virClassForObjectLockable()"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic int\nvirSecurityManagerOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virSecurityManager, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virSecurityManagerDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/security/security_manager.c",
    "lines": "51-59",
    "snippet": "static\nvoid virSecurityManagerDispose(void *obj)\n{\n    virSecurityManagerPtr mgr = obj;\n\n    if (mgr->drv->close)\n        mgr->drv->close(mgr);\n    VIR_FREE(mgr->privateData);\n}",
    "includes": [
      "#include \"virfile.h\"",
      "#include \"virlog.h\"",
      "#include \"virobject.h\"",
      "#include \"viralloc.h\"",
      "#include \"virerror.h\"",
      "#include \"security_dac.h\"",
      "#include \"security_stack.h\"",
      "#include \"security_driver.h\"",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mgr->privateData"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mgr->drv->close",
          "args": [
            "mgr"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virobject.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"security_dac.h\"\n#include \"security_stack.h\"\n#include \"security_driver.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic\nvoid virSecurityManagerDispose(void *obj)\n{\n    virSecurityManagerPtr mgr = obj;\n\n    if (mgr->drv->close)\n        mgr->drv->close(mgr);\n    VIR_FREE(mgr->privateData);\n}"
  }
]