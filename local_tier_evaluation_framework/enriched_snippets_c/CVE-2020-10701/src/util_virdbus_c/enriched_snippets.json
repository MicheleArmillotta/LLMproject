[
  {
    "function_name": "virDBusErrorIsUnknownMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1864-1871",
    "snippet": "bool virDBusErrorIsUnknownMethod(virErrorPtr err)\n{\n    return err->domain == VIR_FROM_DBUS &&\n        err->code == VIR_ERR_DBUS_SERVICE &&\n        err->level == VIR_ERR_ERROR &&\n        STREQ_NULLABLE(\"org.freedesktop.DBus.Error.UnknownMethod\",\n                       err->str1);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ_NULLABLE",
          "args": [
            "\"org.freedesktop.DBus.Error.UnknownMethod\"",
            "err->str1"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nbool virDBusErrorIsUnknownMethod(virErrorPtr err)\n{\n    return err->domain == VIR_FROM_DBUS &&\n        err->code == VIR_ERR_DBUS_SERVICE &&\n        err->level == VIR_ERR_ERROR &&\n        STREQ_NULLABLE(\"org.freedesktop.DBus.Error.UnknownMethod\",\n                       err->str1);\n}"
  },
  {
    "function_name": "virDBusMessageUnref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1858-1861",
    "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
  },
  {
    "function_name": "virDBusIsServiceRegistered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1852-1856",
    "snippet": "int virDBusIsServiceRegistered(const char *name G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return -2;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusIsServiceRegistered(const char *name G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return -2;\n}"
  },
  {
    "function_name": "virDBusIsServiceEnabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1846-1850",
    "snippet": "int virDBusIsServiceEnabled(const char *name G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return -2;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusIsServiceEnabled(const char *name G_GNUC_UNUSED)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return -2;\n}"
  },
  {
    "function_name": "virDBusMessageDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1837-1844",
    "snippet": "int virDBusMessageDecode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1841
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1842
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageDecode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusMessageEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1828-1835",
    "snippet": "int virDBusMessageEncode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageEncode(DBusMessage* msg G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusCallMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1813-1825",
    "snippet": "int virDBusCallMethod(DBusConnection *conn G_GNUC_UNUSED,\n                      DBusMessage **reply G_GNUC_UNUSED,\n                      virErrorPtr error G_GNUC_UNUSED,\n                      const char *destination G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      const char *iface G_GNUC_UNUSED,\n                      const char *member G_GNUC_UNUSED,\n                      const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCallMethod(DBusConnection *conn G_GNUC_UNUSED,\n                      DBusMessage **reply G_GNUC_UNUSED,\n                      virErrorPtr error G_GNUC_UNUSED,\n                      const char *destination G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      const char *iface G_GNUC_UNUSED,\n                      const char *member G_GNUC_UNUSED,\n                      const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusCreateReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1805-1811",
    "snippet": "int virDBusCreateReply(DBusMessage **reply G_GNUC_UNUSED,\n                       const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateReply(DBusMessage **reply G_GNUC_UNUSED,\n                       const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusCreateReplyV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1796-1803",
    "snippet": "int virDBusCreateReplyV(DBusMessage **reply G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED,\n                        va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateReplyV(DBusMessage **reply G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED,\n                        va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusCreateMethodV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1783-1794",
    "snippet": "int virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1792
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusCreateMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1771-1781",
    "snippet": "int virDBusCreateMethod(DBusMessage **call G_GNUC_UNUSED,\n                        const char *destination G_GNUC_UNUSED,\n                        const char *path G_GNUC_UNUSED,\n                        const char *iface G_GNUC_UNUSED,\n                        const char *member G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1779
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethod(DBusMessage **call G_GNUC_UNUSED,\n                        const char *destination G_GNUC_UNUSED,\n                        const char *path G_GNUC_UNUSED,\n                        const char *iface G_GNUC_UNUSED,\n                        const char *member G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
  },
  {
    "function_name": "virDBusGetSessionBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1764-1769",
    "snippet": "DBusConnection *virDBusGetSessionBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1767
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSessionBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
  },
  {
    "function_name": "virDBusCloseSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1759-1762",
    "snippet": "void virDBusCloseSystemBus(void)\n{\n    /* nothing */\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusCloseSystemBus(void)\n{\n    /* nothing */\n}"
  },
  {
    "function_name": "virDBusHasSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1752-1757",
    "snippet": "bool\nvirDBusHasSystemBus(void)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return false;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nbool\nvirDBusHasSystemBus(void)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return false;\n}"
  },
  {
    "function_name": "virDBusGetSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1744-1749",
    "snippet": "DBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus support not compiled into this binary\")"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus support not compiled into this binary\""
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
  },
  {
    "function_name": "virDBusSetSharedBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1739-1742",
    "snippet": "void virDBusSetSharedBus(bool shared G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusSetSharedBus(bool shared G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
  },
  {
    "function_name": "virDBusMessageUnref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1732-1736",
    "snippet": "void virDBusMessageUnref(DBusMessage *msg)\n{\n    if (msg)\n        dbus_message_unref(msg);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_message_unref",
          "args": [
            "msg"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg)\n{\n    if (msg)\n        dbus_message_unref(msg);\n}"
  },
  {
    "function_name": "virDBusIsServiceRegistered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1723-1730",
    "snippet": "int virDBusIsServiceRegistered(const char *name)\n{\n    int ret = virDBusIsServiceInList(\"ListNames\", name);\n\n    VIR_DEBUG(\"Service %s is %s\", name, ret ? \"not registered\" : \"registered\");\n\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Service %s is %s\"",
            "name",
            "ret ? \"not registered\" : \"registered\""
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusIsServiceInList",
          "args": [
            "\"ListNames\"",
            "name"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsServiceInList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1653-1700",
          "snippet": "static int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusIsServiceRegistered(const char *name)\n{\n    int ret = virDBusIsServiceInList(\"ListNames\", name);\n\n    VIR_DEBUG(\"Service %s is %s\", name, ret ? \"not registered\" : \"registered\");\n\n    return ret;\n}"
  },
  {
    "function_name": "virDBusIsServiceEnabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1708-1715",
    "snippet": "int virDBusIsServiceEnabled(const char *name)\n{\n    int ret = virDBusIsServiceInList(\"ListActivatableNames\", name);\n\n    VIR_DEBUG(\"Service %s is %s\", name, ret ? \"unavailable\" : \"available\");\n\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Service %s is %s\"",
            "name",
            "ret ? \"unavailable\" : \"available\""
          ],
          "line": 1712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusIsServiceInList",
          "args": [
            "\"ListActivatableNames\"",
            "name"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsServiceInList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1653-1700",
          "snippet": "static int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusIsServiceEnabled(const char *name)\n{\n    int ret = virDBusIsServiceInList(\"ListActivatableNames\", name);\n\n    VIR_DEBUG(\"Service %s is %s\", name, ret ? \"unavailable\" : \"available\");\n\n    return ret;\n}"
  },
  {
    "function_name": "virDBusIsServiceInList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1653-1700",
    "snippet": "static int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageUnref",
          "args": [
            "reply"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1858-1861",
          "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "service",
            "name"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_next",
          "args": [
            "&sub"
          ],
          "line": 1689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_basic",
          "args": [
            "&sub",
            "&service"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_arg_type",
          "args": [
            "&sub"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_recurse",
          "args": [
            "&iter",
            "&sub"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Reply message incorrect\")"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Reply message incorrect\""
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_arg_type",
          "args": [
            "&iter"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_init",
          "args": [
            "reply",
            "&iter"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCallMethod",
          "args": [
            "conn",
            "&reply",
            "NULL",
            "\"org.freedesktop.DBus\"",
            "\"/org/freedesktop/DBus\"",
            "\"org.freedesktop.DBus\"",
            "listMethod",
            "NULL"
          ],
          "line": 1666
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCallMethod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1813-1825",
          "snippet": "int virDBusCallMethod(DBusConnection *conn G_GNUC_UNUSED,\n                      DBusMessage **reply G_GNUC_UNUSED,\n                      virErrorPtr error G_GNUC_UNUSED,\n                      const char *destination G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      const char *iface G_GNUC_UNUSED,\n                      const char *member G_GNUC_UNUSED,\n                      const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCallMethod(DBusConnection *conn G_GNUC_UNUSED,\n                      DBusMessage **reply G_GNUC_UNUSED,\n                      virErrorPtr error G_GNUC_UNUSED,\n                      const char *destination G_GNUC_UNUSED,\n                      const char *path G_GNUC_UNUSED,\n                      const char *iface G_GNUC_UNUSED,\n                      const char *member G_GNUC_UNUSED,\n                      const char *types G_GNUC_UNUSED, ...)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBus",
          "args": [],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1744-1749",
          "snippet": "DBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSystemBus(void)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusHasSystemBus",
          "args": [],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusHasSystemBus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1752-1757",
          "snippet": "bool\nvirDBusHasSystemBus(void)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return false;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nbool\nvirDBusHasSystemBus(void)\n{\n    VIR_DEBUG(\"DBus support not compiled into this binary\");\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusIsServiceInList(const char *listMethod, const char *name)\n{\n    DBusConnection *conn;\n    DBusMessage *reply = NULL;\n    DBusMessageIter iter, sub;\n    int ret = -1;\n\n    if (!virDBusHasSystemBus())\n        return -2;\n\n    if (!(conn = virDBusGetSystemBus()))\n        return -1;\n\n    if (virDBusCallMethod(conn,\n                          &reply,\n                          NULL,\n                          \"org.freedesktop.DBus\",\n                          \"/org/freedesktop/DBus\",\n                          \"org.freedesktop.DBus\",\n                          listMethod,\n                          NULL) < 0)\n        return ret;\n\n    if (!dbus_message_iter_init(reply, &iter) ||\n        dbus_message_iter_get_arg_type(&iter) != DBUS_TYPE_ARRAY) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Reply message incorrect\"));\n        goto cleanup;\n    }\n\n    ret = -2;\n    dbus_message_iter_recurse(&iter, &sub);\n    while (dbus_message_iter_get_arg_type(&sub) == DBUS_TYPE_STRING) {\n        const char *service = NULL;\n\n        dbus_message_iter_get_basic(&sub, &service);\n        dbus_message_iter_next(&sub);\n\n        if (STREQ(service, name)) {\n            ret = 0;\n            break;\n        }\n    }\n\n cleanup:\n    virDBusMessageUnref(reply);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusCallMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1625-1650",
    "snippet": "int virDBusCallMethod(DBusConnection *conn,\n                      DBusMessage **replyout,\n                      virErrorPtr error,\n                      const char *destination,\n                      const char *path,\n                      const char *iface,\n                      const char *member,\n                      const char *types, ...)\n{\n    DBusMessage *call = NULL;\n    int ret = -1;\n    va_list args;\n\n    va_start(args, types);\n    ret = virDBusCreateMethodV(&call, destination, path,\n                               iface, member, types, args);\n    va_end(args);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virDBusCall(conn, call, replyout, error);\n\n cleanup:\n    virDBusMessageUnref(call);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageUnref",
          "args": [
            "call"
          ],
          "line": 1648
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1858-1861",
          "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusCall",
          "args": [
            "conn",
            "call",
            "replyout",
            "error"
          ],
          "line": 1645
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1522-1587",
          "snippet": "static int\nvirDBusCall(DBusConnection *conn,\n            DBusMessage *call,\n            DBusMessage **replyout,\n            virErrorPtr error)\n\n{\n    DBusMessage *reply = NULL;\n    DBusError localerror;\n    int ret = -1;\n    const char *iface, *member, *path, *dest;\n\n    dbus_error_init(&localerror);\n    if (error)\n        memset(error, 0, sizeof(*error));\n\n    iface = dbus_message_get_interface(call);\n    member = dbus_message_get_member(call);\n    path = dbus_message_get_path(call);\n    dest = dbus_message_get_destination(call);\n\n    PROBE(DBUS_METHOD_CALL,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    if (!(reply = dbus_connection_send_with_reply_and_block(conn,\n                                                            call,\n                                                            VIR_DBUS_METHOD_CALL_TIMEOUT_MILLIS,\n                                                            &localerror))) {\n        PROBE(DBUS_METHOD_ERROR,\n              \"'%s.%s' on '%s' at '%s' error %s: %s\",\n              iface, member, path, dest,\n              localerror.name,\n              localerror.message);\n        if (error) {\n            error->level = VIR_ERR_ERROR;\n            error->code = VIR_ERR_DBUS_SERVICE;\n            error->domain = VIR_FROM_DBUS;\n            error->message = g_strdup(localerror.message);\n            error->str1 = g_strdup(localerror.name);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_DBUS_SERVICE, _(\"%s: %s\"), member,\n                           localerror.message ? : _(\"unknown error\"));\n        }\n        goto cleanup;\n    }\n\n    PROBE(DBUS_METHOD_REPLY,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && error)\n        virResetError(error);\n    dbus_error_free(&localerror);\n    if (reply) {\n        if (ret == 0 && replyout)\n            *replyout = reply;\n        else\n            virDBusMessageUnref(reply);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusCall(DBusConnection *conn,\n            DBusMessage *call,\n            DBusMessage **replyout,\n            virErrorPtr error)\n\n{\n    DBusMessage *reply = NULL;\n    DBusError localerror;\n    int ret = -1;\n    const char *iface, *member, *path, *dest;\n\n    dbus_error_init(&localerror);\n    if (error)\n        memset(error, 0, sizeof(*error));\n\n    iface = dbus_message_get_interface(call);\n    member = dbus_message_get_member(call);\n    path = dbus_message_get_path(call);\n    dest = dbus_message_get_destination(call);\n\n    PROBE(DBUS_METHOD_CALL,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    if (!(reply = dbus_connection_send_with_reply_and_block(conn,\n                                                            call,\n                                                            VIR_DBUS_METHOD_CALL_TIMEOUT_MILLIS,\n                                                            &localerror))) {\n        PROBE(DBUS_METHOD_ERROR,\n              \"'%s.%s' on '%s' at '%s' error %s: %s\",\n              iface, member, path, dest,\n              localerror.name,\n              localerror.message);\n        if (error) {\n            error->level = VIR_ERR_ERROR;\n            error->code = VIR_ERR_DBUS_SERVICE;\n            error->domain = VIR_FROM_DBUS;\n            error->message = g_strdup(localerror.message);\n            error->str1 = g_strdup(localerror.name);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_DBUS_SERVICE, _(\"%s: %s\"), member,\n                           localerror.message ? : _(\"unknown error\"));\n        }\n        goto cleanup;\n    }\n\n    PROBE(DBUS_METHOD_REPLY,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && error)\n        virResetError(error);\n    dbus_error_free(&localerror);\n    if (reply) {\n        if (ret == 0 && replyout)\n            *replyout = reply;\n        else\n            virDBusMessageUnref(reply);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCreateMethodV",
          "args": [
            "&call",
            "destination",
            "path",
            "iface",
            "member",
            "types",
            "args"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCreateMethodV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1783-1794",
          "snippet": "int virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "types"
          ],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCallMethod(DBusConnection *conn,\n                      DBusMessage **replyout,\n                      virErrorPtr error,\n                      const char *destination,\n                      const char *path,\n                      const char *iface,\n                      const char *member,\n                      const char *types, ...)\n{\n    DBusMessage *call = NULL;\n    int ret = -1;\n    va_list args;\n\n    va_start(args, types);\n    ret = virDBusCreateMethodV(&call, destination, path,\n                               iface, member, types, args);\n    va_end(args);\n    if (ret < 0)\n        goto cleanup;\n\n    ret = virDBusCall(conn, call, replyout, error);\n\n cleanup:\n    virDBusMessageUnref(call);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusCall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1522-1587",
    "snippet": "static int\nvirDBusCall(DBusConnection *conn,\n            DBusMessage *call,\n            DBusMessage **replyout,\n            virErrorPtr error)\n\n{\n    DBusMessage *reply = NULL;\n    DBusError localerror;\n    int ret = -1;\n    const char *iface, *member, *path, *dest;\n\n    dbus_error_init(&localerror);\n    if (error)\n        memset(error, 0, sizeof(*error));\n\n    iface = dbus_message_get_interface(call);\n    member = dbus_message_get_member(call);\n    path = dbus_message_get_path(call);\n    dest = dbus_message_get_destination(call);\n\n    PROBE(DBUS_METHOD_CALL,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    if (!(reply = dbus_connection_send_with_reply_and_block(conn,\n                                                            call,\n                                                            VIR_DBUS_METHOD_CALL_TIMEOUT_MILLIS,\n                                                            &localerror))) {\n        PROBE(DBUS_METHOD_ERROR,\n              \"'%s.%s' on '%s' at '%s' error %s: %s\",\n              iface, member, path, dest,\n              localerror.name,\n              localerror.message);\n        if (error) {\n            error->level = VIR_ERR_ERROR;\n            error->code = VIR_ERR_DBUS_SERVICE;\n            error->domain = VIR_FROM_DBUS;\n            error->message = g_strdup(localerror.message);\n            error->str1 = g_strdup(localerror.name);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_DBUS_SERVICE, _(\"%s: %s\"), member,\n                           localerror.message ? : _(\"unknown error\"));\n        }\n        goto cleanup;\n    }\n\n    PROBE(DBUS_METHOD_REPLY,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && error)\n        virResetError(error);\n    dbus_error_free(&localerror);\n    if (reply) {\n        if (ret == 0 && replyout)\n            *replyout = reply;\n        else\n            virDBusMessageUnref(reply);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageUnref",
          "args": [
            "reply"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1858-1861",
          "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_error_free",
          "args": [
            "&localerror"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virResetError",
          "args": [
            "error"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "virResetError",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "466-476",
          "snippet": "void\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirResetError(virErrorPtr err)\n{\n    if (err == NULL)\n        return;\n    VIR_FREE(err->message);\n    VIR_FREE(err->str1);\n    VIR_FREE(err->str2);\n    VIR_FREE(err->str3);\n    memset(err, 0, sizeof(virError));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "DBUS_METHOD_REPLY",
            "\"'%s.%s' on '%s' at '%s'\"",
            "iface",
            "member",
            "path",
            "dest"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_DBUS_SERVICE",
            "_(\"%s: %s\")",
            "member",
            "localerror.message ? : _(\"unknown error\")"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown error\""
          ],
          "line": 1565
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "DBUS_METHOD_ERROR",
            "\"'%s.%s' on '%s' at '%s' error %s: %s\"",
            "iface",
            "member",
            "path",
            "dest",
            "localerror.name",
            "localerror.message"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_send_with_reply_and_block",
          "args": [
            "conn",
            "call",
            "VIR_DBUS_METHOD_CALL_TIMEOUT_MILLIS",
            "&localerror"
          ],
          "line": 1547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROBE",
          "args": [
            "DBUS_METHOD_CALL",
            "\"'%s.%s' on '%s' at '%s'\"",
            "iface",
            "member",
            "path",
            "dest"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_get_destination",
          "args": [
            "call"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_get_path",
          "args": [
            "call"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_get_member",
          "args": [
            "call"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_get_interface",
          "args": [
            "call"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "error",
            "0",
            "sizeof(*error)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "&localerror"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusCall(DBusConnection *conn,\n            DBusMessage *call,\n            DBusMessage **replyout,\n            virErrorPtr error)\n\n{\n    DBusMessage *reply = NULL;\n    DBusError localerror;\n    int ret = -1;\n    const char *iface, *member, *path, *dest;\n\n    dbus_error_init(&localerror);\n    if (error)\n        memset(error, 0, sizeof(*error));\n\n    iface = dbus_message_get_interface(call);\n    member = dbus_message_get_member(call);\n    path = dbus_message_get_path(call);\n    dest = dbus_message_get_destination(call);\n\n    PROBE(DBUS_METHOD_CALL,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    if (!(reply = dbus_connection_send_with_reply_and_block(conn,\n                                                            call,\n                                                            VIR_DBUS_METHOD_CALL_TIMEOUT_MILLIS,\n                                                            &localerror))) {\n        PROBE(DBUS_METHOD_ERROR,\n              \"'%s.%s' on '%s' at '%s' error %s: %s\",\n              iface, member, path, dest,\n              localerror.name,\n              localerror.message);\n        if (error) {\n            error->level = VIR_ERR_ERROR;\n            error->code = VIR_ERR_DBUS_SERVICE;\n            error->domain = VIR_FROM_DBUS;\n            error->message = g_strdup(localerror.message);\n            error->str1 = g_strdup(localerror.name);\n            ret = 0;\n        } else {\n            virReportError(VIR_ERR_DBUS_SERVICE, _(\"%s: %s\"), member,\n                           localerror.message ? : _(\"unknown error\"));\n        }\n        goto cleanup;\n    }\n\n    PROBE(DBUS_METHOD_REPLY,\n          \"'%s.%s' on '%s' at '%s'\",\n          iface, member, path, dest);\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0 && error)\n        virResetError(error);\n    dbus_error_free(&localerror);\n    if (reply) {\n        if (ret == 0 && replyout)\n            *replyout = reply;\n        else\n            virDBusMessageUnref(reply);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virDBusCreateReply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1487-1498",
    "snippet": "int virDBusCreateReply(DBusMessage **reply,\n                       const char *types, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, types);\n    ret = virDBusCreateReplyV(reply, types, args);\n    va_end(args);\n\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCreateReplyV",
          "args": [
            "reply",
            "types",
            "args"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCreateReplyV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1796-1803",
          "snippet": "int virDBusCreateReplyV(DBusMessage **reply G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED,\n                        va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateReplyV(DBusMessage **reply G_GNUC_UNUSED,\n                        const char *types G_GNUC_UNUSED,\n                        va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "types"
          ],
          "line": 1493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateReply(DBusMessage **reply,\n                       const char *types, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, types);\n    ret = virDBusCreateReplyV(reply, types, args);\n    va_end(args);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDBusCreateReplyV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1459-1475",
    "snippet": "int virDBusCreateReplyV(DBusMessage **reply,\n                        const char *types,\n                        va_list args)\n{\n    if (!(*reply = dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_RETURN))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDBusMessageEncodeArgs(*reply, types, args) < 0) {\n        virDBusMessageUnref(*reply);\n        *reply = NULL;\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageUnref",
          "args": [
            "*reply"
          ],
          "line": 1469
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1858-1861",
          "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusMessageEncodeArgs",
          "args": [
            "*reply",
            "types",
            "args"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageEncodeArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1174-1186",
          "snippet": "int\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_new",
          "args": [
            "DBUS_MESSAGE_TYPE_METHOD_RETURN"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateReplyV(DBusMessage **reply,\n                        const char *types,\n                        va_list args)\n{\n    if (!(*reply = dbus_message_new(DBUS_MESSAGE_TYPE_METHOD_RETURN))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDBusMessageEncodeArgs(*reply, types, args) < 0) {\n        virDBusMessageUnref(*reply);\n        *reply = NULL;\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDBusCreateMethod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1426-1442",
    "snippet": "int virDBusCreateMethod(DBusMessage **call,\n                        const char *destination,\n                        const char *path,\n                        const char *iface,\n                        const char *member,\n                        const char *types, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, types);\n    ret = virDBusCreateMethodV(call, destination, path,\n                               iface, member, types, args);\n    va_end(args);\n\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCreateMethodV",
          "args": [
            "call",
            "destination",
            "path",
            "iface",
            "member",
            "types",
            "args"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCreateMethodV",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1783-1794",
          "snippet": "int virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethodV(DBusMessage **call G_GNUC_UNUSED,\n                         const char *destination G_GNUC_UNUSED,\n                         const char *path G_GNUC_UNUSED,\n                         const char *iface G_GNUC_UNUSED,\n                         const char *member G_GNUC_UNUSED,\n                         const char *types G_GNUC_UNUSED,\n                         va_list args G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   \"%s\", _(\"DBus support not compiled into this binary\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "types"
          ],
          "line": 1436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethod(DBusMessage **call,\n                        const char *destination,\n                        const char *path,\n                        const char *iface,\n                        const char *member,\n                        const char *types, ...)\n{\n    va_list args;\n    int ret;\n\n    va_start(args, types);\n    ret = virDBusCreateMethodV(call, destination, path,\n                               iface, member, types, args);\n    va_end(args);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDBusCreateMethodV",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1387-1410",
    "snippet": "int virDBusCreateMethodV(DBusMessage **call,\n                         const char *destination,\n                         const char *path,\n                         const char *iface,\n                         const char *member,\n                         const char *types,\n                         va_list args)\n{\n    if (!(*call = dbus_message_new_method_call(destination,\n                                               path,\n                                               iface,\n                                               member))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDBusMessageEncodeArgs(*call, types, args) < 0) {\n        virDBusMessageUnref(*call);\n        *call = NULL;\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageUnref",
          "args": [
            "*call"
          ],
          "line": 1404
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1858-1861",
          "snippet": "void virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusMessageUnref(DBusMessage *msg G_GNUC_UNUSED)\n{\n    /* nothing */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusMessageEncodeArgs",
          "args": [
            "*call",
            "types",
            "args"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageEncodeArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1174-1186",
          "snippet": "int\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_new_method_call",
          "args": [
            "destination",
            "path",
            "iface",
            "member"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusCreateMethodV(DBusMessage **call,\n                         const char *destination,\n                         const char *path,\n                         const char *iface,\n                         const char *member,\n                         const char *types,\n                         va_list args)\n{\n    if (!(*call = dbus_message_new_method_call(destination,\n                                               path,\n                                               iface,\n                                               member))) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDBusMessageEncodeArgs(*call, types, args) < 0) {\n        virDBusMessageUnref(*call);\n        *call = NULL;\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDBusMessageDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1236-1247",
    "snippet": "int\nvirDBusMessageDecode(DBusMessage* msg,\n                     const char *types,\n                     ...)\n{\n    int ret;\n    va_list args;\n    va_start(args, types);\n    ret = virDBusMessageDecodeArgs(msg, types, args);\n    va_end(args);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusMessageDecodeArgs",
          "args": [
            "msg",
            "types",
            "args"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageDecodeArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1189-1207",
          "snippet": "int virDBusMessageDecodeArgs(DBusMessage* msg,\n                             const char *types,\n                             va_list args)\n{\n    DBusMessageIter iter;\n\n    if (!dbus_message_iter_init(msg, &iter)) {\n        if (*types != '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No args present for signature %s\"),\n                           types);\n        } else {\n            return 0;\n        }\n        return -1;\n    }\n\n    return virDBusMessageIterDecode(&iter, types, args);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageDecodeArgs(DBusMessage* msg,\n                             const char *types,\n                             va_list args)\n{\n    DBusMessageIter iter;\n\n    if (!dbus_message_iter_init(msg, &iter)) {\n        if (*types != '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No args present for signature %s\"),\n                           types);\n        } else {\n            return 0;\n        }\n        return -1;\n    }\n\n    return virDBusMessageIterDecode(&iter, types, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "types"
          ],
          "line": 1243
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint\nvirDBusMessageDecode(DBusMessage* msg,\n                     const char *types,\n                     ...)\n{\n    int ret;\n    va_list args;\n    va_start(args, types);\n    ret = virDBusMessageDecodeArgs(msg, types, args);\n    va_end(args);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusMessageEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1210-1220",
    "snippet": "int virDBusMessageEncode(DBusMessage* msg,\n                         const char *types,\n                         ...)\n{\n    int ret;\n    va_list args;\n    va_start(args, types);\n    ret = virDBusMessageEncodeArgs(msg, types, args);\n    va_end(args);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusMessageEncodeArgs",
          "args": [
            "msg",
            "types",
            "args"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageEncodeArgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "1174-1186",
          "snippet": "int\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "types"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageEncode(DBusMessage* msg,\n                         const char *types,\n                         ...)\n{\n    int ret;\n    va_list args;\n    va_start(args, types);\n    ret = virDBusMessageEncodeArgs(msg, types, args);\n    va_end(args);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusMessageDecodeArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1189-1207",
    "snippet": "int virDBusMessageDecodeArgs(DBusMessage* msg,\n                             const char *types,\n                             va_list args)\n{\n    DBusMessageIter iter;\n\n    if (!dbus_message_iter_init(msg, &iter)) {\n        if (*types != '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No args present for signature %s\"),\n                           types);\n        } else {\n            return 0;\n        }\n        return -1;\n    }\n\n    return virDBusMessageIterDecode(&iter, types, args);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageIterDecode",
          "args": [
            "&iter",
            "types",
            "args"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageIterDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "881-1171",
          "snippet": "static int\nvirDBusMessageIterDecode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    size_t *narrayptr = 0;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t skiplen;\n    size_t siglen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n        bool advanceiter = true;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu type='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p types=%s\", iter, types);\n            if (strchr(types, '}') == NULL) {\n                arrayref = false;\n                arrayptr = NULL;\n                VIR_DEBUG(\"Clear array ref flag\");\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            if (arrayref) {\n                if (!dbus_message_iter_has_next(iter))\n                    narray = 0;\n                else\n                    narray = 1;\n                VIR_DEBUG(\"Pop set narray=%zd\", (ssize_t)narray);\n            }\n            if (!(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            if (!arrayref)\n                narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            GET_NEXT_VAL(unsigned char, byt, unsigned char, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            GET_NEXT_VAL(dbus_bool_t, bool_val, bool, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            GET_NEXT_VAL(dbus_int16_t, i16, short, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            GET_NEXT_VAL(dbus_uint16_t, u16, unsigned short, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            GET_NEXT_VAL(dbus_uint32_t, i32, int, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            GET_NEXT_VAL(dbus_uint32_t, u32, unsigned int, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            GET_NEXT_VAL(dbus_uint64_t, i64, long long, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            GET_NEXT_VAL(dbus_uint64_t, u64, unsigned long long, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            GET_NEXT_VAL(double, dbl, double, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            do {\n                char **x;\n                if (arrayref) {\n                    char ***xptrptr = arrayptr;\n                    if (VIR_EXPAND_N(*xptrptr, *narrayptr, 1) < 0)\n                        goto cleanup;\n                    x = (char **)(*xptrptr + (*narrayptr - 1));\n                    VIR_DEBUG(\"Expanded to %zu\", *narrayptr);\n                } else {\n                    x = (char **)va_arg(args, char **);\n                }\n                char *s;\n                dbus_message_iter_get_basic(iter, &s);\n                *x = g_strdup(s);\n                VIR_DEBUG(\"Read basic type 'char *' varg 'char **'\"\n                          \"' val '%s'\", *x);\n            } while (0);\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type / dict\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Array contsig='%s' skip=%'zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            if (arrayref) {\n                narrayptr = va_arg(args, size_t *);\n                arrayptr = va_arg(args, void *);\n                *narrayptr = 0;\n                *(char **)arrayptr = NULL;\n            } else {\n                narray = va_arg(args, int);\n            }\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            advanceiter = false;\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_DEBUG(\"Push failed\");\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Dict/struct contsig='%s' skip='%zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%c' in signature '%s'\"),\n                           *t, types);\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"After nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n\n        if (arrayref) {\n            if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                narray = 0;\n            } else {\n                if (advanceiter)\n                    dbus_message_iter_next(iter);\n                if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                    narray = 0;\n                } else {\n                    narray = 1;\n                }\n            }\n            VIR_DEBUG(\"Set narray=%zd\", (ssize_t)narray);\n        } else {\n            if (advanceiter &&\n                !(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    if (dbus_message_iter_has_next(iter)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Too many fields in message for signature\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusMessageIterDecode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    size_t *narrayptr = 0;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t skiplen;\n    size_t siglen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n        bool advanceiter = true;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu type='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p types=%s\", iter, types);\n            if (strchr(types, '}') == NULL) {\n                arrayref = false;\n                arrayptr = NULL;\n                VIR_DEBUG(\"Clear array ref flag\");\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            if (arrayref) {\n                if (!dbus_message_iter_has_next(iter))\n                    narray = 0;\n                else\n                    narray = 1;\n                VIR_DEBUG(\"Pop set narray=%zd\", (ssize_t)narray);\n            }\n            if (!(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            if (!arrayref)\n                narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            GET_NEXT_VAL(unsigned char, byt, unsigned char, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            GET_NEXT_VAL(dbus_bool_t, bool_val, bool, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            GET_NEXT_VAL(dbus_int16_t, i16, short, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            GET_NEXT_VAL(dbus_uint16_t, u16, unsigned short, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            GET_NEXT_VAL(dbus_uint32_t, i32, int, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            GET_NEXT_VAL(dbus_uint32_t, u32, unsigned int, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            GET_NEXT_VAL(dbus_uint64_t, i64, long long, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            GET_NEXT_VAL(dbus_uint64_t, u64, unsigned long long, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            GET_NEXT_VAL(double, dbl, double, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            do {\n                char **x;\n                if (arrayref) {\n                    char ***xptrptr = arrayptr;\n                    if (VIR_EXPAND_N(*xptrptr, *narrayptr, 1) < 0)\n                        goto cleanup;\n                    x = (char **)(*xptrptr + (*narrayptr - 1));\n                    VIR_DEBUG(\"Expanded to %zu\", *narrayptr);\n                } else {\n                    x = (char **)va_arg(args, char **);\n                }\n                char *s;\n                dbus_message_iter_get_basic(iter, &s);\n                *x = g_strdup(s);\n                VIR_DEBUG(\"Read basic type 'char *' varg 'char **'\"\n                          \"' val '%s'\", *x);\n            } while (0);\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type / dict\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Array contsig='%s' skip=%'zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            if (arrayref) {\n                narrayptr = va_arg(args, size_t *);\n                arrayptr = va_arg(args, void *);\n                *narrayptr = 0;\n                *(char **)arrayptr = NULL;\n            } else {\n                narray = va_arg(args, int);\n            }\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            advanceiter = false;\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_DEBUG(\"Push failed\");\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Dict/struct contsig='%s' skip='%zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%c' in signature '%s'\"),\n                           *t, types);\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"After nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n\n        if (arrayref) {\n            if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                narray = 0;\n            } else {\n                if (advanceiter)\n                    dbus_message_iter_next(iter);\n                if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                    narray = 0;\n                } else {\n                    narray = 1;\n                }\n            }\n            VIR_DEBUG(\"Set narray=%zd\", (ssize_t)narray);\n        } else {\n            if (advanceiter &&\n                !(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    if (dbus_message_iter_has_next(iter)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Too many fields in message for signature\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No args present for signature %s\")",
            "types"
          ],
          "line": 1197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"No args present for signature %s\""
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_init",
          "args": [
            "msg",
            "&iter"
          ],
          "line": 1195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint virDBusMessageDecodeArgs(DBusMessage* msg,\n                             const char *types,\n                             va_list args)\n{\n    DBusMessageIter iter;\n\n    if (!dbus_message_iter_init(msg, &iter)) {\n        if (*types != '\\0') {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"No args present for signature %s\"),\n                           types);\n        } else {\n            return 0;\n        }\n        return -1;\n    }\n\n    return virDBusMessageIterDecode(&iter, types, args);\n}"
  },
  {
    "function_name": "virDBusMessageEncodeArgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "1174-1186",
    "snippet": "int\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusMessageIterEncode",
          "args": [
            "&iter",
            "types",
            "args"
          ],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusMessageIterEncode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "608-855",
          "snippet": "static int\nvirDBusMessageIterEncode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t siglen;\n    size_t skiplen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            if (*types != '}') {\n                VIR_DEBUG(\"Reset array ref\");\n                arrayref = false;\n                arrayptr = NULL;\n            }\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p\", iter);\n\n            if (!dbus_message_iter_close_container(iter, thisiter)) {\n                if (thisiter != rootiter)\n                    VIR_FREE(thisiter);\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot close container iterator\"));\n                goto cleanup;\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            SET_NEXT_VAL(unsigned char, int, unsigned char *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            SET_NEXT_VAL(dbus_bool_t, int, bool *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            SET_NEXT_VAL(dbus_int16_t, int, short *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            SET_NEXT_VAL(dbus_uint16_t, unsigned int, unsigned short *,\n                         *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            SET_NEXT_VAL(dbus_int32_t, int, int *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            SET_NEXT_VAL(dbus_uint32_t, unsigned int, unsigned int *,\n                         *t, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            SET_NEXT_VAL(dbus_int64_t, long long, long long *, *t, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            SET_NEXT_VAL(dbus_uint64_t, unsigned long long,\n                         unsigned long long *, *t, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            SET_NEXT_VAL(double, double, double *, *t, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            SET_NEXT_VAL(char *, char *, char **, *t, \"%s\");\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type \"\n                                 \"or dict with matching key+value type\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n                                                  contsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            narray = (size_t)va_arg(args, int);\n            if (arrayref)\n                arrayptr = va_arg(args, void *);\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,\n                                                  vsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter,\n                                                  *t == DBUS_STRUCT_BEGIN_CHAR ?\n                                                  DBUS_TYPE_STRUCT : DBUS_TYPE_DICT_ENTRY,\n                                                  NULL, newiter))\n                goto cleanup;\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%x' in signature '%s'\"),\n                           (int)*t, types);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    while (nstack > 0) {\n        DBusMessageIter *thisiter = iter;\n        VIR_DEBUG(\"Popping iter=%p\", iter);\n        ignore_value(virDBusTypeStackPop(&stack, &nstack, &iter,\n                                         &types, &nstruct, &narray));\n        VIR_DEBUG(\"Popped iter=%p\", iter);\n\n        if (thisiter != rootiter)\n            VIR_FREE(thisiter);\n    }\n\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusMessageIterEncode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t siglen;\n    size_t skiplen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            if (*types != '}') {\n                VIR_DEBUG(\"Reset array ref\");\n                arrayref = false;\n                arrayptr = NULL;\n            }\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p\", iter);\n\n            if (!dbus_message_iter_close_container(iter, thisiter)) {\n                if (thisiter != rootiter)\n                    VIR_FREE(thisiter);\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot close container iterator\"));\n                goto cleanup;\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            SET_NEXT_VAL(unsigned char, int, unsigned char *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            SET_NEXT_VAL(dbus_bool_t, int, bool *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            SET_NEXT_VAL(dbus_int16_t, int, short *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            SET_NEXT_VAL(dbus_uint16_t, unsigned int, unsigned short *,\n                         *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            SET_NEXT_VAL(dbus_int32_t, int, int *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            SET_NEXT_VAL(dbus_uint32_t, unsigned int, unsigned int *,\n                         *t, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            SET_NEXT_VAL(dbus_int64_t, long long, long long *, *t, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            SET_NEXT_VAL(dbus_uint64_t, unsigned long long,\n                         unsigned long long *, *t, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            SET_NEXT_VAL(double, double, double *, *t, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            SET_NEXT_VAL(char *, char *, char **, *t, \"%s\");\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type \"\n                                 \"or dict with matching key+value type\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n                                                  contsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            narray = (size_t)va_arg(args, int);\n            if (arrayref)\n                arrayptr = va_arg(args, void *);\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,\n                                                  vsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter,\n                                                  *t == DBUS_STRUCT_BEGIN_CHAR ?\n                                                  DBUS_TYPE_STRUCT : DBUS_TYPE_DICT_ENTRY,\n                                                  NULL, newiter))\n                goto cleanup;\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%x' in signature '%s'\"),\n                           (int)*t, types);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    while (nstack > 0) {\n        DBusMessageIter *thisiter = iter;\n        VIR_DEBUG(\"Popping iter=%p\", iter);\n        ignore_value(virDBusTypeStackPop(&stack, &nstack, &iter,\n                                         &types, &nstruct, &narray));\n        VIR_DEBUG(\"Popped iter=%p\", iter);\n\n        if (thisiter != rootiter)\n            VIR_FREE(thisiter);\n    }\n\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_init_append",
          "args": [
            "msg",
            "&iter"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&iter",
            "0",
            "sizeof(iter)"
          ],
          "line": 1181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nint\nvirDBusMessageEncodeArgs(DBusMessage* msg,\n                         const char *types,\n                         va_list args)\n{\n    DBusMessageIter iter;\n\n    memset(&iter, 0, sizeof(iter));\n\n    dbus_message_iter_init_append(msg, &iter);\n\n    return virDBusMessageIterEncode(&iter, types, args);\n}"
  },
  {
    "function_name": "virDBusMessageIterDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "881-1171",
    "snippet": "static int\nvirDBusMessageIterDecode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    size_t *narrayptr = 0;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t skiplen;\n    size_t siglen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n        bool advanceiter = true;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu type='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p types=%s\", iter, types);\n            if (strchr(types, '}') == NULL) {\n                arrayref = false;\n                arrayptr = NULL;\n                VIR_DEBUG(\"Clear array ref flag\");\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            if (arrayref) {\n                if (!dbus_message_iter_has_next(iter))\n                    narray = 0;\n                else\n                    narray = 1;\n                VIR_DEBUG(\"Pop set narray=%zd\", (ssize_t)narray);\n            }\n            if (!(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            if (!arrayref)\n                narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            GET_NEXT_VAL(unsigned char, byt, unsigned char, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            GET_NEXT_VAL(dbus_bool_t, bool_val, bool, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            GET_NEXT_VAL(dbus_int16_t, i16, short, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            GET_NEXT_VAL(dbus_uint16_t, u16, unsigned short, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            GET_NEXT_VAL(dbus_uint32_t, i32, int, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            GET_NEXT_VAL(dbus_uint32_t, u32, unsigned int, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            GET_NEXT_VAL(dbus_uint64_t, i64, long long, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            GET_NEXT_VAL(dbus_uint64_t, u64, unsigned long long, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            GET_NEXT_VAL(double, dbl, double, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            do {\n                char **x;\n                if (arrayref) {\n                    char ***xptrptr = arrayptr;\n                    if (VIR_EXPAND_N(*xptrptr, *narrayptr, 1) < 0)\n                        goto cleanup;\n                    x = (char **)(*xptrptr + (*narrayptr - 1));\n                    VIR_DEBUG(\"Expanded to %zu\", *narrayptr);\n                } else {\n                    x = (char **)va_arg(args, char **);\n                }\n                char *s;\n                dbus_message_iter_get_basic(iter, &s);\n                *x = g_strdup(s);\n                VIR_DEBUG(\"Read basic type 'char *' varg 'char **'\"\n                          \"' val '%s'\", *x);\n            } while (0);\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type / dict\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Array contsig='%s' skip=%'zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            if (arrayref) {\n                narrayptr = va_arg(args, size_t *);\n                arrayptr = va_arg(args, void *);\n                *narrayptr = 0;\n                *(char **)arrayptr = NULL;\n            } else {\n                narray = va_arg(args, int);\n            }\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            advanceiter = false;\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_DEBUG(\"Push failed\");\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Dict/struct contsig='%s' skip='%zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%c' in signature '%s'\"),\n                           *t, types);\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"After nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n\n        if (arrayref) {\n            if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                narray = 0;\n            } else {\n                if (advanceiter)\n                    dbus_message_iter_next(iter);\n                if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                    narray = 0;\n                } else {\n                    narray = 1;\n                }\n            }\n            VIR_DEBUG(\"Set narray=%zd\", (ssize_t)narray);\n        } else {\n            if (advanceiter &&\n                !(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    if (dbus_message_iter_has_next(iter)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Too many fields in message for signature\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newiter"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackFree",
          "args": [
            "&stack",
            "&nstack"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "548-562",
          "snippet": "static void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Too many fields in message for signature\")"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Too many fields in message for signature\""
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_has_next",
          "args": [
            "iter"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Not enough fields in message for signature\")"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_next",
          "args": [
            "iter"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Set narray=%zd\"",
            "(ssize_t)narray"
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_arg_type",
          "args": [
            "iter"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_next",
          "args": [
            "iter"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_arg_type",
          "args": [
            "iter"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"After nstack=%zu narray=%zd nstruct=%zu types='%s'\"",
            "nstack",
            "(ssize_t)narray",
            "nstruct",
            "types"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown type '%c' in signature '%s'\")",
            "*t",
            "types"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackPush",
          "args": [
            "&stack",
            "&nstack",
            "iter",
            "types",
            "nstruct",
            "narray"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackPush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "497-520",
          "snippet": "static int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_recurse",
          "args": [
            "iter",
            "newiter"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Dict/struct contsig='%s' skip='%zu' len='%zu' types='%s'\"",
            "contsig",
            "skiplen",
            "siglen",
            "types"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCopyContainerSignature",
          "args": [
            "t",
            "&skiplen",
            "&siglen"
          ],
          "line": 1097
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCopyContainerSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "453-479",
          "snippet": "static char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "types"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Push failed\""
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_recurse",
          "args": [
            "iter",
            "newiter"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing variant type signature\")"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 1067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "void*"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "size_t*"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_recurse",
          "args": [
            "iter",
            "newiter"
          ],
          "line": 1052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Array contsig='%s' skip=%'zu' len='%zu' types='%s'\"",
            "contsig",
            "skiplen",
            "siglen",
            "types"
          ],
          "line": 1050
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Got array ref but '%s' is not a single basic type / dict\")",
            "contsig"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusIsAllowedRefType",
          "args": [
            "contsig"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsAllowedRefType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "565-584",
          "snippet": "static bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got array non-ref\""
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got array ref\""
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Read basic type 'char *' varg 'char **'\"\n                          \"' val '%s'\"",
            "*x"
          ],
          "line": 1014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_get_basic",
          "args": [
            "iter",
            "&s"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "char **"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Expanded to %zu\"",
            "*narrayptr"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "*xptrptr",
            "*narrayptr",
            "1"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "double",
            "dbl",
            "double",
            "\"%lf\""
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_uint64_t",
            "u64",
            "unsignedlong long",
            "\"%llu\""
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_uint64_t",
            "i64",
            "longlong",
            "\"%lld\""
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_uint32_t",
            "u32",
            "unsignedint",
            "\"%u\""
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_uint32_t",
            "i32",
            "int",
            "\"%d\""
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_uint16_t",
            "u16",
            "unsignedshort",
            "\"%d\""
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_int16_t",
            "i16",
            "short",
            "\"%d\""
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_NEXT_VAL",
          "args": [
            "dbus_bool_t",
            "bool_val",
            "bool",
            "\"%d\""
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Not enough fields in message for signature\")"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_next",
          "args": [
            "iter"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Pop set narray=%zd\"",
            "(ssize_t)narray"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_has_next",
          "args": [
            "iter"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "thisiter"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Clear array ref flag\""
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "types",
            "'}'"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popped iter=%p types=%s\"",
            "iter",
            "types"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackPop",
          "args": [
            "&stack",
            "&nstack",
            "&iter",
            "&types",
            "&nstruct",
            "&narray"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackPop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "523-545",
          "snippet": "static int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popping iter=%p\"",
            "iter"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loop nstack=%zu narray=%zd nstruct=%zu type='%s'\"",
            "nstack",
            "(ssize_t)narray",
            "nstruct",
            "types"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "types"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"rootiter=%p types=%s\"",
            "rootiter",
            "types"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusMessageIterDecode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    size_t *narrayptr = 0;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t skiplen;\n    size_t siglen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n        bool advanceiter = true;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu type='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p types=%s\", iter, types);\n            if (strchr(types, '}') == NULL) {\n                arrayref = false;\n                arrayptr = NULL;\n                VIR_DEBUG(\"Clear array ref flag\");\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            if (arrayref) {\n                if (!dbus_message_iter_has_next(iter))\n                    narray = 0;\n                else\n                    narray = 1;\n                VIR_DEBUG(\"Pop set narray=%zd\", (ssize_t)narray);\n            }\n            if (!(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            if (!arrayref)\n                narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            GET_NEXT_VAL(unsigned char, byt, unsigned char, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            GET_NEXT_VAL(dbus_bool_t, bool_val, bool, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            GET_NEXT_VAL(dbus_int16_t, i16, short, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            GET_NEXT_VAL(dbus_uint16_t, u16, unsigned short, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            GET_NEXT_VAL(dbus_uint32_t, i32, int, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            GET_NEXT_VAL(dbus_uint32_t, u32, unsigned int, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            GET_NEXT_VAL(dbus_uint64_t, i64, long long, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            GET_NEXT_VAL(dbus_uint64_t, u64, unsigned long long, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            GET_NEXT_VAL(double, dbl, double, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            do {\n                char **x;\n                if (arrayref) {\n                    char ***xptrptr = arrayptr;\n                    if (VIR_EXPAND_N(*xptrptr, *narrayptr, 1) < 0)\n                        goto cleanup;\n                    x = (char **)(*xptrptr + (*narrayptr - 1));\n                    VIR_DEBUG(\"Expanded to %zu\", *narrayptr);\n                } else {\n                    x = (char **)va_arg(args, char **);\n                }\n                char *s;\n                dbus_message_iter_get_basic(iter, &s);\n                *x = g_strdup(s);\n                VIR_DEBUG(\"Read basic type 'char *' varg 'char **'\"\n                          \"' val '%s'\", *x);\n            } while (0);\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type / dict\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Array contsig='%s' skip=%'zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            if (arrayref) {\n                narrayptr = va_arg(args, size_t *);\n                arrayptr = va_arg(args, void *);\n                *narrayptr = 0;\n                *(char **)arrayptr = NULL;\n            } else {\n                narray = va_arg(args, int);\n            }\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            advanceiter = false;\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            dbus_message_iter_recurse(iter, newiter);\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_DEBUG(\"Push failed\");\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            advanceiter = false;\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Dict/struct contsig='%s' skip='%zu' len='%zu' types='%s'\",\n                      contsig, skiplen, siglen, types);\n            dbus_message_iter_recurse(iter, newiter);\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0)\n                goto cleanup;\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%c' in signature '%s'\"),\n                           *t, types);\n            goto cleanup;\n        }\n\n        VIR_DEBUG(\"After nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n\n        if (arrayref) {\n            if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                narray = 0;\n            } else {\n                if (advanceiter)\n                    dbus_message_iter_next(iter);\n                if (dbus_message_iter_get_arg_type(iter) == DBUS_TYPE_INVALID) {\n                    narray = 0;\n                } else {\n                    narray = 1;\n                }\n            }\n            VIR_DEBUG(\"Set narray=%zd\", (ssize_t)narray);\n        } else {\n            if (advanceiter &&\n                !(narray == 0 ||\n                  (narray == (size_t)-1 &&\n                   nstruct == 0)) &&\n                !dbus_message_iter_next(iter)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Not enough fields in message for signature\"));\n                goto cleanup;\n            }\n        }\n    }\n\n    if (dbus_message_iter_has_next(iter)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Too many fields in message for signature\"));\n        goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusMessageIterEncode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "608-855",
    "snippet": "static int\nvirDBusMessageIterEncode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t siglen;\n    size_t skiplen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            if (*types != '}') {\n                VIR_DEBUG(\"Reset array ref\");\n                arrayref = false;\n                arrayptr = NULL;\n            }\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p\", iter);\n\n            if (!dbus_message_iter_close_container(iter, thisiter)) {\n                if (thisiter != rootiter)\n                    VIR_FREE(thisiter);\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot close container iterator\"));\n                goto cleanup;\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            SET_NEXT_VAL(unsigned char, int, unsigned char *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            SET_NEXT_VAL(dbus_bool_t, int, bool *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            SET_NEXT_VAL(dbus_int16_t, int, short *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            SET_NEXT_VAL(dbus_uint16_t, unsigned int, unsigned short *,\n                         *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            SET_NEXT_VAL(dbus_int32_t, int, int *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            SET_NEXT_VAL(dbus_uint32_t, unsigned int, unsigned int *,\n                         *t, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            SET_NEXT_VAL(dbus_int64_t, long long, long long *, *t, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            SET_NEXT_VAL(dbus_uint64_t, unsigned long long,\n                         unsigned long long *, *t, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            SET_NEXT_VAL(double, double, double *, *t, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            SET_NEXT_VAL(char *, char *, char **, *t, \"%s\");\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type \"\n                                 \"or dict with matching key+value type\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n                                                  contsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            narray = (size_t)va_arg(args, int);\n            if (arrayref)\n                arrayptr = va_arg(args, void *);\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,\n                                                  vsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter,\n                                                  *t == DBUS_STRUCT_BEGIN_CHAR ?\n                                                  DBUS_TYPE_STRUCT : DBUS_TYPE_DICT_ENTRY,\n                                                  NULL, newiter))\n                goto cleanup;\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%x' in signature '%s'\"),\n                           (int)*t, types);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    while (nstack > 0) {\n        DBusMessageIter *thisiter = iter;\n        VIR_DEBUG(\"Popping iter=%p\", iter);\n        ignore_value(virDBusTypeStackPop(&stack, &nstack, &iter,\n                                         &types, &nstruct, &narray));\n        VIR_DEBUG(\"Popped iter=%p\", iter);\n\n        if (thisiter != rootiter)\n            VIR_FREE(thisiter);\n    }\n\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newiter"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackFree",
          "args": [
            "&stack",
            "&nstack"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "548-562",
          "snippet": "static void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "thisiter"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popped iter=%p\"",
            "iter"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virDBusTypeStackPop(&stack, &nstack, &iter,\n                                         &types, &nstruct, &narray)"
          ],
          "line": 843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackPop",
          "args": [
            "&stack",
            "&nstack",
            "&iter",
            "&types",
            "&nstruct",
            "&narray"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackPop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "523-545",
          "snippet": "static int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popping iter=%p\"",
            "iter"
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown type '%x' in signature '%s'\")",
            "(int)*t",
            "types"
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown type '%x' in signature '%s'\""
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newiter"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTypeStackPush",
          "args": [
            "&stack",
            "&nstack",
            "iter",
            "types",
            "nstruct",
            "narray"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTypeStackPush",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "497-520",
          "snippet": "static int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_open_container",
          "args": [
            "iter",
            "*t == DBUS_STRUCT_BEGIN_CHAR ?\n                                                  DBUS_TYPE_STRUCT : DBUS_TYPE_DICT_ENTRY",
            "NULL",
            "newiter"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Contsig '%s' skip='%zu' len='%zu'\"",
            "contsig",
            "skiplen",
            "siglen"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusCopyContainerSignature",
          "args": [
            "t",
            "&skiplen",
            "&siglen"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusCopyContainerSignature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "453-479",
          "snippet": "static char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "types"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newiter"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_open_container",
          "args": [
            "iter",
            "DBUS_TYPE_VARIANT",
            "vsig",
            "newiter"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Missing variant type signature\")"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "constchar *"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "void*"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "args",
            "int"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&newiter"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "contsig"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "newiter"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_open_container",
          "args": [
            "iter",
            "DBUS_TYPE_ARRAY",
            "contsig",
            "newiter"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Contsig '%s' skip='%zu' len='%zu'\"",
            "contsig",
            "skiplen",
            "siglen"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "newiter"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Got array ref but '%s' is not a single basic type \"\n                                 \"or dict with matching key+value type\")",
            "contsig"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusIsAllowedRefType",
          "args": [
            "contsig"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsAllowedRefType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "565-584",
          "snippet": "static bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got array non-ref\""
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Got array ref\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "double",
            "double",
            "double*",
            "*t",
            "\"%lf\""
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_uint64_t",
            "unsignedlong long",
            "unsignedlong long *",
            "*t",
            "\"%llu\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_int64_t",
            "longlong",
            "longlong *",
            "*t",
            "\"%lld\""
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_uint32_t",
            "unsignedint",
            "unsignedint *",
            "*t",
            "\"%u\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_int32_t",
            "int",
            "int*",
            "*t",
            "\"%d\""
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_uint16_t",
            "unsignedint",
            "unsignedshort *",
            "*t",
            "\"%d\""
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_int16_t",
            "int",
            "short*",
            "*t",
            "\"%d\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SET_NEXT_VAL",
          "args": [
            "dbus_bool_t",
            "int",
            "bool*",
            "*t",
            "\"%d\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "thisiter"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Cannot close container iterator\")"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "thisiter"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_message_iter_close_container",
          "args": [
            "iter",
            "thisiter"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popped iter=%p\"",
            "iter"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popping iter=%p\"",
            "iter"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Reset array ref\""
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Loop nstack=%zu narray=%zd nstruct=%zu types='%s'\"",
            "nstack",
            "(ssize_t)narray",
            "nstruct",
            "types"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "types"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"rootiter=%p types=%s\"",
            "rootiter",
            "types"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusMessageIterEncode(DBusMessageIter *rootiter,\n                         const char *types,\n                         va_list args)\n{\n    int ret = -1;\n    size_t narray;\n    size_t nstruct;\n    bool arrayref = false;\n    void *arrayptr = NULL;\n    virDBusTypeStack *stack = NULL;\n    size_t nstack = 0;\n    size_t siglen;\n    size_t skiplen;\n    char *contsig = NULL;\n    const char *vsig;\n    DBusMessageIter *newiter = NULL;\n    DBusMessageIter *iter = rootiter;\n\n    VIR_DEBUG(\"rootiter=%p types=%s\", rootiter, types);\n\n    if (!types)\n        return 0;\n\n    narray = (size_t)-1;\n    nstruct = strlen(types);\n\n    for (;;) {\n        const char *t;\n\n        VIR_DEBUG(\"Loop nstack=%zu narray=%zd nstruct=%zu types='%s'\",\n                  nstack, (ssize_t)narray, nstruct, types);\n        if (narray == 0 ||\n            (narray == (size_t)-1 &&\n             nstruct == 0)) {\n            DBusMessageIter *thisiter = iter;\n            if (*types != '}') {\n                VIR_DEBUG(\"Reset array ref\");\n                arrayref = false;\n                arrayptr = NULL;\n            }\n            VIR_DEBUG(\"Popping iter=%p\", iter);\n            if (nstack == 0)\n                break;\n            if (virDBusTypeStackPop(&stack, &nstack, &iter,\n                                    &types, &nstruct, &narray) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Popped iter=%p\", iter);\n\n            if (!dbus_message_iter_close_container(iter, thisiter)) {\n                if (thisiter != rootiter)\n                    VIR_FREE(thisiter);\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Cannot close container iterator\"));\n                goto cleanup;\n            }\n            if (thisiter != rootiter)\n                VIR_FREE(thisiter);\n            continue;\n        }\n\n        t = types;\n        if (narray != (size_t)-1) {\n            narray--;\n        } else {\n            types++;\n            nstruct--;\n        }\n\n        switch (*t) {\n        case DBUS_TYPE_BYTE:\n            SET_NEXT_VAL(unsigned char, int, unsigned char *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_BOOLEAN:\n            SET_NEXT_VAL(dbus_bool_t, int, bool *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT16:\n            SET_NEXT_VAL(dbus_int16_t, int, short *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT16:\n            SET_NEXT_VAL(dbus_uint16_t, unsigned int, unsigned short *,\n                         *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_INT32:\n            SET_NEXT_VAL(dbus_int32_t, int, int *, *t, \"%d\");\n            break;\n\n        case DBUS_TYPE_UINT32:\n            SET_NEXT_VAL(dbus_uint32_t, unsigned int, unsigned int *,\n                         *t, \"%u\");\n            break;\n\n        case DBUS_TYPE_INT64:\n            SET_NEXT_VAL(dbus_int64_t, long long, long long *, *t, \"%lld\");\n            break;\n\n        case DBUS_TYPE_UINT64:\n            SET_NEXT_VAL(dbus_uint64_t, unsigned long long,\n                         unsigned long long *, *t, \"%llu\");\n            break;\n\n        case DBUS_TYPE_DOUBLE:\n            SET_NEXT_VAL(double, double, double *, *t, \"%lf\");\n            break;\n\n        case DBUS_TYPE_STRING:\n        case DBUS_TYPE_OBJECT_PATH:\n        case DBUS_TYPE_SIGNATURE:\n            SET_NEXT_VAL(char *, char *, char **, *t, \"%s\");\n            break;\n\n        case DBUS_TYPE_ARRAY:\n            arrayptr = NULL;\n            if (t[1] == '&') {\n                VIR_DEBUG(\"Got array ref\");\n                t++;\n                types++;\n                nstruct--;\n                arrayref = true;\n            } else {\n                VIR_DEBUG(\"Got array non-ref\");\n                arrayref = false;\n            }\n\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (arrayref && !virDBusIsAllowedRefType(contsig)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Got array ref but '%s' is not a single basic type \"\n                                 \"or dict with matching key+value type\"),\n                               contsig);\n                goto cleanup;\n            }\n\n            if (narray == (size_t)-1) {\n                types += skiplen;\n                nstruct -= skiplen;\n            }\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_ARRAY,\n                                                  contsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen;\n            narray = (size_t)va_arg(args, int);\n            if (arrayref)\n                arrayptr = va_arg(args, void *);\n            break;\n\n        case DBUS_TYPE_VARIANT:\n            vsig = va_arg(args, const char *);\n            if (!vsig) {\n                virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                               _(\"Missing variant type signature\"));\n                goto cleanup;\n            }\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            if (!dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT,\n                                                  vsig, newiter))\n                goto cleanup;\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            iter = g_steal_pointer(&newiter);\n            types = vsig;\n            nstruct = strlen(types);\n            narray = (size_t)-1;\n            break;\n\n        case DBUS_STRUCT_BEGIN_CHAR:\n        case DBUS_DICT_ENTRY_BEGIN_CHAR:\n            if (!(contsig = virDBusCopyContainerSignature(t, &skiplen, &siglen)))\n                goto cleanup;\n\n            if (VIR_ALLOC(newiter) < 0)\n                goto cleanup;\n            VIR_DEBUG(\"Contsig '%s' skip='%zu' len='%zu'\", contsig, skiplen, siglen);\n            if (!dbus_message_iter_open_container(iter,\n                                                  *t == DBUS_STRUCT_BEGIN_CHAR ?\n                                                  DBUS_TYPE_STRUCT : DBUS_TYPE_DICT_ENTRY,\n                                                  NULL, newiter))\n                goto cleanup;\n            if (narray == (size_t)-1) {\n                types += skiplen - 1;\n                nstruct -= skiplen - 1;\n            }\n\n            if (virDBusTypeStackPush(&stack, &nstack,\n                                     iter, types,\n                                     nstruct, narray) < 0) {\n                VIR_FREE(newiter);\n                goto cleanup;\n            }\n            VIR_FREE(contsig);\n            iter = g_steal_pointer(&newiter);\n            types = t + 1;\n            nstruct = skiplen - 2;\n            narray = (size_t)-1;\n\n            break;\n\n        default:\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown type '%x' in signature '%s'\"),\n                           (int)*t, types);\n            goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    while (nstack > 0) {\n        DBusMessageIter *thisiter = iter;\n        VIR_DEBUG(\"Popping iter=%p\", iter);\n        ignore_value(virDBusTypeStackPop(&stack, &nstack, &iter,\n                                         &types, &nstruct, &narray));\n        VIR_DEBUG(\"Popped iter=%p\", iter);\n\n        if (thisiter != rootiter)\n            VIR_FREE(thisiter);\n    }\n\n    virDBusTypeStackFree(&stack, &nstack);\n    VIR_FREE(contsig);\n    VIR_FREE(newiter);\n    return ret;\n}"
  },
  {
    "function_name": "virDBusIsAllowedRefType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "565-584",
    "snippet": "static bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusIsBasicType",
          "args": [
            "sig[0]"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsBasicType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "306-309",
          "snippet": "static bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sig"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sig"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool\nvirDBusIsAllowedRefType(const char *sig)\n{\n    if (*sig == '{') {\n        if (strlen(sig) != 4)\n            return false;\n        if (!virDBusIsBasicType(sig[1]) ||\n            !virDBusIsBasicType(sig[2]) ||\n            sig[1] != sig[2])\n            return false;\n        if (sig[3] != '}')\n            return false;\n    } else {\n        if (strlen(sig) != 1)\n            return false;\n        if (!virDBusIsBasicType(sig[0]))\n            return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virDBusTypeStackFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "548-562",
    "snippet": "static void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*stack"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*stack)[i].iter"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusTypeStackFree(virDBusTypeStack **stack,\n                                 size_t *nstack)\n{\n    size_t i;\n\n    if (!*stack)\n        return;\n\n    /* The iter in the first level of the stack is the\n     * root iter which must not be freed\n     */\n    for (i = 1; i < *nstack; i++)\n        VIR_FREE((*stack)[i].iter);\n    VIR_FREE(*stack);\n}"
  },
  {
    "function_name": "virDBusTypeStackPop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "523-545",
    "snippet": "static int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_SHRINK_N",
          "args": [
            "*stack",
            "*nstack",
            "1"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Popped types='%s' nstruct=%zu narray=%zd\"",
            "*types",
            "*nstruct",
            "(ssize_t)*narray"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus type stack is empty\")"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus type stack is empty\""
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPop(virDBusTypeStack **stack,\n                               size_t *nstack,\n                               DBusMessageIter **iter,\n                               const char **types,\n                               size_t *nstruct,\n                               size_t *narray)\n{\n    if (*nstack == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type stack is empty\"));\n        return -1;\n    }\n\n    *iter = (*stack)[(*nstack) - 1].iter;\n    *types = (*stack)[(*nstack) - 1].types;\n    *nstruct = (*stack)[(*nstack) - 1].nstruct;\n    *narray = (*stack)[(*nstack) - 1].narray;\n    VIR_DEBUG(\"Popped types='%s' nstruct=%zu narray=%zd\",\n              *types, *nstruct, (ssize_t)*narray);\n    VIR_SHRINK_N(*stack, *nstack, 1);\n\n    return 0;\n}"
  },
  {
    "function_name": "virDBusTypeStackPush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "497-520",
    "snippet": "static int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Pushed types='%s' nstruct=%zu narray=%zd\"",
            "types",
            "nstruct",
            "(ssize_t)narray"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "*stack",
            "*nstack",
            "1"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"DBus type too deeply nested\")"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"DBus type too deeply nested\""
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTypeStackPush(virDBusTypeStack **stack,\n                                size_t *nstack,\n                                DBusMessageIter *iter,\n                                const char *types,\n                                size_t nstruct,\n                                size_t narray)\n{\n    if (*nstack >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"DBus type too deeply nested\"));\n        return -1;\n    }\n\n    if (VIR_EXPAND_N(*stack, *nstack, 1) < 0)\n        return -1;\n\n    (*stack)[(*nstack) - 1].iter = iter;\n    (*stack)[(*nstack) - 1].types = types;\n    (*stack)[(*nstack) - 1].nstruct = nstruct;\n    (*stack)[(*nstack) - 1].narray = narray;\n    VIR_DEBUG(\"Pushed types='%s' nstruct=%zu narray=%zd\",\n              types, nstruct, (ssize_t)narray);\n    return 0;\n}"
  },
  {
    "function_name": "virDBusCopyContainerSignature",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "453-479",
    "snippet": "static char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Extracted '%s' from '%s'\"",
            "contsig",
            "sig"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "contsig",
            "*siglen + 1"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusSignatureLength",
          "args": [
            "isGroup ? sig : sig + 1",
            "skiplen",
            "siglen"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusSignatureLength",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "447-450",
          "snippet": "static int virDBusSignatureLength(const char *s, size_t *skiplen, size_t *siglen)\n{\n    return virDBusSignatureLengthInternal(s, true, 0, 0, skiplen, siglen);\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusSignatureLength(const char *s, size_t *skiplen, size_t *siglen)\n{\n    return virDBusSignatureLengthInternal(s, true, 0, 0, skiplen, siglen);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic char *virDBusCopyContainerSignature(const char *sig,\n                                           size_t *skiplen,\n                                           size_t *siglen)\n{\n    size_t i, j;\n    char *contsig;\n    bool isGroup;\n\n    isGroup = (sig[0] == DBUS_STRUCT_BEGIN_CHAR ||\n               sig[0] == DBUS_DICT_ENTRY_BEGIN_CHAR);\n\n    if (virDBusSignatureLength(isGroup ? sig : sig + 1, skiplen, siglen) < 0)\n        return NULL;\n\n    if (VIR_ALLOC_N(contsig, *siglen + 1) < 0)\n        return NULL;\n\n    for (i = 0, j = 0; i < *skiplen && j < *siglen; i++) {\n        if (sig[i + 1] == '&')\n            continue;\n        contsig[j] = sig[i + 1];\n        j++;\n    }\n    contsig[*siglen] = '\\0';\n    VIR_DEBUG(\"Extracted '%s' from '%s'\", contsig, sig);\n    return contsig;\n}"
  },
  {
    "function_name": "virDBusSignatureLength",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "447-450",
    "snippet": "static int virDBusSignatureLength(const char *s, size_t *skiplen, size_t *siglen)\n{\n    return virDBusSignatureLengthInternal(s, true, 0, 0, skiplen, siglen);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusSignatureLengthInternal",
          "args": [
            "s",
            "true",
            "0",
            "0",
            "skiplen",
            "siglen"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusSignatureLengthInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "317-444",
          "snippet": "static int\nvirDBusSignatureLengthInternal(const char *s,\n                               bool allowDict,\n                               unsigned arrayDepth,\n                               unsigned structDepth,\n                               size_t *skiplen,\n                               size_t *siglen)\n{\n    if (virDBusIsBasicType(*s) || *s == DBUS_TYPE_VARIANT) {\n        *skiplen = *siglen = 1;\n        return 0;\n    }\n\n    if (*s == DBUS_TYPE_ARRAY) {\n        size_t skiplencont;\n        size_t siglencont;\n        bool arrayref = false;\n\n        if (arrayDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        if (*(s + 1) == '&') {\n            arrayref = true;\n            s++;\n        }\n\n        if (virDBusSignatureLengthInternal(s + 1,\n                                           true,\n                                           arrayDepth + 1,\n                                           structDepth,\n                                           &skiplencont,\n                                           &siglencont) < 0)\n            return -1;\n\n        *skiplen = skiplencont + 1;\n        *siglen = siglencont + 1;\n        if (arrayref)\n            (*skiplen)++;\n        return 0;\n    }\n\n    if (*s == DBUS_STRUCT_BEGIN_CHAR) {\n        const char *p = s + 1;\n\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_STRUCT_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n        }\n\n        return 0;\n    }\n\n    if (*s == DBUS_DICT_ENTRY_BEGIN_CHAR && allowDict) {\n        const char *p = s + 1;\n        unsigned n = 0;\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_DICT_ENTRY_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (n == 0 && !virDBusIsBasicType(*p)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Dict entry in signature '%s' must be a basic type\"),\n                               s);\n                return -1;\n            }\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n            n++;\n        }\n\n        if (n != 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Dict entry in signature '%s' is wrong size\"),\n                           s);\n            return -1;\n        }\n\n        return 0;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected signature '%s'\"), s);\n    return -1;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusSignatureLengthInternal(const char *s,\n                               bool allowDict,\n                               unsigned arrayDepth,\n                               unsigned structDepth,\n                               size_t *skiplen,\n                               size_t *siglen)\n{\n    if (virDBusIsBasicType(*s) || *s == DBUS_TYPE_VARIANT) {\n        *skiplen = *siglen = 1;\n        return 0;\n    }\n\n    if (*s == DBUS_TYPE_ARRAY) {\n        size_t skiplencont;\n        size_t siglencont;\n        bool arrayref = false;\n\n        if (arrayDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        if (*(s + 1) == '&') {\n            arrayref = true;\n            s++;\n        }\n\n        if (virDBusSignatureLengthInternal(s + 1,\n                                           true,\n                                           arrayDepth + 1,\n                                           structDepth,\n                                           &skiplencont,\n                                           &siglencont) < 0)\n            return -1;\n\n        *skiplen = skiplencont + 1;\n        *siglen = siglencont + 1;\n        if (arrayref)\n            (*skiplen)++;\n        return 0;\n    }\n\n    if (*s == DBUS_STRUCT_BEGIN_CHAR) {\n        const char *p = s + 1;\n\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_STRUCT_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n        }\n\n        return 0;\n    }\n\n    if (*s == DBUS_DICT_ENTRY_BEGIN_CHAR && allowDict) {\n        const char *p = s + 1;\n        unsigned n = 0;\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_DICT_ENTRY_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (n == 0 && !virDBusIsBasicType(*p)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Dict entry in signature '%s' must be a basic type\"),\n                               s);\n                return -1;\n            }\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n            n++;\n        }\n\n        if (n != 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Dict entry in signature '%s' is wrong size\"),\n                           s);\n            return -1;\n        }\n\n        return 0;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected signature '%s'\"), s);\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusSignatureLength(const char *s, size_t *skiplen, size_t *siglen)\n{\n    return virDBusSignatureLengthInternal(s, true, 0, 0, skiplen, siglen);\n}"
  },
  {
    "function_name": "virDBusSignatureLengthInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "317-444",
    "snippet": "static int\nvirDBusSignatureLengthInternal(const char *s,\n                               bool allowDict,\n                               unsigned arrayDepth,\n                               unsigned structDepth,\n                               size_t *skiplen,\n                               size_t *siglen)\n{\n    if (virDBusIsBasicType(*s) || *s == DBUS_TYPE_VARIANT) {\n        *skiplen = *siglen = 1;\n        return 0;\n    }\n\n    if (*s == DBUS_TYPE_ARRAY) {\n        size_t skiplencont;\n        size_t siglencont;\n        bool arrayref = false;\n\n        if (arrayDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        if (*(s + 1) == '&') {\n            arrayref = true;\n            s++;\n        }\n\n        if (virDBusSignatureLengthInternal(s + 1,\n                                           true,\n                                           arrayDepth + 1,\n                                           structDepth,\n                                           &skiplencont,\n                                           &siglencont) < 0)\n            return -1;\n\n        *skiplen = skiplencont + 1;\n        *siglen = siglencont + 1;\n        if (arrayref)\n            (*skiplen)++;\n        return 0;\n    }\n\n    if (*s == DBUS_STRUCT_BEGIN_CHAR) {\n        const char *p = s + 1;\n\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_STRUCT_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n        }\n\n        return 0;\n    }\n\n    if (*s == DBUS_DICT_ENTRY_BEGIN_CHAR && allowDict) {\n        const char *p = s + 1;\n        unsigned n = 0;\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_DICT_ENTRY_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (n == 0 && !virDBusIsBasicType(*p)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Dict entry in signature '%s' must be a basic type\"),\n                               s);\n                return -1;\n            }\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n            n++;\n        }\n\n        if (n != 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Dict entry in signature '%s' is wrong size\"),\n                           s);\n            return -1;\n        }\n\n        return 0;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected signature '%s'\"), s);\n    return -1;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unexpected signature '%s'\")",
            "s"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unexpected signature '%s'\""
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Dict entry in signature '%s' is wrong size\")",
            "s"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusSignatureLengthInternal",
          "args": [
            "p",
            "false",
            "arrayDepth",
            "structDepth + 1",
            "&skiplencont",
            "&siglencont"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusSignatureLengthInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "317-444",
          "snippet": "static int\nvirDBusSignatureLengthInternal(const char *s,\n                               bool allowDict,\n                               unsigned arrayDepth,\n                               unsigned structDepth,\n                               size_t *skiplen,\n                               size_t *siglen)\n{\n    if (virDBusIsBasicType(*s) || *s == DBUS_TYPE_VARIANT) {\n        *skiplen = *siglen = 1;\n        return 0;\n    }\n\n    if (*s == DBUS_TYPE_ARRAY) {\n        size_t skiplencont;\n        size_t siglencont;\n        bool arrayref = false;\n\n        if (arrayDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        if (*(s + 1) == '&') {\n            arrayref = true;\n            s++;\n        }\n\n        if (virDBusSignatureLengthInternal(s + 1,\n                                           true,\n                                           arrayDepth + 1,\n                                           structDepth,\n                                           &skiplencont,\n                                           &siglencont) < 0)\n            return -1;\n\n        *skiplen = skiplencont + 1;\n        *siglen = siglencont + 1;\n        if (arrayref)\n            (*skiplen)++;\n        return 0;\n    }\n\n    if (*s == DBUS_STRUCT_BEGIN_CHAR) {\n        const char *p = s + 1;\n\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_STRUCT_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n        }\n\n        return 0;\n    }\n\n    if (*s == DBUS_DICT_ENTRY_BEGIN_CHAR && allowDict) {\n        const char *p = s + 1;\n        unsigned n = 0;\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_DICT_ENTRY_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (n == 0 && !virDBusIsBasicType(*p)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Dict entry in signature '%s' must be a basic type\"),\n                               s);\n                return -1;\n            }\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n            n++;\n        }\n\n        if (n != 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Dict entry in signature '%s' is wrong size\"),\n                           s);\n            return -1;\n        }\n\n        return 0;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected signature '%s'\"), s);\n    return -1;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Dict entry in signature '%s' must be a basic type\")",
            "s"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusIsBasicType",
          "args": [
            "*p"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusIsBasicType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "306-309",
          "snippet": "static bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Signature '%s' too deeply nested\")",
            "s"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Signature '%s' too deeply nested\")",
            "s"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Signature '%s' too deeply nested\")",
            "s"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int\nvirDBusSignatureLengthInternal(const char *s,\n                               bool allowDict,\n                               unsigned arrayDepth,\n                               unsigned structDepth,\n                               size_t *skiplen,\n                               size_t *siglen)\n{\n    if (virDBusIsBasicType(*s) || *s == DBUS_TYPE_VARIANT) {\n        *skiplen = *siglen = 1;\n        return 0;\n    }\n\n    if (*s == DBUS_TYPE_ARRAY) {\n        size_t skiplencont;\n        size_t siglencont;\n        bool arrayref = false;\n\n        if (arrayDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        if (*(s + 1) == '&') {\n            arrayref = true;\n            s++;\n        }\n\n        if (virDBusSignatureLengthInternal(s + 1,\n                                           true,\n                                           arrayDepth + 1,\n                                           structDepth,\n                                           &skiplencont,\n                                           &siglencont) < 0)\n            return -1;\n\n        *skiplen = skiplencont + 1;\n        *siglen = siglencont + 1;\n        if (arrayref)\n            (*skiplen)++;\n        return 0;\n    }\n\n    if (*s == DBUS_STRUCT_BEGIN_CHAR) {\n        const char *p = s + 1;\n\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_STRUCT_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n        }\n\n        return 0;\n    }\n\n    if (*s == DBUS_DICT_ENTRY_BEGIN_CHAR && allowDict) {\n        const char *p = s + 1;\n        unsigned n = 0;\n        if (structDepth >= VIR_DBUS_TYPE_STACK_MAX_DEPTH) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Signature '%s' too deeply nested\"),\n                           s);\n            return -1;\n        }\n\n        *skiplen = *siglen = 2;\n\n        while (*p != DBUS_DICT_ENTRY_END_CHAR) {\n            size_t skiplencont;\n            size_t siglencont;\n\n            if (n == 0 && !virDBusIsBasicType(*p)) {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Dict entry in signature '%s' must be a basic type\"),\n                               s);\n                return -1;\n            }\n\n            if (virDBusSignatureLengthInternal(p,\n                                               false,\n                                               arrayDepth,\n                                               structDepth + 1,\n                                               &skiplencont,\n                                               &siglencont) < 0)\n                return -1;\n\n            p += skiplencont;\n            *skiplen += skiplencont;\n            *siglen += siglencont;\n            n++;\n        }\n\n        if (n != 2) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Dict entry in signature '%s' is wrong size\"),\n                           s);\n            return -1;\n        }\n\n        return 0;\n    }\n\n    virReportError(VIR_ERR_INTERNAL_ERROR,\n                   _(\"Unexpected signature '%s'\"), s);\n    return -1;\n}"
  },
  {
    "function_name": "virDBusIsBasicType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "306-309",
    "snippet": "static bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "virDBusBasicTypes",
            "c",
            "G_N_ELEMENTS(virDBusBasicTypes)"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "virDBusBasicTypes"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic bool virDBusIsBasicType(char c)\n{\n    return !!memchr(virDBusBasicTypes, c, G_N_ELEMENTS(virDBusBasicTypes));\n}"
  },
  {
    "function_name": "virDBusToggleWatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "275-287",
    "snippet": "static void virDBusToggleWatch(DBusWatch *watch,\n                               void *data G_GNUC_UNUSED)\n{\n    int flags = 0;\n    struct virDBusWatch *info;\n\n    if (dbus_watch_get_enabled(watch))\n        flags = virDBusTranslateWatchFlags(dbus_watch_get_flags(watch));\n\n    info = dbus_watch_get_data(watch);\n\n    (void)virEventUpdateHandle(info->watch, flags);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventUpdateHandle",
          "args": [
            "info->watch",
            "flags"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "virEventUpdateHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "98-103",
          "snippet": "void\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventUpdateHandleFunc updateHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventUpdateHandleFunc updateHandleImpl;\n\nvoid\nvirEventUpdateHandle(int watch, int events)\n{\n    if (updateHandleImpl)\n        updateHandleImpl(watch, events);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_data",
          "args": [
            "watch"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTranslateWatchFlags",
          "args": [
            "dbus_watch_get_flags(watch)"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTranslateWatchFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "211-223",
          "snippet": "static int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_flags",
          "args": [
            "watch"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_enabled",
          "args": [
            "watch"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusToggleWatch(DBusWatch *watch,\n                               void *data G_GNUC_UNUSED)\n{\n    int flags = 0;\n    struct virDBusWatch *info;\n\n    if (dbus_watch_get_enabled(watch))\n        flags = virDBusTranslateWatchFlags(dbus_watch_get_flags(watch));\n\n    info = dbus_watch_get_data(watch);\n\n    (void)virEventUpdateHandle(info->watch, flags);\n}"
  },
  {
    "function_name": "virDBusRemoveWatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "264-272",
    "snippet": "static void virDBusRemoveWatch(DBusWatch *watch,\n                               void *data G_GNUC_UNUSED)\n{\n    struct virDBusWatch *info;\n\n    info = dbus_watch_get_data(watch);\n\n    (void)virEventRemoveHandle(info->watch);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virEventRemoveHandle",
          "args": [
            "info->watch"
          ],
          "line": 271
        },
        "resolved": true,
        "details": {
          "function_name": "virEventRemoveHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "116-123",
          "snippet": "int\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventRemoveHandleFunc removeHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventRemoveHandleFunc removeHandleImpl;\n\nint\nvirEventRemoveHandle(int watch)\n{\n    if (!removeHandleImpl)\n        return -1;\n\n    return removeHandleImpl(watch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_data",
          "args": [
            "watch"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusRemoveWatch(DBusWatch *watch,\n                               void *data G_GNUC_UNUSED)\n{\n    struct virDBusWatch *info;\n\n    info = dbus_watch_get_data(watch);\n\n    (void)virEventRemoveHandle(info->watch);\n}"
  },
  {
    "function_name": "virDBusAddWatch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "232-261",
    "snippet": "static dbus_bool_t virDBusAddWatch(DBusWatch *watch,\n                                   void *data)\n{\n    int flags = 0;\n    int fd;\n    struct virDBusWatch *info;\n\n    if (VIR_ALLOC(info) < 0)\n        return FALSE;\n\n    if (dbus_watch_get_enabled(watch))\n        flags = virDBusTranslateWatchFlags(dbus_watch_get_flags(watch));\n\n# if HAVE_DBUS_WATCH_GET_UNIX_FD\n    fd = dbus_watch_get_unix_fd(watch);\n# else\n    fd = dbus_watch_get_fd(watch);\n# endif\n    dbus_watch_set_data(watch, info, virDBusWatchFree);\n    info->bus = (DBusConnection *)data;\n    info->watch = virEventAddHandle(fd, flags,\n                                    virDBusWatchCallback,\n                                    watch, NULL);\n    if (info->watch < 0) {\n        dbus_watch_set_data(watch, NULL, NULL);\n        return FALSE;\n    }\n\n    return TRUE;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_watch_set_data",
          "args": [
            "watch",
            "NULL",
            "NULL"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virEventAddHandle",
          "args": [
            "fd",
            "flags",
            "virDBusWatchCallback",
            "watch",
            "NULL"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virEventAddHandle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virevent.c",
          "lines": "73-84",
          "snippet": "int\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vireventglib.h\"",
            "#include \"virevent.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virEventAddHandleFunc addHandleImpl;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vireventglib.h\"\n#include \"virevent.h\"\n#include <config.h>\n\nstatic virEventAddHandleFunc addHandleImpl;\n\nint\nvirEventAddHandle(int fd,\n                  int events,\n                  virEventHandleCallback cb,\n                  void *opaque,\n                  virFreeCallback ff)\n{\n    if (!addHandleImpl)\n        return -1;\n\n    return addHandleImpl(fd, events, cb, opaque, ff);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_watch_set_data",
          "args": [
            "watch",
            "info",
            "virDBusWatchFree"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_fd",
          "args": [
            "watch"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_unix_fd",
          "args": [
            "watch"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusTranslateWatchFlags",
          "args": [
            "dbus_watch_get_flags(watch)"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusTranslateWatchFlags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "211-223",
          "snippet": "static int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_flags",
          "args": [
            "watch"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_enabled",
          "args": [
            "watch"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "info"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic dbus_bool_t virDBusAddWatch(DBusWatch *watch,\n                                   void *data)\n{\n    int flags = 0;\n    int fd;\n    struct virDBusWatch *info;\n\n    if (VIR_ALLOC(info) < 0)\n        return FALSE;\n\n    if (dbus_watch_get_enabled(watch))\n        flags = virDBusTranslateWatchFlags(dbus_watch_get_flags(watch));\n\n# if HAVE_DBUS_WATCH_GET_UNIX_FD\n    fd = dbus_watch_get_unix_fd(watch);\n# else\n    fd = dbus_watch_get_fd(watch);\n# endif\n    dbus_watch_set_data(watch, info, virDBusWatchFree);\n    info->bus = (DBusConnection *)data;\n    info->watch = virEventAddHandle(fd, flags,\n                                    virDBusWatchCallback,\n                                    watch, NULL);\n    if (info->watch < 0) {\n        dbus_watch_set_data(watch, NULL, NULL);\n        return FALSE;\n    }\n\n    return TRUE;\n}"
  },
  {
    "function_name": "virDBusWatchFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "226-230",
    "snippet": "static void virDBusWatchFree(void *data)\n{\n    struct virDBusWatch *info = data;\n    VIR_FREE(info);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "info"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusWatchFree(void *data)\n{\n    struct virDBusWatch *info = data;\n    VIR_FREE(info);\n}"
  },
  {
    "function_name": "virDBusTranslateWatchFlags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "211-223",
    "snippet": "static int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic int virDBusTranslateWatchFlags(int dbus_flags)\n{\n    unsigned int flags = 0;\n    if (dbus_flags & DBUS_WATCH_READABLE)\n        flags |= VIR_EVENT_HANDLE_READABLE;\n    if (dbus_flags & DBUS_WATCH_WRITABLE)\n        flags |= VIR_EVENT_HANDLE_WRITABLE;\n    if (dbus_flags & DBUS_WATCH_ERROR)\n        flags |= VIR_EVENT_HANDLE_ERROR;\n    if (dbus_flags & DBUS_WATCH_HANGUP)\n        flags |= VIR_EVENT_HANDLE_HANGUP;\n    return flags;\n}"
  },
  {
    "function_name": "virDBusWatchCallback",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "182-208",
    "snippet": "static void virDBusWatchCallback(int fdatch G_GNUC_UNUSED,\n                                 int fd G_GNUC_UNUSED,\n                                 int events, void *opaque)\n{\n    DBusWatch *watch = opaque;\n    struct virDBusWatch *info;\n    int dbus_flags = 0;\n\n    info = dbus_watch_get_data(watch);\n\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        dbus_flags |= DBUS_WATCH_READABLE;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        dbus_flags |= DBUS_WATCH_WRITABLE;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        dbus_flags |= DBUS_WATCH_ERROR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        dbus_flags |= DBUS_WATCH_HANGUP;\n\n    if (dbus_watch_handle(watch, dbus_flags) == FALSE)\n        VIR_DEBUG(\"dbus_watch_handle() returned FALSE\");\n\n    dbus_connection_ref(info->bus);\n    while (dbus_connection_dispatch(info->bus) == DBUS_DISPATCH_DATA_REMAINS)\n        /* keep dispatching while data remains */;\n    dbus_connection_unref(info->bus);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_connection_unref",
          "args": [
            "info->bus"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_dispatch",
          "args": [
            "info->bus"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_ref",
          "args": [
            "info->bus"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"dbus_watch_handle() returned FALSE\""
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_handle",
          "args": [
            "watch",
            "dbus_flags"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_watch_get_data",
          "args": [
            "watch"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusWatchCallback(int fdatch G_GNUC_UNUSED,\n                                 int fd G_GNUC_UNUSED,\n                                 int events, void *opaque)\n{\n    DBusWatch *watch = opaque;\n    struct virDBusWatch *info;\n    int dbus_flags = 0;\n\n    info = dbus_watch_get_data(watch);\n\n    if (events & VIR_EVENT_HANDLE_READABLE)\n        dbus_flags |= DBUS_WATCH_READABLE;\n    if (events & VIR_EVENT_HANDLE_WRITABLE)\n        dbus_flags |= DBUS_WATCH_WRITABLE;\n    if (events & VIR_EVENT_HANDLE_ERROR)\n        dbus_flags |= DBUS_WATCH_ERROR;\n    if (events & VIR_EVENT_HANDLE_HANGUP)\n        dbus_flags |= DBUS_WATCH_HANGUP;\n\n    if (dbus_watch_handle(watch, dbus_flags) == FALSE)\n        VIR_DEBUG(\"dbus_watch_handle() returned FALSE\");\n\n    dbus_connection_ref(info->bus);\n    while (dbus_connection_dispatch(info->bus) == DBUS_DISPATCH_DATA_REMAINS)\n        /* keep dispatching while data remains */;\n    dbus_connection_unref(info->bus);\n}"
  },
  {
    "function_name": "virDBusGetSessionBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "158-174",
    "snippet": "DBusConnection *virDBusGetSessionBus(void)\n{\n    if (virOnce(&sessiononce, virDBusSessionBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    if (!sessionbus) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to get DBus session bus connection: %s\"),\n                       sessiondbuserr.message ? sessiondbuserr.message : \"watch setup failed\");\n        return NULL;\n    }\n\n    return sessionbus;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get DBus session bus connection: %s\")",
            "sessiondbuserr.message ? sessiondbuserr.message : \"watch setup failed\""
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get DBus session bus connection: %s\""
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to run one time DBus initializer\")"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virOnce",
          "args": [
            "&sessiononce",
            "virDBusSessionBusInit"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "virOnce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "40-43",
          "snippet": "int virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *virDBusGetSessionBus(void)\n{\n    if (virOnce(&sessiononce, virDBusSessionBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    if (!sessionbus) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to get DBus session bus connection: %s\"),\n                       sessiondbuserr.message ? sessiondbuserr.message : \"watch setup failed\");\n        return NULL;\n    }\n\n    return sessionbus;\n}"
  },
  {
    "function_name": "virDBusSessionBusInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "153-156",
    "snippet": "static void virDBusSessionBusInit(void)\n{\n    sessionbus = virDBusBusInit(DBUS_BUS_SESSION, &sessiondbuserr);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusBusInit",
          "args": [
            "DBUS_BUS_SESSION",
            "&sessiondbuserr"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusBusInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "56-82",
          "snippet": "static DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusSessionBusInit(void)\n{\n    sessionbus = virDBusBusInit(DBUS_BUS_SESSION, &sessiondbuserr);\n}"
  },
  {
    "function_name": "virDBusCloseSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "144-151",
    "snippet": "void virDBusCloseSystemBus(void)\n{\n    if (systembus && !sharedBus) {\n        dbus_connection_close(systembus);\n        dbus_connection_unref(systembus);\n        systembus = NULL;\n    }\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_connection_unref",
          "args": [
            "systembus"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_close",
          "args": [
            "systembus"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusCloseSystemBus(void)\n{\n    if (systembus && !sharedBus) {\n        dbus_connection_close(systembus);\n        dbus_connection_unref(systembus);\n        systembus = NULL;\n    }\n}"
  },
  {
    "function_name": "virDBusHasSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "128-141",
    "snippet": "bool\nvirDBusHasSystemBus(void)\n{\n    if (virDBusGetSystemBusInternal())\n        return true;\n\n    if (systemdbuserr.name &&\n        (STREQ(systemdbuserr.name, \"org.freedesktop.DBus.Error.FileNotFound\") ||\n         STREQ(systemdbuserr.name, \"org.freedesktop.DBus.Error.NoServer\"))) {\n        VIR_DEBUG(\"System DBus not available: %s\", NULLSTR(systemdbuserr.message));\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"System DBus not available: %s\"",
            "NULLSTR(systemdbuserr.message)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "systemdbuserr.message"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "systemdbuserr.name",
            "\"org.freedesktop.DBus.Error.NoServer\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "systemdbuserr.name",
            "\"org.freedesktop.DBus.Error.FileNotFound\""
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBusInternal",
          "args": [],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBusInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "89-99",
          "snippet": "static DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nbool\nvirDBusHasSystemBus(void)\n{\n    if (virDBusGetSystemBusInternal())\n        return true;\n\n    if (systemdbuserr.name &&\n        (STREQ(systemdbuserr.name, \"org.freedesktop.DBus.Error.FileNotFound\") ||\n         STREQ(systemdbuserr.name, \"org.freedesktop.DBus.Error.NoServer\"))) {\n        VIR_DEBUG(\"System DBus not available: %s\", NULLSTR(systemdbuserr.message));\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virDBusGetSystemBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "102-115",
    "snippet": "DBusConnection *\nvirDBusGetSystemBus(void)\n{\n    DBusConnection *bus;\n\n    if (!(bus = virDBusGetSystemBusInternal())) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to get DBus system bus connection: %s\"),\n                       systemdbuserr.message ? systemdbuserr.message : \"watch setup failed\");\n        return NULL;\n    }\n\n    return bus;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to get DBus system bus connection: %s\")",
            "systemdbuserr.message ? systemdbuserr.message : \"watch setup failed\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to get DBus system bus connection: %s\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDBusGetSystemBusInternal",
          "args": [],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusGetSystemBusInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "89-99",
          "snippet": "static DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nDBusConnection *\nvirDBusGetSystemBus(void)\n{\n    DBusConnection *bus;\n\n    if (!(bus = virDBusGetSystemBusInternal())) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to get DBus system bus connection: %s\"),\n                       systemdbuserr.message ? systemdbuserr.message : \"watch setup failed\");\n        return NULL;\n    }\n\n    return bus;\n}"
  },
  {
    "function_name": "virDBusGetSystemBusInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "89-99",
    "snippet": "static DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Unable to run one time DBus initializer\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to run one time DBus initializer\""
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virOnce",
          "args": [
            "&systemonce",
            "virDBusSystemBusInit"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "virOnce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virthread.c",
          "lines": "40-43",
          "snippet": "int virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}",
          "includes": [
            "#include \"virthreadjob.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/syscall.h>",
            "#include <inttypes.h>",
            "#include <unistd.h>",
            "# include <pthread_np.h>",
            "#include \"virthread.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthreadjob.h\"\n#include \"viralloc.h\"\n# include <sys/syscall.h>\n#include <inttypes.h>\n#include <unistd.h>\n# include <pthread_np.h>\n#include \"virthread.h\"\n#include <config.h>\n\nint virOnce(virOnceControlPtr once, virOnceFunc init)\n{\n    return pthread_once(&once->once, init);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *\nvirDBusGetSystemBusInternal(void)\n{\n    if (virOnce(&systemonce, virDBusSystemBusInit) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to run one time DBus initializer\"));\n        return NULL;\n    }\n\n    return systembus;\n}"
  },
  {
    "function_name": "virDBusSystemBusInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "84-87",
    "snippet": "static void virDBusSystemBusInit(void)\n{\n    systembus = virDBusBusInit(DBUS_BUS_SYSTEM, &systemdbuserr);\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDBusBusInit",
          "args": [
            "DBUS_BUS_SYSTEM",
            "&systemdbuserr"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "virDBusBusInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
          "lines": "56-82",
          "snippet": "static DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}",
          "includes": [
            "#include \"virprobe.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virdbuspriv.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic void virDBusSystemBusInit(void)\n{\n    systembus = virDBusBusInit(DBUS_BUS_SYSTEM, &systemdbuserr);\n}"
  },
  {
    "function_name": "virDBusBusInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "56-82",
    "snippet": "static DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dbus_connection_set_watch_functions",
          "args": [
            "bus",
            "virDBusAddWatch",
            "virDBusRemoveWatch",
            "virDBusToggleWatch",
            "bus",
            "NULL"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_set_exit_on_disconnect",
          "args": [
            "bus",
            "FALSE"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_bus_get_private",
          "args": [
            "type",
            "dbuserr"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_bus_get",
          "args": [
            "type",
            "dbuserr"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_error_init",
          "args": [
            "dbuserr"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_threads_init_default",
          "args": [],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbus_connection_set_change_sigpipe",
          "args": [
            "FALSE"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nstatic DBusConnection *virDBusBusInit(DBusBusType type, DBusError *dbuserr)\n{\n    DBusConnection *bus;\n\n    /* Allocate and initialize a new HAL context */\n    dbus_connection_set_change_sigpipe(FALSE);\n    dbus_threads_init_default();\n\n    dbus_error_init(dbuserr);\n    bus = sharedBus ?\n        dbus_bus_get(type, dbuserr) :\n        dbus_bus_get_private(type, dbuserr);\n    if (!bus)\n        return NULL;\n\n    dbus_connection_set_exit_on_disconnect(bus, FALSE);\n\n    /* Register dbus watch callbacks */\n    if (!dbus_connection_set_watch_functions(bus,\n                                             virDBusAddWatch,\n                                             virDBusRemoveWatch,\n                                             virDBusToggleWatch,\n                                             bus, NULL)) {\n        return NULL;\n    }\n    return bus;\n}"
  },
  {
    "function_name": "virDBusSetSharedBus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virdbus.c",
    "lines": "51-54",
    "snippet": "void virDBusSetSharedBus(bool shared)\n{\n    sharedBus = shared;\n}",
    "includes": [
      "#include \"virprobe.h\"",
      "#include \"virstring.h\"",
      "#include \"virthread.h\"",
      "#include \"virlog.h\"",
      "#include \"virerror.h\"",
      "#include \"viralloc.h\"",
      "#include \"virdbuspriv.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virprobe.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virdbuspriv.h\"\n#include <config.h>\n\nvoid virDBusSetSharedBus(bool shared)\n{\n    sharedBus = shared;\n}"
  }
]