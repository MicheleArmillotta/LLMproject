[
  {
    "function_name": "virDomainBackupAlignDisks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "437-507",
    "snippet": "int\nvirDomainBackupAlignDisks(virDomainBackupDefPtr def,\n                          virDomainDefPtr dom,\n                          const char *suffix)\n{\n    g_autoptr(virHashTable) disks = virHashNew(NULL);\n    size_t i;\n    int ndisks;\n    bool backup_all = false;\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"domain must have at least one disk to perform backup\"));\n        return -1;\n    }\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = &def->disks[i];\n        virDomainDiskDefPtr domdisk;\n\n        if (!(domdisk = virDomainDiskByTarget(dom, backupdisk->name))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), backupdisk->name);\n            return -1;\n        }\n\n        if (virHashAddEntry(disks, backupdisk->name, NULL) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           backupdisk->name);\n            return -1;\n        }\n\n        if (backupdisk->backup == VIR_TRISTATE_BOOL_YES &&\n            virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n            return -1;\n    }\n\n    if (def->ndisks == 0)\n        backup_all = true;\n\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks, dom->ndisks - def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < dom->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = NULL;\n        virDomainDiskDefPtr domdisk =  dom->disks[i];\n\n        if (virHashHasEntry(disks, domdisk->dst))\n            continue;\n\n        backupdisk = &def->disks[ndisks++];\n        backupdisk->name = g_strdup(domdisk->dst);\n\n        if (backup_all &&\n            !virStorageSourceIsEmpty(domdisk->src) &&\n            !domdisk->src->readonly) {\n            backupdisk->backup = VIR_TRISTATE_BOOL_YES;\n\n            if (virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n                return -1;\n        } else {\n            backupdisk->backup = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainBackupDefAssignStore",
          "args": [
            "backupdisk",
            "domdisk->src",
            "suffix"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefAssignStore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "400-434",
          "snippet": "static int\nvirDomainBackupDefAssignStore(virDomainBackupDiskDefPtr disk,\n                              virStorageSourcePtr src,\n                              const char *suffix)\n{\n    if (virStorageSourceIsEmpty(src)) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' has no media\"), disk->name);\n            return -1;\n        }\n    } else if (src->readonly) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"backup of readonly disk '%s' makes no sense\"),\n                           disk->name);\n            return -1;\n        }\n    } else if (!disk->store) {\n        if (virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_FILE) {\n            if (!(disk->store = virStorageSourceNew()))\n                return -1;\n\n            disk->store->type = VIR_STORAGE_TYPE_FILE;\n            disk->store->path = g_strdup_printf(\"%s.%s\", src->path, suffix);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"refusing to generate file name for disk '%s'\"),\n                           disk->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDefAssignStore(virDomainBackupDiskDefPtr disk,\n                              virStorageSourcePtr src,\n                              const char *suffix)\n{\n    if (virStorageSourceIsEmpty(src)) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' has no media\"), disk->name);\n            return -1;\n        }\n    } else if (src->readonly) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"backup of readonly disk '%s' makes no sense\"),\n                           disk->name);\n            return -1;\n        }\n    } else if (!disk->store) {\n        if (virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_FILE) {\n            if (!(disk->store = virStorageSourceNew()))\n                return -1;\n\n            disk->store->type = VIR_STORAGE_TYPE_FILE;\n            disk->store->path = g_strdup_printf(\"%s.%s\", src->path, suffix);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"refusing to generate file name for disk '%s'\"),\n                           disk->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "domdisk->src"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "domdisk->dst"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashHasEntry",
          "args": [
            "disks",
            "domdisk->dst"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "virHashHasEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "494-499",
          "snippet": "bool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nbool\nvirHashHasEntry(const virHashTable *table,\n                const void *name)\n{\n    return !!virHashGetEntry(table, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_EXPAND_N",
          "args": [
            "def->disks",
            "def->ndisks",
            "dom->ndisks - def->ndisks"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk '%s' specified twice\")",
            "backupdisk->name"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"disk '%s' specified twice\""
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "disks",
            "backupdisk->name",
            "NULL"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"no disk named '%s'\")",
            "backupdisk->name"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "dom",
            "backupdisk->name"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"domain must have at least one disk to perform backup\")"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashNew",
          "args": [
            "NULL"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virHashNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "180-190",
          "snippet": "virHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirHashTablePtr\nvirHashNew(virHashDataFree dataFree)\n{\n    return virHashCreateFull(32,\n                             dataFree,\n                             virHashStrCode,\n                             virHashStrEqual,\n                             virHashStrCopy,\n                             virHashStrPrintHuman,\n                             virHashStrFree);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nint\nvirDomainBackupAlignDisks(virDomainBackupDefPtr def,\n                          virDomainDefPtr dom,\n                          const char *suffix)\n{\n    g_autoptr(virHashTable) disks = virHashNew(NULL);\n    size_t i;\n    int ndisks;\n    bool backup_all = false;\n\n    /* Unlikely to have a guest without disks but technically possible.  */\n    if (!dom->ndisks) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                       _(\"domain must have at least one disk to perform backup\"));\n        return -1;\n    }\n\n    /* Double check requested disks.  */\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = &def->disks[i];\n        virDomainDiskDefPtr domdisk;\n\n        if (!(domdisk = virDomainDiskByTarget(dom, backupdisk->name))) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"no disk named '%s'\"), backupdisk->name);\n            return -1;\n        }\n\n        if (virHashAddEntry(disks, backupdisk->name, NULL) < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' specified twice\"),\n                           backupdisk->name);\n            return -1;\n        }\n\n        if (backupdisk->backup == VIR_TRISTATE_BOOL_YES &&\n            virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n            return -1;\n    }\n\n    if (def->ndisks == 0)\n        backup_all = true;\n\n    ndisks = def->ndisks;\n    if (VIR_EXPAND_N(def->disks, def->ndisks, dom->ndisks - def->ndisks) < 0)\n        return -1;\n\n    for (i = 0; i < dom->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = NULL;\n        virDomainDiskDefPtr domdisk =  dom->disks[i];\n\n        if (virHashHasEntry(disks, domdisk->dst))\n            continue;\n\n        backupdisk = &def->disks[ndisks++];\n        backupdisk->name = g_strdup(domdisk->dst);\n\n        if (backup_all &&\n            !virStorageSourceIsEmpty(domdisk->src) &&\n            !domdisk->src->readonly) {\n            backupdisk->backup = VIR_TRISTATE_BOOL_YES;\n\n            if (virDomainBackupDefAssignStore(backupdisk, domdisk->src, suffix) < 0)\n                return -1;\n        } else {\n            backupdisk->backup = VIR_TRISTATE_BOOL_NO;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainBackupDefAssignStore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "400-434",
    "snippet": "static int\nvirDomainBackupDefAssignStore(virDomainBackupDiskDefPtr disk,\n                              virStorageSourcePtr src,\n                              const char *suffix)\n{\n    if (virStorageSourceIsEmpty(src)) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' has no media\"), disk->name);\n            return -1;\n        }\n    } else if (src->readonly) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"backup of readonly disk '%s' makes no sense\"),\n                           disk->name);\n            return -1;\n        }\n    } else if (!disk->store) {\n        if (virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_FILE) {\n            if (!(disk->store = virStorageSourceNew()))\n                return -1;\n\n            disk->store->type = VIR_STORAGE_TYPE_FILE;\n            disk->store->path = g_strdup_printf(\"%s.%s\", src->path, suffix);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"refusing to generate file name for disk '%s'\"),\n                           disk->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"refusing to generate file name for disk '%s'\")",
            "disk->name"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"refusing to generate file name for disk '%s'\""
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s.%s\"",
            "src->path",
            "suffix"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "src"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"backup of readonly disk '%s' makes no sense\")",
            "disk->name"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"disk '%s' has no media\")",
            "disk->name"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "src"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDefAssignStore(virDomainBackupDiskDefPtr disk,\n                              virStorageSourcePtr src,\n                              const char *suffix)\n{\n    if (virStorageSourceIsEmpty(src)) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"disk '%s' has no media\"), disk->name);\n            return -1;\n        }\n    } else if (src->readonly) {\n        if (disk->store) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"backup of readonly disk '%s' makes no sense\"),\n                           disk->name);\n            return -1;\n        }\n    } else if (!disk->store) {\n        if (virStorageSourceGetActualType(src) == VIR_STORAGE_TYPE_FILE) {\n            if (!(disk->store = virStorageSourceNew()))\n                return -1;\n\n            disk->store->type = VIR_STORAGE_TYPE_FILE;\n            disk->store->path = g_strdup_printf(\"%s.%s\", src->path, suffix);\n        } else {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"refusing to generate file name for disk '%s'\"),\n                           disk->name);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainBackupDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "360-397",
    "snippet": "int\nvirDomainBackupDefFormat(virBufferPtr buf,\n                         virDomainBackupDefPtr def,\n                         bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    g_auto(virBuffer) serverAttrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) disksChildBuf = VIR_BUFFER_INIT_CHILD(&childBuf);\n    size_t i;\n\n    virBufferAsprintf(&attrBuf, \" mode='%s'\", virDomainBackupTypeToString(def->type));\n\n    virBufferEscapeString(&childBuf, \"<incremental>%s</incremental>\\n\", def->incremental);\n\n    if (def->server) {\n        virBufferAsprintf(&serverAttrBuf, \" transport='%s'\",\n                          virStorageNetHostTransportTypeToString(def->server->transport));\n        virBufferEscapeString(&serverAttrBuf, \" name='%s'\", def->server->name);\n        if (def->server->port)\n            virBufferAsprintf(&serverAttrBuf, \" port='%u'\", def->server->port);\n        virBufferEscapeString(&serverAttrBuf, \" socket='%s'\", def->server->socket);\n    }\n\n    virXMLFormatElement(&childBuf, \"server\", &serverAttrBuf, NULL);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefFormat(&disksChildBuf, &def->disks[i],\n                                         def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                         internal) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(&childBuf, \"disks\", NULL, &disksChildBuf);\n    virXMLFormatElement(buf, \"domainbackup\", &attrBuf, &childBuf);\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXMLFormatElement",
          "args": [
            "buf",
            "\"domainbackup\"",
            "&attrBuf",
            "&childBuf"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLFormatElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1374-1399",
          "snippet": "void\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainBackupDiskDefFormat",
          "args": [
            "&disksChildBuf",
            "&def->disks[i]",
            "def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH",
            "internal"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDiskDefFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "318-357",
          "snippet": "static int\nvirDomainBackupDiskDefFormat(virBufferPtr buf,\n                             virDomainBackupDiskDefPtr disk,\n                             bool push,\n                             bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    const char *sourcename = \"scratch\";\n    unsigned int storageSourceFormatFlags = 0;\n\n    if (push)\n        sourcename = \"target\";\n\n    if (internal)\n        storageSourceFormatFlags |= VIR_DOMAIN_DEF_FORMAT_STATUS;\n\n    virBufferEscapeString(&attrBuf, \" name='%s'\", disk->name);\n    virBufferAsprintf(&attrBuf, \" backup='%s'\", virTristateBoolTypeToString(disk->backup));\n    if (internal)\n        virBufferAsprintf(&attrBuf, \" state='%s'\", virDomainBackupDiskStateTypeToString(disk->state));\n\n    if (disk->backup == VIR_TRISTATE_BOOL_YES) {\n        virBufferAsprintf(&attrBuf, \" type='%s'\", virStorageTypeToString(disk->store->type));\n\n        virBufferEscapeString(&attrBuf, \" exportname='%s'\", disk->exportname);\n        virBufferEscapeString(&attrBuf, \" exportbitmap='%s'\", disk->exportbitmap);\n\n        if (disk->store->format > 0)\n            virBufferEscapeString(&childBuf, \"<driver type='%s'/>\\n\",\n                                  virStorageFileFormatTypeToString(disk->store->format));\n\n        if (virDomainDiskSourceFormat(&childBuf, disk->store, sourcename,\n                                      0, false, storageSourceFormatFlags, true, NULL) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(buf, \"disk\", &attrBuf, &childBuf);\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDiskDefFormat(virBufferPtr buf,\n                             virDomainBackupDiskDefPtr disk,\n                             bool push,\n                             bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    const char *sourcename = \"scratch\";\n    unsigned int storageSourceFormatFlags = 0;\n\n    if (push)\n        sourcename = \"target\";\n\n    if (internal)\n        storageSourceFormatFlags |= VIR_DOMAIN_DEF_FORMAT_STATUS;\n\n    virBufferEscapeString(&attrBuf, \" name='%s'\", disk->name);\n    virBufferAsprintf(&attrBuf, \" backup='%s'\", virTristateBoolTypeToString(disk->backup));\n    if (internal)\n        virBufferAsprintf(&attrBuf, \" state='%s'\", virDomainBackupDiskStateTypeToString(disk->state));\n\n    if (disk->backup == VIR_TRISTATE_BOOL_YES) {\n        virBufferAsprintf(&attrBuf, \" type='%s'\", virStorageTypeToString(disk->store->type));\n\n        virBufferEscapeString(&attrBuf, \" exportname='%s'\", disk->exportname);\n        virBufferEscapeString(&attrBuf, \" exportbitmap='%s'\", disk->exportbitmap);\n\n        if (disk->store->format > 0)\n            virBufferEscapeString(&childBuf, \"<driver type='%s'/>\\n\",\n                                  virStorageFileFormatTypeToString(disk->store->format));\n\n        if (virDomainDiskSourceFormat(&childBuf, disk->store, sourcename,\n                                      0, false, storageSourceFormatFlags, true, NULL) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(buf, \"disk\", &attrBuf, &childBuf);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&serverAttrBuf",
            "\" socket='%s'\"",
            "def->server->socket"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&serverAttrBuf",
            "\" port='%u'\"",
            "def->server->port"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageNetHostTransportTypeToString",
          "args": [
            "def->server->transport"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupTypeToString",
          "args": [
            "def->type"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "&childBuf"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nint\nvirDomainBackupDefFormat(virBufferPtr buf,\n                         virDomainBackupDefPtr def,\n                         bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    g_auto(virBuffer) serverAttrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) disksChildBuf = VIR_BUFFER_INIT_CHILD(&childBuf);\n    size_t i;\n\n    virBufferAsprintf(&attrBuf, \" mode='%s'\", virDomainBackupTypeToString(def->type));\n\n    virBufferEscapeString(&childBuf, \"<incremental>%s</incremental>\\n\", def->incremental);\n\n    if (def->server) {\n        virBufferAsprintf(&serverAttrBuf, \" transport='%s'\",\n                          virStorageNetHostTransportTypeToString(def->server->transport));\n        virBufferEscapeString(&serverAttrBuf, \" name='%s'\", def->server->name);\n        if (def->server->port)\n            virBufferAsprintf(&serverAttrBuf, \" port='%u'\", def->server->port);\n        virBufferEscapeString(&serverAttrBuf, \" socket='%s'\", def->server->socket);\n    }\n\n    virXMLFormatElement(&childBuf, \"server\", &serverAttrBuf, NULL);\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefFormat(&disksChildBuf, &def->disks[i],\n                                         def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH,\n                                         internal) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(&childBuf, \"disks\", NULL, &disksChildBuf);\n    virXMLFormatElement(buf, \"domainbackup\", &attrBuf, &childBuf);\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainBackupDiskDefFormat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "318-357",
    "snippet": "static int\nvirDomainBackupDiskDefFormat(virBufferPtr buf,\n                             virDomainBackupDiskDefPtr disk,\n                             bool push,\n                             bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    const char *sourcename = \"scratch\";\n    unsigned int storageSourceFormatFlags = 0;\n\n    if (push)\n        sourcename = \"target\";\n\n    if (internal)\n        storageSourceFormatFlags |= VIR_DOMAIN_DEF_FORMAT_STATUS;\n\n    virBufferEscapeString(&attrBuf, \" name='%s'\", disk->name);\n    virBufferAsprintf(&attrBuf, \" backup='%s'\", virTristateBoolTypeToString(disk->backup));\n    if (internal)\n        virBufferAsprintf(&attrBuf, \" state='%s'\", virDomainBackupDiskStateTypeToString(disk->state));\n\n    if (disk->backup == VIR_TRISTATE_BOOL_YES) {\n        virBufferAsprintf(&attrBuf, \" type='%s'\", virStorageTypeToString(disk->store->type));\n\n        virBufferEscapeString(&attrBuf, \" exportname='%s'\", disk->exportname);\n        virBufferEscapeString(&attrBuf, \" exportbitmap='%s'\", disk->exportbitmap);\n\n        if (disk->store->format > 0)\n            virBufferEscapeString(&childBuf, \"<driver type='%s'/>\\n\",\n                                  virStorageFileFormatTypeToString(disk->store->format));\n\n        if (virDomainDiskSourceFormat(&childBuf, disk->store, sourcename,\n                                      0, false, storageSourceFormatFlags, true, NULL) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(buf, \"disk\", &attrBuf, &childBuf);\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virXMLFormatElement",
          "args": [
            "buf",
            "\"disk\"",
            "&attrBuf",
            "&childBuf"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLFormatElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1374-1399",
          "snippet": "void\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirXMLFormatElement(virBufferPtr buf,\n                    const char *name,\n                    virBufferPtr attrBuf,\n                    virBufferPtr childBuf)\n{\n    if ((!attrBuf || virBufferUse(attrBuf) == 0) &&\n        (!childBuf || virBufferUse(childBuf) == 0))\n        return;\n\n    virBufferAsprintf(buf, \"<%s\", name);\n\n    if (attrBuf && virBufferUse(attrBuf) > 0)\n        virBufferAddBuffer(buf, attrBuf);\n\n    if (childBuf && virBufferUse(childBuf) > 0) {\n        virBufferAddLit(buf, \">\\n\");\n        virBufferAddBuffer(buf, childBuf);\n        virBufferAsprintf(buf, \"</%s>\\n\", name);\n    } else {\n        virBufferAddLit(buf, \"/>\\n\");\n    }\n\n    virBufferFreeAndReset(attrBuf);\n    virBufferFreeAndReset(childBuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskSourceFormat",
          "args": [
            "&childBuf",
            "disk->store",
            "sourcename",
            "0",
            "false",
            "storageSourceFormatFlags",
            "true",
            "NULL"
          ],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskSourceFormat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "24732-24824",
          "snippet": "int\nvirDomainDiskSourceFormat(virBufferPtr buf,\n                          virStorageSourcePtr src,\n                          const char *element,\n                          int policy,\n                          bool attrIndex,\n                          unsigned int flags,\n                          bool formatsecrets,\n                          virDomainXMLOptionPtr xmlopt)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        virBufferEscapeString(&attrBuf, \" file='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        virBufferEscapeString(&attrBuf, \" dev='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        virBufferEscapeString(&attrBuf, \" dir='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceFormatNetwork(&attrBuf, &childBuf,\n                                             src, flags) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (src->srcpool) {\n            virBufferEscapeString(&attrBuf, \" pool='%s'\", src->srcpool->pool);\n            virBufferEscapeString(&attrBuf, \" volume='%s'\",\n                                  src->srcpool->volume);\n            if (src->srcpool->mode)\n                virBufferAsprintf(&attrBuf, \" mode='%s'\",\n                                  virStorageSourcePoolModeTypeToString(src->srcpool->mode));\n        }\n\n        break;\n\n    case VIR_STORAGE_TYPE_NVME:\n        virDomainDiskSourceNVMeFormat(&attrBuf, &childBuf, src->nvme);\n        break;\n\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %d\"), src->type);\n        return -1;\n    }\n\n    virDomainDiskSourceFormatSlices(&childBuf, src);\n\n    if (src->type != VIR_STORAGE_TYPE_NETWORK)\n        virDomainSourceDefFormatSeclabel(&childBuf, src->nseclabels,\n                                         src->seclabels, flags);\n\n    /* Storage Source formatting will not carry through the blunder\n     * that disk source formatting had at one time to format the\n     * <auth> for a volume source type. The <auth> information is\n     * kept in the storage pool and would be overwritten anyway.\n     * So avoid formatting it for volumes. */\n    if (src->auth && (src->authInherited || formatsecrets) &&\n        src->type != VIR_STORAGE_TYPE_VOLUME)\n        virStorageAuthDefFormat(&childBuf, src->auth);\n\n    /* If we found encryption as a child of <source>, then format it\n     * as we found it. */\n    if (src->encryption && (src->encryptionInherited || formatsecrets) &&\n        virStorageEncryptionFormat(&childBuf, src->encryption) < 0)\n        return -1;\n\n    if (src->pr)\n        virStoragePRDefFormat(&childBuf, src->pr,\n                              flags & VIR_DOMAIN_DEF_FORMAT_MIGRATABLE);\n    if (policy && src->type != VIR_STORAGE_TYPE_NETWORK)\n        virBufferEscapeString(&attrBuf, \" startupPolicy='%s'\",\n                              virDomainStartupPolicyTypeToString(policy));\n\n    if (attrIndex && src->id != 0)\n        virBufferAsprintf(&attrBuf, \" index='%u'\", src->id);\n\n    if (virDomainDiskSourceFormatPrivateData(&childBuf, src, flags, xmlopt) < 0)\n        return -1;\n\n    virXMLFormatElement(buf, element, &attrBuf, &childBuf);\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainDiskSourceFormat(virBufferPtr buf,\n                          virStorageSourcePtr src,\n                          const char *element,\n                          int policy,\n                          bool attrIndex,\n                          unsigned int flags,\n                          bool formatsecrets,\n                          virDomainXMLOptionPtr xmlopt)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        virBufferEscapeString(&attrBuf, \" file='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_BLOCK:\n        virBufferEscapeString(&attrBuf, \" dev='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_DIR:\n        virBufferEscapeString(&attrBuf, \" dir='%s'\", src->path);\n        break;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceFormatNetwork(&attrBuf, &childBuf,\n                                             src, flags) < 0)\n            return -1;\n        break;\n\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (src->srcpool) {\n            virBufferEscapeString(&attrBuf, \" pool='%s'\", src->srcpool->pool);\n            virBufferEscapeString(&attrBuf, \" volume='%s'\",\n                                  src->srcpool->volume);\n            if (src->srcpool->mode)\n                virBufferAsprintf(&attrBuf, \" mode='%s'\",\n                                  virStorageSourcePoolModeTypeToString(src->srcpool->mode));\n        }\n\n        break;\n\n    case VIR_STORAGE_TYPE_NVME:\n        virDomainDiskSourceNVMeFormat(&attrBuf, &childBuf, src->nvme);\n        break;\n\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %d\"), src->type);\n        return -1;\n    }\n\n    virDomainDiskSourceFormatSlices(&childBuf, src);\n\n    if (src->type != VIR_STORAGE_TYPE_NETWORK)\n        virDomainSourceDefFormatSeclabel(&childBuf, src->nseclabels,\n                                         src->seclabels, flags);\n\n    /* Storage Source formatting will not carry through the blunder\n     * that disk source formatting had at one time to format the\n     * <auth> for a volume source type. The <auth> information is\n     * kept in the storage pool and would be overwritten anyway.\n     * So avoid formatting it for volumes. */\n    if (src->auth && (src->authInherited || formatsecrets) &&\n        src->type != VIR_STORAGE_TYPE_VOLUME)\n        virStorageAuthDefFormat(&childBuf, src->auth);\n\n    /* If we found encryption as a child of <source>, then format it\n     * as we found it. */\n    if (src->encryption && (src->encryptionInherited || formatsecrets) &&\n        virStorageEncryptionFormat(&childBuf, src->encryption) < 0)\n        return -1;\n\n    if (src->pr)\n        virStoragePRDefFormat(&childBuf, src->pr,\n                              flags & VIR_DOMAIN_DEF_FORMAT_MIGRATABLE);\n    if (policy && src->type != VIR_STORAGE_TYPE_NETWORK)\n        virBufferEscapeString(&attrBuf, \" startupPolicy='%s'\",\n                              virDomainStartupPolicyTypeToString(policy));\n\n    if (attrIndex && src->id != 0)\n        virBufferAsprintf(&attrBuf, \" index='%u'\", src->id);\n\n    if (virDomainDiskSourceFormatPrivateData(&childBuf, src, flags, xmlopt) < 0)\n        return -1;\n\n    virXMLFormatElement(buf, element, &attrBuf, &childBuf);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virBufferEscapeString",
          "args": [
            "&childBuf",
            "\"<driver type='%s'/>\\n\"",
            "virStorageFileFormatTypeToString(disk->store->format)"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferEscapeString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "343-418",
          "snippet": "void\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferEscapeString(virBufferPtr buf, const char *format, const char *str)\n{\n    int len;\n    g_autofree char *escaped = NULL;\n    char *out;\n    const char *cur;\n    const char forbidden_characters[] = {\n        0x01,   0x02,   0x03,   0x04,   0x05,   0x06,   0x07,   0x08,\n        /*\\t*/  /*\\n*/  0x0B,   0x0C,   /*\\r*/  0x0E,   0x0F,   0x10,\n        0x11,   0x12,   0x13,   0x14,   0x15,   0x16,   0x17,   0x18,\n        0x19,   '\"',    '&',    '\\'',   '<',    '>',\n        '\\0'\n    };\n\n    if ((format == NULL) || (buf == NULL) || (str == NULL))\n        return;\n\n    len = strlen(str);\n    if (strcspn(str, forbidden_characters) == len) {\n        virBufferAsprintf(buf, format, str);\n        return;\n    }\n\n    escaped = g_malloc0_n(len + 1, 6);\n\n    cur = str;\n    out = escaped;\n    while (*cur != 0) {\n        if (*cur == '<') {\n            *out++ = '&';\n            *out++ = 'l';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '>') {\n            *out++ = '&';\n            *out++ = 'g';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '&') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'm';\n            *out++ = 'p';\n            *out++ = ';';\n        } else if (*cur == '\"') {\n            *out++ = '&';\n            *out++ = 'q';\n            *out++ = 'u';\n            *out++ = 'o';\n            *out++ = 't';\n            *out++ = ';';\n        } else if (*cur == '\\'') {\n            *out++ = '&';\n            *out++ = 'a';\n            *out++ = 'p';\n            *out++ = 'o';\n            *out++ = 's';\n            *out++ = ';';\n        } else if (!strchr(forbidden_characters, *cur)) {\n            /*\n             * default case, just copy !\n             * Note that character over 0x80 are likely to give problem\n             * with UTF-8 XML, but since our string don't have an encoding\n             * it's hard to handle properly we have to assume it's UTF-8 too\n             */\n            *out++ = *cur;\n        } else {\n            /* silently ignore control characters */\n        }\n        cur++;\n    }\n    *out = 0;\n\n    virBufferAsprintf(buf, format, escaped);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeToString",
          "args": [
            "disk->store->format"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBufferAsprintf",
          "args": [
            "&attrBuf",
            "\" type='%s'\"",
            "virStorageTypeToString(disk->store->type)"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virBufferAsprintf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbuffer.c",
          "lines": "302-309",
          "snippet": "void\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include <stdarg.h>\n#include <config.h>\n\nvoid\nvirBufferAsprintf(virBufferPtr buf, const char *format, ...)\n{\n    va_list argptr;\n    va_start(argptr, format);\n    virBufferVasprintf(buf, format, argptr);\n    va_end(argptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageTypeToString",
          "args": [
            "disk->store->type"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupDiskStateTypeToString",
          "args": [
            "disk->state"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeToString",
          "args": [
            "disk->backup"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_BUFFER_INIT_CHILD",
          "args": [
            "buf"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDiskDefFormat(virBufferPtr buf,\n                             virDomainBackupDiskDefPtr disk,\n                             bool push,\n                             bool internal)\n{\n    g_auto(virBuffer) attrBuf = VIR_BUFFER_INITIALIZER;\n    g_auto(virBuffer) childBuf = VIR_BUFFER_INIT_CHILD(buf);\n    const char *sourcename = \"scratch\";\n    unsigned int storageSourceFormatFlags = 0;\n\n    if (push)\n        sourcename = \"target\";\n\n    if (internal)\n        storageSourceFormatFlags |= VIR_DOMAIN_DEF_FORMAT_STATUS;\n\n    virBufferEscapeString(&attrBuf, \" name='%s'\", disk->name);\n    virBufferAsprintf(&attrBuf, \" backup='%s'\", virTristateBoolTypeToString(disk->backup));\n    if (internal)\n        virBufferAsprintf(&attrBuf, \" state='%s'\", virDomainBackupDiskStateTypeToString(disk->state));\n\n    if (disk->backup == VIR_TRISTATE_BOOL_YES) {\n        virBufferAsprintf(&attrBuf, \" type='%s'\", virStorageTypeToString(disk->store->type));\n\n        virBufferEscapeString(&attrBuf, \" exportname='%s'\", disk->exportname);\n        virBufferEscapeString(&attrBuf, \" exportbitmap='%s'\", disk->exportbitmap);\n\n        if (disk->store->format > 0)\n            virBufferEscapeString(&childBuf, \"<driver type='%s'/>\\n\",\n                                  virStorageFileFormatTypeToString(disk->store->format));\n\n        if (virDomainDiskSourceFormat(&childBuf, disk->store, sourcename,\n                                      0, false, storageSourceFormatFlags, true, NULL) < 0)\n            return -1;\n    }\n\n    virXMLFormatElement(buf, \"disk\", &attrBuf, &childBuf);\n    return 0;\n}"
  },
  {
    "function_name": "virDomainBackupDefParseNode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "286-315",
    "snippet": "virDomainBackupDefPtr\nvirDomainBackupDefParseNode(xmlDocPtr xml,\n                            xmlNodePtr root,\n                            virDomainXMLOptionPtr xmlopt,\n                            unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autofree char *schema = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainbackup\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainbackup\"));\n        return NULL;\n    }\n\n    if (!(flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL)) {\n        if (!(schema = virFileFindResource(\"domainbackup.rng\",\n                                           abs_top_srcdir \"/docs/schemas\",\n                                           PKGDATADIR \"/schemas\")))\n            return NULL;\n\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainBackupDefParse(ctxt, xmlopt, flags);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virDomainBackupDefParse",
          "args": [
            "ctxt",
            "xmlopt",
            "flags"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefParseString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "266-283",
          "snippet": "virDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLXPathContextNew",
          "args": [
            "xml"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLXPathContextNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "48-59",
          "snippet": "xmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlXPathContextPtr\nvirXMLXPathContextNew(xmlDocPtr xml)\n{\n    xmlXPathContextPtr ctxt;\n\n    if (!(ctxt = xmlXPathNewContext(xml))) {\n        virReportOOMError();\n        return NULL;\n    }\n\n    return ctxt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLValidateAgainstSchema",
          "args": [
            "schema",
            "xml"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLValidateAgainstSchema",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1325-1342",
          "snippet": "int\nvirXMLValidateAgainstSchema(const char *schemafile,\n                            xmlDocPtr doc)\n{\n    virXMLValidatorPtr validator = NULL;\n    int ret = -1;\n\n    if (!(validator = virXMLValidatorInit(schemafile)))\n        return -1;\n\n    if (virXMLValidatorValidate(validator, doc) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virXMLValidatorFree(validator);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXMLValidateAgainstSchema(const char *schemafile,\n                            xmlDocPtr doc)\n{\n    virXMLValidatorPtr validator = NULL;\n    int ret = -1;\n\n    if (!(validator = virXMLValidatorInit(schemafile)))\n        return -1;\n\n    if (virXMLValidatorValidate(validator, doc) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    virXMLValidatorFree(validator);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResource",
          "args": [
            "\"domainbackup.rng\"",
            "abs_top_srcdir \"/docs/schemas\"",
            "PKGDATADIR \"/schemas\""
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1771-1777",
          "snippet": "char *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileFindResource(const char *filename,\n                    const char *builddir,\n                    const char *installdir)\n{\n    return virFileFindResourceFull(filename, NULL, NULL, builddir, installdir, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"domainbackup\")"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"domainbackup\""
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXMLNodeNameEqual",
          "args": [
            "root",
            "\"domainbackup\""
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLNodeNameEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "1013-1018",
          "snippet": "bool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nbool\nvirXMLNodeNameEqual(xmlNodePtr node,\n                    const char *name)\n{\n    return xmlStrEqual(node->name, BAD_CAST name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainBackupDefPtr\nvirDomainBackupDefParseNode(xmlDocPtr xml,\n                            xmlNodePtr root,\n                            virDomainXMLOptionPtr xmlopt,\n                            unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autofree char *schema = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainbackup\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainbackup\"));\n        return NULL;\n    }\n\n    if (!(flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL)) {\n        if (!(schema = virFileFindResource(\"domainbackup.rng\",\n                                           abs_top_srcdir \"/docs/schemas\",\n                                           PKGDATADIR \"/schemas\")))\n            return NULL;\n\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainBackupDefParse(ctxt, xmlopt, flags);\n}"
  },
  {
    "function_name": "virDomainBackupDefParseString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "266-283",
    "snippet": "virDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "keepBlanksDefault"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupDefParseNode",
          "args": [
            "xml",
            "xmlDocGetRootElement(xml)",
            "xmlopt",
            "flags"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDefParseNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "286-315",
          "snippet": "virDomainBackupDefPtr\nvirDomainBackupDefParseNode(xmlDocPtr xml,\n                            xmlNodePtr root,\n                            virDomainXMLOptionPtr xmlopt,\n                            unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autofree char *schema = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainbackup\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainbackup\"));\n        return NULL;\n    }\n\n    if (!(flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL)) {\n        if (!(schema = virFileFindResource(\"domainbackup.rng\",\n                                           abs_top_srcdir \"/docs/schemas\",\n                                           PKGDATADIR \"/schemas\")))\n            return NULL;\n\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainBackupDefParse(ctxt, xmlopt, flags);\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainBackupDefPtr\nvirDomainBackupDefParseNode(xmlDocPtr xml,\n                            xmlNodePtr root,\n                            virDomainXMLOptionPtr xmlopt,\n                            unsigned int flags)\n{\n    g_autoptr(xmlXPathContext) ctxt = NULL;\n    g_autofree char *schema = NULL;\n\n    if (!virXMLNodeNameEqual(root, \"domainbackup\")) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\", _(\"domainbackup\"));\n        return NULL;\n    }\n\n    if (!(flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL)) {\n        if (!(schema = virFileFindResource(\"domainbackup.rng\",\n                                           abs_top_srcdir \"/docs/schemas\",\n                                           PKGDATADIR \"/schemas\")))\n            return NULL;\n\n        if (virXMLValidateAgainstSchema(schema, xml) < 0)\n            return NULL;\n    }\n\n    if (!(ctxt = virXMLXPathContextNew(xml)))\n        return NULL;\n\n    ctxt->node = root;\n    return virDomainBackupDefParse(ctxt, xmlopt, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlDocGetRootElement",
          "args": [
            "xml"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "keepBlanksDefault"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLParse",
          "args": [
            "NULL",
            "xmlStr",
            "_(\"(domain_backup)\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"(domain_backup)\""
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmlKeepBlanksDefault",
          "args": [
            "0"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvirDomainBackupDefPtr\nvirDomainBackupDefParseString(const char *xmlStr,\n                              virDomainXMLOptionPtr xmlopt,\n                              unsigned int flags)\n{\n    virDomainBackupDefPtr ret = NULL;\n    g_autoptr(xmlDoc) xml = NULL;\n    int keepBlanksDefault = xmlKeepBlanksDefault(0);\n\n    if ((xml = virXMLParse(NULL, xmlStr, _(\"(domain_backup)\")))) {\n        xmlKeepBlanksDefault(keepBlanksDefault);\n        ret = virDomainBackupDefParseNode(xml, xmlDocGetRootElement(xml),\n                                          xmlopt, flags);\n    }\n    xmlKeepBlanksDefault(keepBlanksDefault);\n\n    return ret;\n}"
  },
  {
    "function_name": "virDomainBackupDefParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "193-263",
    "snippet": "static virDomainBackupDefPtr\nvirDomainBackupDefParse(xmlXPathContextPtr ctxt,\n                        virDomainXMLOptionPtr xmlopt,\n                        unsigned int flags)\n{\n    g_autoptr(virDomainBackupDef) def = NULL;\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr node = NULL;\n    g_autofree char *mode = NULL;\n    bool push;\n    size_t i;\n    int n;\n\n    def = g_new0(virDomainBackupDef, 1);\n\n    def->type = VIR_DOMAIN_BACKUP_TYPE_PUSH;\n\n    if ((mode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if ((def->type = virDomainBackupTypeFromString(mode)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown backup mode '%s'\"), mode);\n            return NULL;\n        }\n    }\n\n    push = def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH;\n\n    def->incremental = virXPathString(\"string(./incremental)\", ctxt);\n\n    if ((node = virXPathNode(\"./server\", ctxt))) {\n        if (def->type != VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"use of <server> requires pull mode backup\"));\n            return NULL;\n        }\n\n        def->server = g_new0(virStorageNetHostDef, 1);\n\n        if (virDomainStorageNetworkParseHost(node, def->server) < 0)\n            return NULL;\n\n        if (def->server->transport == VIR_STORAGE_NET_HOST_TRANS_RDMA) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"transport rdma is not supported for <server>\"));\n            return NULL;\n        }\n\n        if (def->server->transport == VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n            def->server->socket[0] != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"backup socket path '%s' must be absolute\"),\n                           def->server->socket);\n            return NULL;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./disks/*\", ctxt, &nodes)) < 0)\n        return NULL;\n\n    def->disks = g_new0(virDomainBackupDiskDef, n);\n\n    def->ndisks = n;\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefParseXML(nodes[i], ctxt,\n                                           &def->disks[i], push,\n                                           flags, xmlopt) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&def"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupDiskDefParseXML",
          "args": [
            "nodes[i]",
            "ctxt",
            "&def->disks[i]",
            "push",
            "flags",
            "xmlopt"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainBackupDiskDefParseXML",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
          "lines": "84-190",
          "snippet": "static int\nvirDomainBackupDiskDefParseXML(xmlNodePtr node,\n                               xmlXPathContextPtr ctxt,\n                               virDomainBackupDiskDefPtr def,\n                               bool push,\n                               unsigned int flags,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    g_autofree char *type = NULL;\n    g_autofree char *driver = NULL;\n    g_autofree char *backup = NULL;\n    g_autofree char *state = NULL;\n    int tmp;\n    xmlNodePtr srcNode;\n    unsigned int storageSourceParseFlags = 0;\n    bool internal = flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL;\n\n    if (internal)\n        storageSourceParseFlags = VIR_DOMAIN_DEF_PARSE_STATUS;\n\n    ctxt->node = node;\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing name from disk backup element\"));\n        return -1;\n    }\n\n    def->backup = VIR_TRISTATE_BOOL_YES;\n\n    if ((backup = virXMLPropString(node, \"backup\"))) {\n        if ((tmp = virTristateBoolTypeFromString(backup)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid disk 'backup' state '%s'\"), backup);\n            return -1;\n        }\n\n        def->backup = tmp;\n    }\n\n    /* don't parse anything else if backup is disabled */\n    if (def->backup == VIR_TRISTATE_BOOL_NO)\n        return 0;\n\n    if (!push) {\n        def->exportname = virXMLPropString(node, \"exportname\");\n        def->exportbitmap = virXMLPropString(node, \"exportbitmap\");\n    }\n\n    if (internal) {\n        if (!(state = virXMLPropString(node, \"state\")) ||\n            (tmp = virDomainBackupDiskStateTypeFromString(state)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"disk '%s' backup state wrong or missing'\"), def->name);\n            return -1;\n        }\n\n        def->state = tmp;\n    }\n\n    if (!(def->store = virStorageSourceNew()))\n        return -1;\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->store->type = virStorageTypeFromString(type)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk backup type '%s'\"), type);\n            return -1;\n        }\n\n        if (def->store->type != VIR_STORAGE_TYPE_FILE &&\n            def->store->type != VIR_STORAGE_TYPE_BLOCK) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported disk backup type '%s'\"), type);\n            return -1;\n        }\n    } else {\n        def->store->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if (push)\n        srcNode = virXPathNode(\"./target\", ctxt);\n    else\n        srcNode = virXPathNode(\"./scratch\", ctxt);\n\n    if (srcNode &&\n        virDomainStorageSourceParse(srcNode, ctxt, def->store,\n                                    storageSourceParseFlags, xmlopt) < 0)\n        return -1;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt))) {\n        def->store->format = virStorageFileFormatTypeFromString(driver);\n        if (def->store->format <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk backup driver '%s'\"), driver);\n            return -1;\n        } else if (!push && def->store->format != VIR_STORAGE_FILE_QCOW2) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"pull mode requires qcow2 driver, not '%s'\"),\n                           driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virenum.h\"",
            "#include \"virhash.h\"",
            "#include \"virstring.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"backup_conf.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include \"domain_conf.h\"",
            "#include \"datatypes.h\"",
            "#include \"virbuffer.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDiskDefParseXML(xmlNodePtr node,\n                               xmlXPathContextPtr ctxt,\n                               virDomainBackupDiskDefPtr def,\n                               bool push,\n                               unsigned int flags,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    g_autofree char *type = NULL;\n    g_autofree char *driver = NULL;\n    g_autofree char *backup = NULL;\n    g_autofree char *state = NULL;\n    int tmp;\n    xmlNodePtr srcNode;\n    unsigned int storageSourceParseFlags = 0;\n    bool internal = flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL;\n\n    if (internal)\n        storageSourceParseFlags = VIR_DOMAIN_DEF_PARSE_STATUS;\n\n    ctxt->node = node;\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing name from disk backup element\"));\n        return -1;\n    }\n\n    def->backup = VIR_TRISTATE_BOOL_YES;\n\n    if ((backup = virXMLPropString(node, \"backup\"))) {\n        if ((tmp = virTristateBoolTypeFromString(backup)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid disk 'backup' state '%s'\"), backup);\n            return -1;\n        }\n\n        def->backup = tmp;\n    }\n\n    /* don't parse anything else if backup is disabled */\n    if (def->backup == VIR_TRISTATE_BOOL_NO)\n        return 0;\n\n    if (!push) {\n        def->exportname = virXMLPropString(node, \"exportname\");\n        def->exportbitmap = virXMLPropString(node, \"exportbitmap\");\n    }\n\n    if (internal) {\n        if (!(state = virXMLPropString(node, \"state\")) ||\n            (tmp = virDomainBackupDiskStateTypeFromString(state)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"disk '%s' backup state wrong or missing'\"), def->name);\n            return -1;\n        }\n\n        def->state = tmp;\n    }\n\n    if (!(def->store = virStorageSourceNew()))\n        return -1;\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->store->type = virStorageTypeFromString(type)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk backup type '%s'\"), type);\n            return -1;\n        }\n\n        if (def->store->type != VIR_STORAGE_TYPE_FILE &&\n            def->store->type != VIR_STORAGE_TYPE_BLOCK) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported disk backup type '%s'\"), type);\n            return -1;\n        }\n    } else {\n        def->store->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if (push)\n        srcNode = virXPathNode(\"./target\", ctxt);\n    else\n        srcNode = virXPathNode(\"./scratch\", ctxt);\n\n    if (srcNode &&\n        virDomainStorageSourceParse(srcNode, ctxt, def->store,\n                                    storageSourceParseFlags, xmlopt) < 0)\n        return -1;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt))) {\n        def->store->format = virStorageFileFormatTypeFromString(driver);\n        if (def->store->format <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk backup driver '%s'\"), driver);\n            return -1;\n        } else if (!push && def->store->format != VIR_STORAGE_FILE_QCOW2) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"pull mode requires qcow2 driver, not '%s'\"),\n                           driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virDomainBackupDiskDef",
            "n"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./disks/*\"",
            "ctxt",
            "&nodes"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"backup socket path '%s' must be absolute\")",
            "def->server->socket"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"backup socket path '%s' must be absolute\""
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"transport rdma is not supported for <server>\")"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainStorageNetworkParseHost",
          "args": [
            "node",
            "def->server"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainStorageNetworkParseHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "8024-8083",
          "snippet": "int\nvirDomainStorageNetworkParseHost(xmlNodePtr hostnode,\n                                 virStorageNetHostDefPtr host)\n{\n    int ret = -1;\n    g_autofree char *transport = NULL;\n    g_autofree char *port = NULL;\n\n    memset(host, 0, sizeof(*host));\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* transport can be tcp (default), unix or rdma.  */\n    if ((transport = virXMLPropString(hostnode, \"transport\"))) {\n        host->transport = virStorageNetHostTransportTypeFromString(transport);\n        if (host->transport < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown protocol transport type '%s'\"),\n                           transport);\n            goto cleanup;\n        }\n    }\n\n    host->socket = virXMLPropString(hostnode, \"socket\");\n\n    if (host->transport == VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n        host->socket == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing socket for unix transport\"));\n        goto cleanup;\n    }\n\n    if (host->transport != VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n        host->socket != NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"transport '%s' does not support \"\n                         \"socket attribute\"),\n                       transport);\n        goto cleanup;\n    }\n\n    if (host->transport != VIR_STORAGE_NET_HOST_TRANS_UNIX) {\n        if (!(host->name = virXMLPropString(hostnode, \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing name for host\"));\n            goto cleanup;\n        }\n\n        if ((port = virXMLPropString(hostnode, \"port\"))) {\n            if (virStringParsePort(port, &host->port) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        virStorageNetHostDefClear(host);\n    return ret;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainStorageNetworkParseHost(xmlNodePtr hostnode,\n                                 virStorageNetHostDefPtr host)\n{\n    int ret = -1;\n    g_autofree char *transport = NULL;\n    g_autofree char *port = NULL;\n\n    memset(host, 0, sizeof(*host));\n    host->transport = VIR_STORAGE_NET_HOST_TRANS_TCP;\n\n    /* transport can be tcp (default), unix or rdma.  */\n    if ((transport = virXMLPropString(hostnode, \"transport\"))) {\n        host->transport = virStorageNetHostTransportTypeFromString(transport);\n        if (host->transport < 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown protocol transport type '%s'\"),\n                           transport);\n            goto cleanup;\n        }\n    }\n\n    host->socket = virXMLPropString(hostnode, \"socket\");\n\n    if (host->transport == VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n        host->socket == NULL) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing socket for unix transport\"));\n        goto cleanup;\n    }\n\n    if (host->transport != VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n        host->socket != NULL) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"transport '%s' does not support \"\n                         \"socket attribute\"),\n                       transport);\n        goto cleanup;\n    }\n\n    if (host->transport != VIR_STORAGE_NET_HOST_TRANS_UNIX) {\n        if (!(host->name = virXMLPropString(hostnode, \"name\"))) {\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"missing name for host\"));\n            goto cleanup;\n        }\n\n        if ((port = virXMLPropString(hostnode, \"port\"))) {\n            if (virStringParsePort(port, &host->port) < 0)\n                goto cleanup;\n        }\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret < 0)\n        virStorageNetHostDefClear(host);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virStorageNetHostDef",
            "1"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "\"%s\"",
            "_(\"use of <server> requires pull mode backup\")"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./server\"",
            "ctxt"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./incremental)\"",
            "ctxt"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown backup mode '%s'\")",
            "mode"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupTypeFromString",
          "args": [
            "mode"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "ctxt->node",
            "\"mode\""
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_new0",
          "args": [
            "virDomainBackupDef",
            "1"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic virDomainBackupDefPtr\nvirDomainBackupDefParse(xmlXPathContextPtr ctxt,\n                        virDomainXMLOptionPtr xmlopt,\n                        unsigned int flags)\n{\n    g_autoptr(virDomainBackupDef) def = NULL;\n    g_autofree xmlNodePtr *nodes = NULL;\n    xmlNodePtr node = NULL;\n    g_autofree char *mode = NULL;\n    bool push;\n    size_t i;\n    int n;\n\n    def = g_new0(virDomainBackupDef, 1);\n\n    def->type = VIR_DOMAIN_BACKUP_TYPE_PUSH;\n\n    if ((mode = virXMLPropString(ctxt->node, \"mode\"))) {\n        if ((def->type = virDomainBackupTypeFromString(mode)) <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown backup mode '%s'\"), mode);\n            return NULL;\n        }\n    }\n\n    push = def->type == VIR_DOMAIN_BACKUP_TYPE_PUSH;\n\n    def->incremental = virXPathString(\"string(./incremental)\", ctxt);\n\n    if ((node = virXPathNode(\"./server\", ctxt))) {\n        if (def->type != VIR_DOMAIN_BACKUP_TYPE_PULL) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"use of <server> requires pull mode backup\"));\n            return NULL;\n        }\n\n        def->server = g_new0(virStorageNetHostDef, 1);\n\n        if (virDomainStorageNetworkParseHost(node, def->server) < 0)\n            return NULL;\n\n        if (def->server->transport == VIR_STORAGE_NET_HOST_TRANS_RDMA) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED, \"%s\",\n                           _(\"transport rdma is not supported for <server>\"));\n            return NULL;\n        }\n\n        if (def->server->transport == VIR_STORAGE_NET_HOST_TRANS_UNIX &&\n            def->server->socket[0] != '/') {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"backup socket path '%s' must be absolute\"),\n                           def->server->socket);\n            return NULL;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./disks/*\", ctxt, &nodes)) < 0)\n        return NULL;\n\n    def->disks = g_new0(virDomainBackupDiskDef, n);\n\n    def->ndisks = n;\n    for (i = 0; i < def->ndisks; i++) {\n        if (virDomainBackupDiskDefParseXML(nodes[i], ctxt,\n                                           &def->disks[i], push,\n                                           flags, xmlopt) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&def);\n}"
  },
  {
    "function_name": "virDomainBackupDiskDefParseXML",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "84-190",
    "snippet": "static int\nvirDomainBackupDiskDefParseXML(xmlNodePtr node,\n                               xmlXPathContextPtr ctxt,\n                               virDomainBackupDiskDefPtr def,\n                               bool push,\n                               unsigned int flags,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    g_autofree char *type = NULL;\n    g_autofree char *driver = NULL;\n    g_autofree char *backup = NULL;\n    g_autofree char *state = NULL;\n    int tmp;\n    xmlNodePtr srcNode;\n    unsigned int storageSourceParseFlags = 0;\n    bool internal = flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL;\n\n    if (internal)\n        storageSourceParseFlags = VIR_DOMAIN_DEF_PARSE_STATUS;\n\n    ctxt->node = node;\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing name from disk backup element\"));\n        return -1;\n    }\n\n    def->backup = VIR_TRISTATE_BOOL_YES;\n\n    if ((backup = virXMLPropString(node, \"backup\"))) {\n        if ((tmp = virTristateBoolTypeFromString(backup)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid disk 'backup' state '%s'\"), backup);\n            return -1;\n        }\n\n        def->backup = tmp;\n    }\n\n    /* don't parse anything else if backup is disabled */\n    if (def->backup == VIR_TRISTATE_BOOL_NO)\n        return 0;\n\n    if (!push) {\n        def->exportname = virXMLPropString(node, \"exportname\");\n        def->exportbitmap = virXMLPropString(node, \"exportbitmap\");\n    }\n\n    if (internal) {\n        if (!(state = virXMLPropString(node, \"state\")) ||\n            (tmp = virDomainBackupDiskStateTypeFromString(state)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"disk '%s' backup state wrong or missing'\"), def->name);\n            return -1;\n        }\n\n        def->state = tmp;\n    }\n\n    if (!(def->store = virStorageSourceNew()))\n        return -1;\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->store->type = virStorageTypeFromString(type)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk backup type '%s'\"), type);\n            return -1;\n        }\n\n        if (def->store->type != VIR_STORAGE_TYPE_FILE &&\n            def->store->type != VIR_STORAGE_TYPE_BLOCK) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported disk backup type '%s'\"), type);\n            return -1;\n        }\n    } else {\n        def->store->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if (push)\n        srcNode = virXPathNode(\"./target\", ctxt);\n    else\n        srcNode = virXPathNode(\"./scratch\", ctxt);\n\n    if (srcNode &&\n        virDomainStorageSourceParse(srcNode, ctxt, def->store,\n                                    storageSourceParseFlags, xmlopt) < 0)\n        return -1;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt))) {\n        def->store->format = virStorageFileFormatTypeFromString(driver);\n        if (def->store->format <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk backup driver '%s'\"), driver);\n            return -1;\n        } else if (!push && def->store->format != VIR_STORAGE_FILE_QCOW2) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"pull mode requires qcow2 driver, not '%s'\"),\n                           driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"pull mode requires qcow2 driver, not '%s'\")",
            "driver"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"pull mode requires qcow2 driver, not '%s'\""
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "ATTRIBUTE_NONNULL",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "135-141",
          "snippet": "int ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint ATTRIBUTE_NONNULL(1) ATTRIBUTE_NONNULL(2)\nvirCPUDefCopyModel(virCPUDefPtr dst,\n                   const virCPUDef *src,\n                   bool resetPolicy)\n{\n    return virCPUDefCopyModelFilter(dst, src, resetPolicy, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"unknown disk backup driver '%s'\")",
            "driver"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageFileFormatTypeFromString",
          "args": [
            "driver"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./driver/@type)\"",
            "ctxt"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainStorageSourceParse",
          "args": [
            "srcNode",
            "ctxt",
            "def->store",
            "storageSourceParseFlags",
            "xmlopt"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainStorageSourceParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "9702-9778",
          "snippet": "int\nvirDomainStorageSourceParse(xmlNodePtr node,\n                            xmlXPathContextPtr ctxt,\n                            virStorageSourcePtr src,\n                            unsigned int flags,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    xmlNodePtr tmp;\n\n    ctxt->node = node;\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        src->path = virXMLPropString(node, \"file\");\n        break;\n    case VIR_STORAGE_TYPE_BLOCK:\n        src->path = virXMLPropString(node, \"dev\");\n        break;\n    case VIR_STORAGE_TYPE_DIR:\n        src->path = virXMLPropString(node, \"dir\");\n        break;\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceNetworkParse(node, ctxt, src, flags) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (virDomainDiskSourcePoolDefParse(node, &src->srcpool) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NVME:\n        if (virDomainDiskSourceNVMeParse(node, ctxt, src) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %s\"),\n                       virStorageTypeToString(src->type));\n        return -1;\n    }\n\n    if ((tmp = virXPathNode(\"./auth\", ctxt)) &&\n        !(src->auth = virStorageAuthDefParse(tmp, ctxt)))\n        return -1;\n\n    if ((tmp = virXPathNode(\"./encryption\", ctxt)) &&\n        !(src->encryption = virStorageEncryptionParseNode(tmp, ctxt)))\n        return -1;\n\n    if (virDomainDiskSourcePRParse(node, ctxt, &src->pr) < 0)\n        return -1;\n\n    if (virDomainStorageSourceParseSlices(src, ctxt) < 0)\n        return -1;\n\n    if (virSecurityDeviceLabelDefParseXML(&src->seclabels, &src->nseclabels,\n                                          ctxt, flags) < 0)\n        return -1;\n\n    /* People sometimes pass a bogus '' source path when they mean to omit the\n     * source element completely (e.g. CDROM without media). This is just a\n     * little compatibility check to help those broken apps */\n    if (src->path && !*src->path)\n        VIR_FREE(src->path);\n\n    if ((flags & VIR_DOMAIN_DEF_PARSE_STATUS) &&\n        xmlopt && xmlopt->privateData.storageParse &&\n        (tmp = virXPathNode(\"./privateData\", ctxt))) {\n        ctxt->node = tmp;\n\n        if (xmlopt->privateData.storageParse(ctxt, src) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nint\nvirDomainStorageSourceParse(xmlNodePtr node,\n                            xmlXPathContextPtr ctxt,\n                            virStorageSourcePtr src,\n                            unsigned int flags,\n                            virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    xmlNodePtr tmp;\n\n    ctxt->node = node;\n\n    switch ((virStorageType)src->type) {\n    case VIR_STORAGE_TYPE_FILE:\n        src->path = virXMLPropString(node, \"file\");\n        break;\n    case VIR_STORAGE_TYPE_BLOCK:\n        src->path = virXMLPropString(node, \"dev\");\n        break;\n    case VIR_STORAGE_TYPE_DIR:\n        src->path = virXMLPropString(node, \"dir\");\n        break;\n    case VIR_STORAGE_TYPE_NETWORK:\n        if (virDomainDiskSourceNetworkParse(node, ctxt, src, flags) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_VOLUME:\n        if (virDomainDiskSourcePoolDefParse(node, &src->srcpool) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NVME:\n        if (virDomainDiskSourceNVMeParse(node, ctxt, src) < 0)\n            return -1;\n        break;\n    case VIR_STORAGE_TYPE_NONE:\n    case VIR_STORAGE_TYPE_LAST:\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"unexpected disk type %s\"),\n                       virStorageTypeToString(src->type));\n        return -1;\n    }\n\n    if ((tmp = virXPathNode(\"./auth\", ctxt)) &&\n        !(src->auth = virStorageAuthDefParse(tmp, ctxt)))\n        return -1;\n\n    if ((tmp = virXPathNode(\"./encryption\", ctxt)) &&\n        !(src->encryption = virStorageEncryptionParseNode(tmp, ctxt)))\n        return -1;\n\n    if (virDomainDiskSourcePRParse(node, ctxt, &src->pr) < 0)\n        return -1;\n\n    if (virDomainStorageSourceParseSlices(src, ctxt) < 0)\n        return -1;\n\n    if (virSecurityDeviceLabelDefParseXML(&src->seclabels, &src->nseclabels,\n                                          ctxt, flags) < 0)\n        return -1;\n\n    /* People sometimes pass a bogus '' source path when they mean to omit the\n     * source element completely (e.g. CDROM without media). This is just a\n     * little compatibility check to help those broken apps */\n    if (src->path && !*src->path)\n        VIR_FREE(src->path);\n\n    if ((flags & VIR_DOMAIN_DEF_PARSE_STATUS) &&\n        xmlopt && xmlopt->privateData.storageParse &&\n        (tmp = virXPathNode(\"./privateData\", ctxt))) {\n        ctxt->node = tmp;\n\n        if (xmlopt->privateData.storageParse(ctxt, src) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathNode",
          "args": [
            "\"./scratch\"",
            "ctxt"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "608-634",
          "snippet": "xmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nxmlNodePtr\nvirXPathNode(const char *xpath,\n             xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    xmlNodePtr ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNode()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_NODESET) ||\n        (obj->nodesetval == NULL) || (obj->nodesetval->nodeNr <= 0) ||\n        (obj->nodesetval->nodeTab == NULL)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n\n    ret = obj->nodesetval->nodeTab[0];\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unsupported disk backup type '%s'\")",
            "type"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"unknown disk backup type '%s'\")",
            "type"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageTypeFromString",
          "args": [
            "type"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXMLPropString",
          "args": [
            "node",
            "\"type\""
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "virXMLPropString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "515-520",
          "snippet": "char *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXMLPropString(xmlNodePtr node,\n                 const char *name)\n{\n    return (char *)xmlGetProp(node, BAD_CAST name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceNew",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2744-2751",
          "snippet": "virStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virStorageSourceClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic virClassPtr virStorageSourceClass;\n\nvirStorageSourcePtr\nvirStorageSourceNew(void)\n{\n    if (virStorageSourceInitialize() < 0)\n        return NULL;\n\n    return virObjectNew(virStorageSourceClass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"disk '%s' backup state wrong or missing'\")",
            "def->name"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainBackupDiskStateTypeFromString",
          "args": [
            "state"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"invalid disk 'backup' state '%s'\")",
            "backup"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virTristateBoolTypeFromString",
          "args": [
            "backup"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"missing name from disk backup element\")"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_XPATH_NODE_AUTORESTORE",
          "args": [
            "ctxt"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nstatic int\nvirDomainBackupDiskDefParseXML(xmlNodePtr node,\n                               xmlXPathContextPtr ctxt,\n                               virDomainBackupDiskDefPtr def,\n                               bool push,\n                               unsigned int flags,\n                               virDomainXMLOptionPtr xmlopt)\n{\n    VIR_XPATH_NODE_AUTORESTORE(ctxt);\n    g_autofree char *type = NULL;\n    g_autofree char *driver = NULL;\n    g_autofree char *backup = NULL;\n    g_autofree char *state = NULL;\n    int tmp;\n    xmlNodePtr srcNode;\n    unsigned int storageSourceParseFlags = 0;\n    bool internal = flags & VIR_DOMAIN_BACKUP_PARSE_INTERNAL;\n\n    if (internal)\n        storageSourceParseFlags = VIR_DOMAIN_DEF_PARSE_STATUS;\n\n    ctxt->node = node;\n\n    if (!(def->name = virXMLPropString(node, \"name\"))) {\n        virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                       _(\"missing name from disk backup element\"));\n        return -1;\n    }\n\n    def->backup = VIR_TRISTATE_BOOL_YES;\n\n    if ((backup = virXMLPropString(node, \"backup\"))) {\n        if ((tmp = virTristateBoolTypeFromString(backup)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"invalid disk 'backup' state '%s'\"), backup);\n            return -1;\n        }\n\n        def->backup = tmp;\n    }\n\n    /* don't parse anything else if backup is disabled */\n    if (def->backup == VIR_TRISTATE_BOOL_NO)\n        return 0;\n\n    if (!push) {\n        def->exportname = virXMLPropString(node, \"exportname\");\n        def->exportbitmap = virXMLPropString(node, \"exportbitmap\");\n    }\n\n    if (internal) {\n        if (!(state = virXMLPropString(node, \"state\")) ||\n            (tmp = virDomainBackupDiskStateTypeFromString(state)) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"disk '%s' backup state wrong or missing'\"), def->name);\n            return -1;\n        }\n\n        def->state = tmp;\n    }\n\n    if (!(def->store = virStorageSourceNew()))\n        return -1;\n\n    if ((type = virXMLPropString(node, \"type\"))) {\n        if ((def->store->type = virStorageTypeFromString(type)) <= 0) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unknown disk backup type '%s'\"), type);\n            return -1;\n        }\n\n        if (def->store->type != VIR_STORAGE_TYPE_FILE &&\n            def->store->type != VIR_STORAGE_TYPE_BLOCK) {\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"unsupported disk backup type '%s'\"), type);\n            return -1;\n        }\n    } else {\n        def->store->type = VIR_STORAGE_TYPE_FILE;\n    }\n\n    if (push)\n        srcNode = virXPathNode(\"./target\", ctxt);\n    else\n        srcNode = virXPathNode(\"./scratch\", ctxt);\n\n    if (srcNode &&\n        virDomainStorageSourceParse(srcNode, ctxt, def->store,\n                                    storageSourceParseFlags, xmlopt) < 0)\n        return -1;\n\n    if ((driver = virXPathString(\"string(./driver/@type)\", ctxt))) {\n        def->store->format = virStorageFileFormatTypeFromString(driver);\n        if (def->store->format <= 0) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"unknown disk backup driver '%s'\"), driver);\n            return -1;\n        } else if (!push && def->store->format != VIR_STORAGE_FILE_QCOW2) {\n            virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                           _(\"pull mode requires qcow2 driver, not '%s'\"),\n                           driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virDomainBackupDefFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/backup_conf.c",
    "lines": "59-81",
    "snippet": "void\nvirDomainBackupDefFree(virDomainBackupDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    g_free(def->incremental);\n    virStorageNetHostDefFree(1, def->server);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr disk = def->disks + i;\n\n        g_free(disk->name);\n        g_free(disk->exportname);\n        g_free(disk->exportbitmap);\n        virObjectUnref(disk->store);\n    }\n\n    g_free(def->disks);\n    g_free(def);\n}",
    "includes": [
      "#include \"virenum.h\"",
      "#include \"virhash.h\"",
      "#include \"virstring.h\"",
      "#include \"virxml.h\"",
      "#include \"virerror.h\"",
      "#include \"virfile.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"backup_conf.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include \"domain_conf.h\"",
      "#include \"datatypes.h\"",
      "#include \"virbuffer.h\"",
      "#include \"internal.h\"",
      "#include \"configmake.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def->disks"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "disk->store"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "disk->exportbitmap"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "disk->exportname"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "disk->name"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageNetHostDefFree",
          "args": [
            "1",
            "def->server"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageNetHostDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1713-1726",
          "snippet": "void\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nvoid\nvirStorageNetHostDefFree(size_t nhosts,\n                         virStorageNetHostDefPtr hosts)\n{\n    size_t i;\n\n    if (!hosts)\n        return;\n\n    for (i = 0; i < nhosts; i++)\n        virStorageNetHostDefClear(&hosts[i]);\n\n    VIR_FREE(hosts);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "def->incremental"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virenum.h\"\n#include \"virhash.h\"\n#include \"virstring.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"backup_conf.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include \"domain_conf.h\"\n#include \"datatypes.h\"\n#include \"virbuffer.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <config.h>\n\nvoid\nvirDomainBackupDefFree(virDomainBackupDefPtr def)\n{\n    size_t i;\n\n    if (!def)\n        return;\n\n    g_free(def->incremental);\n    virStorageNetHostDefFree(1, def->server);\n\n    for (i = 0; i < def->ndisks; i++) {\n        virDomainBackupDiskDefPtr disk = def->disks + i;\n\n        g_free(disk->name);\n        g_free(disk->exportname);\n        g_free(disk->exportbitmap);\n        virObjectUnref(disk->store);\n    }\n\n    g_free(def->disks);\n    g_free(def);\n}"
  }
]